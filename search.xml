<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DDD简介科普</title>
    <url>/2021/09/10/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h2 id="名词科普"><a href="#名词科普" class="headerlink" title="名词科普"></a>名词科普</h2><h3 id="集群、分布式、SOA、微服务"><a href="#集群、分布式、SOA、微服务" class="headerlink" title="集群、分布式、SOA、微服务"></a>集群、分布式、SOA、微服务</h3><p><strong>单体</strong>：一个应用里包含完整的服务</p>
<p><strong>集群</strong>：不同服务器部署同一套应用对外提供服务，指同一组件的多个实例，是一种物理形态。</p>
<p><strong>分布式</strong>：与集群不同，强调的是不同的模块部署在不同服务器上，提供完整的服务（可以存在相同服务部署在多个节点上），强调的是工作方式</p>
<p><strong>SOA</strong>（Service-Oriented Architecture）:面向服务的架构，是一种设计方法。服务拆分，多个服务相互依赖通过接口和协议联系起来</p>
<p>​    中心化实现：ESB（Enterprise Service Bus ） 企业服务总线，各服务通过ESB交互的方式实现与其他服务的通信，解决异构系统的连通性，屏蔽其他服务的细节。</p>
<pre><code> 去中心化：微服务，SOA的升华
</code></pre>
<p><strong>微服务</strong>：强调业务的彻底组件化和服务化，每个服务可单独开发，迭代运行，更符合单一职责原则，通过网关</p>
<p>服务发现与注册，restful api风格轻量级通信等等，各司其职</p>
<h2 id="系统老化谁的锅"><a href="#系统老化谁的锅" class="headerlink" title="系统老化谁的锅"></a>系统老化谁的锅</h2><p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902221412119.png" alt="image-20210902221412119"></p>
<h2 id="DDD是什么"><a href="#DDD是什么" class="headerlink" title="DDD是什么"></a>DDD是什么</h2><p>​    DDD最早由Eric Evans提出一种的软件设计理念，通过一些规则和概念来指导如何合理的进行领域划，防止程序腐化，帮助整个研发团队内部更好的进行沟通。</p>
<h3 id="DDD的一些概念"><a href="#DDD的一些概念" class="headerlink" title="DDD的一些概念"></a>DDD的一些概念</h3><p><strong>领域（Domain）：</strong>指软件要解决的业务问题和诉求，是一个广义的概念，包括业务的各种概念、规则和逻辑。</p>
<p><strong>领域模型（Model）：</strong>业务概念在程序中的一种表达方式，使用面向对象的编程语言中的类作为业务概念的承载体，也可以使用 UML 可视化地表达模型。<br><strong>通用语言（Ubiquitous language）：</strong>指在软件设计中，业务人员和开发人员需要使用无歧义的统一语言来对话，包括对概念的统一理解和定义，以及业务人员参与到软件建模中。<br><strong>实体（Entity）：</strong>领域模型中面向对象语言的具体体现，一般是一个类，具有唯一标识符，且标识符在经历过各种状态变更后仍能保持一致。<br><strong>值对象（Value Object）：</strong>一种特殊的实体，没有自己的状态和生命周期，用属性标识，任何属性的变化都视为新的对象。<br><strong>聚合（Aggregate）：</strong>一组生命周期一致的实体集合，表达统一的业务意义，其中有且只有一个聚合根，是聚合的核心对象。<br><strong>聚合根（Aggregate Root）：</strong>聚合中最核心的对象，是聚合的领航员，用于管理聚合，实现发现、持久化聚合的作用。<br><strong>界限上下文（Bounded Context）：</strong>由统一业务目标和概念的聚合组成的集合，用于识别上下文，避免模型的不正确复用带来的问题。<br><strong>服务（Service）：</strong>领域模型的操作者，承载领域的业务规则，用于处理业务逻辑，让逻辑更为清晰明了。<br><strong>模块（Module）：</strong>同领域的类或者对象组成的集合，模块的划分没有固定的模式，可以根据业务逻辑的复杂程度进行划分。<br><strong>工厂（Factory）：</strong>以构建模型为职责的类或方法，可以把不同的业务参数转化为领域模型。<br><strong>仓库（Repository）：</strong>以持久化领域模型为职责的类，用于屏蔽业务逻辑和持久化基础设施的差异。</p>
<h1 id="DDD的特点"><a href="#DDD的特点" class="headerlink" title="DDD的特点"></a>DDD的特点</h1><h2 id="基于充血模型的面向对象开发"><a href="#基于充血模型的面向对象开发" class="headerlink" title="基于充血模型的面向对象开发"></a>基于充血模型的面向对象开发</h2><p>贫血模型：</p>
<p>​    定义对象的简单的属性值，没有业务逻辑上的方法（个人理解）</p>
<p>​    MVC模式开发是是面向过程的编程方式，符合人类大脑逻辑。定义DTO，定义数据库Model，BO等，对其进行get set方法，然后通过service 对Bo对象进行操作，最后通过copy属性持久化数据库和DTO传输。</p>
<p>充血模型：</p>
<p>​    就是我们在定义属性的同时也会定义方法，我们的属性是可以通过某些方式直接得到属性值，那我们也就可以在对象中嵌入方法直接创建出一个具有属性值的对象。也就是说这个对象不再需要我们在进行进一步的操作，这也就复合了OOP的三大特性之一的封装</p>
<h2 id="参考DDD的部分概念落地方案"><a href="#参考DDD的部分概念落地方案" class="headerlink" title="参考DDD的部分概念落地方案"></a>参考DDD的部分概念落地方案</h2><p>借鉴到的DDD的思路，避免循环依赖或者使代码接口清晰，延缓腐化</p>
<p>1、进行领域划分，不同领域的服务之间不能相互注入，但可以通过别的方式来调用，把他当做跨微服务调用，通过在防腐层的xxxLocalclient调用查询相关或者走消息总线的事件方式执行操作相关的动作</p>
<p>2、领域对象实体</p>
<p>3、聚合：把操同一领域数据库的操作分为查询xxxquery和执行xxxexcute2个类</p>
<p>4、对领域相关数据的转化固定放在data层：DTO转entity，entity转VO等的数据处理，统一放置</p>
<ul>
<li><p>interface（接口层）</p>
<ul>
<li>很薄的一层</li>
<li>类似于MVC中的controller层 只能直接注入app层</li>
</ul>
</li>
<li><p>application（应用层）</p>
<ul>
<li>很薄的一层</li>
<li>注入领域对象，可以设置状态参数（领域层是无状态的，可以在app层设置用户状态，系统标志等等参数）调用领域服务</li>
</ul>
</li>
<li><p>domain（领域服务层）</p>
<ul>
<li>Aservice 领域服务：定义领域方法，只能注入execute、query聚合根来操作持久层<ul>
<li>A1子领域</li>
<li>A2子领域</li>
<li>transfer层 领域内部之前通过该层调用 如 A1service -&gt; A2transfer</li>
<li>repository 存放领域内部仓库，操作持久化层<ul>
<li>dao 存放Mybatis Mapper接口和实现的XML文件</li>
<li>data（可选）查询前后的数据计算、转化</li>
<li><strong>execute聚合根</strong> 定义所有增删改操作</li>
<li><strong>query聚合根</strong> 定义所有查询操作</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>infrastructure（基础设施层）（配置、自研组件、缓存、防腐层（client）、工具包）</p>
<ul>
<li><p>client</p>
<ul>
<li>remote<ul>
<li>外围、外部服务client客户端</li>
</ul>
</li>
<li>native 不同领域对外开放的跨领域本地客户端 比如 A调用B Aservice -&gt; BLocalClient <ul>
<li>BLocalClient</li>
<li>ALocalClient</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>helper 工具类包</p>
<ul>
<li>config 引入各组件的配置</li>
</ul>
</li>
<li><p>component 存放着系统无关、可以随时迁移的自定义组件</p>
<ul>
<li>common 存放着系统无关、可以随时迁移的实体、常量类、异常类</li>
</ul>
</li>
<li><p>bus（消息总线层）</p>
<ul>
<li>remote<ul>
<li>外围MQ等</li>
</ul>
</li>
<li>native <ul>
<li>跨领域操作的事件监听</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="DDD代码编排："><a href="#DDD代码编排：" class="headerlink" title="DDD代码编排："></a>DDD代码编排：</h2><ol>
<li><p>interfaces-&gt;</p>
<ol>
<li>application-&gt;<ol>
<li>domainService-&gt;<ol>
<li>Repository(聚合跟DeviceExecuteRepo)-&gt;<ol>
<li>DeviceMapper-&gt;<ol>
<li>DeviceDao-&gt;DeviceDao.xml</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>domainService-&gt;<ol>
<li>发布事件</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>Job/Mq/Eventlistener 监听到事件或MQ-&gt;</p>
<ol>
<li>application-&gt; <ol>
<li>domainService-&gt;<ol>
<li>业务逻辑    </li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902222626509.png" alt="image-20210902222626509"></p>
<h2 id="DDD可指导单体项目和微服务架构"><a href="#DDD可指导单体项目和微服务架构" class="headerlink" title="DDD可指导单体项目和微服务架构"></a>DDD可指导单体项目和微服务架构</h2><h3 id="微服务架构治标不治本"><a href="#微服务架构治标不治本" class="headerlink" title="微服务架构治标不治本"></a>微服务架构治标不治本</h3><p>​    即便在微服务架构下，比如订单服务部署了多个节点，也避免不了每个节点内代码的复杂和凌乱，因此，在DDD指导下，无论单体还是微服务架构下，每个领域后续都可拆分或者当成一个微服务来看待</p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902221834222.png" alt="image-20210902221834222"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902222916470.png" alt="image-20210902222916470"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902222841017.png" alt="image-20210902222841017"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902223018287.png" alt="image-20210902223018287"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902223029121.png" alt="image-20210902223029121"></p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902215335205.png" alt="image-20210902215335205"></p>
<h2 id="DDD与中台"><a href="#DDD与中台" class="headerlink" title="DDD与中台"></a>DDD与中台</h2><p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902223538517.png" alt="image-20210902223538517"></p>
<h2 id="DDD并非银弹"><a href="#DDD并非银弹" class="headerlink" title="DDD并非银弹"></a>DDD并非银弹</h2><p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210902224541628.png" alt="image-20210902224541628"></p>
<p>数据中台的定义：<a href="https://www.sohu.com/a/425913998_114819">https://www.sohu.com/a/425913998_114819</a></p>
<blockquote>
<p>在数据应用和统计分散化的背景下，通过建设统一的数据服务体系，结合业务、安全、风控等相关诉求，完成数据的采集、清晰、建模等行为，并提供准确以及及时的数据服务、以满足企业不断复杂变化的数据统计与数据应用的需求</p>
</blockquote>
<p>实例一：今年我们的库存周转率如何协调财务、库存、运营的口径或者标准</p>
<p>实例二：如何统一提供sku管理和服务（商品中台）</p>
<p><img src="/images/DDD%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E4%BB%8B%E7%BB%8D/image-20210903000820115.png" alt="image-20210903000820115"></p>
]]></content>
      <categories>
        <category>DDD</category>
      </categories>
      <tags>
        <tag>DDD</tag>
        <tag>中台</tag>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP介绍与背景</title>
    <url>/2022/02/22/HTTP/</url>
    <content><![CDATA[<h1 id="HTTP介绍与背景"><a href="#HTTP介绍与背景" class="headerlink" title="HTTP介绍与背景"></a>HTTP介绍与背景</h1><p><a href="http://www.blogjava.net/zjusuyong/articles/304788.html">参考文献</a></p>
<h2 id="网络科普"><a href="#网络科普" class="headerlink" title="网络科普"></a>网络科普</h2><h3 id="OSI与TCP-IP模型"><a href="#OSI与TCP-IP模型" class="headerlink" title="OSI与TCP/IP模型"></a>OSI与TCP/IP模型</h3><h4 id="OSI"><a href="#OSI" class="headerlink" title="OSI"></a>OSI</h4><p>​    OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p>
<h4 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h4><p>​    TCP/IP是一个协议簇，是在 IP 协议的通信过程中，使用到的协议族的统称。</p>
<p>TCPl(Transmission Control Protocol):传输控制协议</p>
<p>IP(Internet Protocol):网际协议</p>
<p><img src="/images/HTTP/20180411120702438.png" alt="img"></p>
<p><img src="/images/HTTP/image-20220222145256978.png" alt="image-20220222145256978"></p>
<h4 id="TCP与UDP"><a href="#TCP与UDP" class="headerlink" title="TCP与UDP"></a>TCP与UDP</h4><p>TCPl(Transmission Control Protocol):传输控制协议</p>
<p>UDP(User Datagram Protocol):用户数据报协议</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left">UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="left">是否连接</td>
<td align="left">无连接</td>
<td>面向连接（三次握手，四次挥手）</td>
</tr>
<tr>
<td align="left">是否可靠</td>
<td align="left">不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输，使用流量控制和拥塞控制</td>
</tr>
<tr>
<td align="left">连接对象个数</td>
<td align="left">支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td align="left">传输方式</td>
<td align="left">面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td align="left">首部开销</td>
<td align="left">首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td align="left">适用场景</td>
<td align="left">适用于实时应用（IP电话、视频会议、直播等）</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<p><img src="/images/HTTP/2019-03-21-02.gif" alt="img"></p>
<p><img src="/images/HTTP/2019-03-21-05.gif" alt="img"></p>
<h2 id="HTTP介绍"><a href="#HTTP介绍" class="headerlink" title="HTTP介绍"></a>HTTP介绍</h2><p>​    <strong>HTTP是Hyper Text Transfer Protocol 超文本传输协议</strong>。是用于从WWW服务器传输超文本到本地浏览器的传送协议。它可以使浏览器更加高效，使网络传输减少。它不仅保证计算机正确快速地传输超文本文档，还确定传输文档中的哪一部分，以及哪部分内容首先显示(如文本先于图形)等,，请求端口是80。</p>
<p><strong>HTTP是无状态的<span style="color:red">半双工</span>应用层协议</strong></p>
<p>​    HTTP是⽆状态的，也就是说，它是不对通信状态进⾏保存的。它并不知道之前通信的对⽅是谁，这样设计的⽬的就是为了让HTTP简单化，能够快速处理⼤量的事务！但是，我们经常是需要知道访问的⼈是谁，于是就有了<strong>Cookie技术</strong>或者通过<strong>请求头传递身份认证令牌</strong></p>
<h3 id="HTTP请求方法介绍"><a href="#HTTP请求方法介绍" class="headerlink" title="HTTP请求方法介绍"></a>HTTP请求方法介绍</h3><p>GET：用作于获取资源</p>
<p>POST：用来传输实体的主体（RESTFUL中主要用来创建单个资源）</p>
<p>PUT：要用来传输文件（RESTFUL中主要用来更新单个资源）</p>
<p>DELETE：删除资源</p>
<p>OPTIONS：查询请求的指定资源都服务端支持什么http方法</p>
<p>HEAD：获得报⽂⾸部，与GET⽅法类似，只是不返回报⽂主体，⼀般⽤于验证URI是否有效。</p>
<h3 id="HTTP常⽤的状态码"><a href="#HTTP常⽤的状态码" class="headerlink" title="HTTP常⽤的状态码"></a>HTTP常⽤的状态码</h3><h4 id="2XX：一般是请求成功"><a href="#2XX：一般是请求成功" class="headerlink" title="2XX：一般是请求成功"></a>2XX：一般是请求成功</h4><p>200：正常处理</p>
<p>204：成功处理，但是服务器没有新数据返回，显示页面不更新</p>
<p>206：对服务器进行范围请求，只返回一部分数据</p>
<h4 id="3XX：一般表示重定向重定向区分解释"><a href="#3XX：一般表示重定向重定向区分解释" class="headerlink" title="3XX：一般表示重定向重定向区分解释"></a>3XX：一般表示重定向<a href="https://www.cnblogs.com/wuguanglin/p/redirect.html">重定向区分解释</a></h4><p>301：永久重新向：请求的资源已分配了新的URI中，URL地址改变了</p>
<p>302：临时重新向：请求的资源临时分配了新的URI中，URL地址没变</p>
<p>303：同302，明确客户端用GET方式请求资源</p>
<p>307：同302，请求方法不变（如不会把POST请求变成GET）</p>
<p>308：同301，请求方法不变（如不会把POST请求变成GET）</p>
<h4 id="4XX：表示客户端出错了"><a href="#4XX：表示客户端出错了" class="headerlink" title="4XX：表示客户端出错了"></a>4XX：表示客户端出错了</h4><p>400：请求报文语法出错</p>
<p>401：需要身份认证</p>
<p>403：没有权限访问</p>
<p>404：服务器没有这个资源</p>
<h4 id="5XX：服务器出错"><a href="#5XX：服务器出错" class="headerlink" title="5XX：服务器出错"></a>5XX：服务器出错</h4><p>500：服务器内部异常</p>
<p>502：错误的网关（网站的服务器暂时挂了(不响应)），可能是服务器正在发版重启，或者响应不过来</p>
<p>503：服务器正忙</p>
<h3 id="HTTP请求报文介绍"><a href="#HTTP请求报文介绍" class="headerlink" title="HTTP请求报文介绍"></a>HTTP请求报文介绍</h3><h4 id="请求报文"><a href="#请求报文" class="headerlink" title="请求报文"></a>请求报文</h4><p>请求行（请求方法 + URI + HTTP版本） + 请求头 +请求体</p>
<p>POST /cms/web/tms/check/pageCheckJira HTTP/1.1<br>Host: mss-dev01.dotfashion.cn<br>Proxy-Connection: keep-alive<br>Content-Length: 115<br>Accept: application/json, text/plain, <em>/</em><br>User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/98.0.4758.102 Safari/537.36<br>Content-Type: application/json;charset=UTF-8<br>Origin: <a href="http://www.example.com/">www.example.com</a><br>Referer: <a href="http://www.example.com/system-cms/">www.example.com/system-cms/</a><br>Accept-Encoding: gzip, deflate<br>Accept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7<br>空行<br>request请求体：{}</p>
<p><img src="/images/HTTP/1444829-20180719145047278-258771729.png" alt="img"></p>
<h4 id="响应报文"><a href="#响应报文" class="headerlink" title="响应报文"></a>响应报文</h4><p>响应行 +响应头 +响应体</p>
<p>HTTP/1.1 200 OK<br>Server: openresty<br>Date: Wed, 23 Feb 2022 07:54:42 GMT<br>Content-Type: application/json<br>Transfer-Encoding: chunked<br>Connection: keep-alive<br>Vary: Accept-Encoding<br>Vary: Accept-Encoding<br>P-Version: 220224<br>Trace-Id: 2937c15ea18fea3f<br>Access-Control-Allow-Origin: <a href="http://www.example.com/">www.example.com</a><br>Vary: Origin<br>Vary: Access-Control-Request-Method<br>Vary: Access-Control-Request-Headers<br>Access-Control-Allow-Credentials: true<br>Content-Encoding: gzip<br>空行<br>response请求体：{}<br><img src="/images/HTTP/1444829-20180719145056458-1519744336.png" alt="img"></p>
<h4 id="Header举例"><a href="#Header举例" class="headerlink" title="Header举例"></a>Header举例</h4><p>Location: <a href="http://www.it315.org/index.jsp">http://www.it315.org/index.jsp</a> 【服务器告诉浏览器要跳转到哪个⻚⾯】<br>Server:apache tomcat【服务器告诉浏览器，服务器的型号是什么】<br>Content-Encoding: gzip 【服务器告诉浏览器数据压缩的格式】<br><strong>Content-Length: 80</strong> 【服务器告诉浏览器回送数据的⻓度】<br>Content-Language: zh-cn 【服务器告诉浏览器，服务器的语⾔环境】<br>Content-Type: text/html; charset=GB2312 【服务器告诉浏览器，回送数据的类型】<br>Last-Modified: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器该资源上次更新时间】<br>Refresh: 1;url=<a href="http://www.it315.org【服务器告诉浏览器要定时刷新】/">http://www.it315.org【服务器告诉浏览器要定时刷新】</a><br>Content-Disposition: attachment; filename=aaa.zip【服务器告诉浏览器以下载⽅式打开数据】<br>Transfer-Encoding: chunked 【服务器告诉浏览器数据以分块⽅式回送】<br>Set-Cookie:SS=Q0=5Lb_nQ; path=/search【服务器告诉浏览器要保存Cookie】<br>Expires: -1【服务器告诉浏览器不要设置缓存】<br>Cache-Control: no-cache 【服务器告诉浏览器不要设置缓存】<br>Pragma: no-cache 【服务器告诉浏览器不要设置缓存】<br><strong>Connection: close/Keep-Alive</strong> 【服务器告诉浏览器连接⽅式】<br>Date: Tue, 11 Jul 2000 18:23:51 GMT【服务器告诉浏览器回送数据的时间】</p>
<h3 id="网页通信的大致过程"><a href="#网页通信的大致过程" class="headerlink" title="网页通信的大致过程"></a>网页通信的大致过程</h3><p><img src="/images/HTTP/v2-e16868f6d6ccbb120a34de3e4dde8805_720w.jpg" alt="img"></p>
<p>​    我们知道HTTP是在应⽤层中的，显然，我们在Web通信的过程中，不仅仅是需要HTTP协议的，还会涉<br>及到其他的协议的。<br><strong>DNS：负责解析域名</strong><br>​    我们访问⼀个⽹⻚的时候，往往是通过域名来访问的 <a href="http://www.baidu.com/">www.baidu.com</a> ,⽽计算机通信只<br>认的是我们的主机地址(192.168.xxx.xxx)，因此，当我们输⼊域名的时候，需要DNS把域名解析成<br>主机来进⾏访问。<br><strong>HTTP：产⽣请求报⽂数据</strong><br>​    当我们对Web⻚⾯进⾏操作的时候，就会产⽣HTTP报⽂数据，请求对应的服务端进⾏响应。<br><strong>TCP协议：分割HTTP数据，保证数据运输</strong><br>​    TCP协议采⽤了三次握⼿的⽅式来保证数据的准确运输，在运输的数据的时候，发送标识过去给服<br>务器，服务器也返回标识给客户端，⽽客户端收到消息后再次返回标识给服务器。这样⼀来就保证<br>了数据运输是可靠的。<br><strong>IP协议：传输数据包，找到通信⽬的地地址。</strong><br>​    IP协议把我们的产⽣的数据包发送给对⽅，IP地址指明了节点被分配的地址，但IP地址可能会变<br>换，我们可以使⽤ARP协议来将IP地址反射为MAC地址。MAC地址是不会更改的，是⽹卡所属的<br>固定地址。在找到通信⽬的地之前，我们是需要不断的中转的，这过程我们称作为：“路由中转”，我们并不知<br>道路由中转了多少次的。因此是不能全⾯了解到互联⽹中的传输状况的。<br>​    我们⽹⻚上请求数据就是这么⼀个流程</p>
<h3 id="HTTP版本差异"><a href="#HTTP版本差异" class="headerlink" title="HTTP版本差异"></a>HTTP版本差异</h3><p><img src="/images/HTTP/0.png" alt="img"></p>
<p><img src="/images/HTTP/image-20220221175140721.png" alt="image-20220221175140721"></p>
<h4 id="HTTP1-1新改动"><a href="#HTTP1-1新改动" class="headerlink" title="HTTP1.1新改动"></a>HTTP1.1新改动</h4><p>1、持久连接（一次TCP连接可以多次使用，当然如果并发发起多个HTTP请求，也会有多个TCP连接）</p>
<p>2、提出管线化理论（<strong>由于实践中存在很多问题无法解决，所以浏览器默认是关闭，所以可以认为是不支持同时多个请求</strong>，依然阻塞，HTTP Pipelining其实是把多个HTTP请求放到⼀个TCP连接中⼀⼀发送，⽽在发送过程中不需要等待服务器对前⼀个请求的响应；只不过，客户端还是要按照发送请求的顺序来接收响应）</p>
<p>3、增加host字段，支持断点传输（将实体主体分块传输，资源下载终端后，下载剩余部分即可，无需重新下载）</p>
<p>4、增加缓存处理（新的header如Cache-Control）</p>
<p>补充说明：</p>
<p>1、浏览器http请求的并发性是如何体现的？并发请求的数量有没有限制？</p>
<p>​    页面资源请求时，浏览器会同时和服务器建立多个TCP连接，<strong>在同一个TCP连接上顺序处理多个HTTP请求</strong>。所以浏览器的并发性就体现在可以建立多个TCP连接，来支持多个http同时请求。<strong>Chrome浏览器最多允许对同一个域名Host建立6个TCP连接</strong>，不同的浏览器有所区别</p>
<h4 id="HTTP2-0新改动"><a href="#HTTP2-0新改动" class="headerlink" title="HTTP2.0新改动"></a>HTTP2.0新改动</h4><p>1、二进制分帧</p>
<p>2、多路复用，请求不阻塞</p>
<p>3、头部压缩</p>
<p>4、服务器推送</p>
<h3 id="HTTP优化方案"><a href="#HTTP优化方案" class="headerlink" title="HTTP优化方案"></a>HTTP优化方案</h3><p><a href="https://blog.51cto.com/gaibianziji/1211940">参考文档</a></p>
<ul>
<li>TCP复⽤：TCP连接复⽤是将多个客户端的HTTP请求复⽤到⼀个服务器端TCP连接上，⽽HTTP复<br>⽤则是⼀个客户端的多个HTTP请求通过⼀个TCP连接进⾏处理。前者是负载均衡设备的独特功<br>能；⽽后者是HTTP 1.1协议所⽀持的新功能</li>
<li>内容缓存：将经常⽤到的内容进⾏缓存起来，那么客户端就可以直接在内存中获取相应的数据了。</li>
<li>压缩：将⽂本数据进⾏压缩，减少带宽</li>
<li>SSL加速（SSL Acceleration）：使⽤SSL协议对HTTP协议进⾏加密，在通道内加密并加速</li>
<li>TCP缓冲：通过采⽤TCP缓冲技术，可以提⾼服务器端响应时间和处理效率，减少由于通信链路问<br>题给服务器造成的连接负担。</li>
</ul>
<h2 id="HTTPS介绍"><a href="#HTTPS介绍" class="headerlink" title="HTTPS介绍"></a>HTTPS介绍</h2><h3 id="HTTP的安全隐患"><a href="#HTTP的安全隐患" class="headerlink" title="HTTP的安全隐患"></a>HTTP的安全隐患</h3><p>1、通信使⽤明⽂【没有加密过内容的】<br>2、不验证身份，无论是客户端还是服务端【HTTP无状态】（可以通过请求头带JWT-token来验证客户端身份）<br>3、无法保证所见即所得【可以被篡改】（可以设置数字验签（哈希整个json体），把双方约定的某个secret字段作为其中一个字段参与签名字段生成后移除）</p>
<h3 id="HTTPS相关概念介绍"><a href="#HTTPS相关概念介绍" class="headerlink" title="HTTPS相关概念介绍"></a>HTTPS相关概念介绍</h3><p>​    <strong>HTTPS</strong>（全称：Hypertext Transfer Protocol over <strong>Secure Socket Layer（SSL）</strong>），是以安全为目标的HTTP通道，简单讲是HTTP的安全版，端口号是443。即HTTP下加入SSL层.</p>
<p>​    <strong>SSL</strong>(Secure Socket Layer):安全套接字协议，<strong>SSL是基于HTTP之下TCP之上的一个协议层</strong>，是基于HTTP标准并对TCP传输数据时进行加密，所以HPPTS是HTTP+SSL/TCP的简称。</p>
<p>​    <strong>TLS</strong>(Transport Layer Security)安全传输层协议,是SSL的3.0版本</p>
<p><img src="/images/HTTP/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97-3-4.jpg" alt="img"></p>
<h3 id="HTTPS的通信过程"><a href="#HTTPS的通信过程" class="headerlink" title="HTTPS的通信过程"></a>HTTPS的通信过程</h3><p><img src="/images/HTTP/o_http%E5%8D%8F%E8%AE%AE%E5%AD%A6%E4%B9%A0%E5%92%8C%E6%80%BB%E7%BB%93%E7%B3%BB%E5%88%97-3-5.jpg" alt="img"></p>
<p><strong>TCP三次握手建立连接后，再通过TCP进行TLS认证，最终得到会话秘钥</strong></p>
<p><a href="https://www.bilibili.com/video/BV1KY411x7Jp/?spm_id_from=333.337.search-card.all.click&vd_source=41042e45d4153dbeef9497c29d126b3e">参考资料</a></p>
<p><img src="/images/HTTP/image-20221212224859917.png" alt="image-20221212224859917"></p>
<h2 id="HTTPS通信的优点"><a href="#HTTPS通信的优点" class="headerlink" title="HTTPS通信的优点"></a>HTTPS通信的优点</h2><p>1、所有信息都是加密传播，⿊客⽆法窃听</p>
<p>2、具有校验机制，⼀旦被篡改，通信双⽅会⽴刻发现</p>
<p>3、配备身份证书，防⽌身份被冒充。</p>
]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>计算机基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫01-httpclient和jsoup</title>
    <url>/2024/09/08/Java%E7%88%AC%E8%99%AB01-httpclient%E5%92%8Cjsoup/</url>
    <content><![CDATA[<h1 id="Httpclient"><a href="#Httpclient" class="headerlink" title="Httpclient"></a>Httpclient</h1><h2 id="GET请求"><a href="#GET请求" class="headerlink" title="GET请求"></a>GET请求</h2><h3 id="百度一下"><a href="#百度一下" class="headerlink" title="百度一下"></a>百度一下</h3><p><strong>百度搜索林俊杰，爬取搜索结果页下载为html</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.13<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        CloseableHttpClient httpClient = HttpClients.createDefault();<br>        <span class="hljs-comment">//https://www.baidu.com/s?wd=林俊杰</span><br>        HttpGet httpGet = <span class="hljs-keyword">new</span> HttpGet(<span class="hljs-string">&quot;https://www.baidu.com/s?wd=%E6%9E%97%E4%BF%8A%E6%9D%B0&quot;</span>);<br>        <span class="hljs-comment">//设置请求头UA，模拟浏览器行为</span><br>        httpGet.addHeader(<span class="hljs-string">&quot;user-agent&quot;</span>,<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/127.0.0.0 Safari/537.36&quot;</span>);<br>        CloseableHttpResponse response = httpClient.execute(httpGet);<br>        StatusLine statusLine = response.getStatusLine();<br>        System.out.println(statusLine.getStatusCode());<br><br>        HttpEntity entity = response.getEntity();<br>        InputStream is = entity.getContent();<br>        File file = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;./search.html&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        FileOutputStream fileOutputStream = <span class="hljs-keyword">new</span> FileOutputStream(file);<br>        <span class="hljs-keyword">int</span> ch = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>((ch = is.read(bytes)) != -<span class="hljs-number">1</span>)&#123;<br>            fileOutputStream.write(bytes,<span class="hljs-number">0</span>,ch);<br>        &#125;<br>        is.close();<br>        fileOutputStream.flush();<br>        fileOutputStream.close();<br>        is.close();<br><br><span class="hljs-comment">//        String responseBody = EntityUtils.toString(entity, &quot;utf-8&quot;);</span><br><span class="hljs-comment">//        File file = new File(&quot;./search.html&quot;);</span><br><span class="hljs-comment">//        FileOutputStream fileOutputStream = new FileOutputStream(file);</span><br><span class="hljs-comment">//        fileOutputStream.write(responseBody.getBytes(&quot;utf-8&quot;));</span><br>    &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/java%E7%88%AC%E8%99%AB01/image-20240908223509742.png" alt="image-20240908223509742"></p>
<h2 id="POST请求"><a href="#POST请求" class="headerlink" title="POST请求"></a>POST请求</h2><h2 id="百度翻译"><a href="#百度翻译" class="headerlink" title="百度翻译"></a>百度翻译</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String searchWord = <span class="hljs-string">&quot;爬虫&quot;</span>;<br>    String defaultReqBody = <span class="hljs-string">&quot;&#123;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;from\&quot;: \&quot;zh\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;to\&quot;: \&quot;en\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;reference\&quot;: \&quot;\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;corpusIds\&quot;: [\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \n&quot;</span> +<br>            <span class="hljs-string">&quot;    ],\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;qcSettings\&quot;: [\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;1\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;2\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;3\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;4\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;5\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;6\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;7\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;8\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;9\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;10\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;        \&quot;11\&quot;\n&quot;</span> +<br>            <span class="hljs-string">&quot;    ],\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;needPhonetic\&quot;: false,\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;domain\&quot;: \&quot;common\&quot;,\n&quot;</span> +<br>            <span class="hljs-string">&quot;    \&quot;milliTimestamp\&quot;: 1725808602840\n&quot;</span> +<br>            <span class="hljs-string">&quot;&#125;&quot;</span>;<br>    CloseableHttpClient httpClient = HttpClients.createDefault();<br>    HttpPost httpPost = <span class="hljs-keyword">new</span> HttpPost(<span class="hljs-string">&quot;https://fanyi.baidu.com/ait/text/translate&quot;</span>);<br>    JSONObject params =  JSONObject.parseObject(defaultReqBody);<br>    params.put(<span class="hljs-string">&quot;query&quot;</span>,searchWord);<br>    params.put(<span class="hljs-string">&quot;milliTimestamp&quot;</span>,System.currentTimeMillis());<br>    httpPost.setEntity(<span class="hljs-keyword">new</span> StringEntity(params.toString(),<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    httpPost.addHeader(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><br><span class="hljs-comment">//        https://www.baidu.com/s?wd=林俊杰 表单方式</span><br><span class="hljs-comment">//        HttpPost httpPost = new HttpPost(&quot;https://fanyi.baidu.com/sug&quot;);</span><br><span class="hljs-comment">//        List&lt;BasicNameValuePair&gt; formData = Arrays.asList(new BasicNameValuePair(&quot;kw&quot;, searchWord));</span><br><span class="hljs-comment">//        httpPost.setEntity(new UrlEncodedFormEntity(formData));</span><br><br><br>    System.out.println(params);<br>    CloseableHttpResponse response = httpClient.execute(httpPost);<br>    HttpEntity entity = response.getEntity();<br>    String result = EntityUtils.toString(entity);<br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/java%E7%88%AC%E8%99%AB01/image-20240909233515742.png" alt="image-20240909233515742"></p>
<h1 id="Jsoup爬取数据"><a href="#Jsoup爬取数据" class="headerlink" title="Jsoup爬取数据"></a>Jsoup爬取数据</h1><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jsoup<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jsoup<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.11.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    URL url = <span class="hljs-keyword">new</span> URL(<span class="hljs-string">&quot;https://www.jd.com/?cu=true&quot;</span>);<br>    Document document = Jsoup.parse(url, <span class="hljs-number">5000</span>);<br>    Elements elements = document.getElementsByTag(<span class="hljs-string">&quot;title&quot;</span>);<br>    System.out.println(elements.get(<span class="hljs-number">0</span>).text());<br><br>    Elements liElements = document.getElementById(<span class="hljs-string">&quot;navitems-group1&quot;</span>).getElementsByTag(<span class="hljs-string">&quot;li&quot;</span>);<br>    System.out.println(liElements.stream().map(e -&gt; e.text()).collect(Collectors.toList()));<br><br>    Elements select = document.select(<span class="hljs-string">&quot;#navitems-group1&quot;</span>);<br>    System.out.println(select.stream().map(e -&gt; e.text()).collect(Collectors.toList())); <br>&#125;<br>京东(JD.COM)-正品低价、品质保障、配送及时、轻松购物！<br>[企业会员, 大牌奥莱, 京东五金城, 进口好物]<br>[企业会员 大牌奥莱 京东五金城 进口好物]<br></code></pre></td></tr></table></figure>

<p><img src="/images/java%E7%88%AC%E8%99%AB01/image-20240910231627632.png" alt="image-20240910231627632"></p>
<p>发现加载结果与实际访问结果不一致，说明京东做了一定的反爬或者前端实用Ajax异步加载，这些往往比较难以识别爬取，需要依赖框架或者浏览器驱动来模拟爬取</p>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>​    目前主流爬虫框架底层也是采用Httpclient和Jsoup来发起请求和解析HTML</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Java集合</title>
    <url>/2024/04/02/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<h3 id="Arraylist与LinkedList区别"><a href="#Arraylist与LinkedList区别" class="headerlink" title="Arraylist与LinkedList区别"></a>Arraylist与LinkedList区别</h3><p>可以从它们的底层数据结构、效率、开销进行阐述。</p>
<table>
<thead>
<tr>
<th></th>
<th>ArrayList</th>
<th>LinkedList</th>
</tr>
</thead>
<tbody><tr>
<td>底层结构</td>
<td>数组</td>
<td>双向链表</td>
</tr>
<tr>
<td>访问效率</td>
<td>快</td>
<td>较慢，需要遍历</td>
</tr>
<tr>
<td>增删效率</td>
<td>较慢，需要移动</td>
<td>快</td>
</tr>
<tr>
<td></td>
<td>少</td>
<td>较大，链表比数组需要额外存储引用</td>
</tr>
</tbody></table>
<h3 id="Arrays-sort或者Collections-sort的底层实现"><a href="#Arrays-sort或者Collections-sort的底层实现" class="headerlink" title="Arrays.sort或者Collections.sort的底层实现"></a>Arrays.sort或者Collections.sort的底层实现</h3><p>Collections.sort底层调用了Arrays.sort<br>Arrays.sort的底层是<strong>归并排序</strong> 或者  <strong>Timsort排序</strong>，默认使用Timsort排序。<br>Timsort排序是一种混合排序，结合了归并排序和插入排序的特点，旨在提供高效且稳定的排序性能：<code>TimSort</code> 的主要部分包括将数组分割成多个“run”（分区），并对这些“run”进行归并排序。当“run”的大小较小时，或者当它们几乎有序时，<code>binarySort</code> 会被用来代替归并排序，以提高效率。</p>
<p>以下是 <code>TimSort.sort</code> 方法的一些主要特点和实现原理：</p>
<ol>
<li><strong>数据特性利用</strong>：<br>TimSort 充分利用了现实世界数据的特性，特别是数据通常部分有序的特点。它首先会将待排序的数组或集合拆分成多个已排序或近似排序的分区（称为“run”）。</li>
<li><strong>分区排序</strong>：<br>对于每个分区，如果其长度小于某个阈值（通常是 32），TimSort 会使用<strong>二分插入排序</strong>对其进行排序。这是因为对于小数组，插入排序通常比归并排序更快。如果分区长度大于阈值，TimSort 会尝试使用更高效的排序算法（通常是归并排序的一个变种）进行排序。</li>
<li><strong>合并排序</strong>：<br>一旦所有的分区都被排序，TimSort 会使用一个高效的合并过程来将这些分区合并成一个完全有序的数组。这个过程类似于归并排序中的合并步骤，但它通过一些优化技巧来减少不必要的比较和复制操作。</li>
<li><strong>稳定性</strong>：<br>TimSort 是一个稳定的排序算法，这意味着具有相等值的元素在排序后保持它们原来的相对顺序。这对于某些应用（如排序包含复杂对象的列表）来说是非常重要的。</li>
<li><strong>性能优化</strong>：<br>TimSort 的设计旨在在各种情况下都提供高效的性能，特别是在处理部分有序或包含小规模子数组的数据时。通过结合插入排序和归并排序的优点，并利用数据的局部有序性，TimSort 能够在多种情况下实现接近线性对数时间复杂度（O(n log n)）的性能。</li>
</ol>
<h3 id="HashMap是什么，原理是什么"><a href="#HashMap是什么，原理是什么" class="headerlink" title="HashMap是什么，原理是什么"></a>HashMap是什么，原理是什么</h3><blockquote>
<p>HashMap存储的是存在映射关系的键值对，存储在被称为哈希表（数组+链表或红黑树（JDK&gt;7后））的数据结构中。通过计算key的hashCode值来确定键值对在数组中的位置，假如产生碰撞，则使用链表或红黑树。而为了避免hashcode碰撞，就涉及了元素的<strong>分布策略</strong>和<strong>动态扩容</strong></p>
</blockquote>
<h4 id="分布策略"><a href="#分布策略" class="headerlink" title="分布策略"></a><strong>分布策略</strong></h4><p>1、HashMap的底层数组长度始终保存为2的次幂</p>
<p>2、hash算法使用了key哈希值的高位</p>
<p>3、通过与操作对数组长度取模，如index =  31 &amp; (16-1) = 15</p>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a><strong>动态扩容</strong></h4><p>1、HashMap长度默认为16，loadFactor负载因子默认为0.75</p>
<p>2、threshold：阈值容量 = loadFactor * capacity，每当hashmap的数组长度超过threshold时，hashmap就会进行扩容一倍，避免因为数组太满导致过多的<strong>hash碰撞</strong></p>
<p>3、扩容过程：由于底层数组的长度始终为2的次幂，也就是说每次扩容，长度值都会扩大一倍，数组长度length的二进制表示在高位会多出1bit。而扩容时，该length值将会参与位于操作来确定元素所在数组中的新位置。所以，原数组中的元素所在位置要么保持不动，要么就是移动2次幂个位置，比如容量从16扩容为32时，hash=31的下标从15移动到31，hash=15的下标还是原来的15不移动。</p>
<h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a><strong>线程不安全</strong></h4><p>扩容时可能会产生死锁：多线程扩容时链表<strong>JDK7头插法</strong>并发扩容时，可能产生闭环</p>
<p><img src="/images/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/image-20221106172105380.png" alt="image-20221106172105380"></p>
<p>jdk8后，改用了尾插法，避免了闭环问题，但还是存在其他并发问题，所以多线程环境下，要使用ConcurrentHashMap</p>
<h3 id="Java8-HashMap"><a href="#Java8-HashMap" class="headerlink" title="Java8 HashMap"></a><strong>Java8 HashMap</strong></h3><p>1、Hash表 = 数组 + 链表 + 红黑树</p>
<p>2、数组扩容时，高低位搭配，不可能形成闭环。<strong>if((e.hash &amp; oldCap) == 0) 判断是否需要移动元素</strong>，hash值在oldCap的最高位=1，则扩容后下标=扩容前大小+原下标，否则=原下标。</p>
<p>3、<strong>链表转红黑树</strong>：链表长度大于8并且数组的长度大于64，会把链表转换成红黑树；当链表长度小于等于6时恢复为链表</p>
<h4 id="链表转红黑树"><a href="#链表转红黑树" class="headerlink" title="链表转红黑树"></a>链表转红黑树</h4><p>1、TreeNodes占用空间是普通Nodes的两倍，所以只有当Entry链包含足够多的节点且数组长度足够大时才会转成TreeNodes以追求查询速度log2N。</p>
<p>2、且正常来说如果hashcode的离散性好的话，value会均匀分布在数组中而很难达到长度为8的地步，理想情况下我们可以看到，一个map中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件。</p>
<p>3、所以当出现了碰撞度比较高的离散算法时，才会使用到红黑树</p>
<h4 id="PUT过程"><a href="#PUT过程" class="headerlink" title="PUT过程"></a>PUT过程</h4><p>1、数组[i]对象是否存在，不存在则直接创建节点并插入</p>
<p>2、存在，判断key值是否存在，不存在则直接插入</p>
<p>3、存在，直接覆盖</p>
<p>4、插入后根据数组 size++ &gt; threshold？判断是否需要扩容</p>
<p>5、第二三步插入时，判断是否需要将链表转化为红黑树</p>
<img src="images/Java集合相关/HashMap的put方法的过程.jpg" alt="HashMap的put方法的过程" style="zoom:50%;">

<h4 id="线程不安全-1"><a href="#线程不安全-1" class="headerlink" title="线程不安全"></a>线程不安全</h4><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><p>​    既然HashMap是线程不安全的，那我每次put/get操作时都用锁进行控制不就好了？HashTable确实是这么做的，给get/put操作加上了synchronized关键字。但是这样会导致效率低下，在多线程环境下进行读写操作时，其他操作都会被阻塞。所以基本上不推荐使用HashTable。</p>
<h3 id="ConcurrentHashMap-线程安全"><a href="#ConcurrentHashMap-线程安全" class="headerlink" title="ConcurrentHashMap-线程安全"></a>ConcurrentHashMap-线程安全</h3><h4 id="java7"><a href="#java7" class="headerlink" title="java7"></a>java7</h4><p>ConcurrentHashMap = Segement数组（继承ReentrantLock）+ HashEntry数组 + 链表，分段锁：每次锁一个segement，锁粒度较大</p>
<p><img src="/images/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/image-20211109233748646.png"></p>
<h4 id="java8"><a href="#java8" class="headerlink" title="java8"></a>java8</h4><p>ConcurrentHashMap = Node数组 + 链表/红黑树，bucket桶锁：synchronized第一个节点，相当于锁一个链表，锁粒度小，并且通过CAS的算法插入每个链表的第一个阶段，从而达到并发，锁的粒度较小，灵活。</p>
<p><img src="/images/Java%E9%9B%86%E5%90%88%E7%9B%B8%E5%85%B3/image-20221106233921455.png"></p>
<h3 id="红黑树的由来"><a href="#红黑树的由来" class="headerlink" title="红黑树的由来"></a>红黑树的由来</h3><p>二叉树：一个节点最多有2个子节点</p>
<p>二叉搜索树：有顺序的二叉树：左节点 &lt; 父节点 &lt; 右节点，二叉搜索树高度不确定，检索稳定性差。</p>
<p>平衡二叉树：任意一个节点，左子树高度 与 右子树高度的差不超过1，但是维护平衡二叉树这一特性比较复杂</p>
<h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p>1、节点颜色，不是红色就是黑色</p>
<p>2、根节点是黑色</p>
<p>3、叶子节点（空节点）是黑色</p>
<p>4、红色节点的孩子节点是黑色</p>
<p>5、任一节点到叶子节点的黑色节点的数量是一致的</p>
<p>红黑树也是动态树，寻找过程复杂度也趋近LogN，插入过程也是，先查找，然后通过红黑特殊规则调整和旋转（该过程比平衡二叉树快也是LogN维度）</p>
<h3 id="用java手写实现简单HashMap"><a href="#用java手写实现简单HashMap" class="headerlink" title="用java手写实现简单HashMap"></a>用java手写实现简单HashMap</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure>

<h2 id="java8和java17的区别（java9-17新特性有哪些）"><a href="#java8和java17的区别（java9-17新特性有哪些）" class="headerlink" title="java8和java17的区别（java9-17新特性有哪些）"></a>java8和java17的区别（java9-17新特性有哪些）</h2><p>背景：</p>
<p>2020.9。JDK15 发布，宣布 ZGC 可用于生产，2021.9。JDK17 发布，宣布商用免费</p>
<h3 id="zgc"><a href="#zgc" class="headerlink" title="zgc"></a>zgc</h3><p>低延迟：控制GC停顿时间在10ms内，对停顿时间敏感</p>
<p>大内存：可支持到TB级别的内存，适用于大规模、高并发的应用。</p>
<p>并发性：大部分工作都是并发完成的，包括标记、压缩、清理，减少了应用STW时间</p>
<p>内存碎片处理：使用基于指针压缩的内存管理，减少内存碎片，并通过并发压缩进一步优化内存利用。</p>
<h3 id="新语法特性"><a href="#新语法特性" class="headerlink" title="新语法特性"></a>新语法特性</h3><h4 id="1、密封类-Sealed-Classes"><a href="#1、密封类-Sealed-Classes" class="headerlink" title="1、密封类 Sealed Classes"></a>1、密封类 Sealed Classes</h4><p>密封类可以限制其他类可以继承。</p>
<p>使用场景：组件开发者写的接口，不希望组件使用者继承</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> sealed <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Shape</span></span><br><span class="hljs-class">    <span class="hljs-title">permits</span> <span class="hljs-title">Circle</span>, <span class="hljs-title">Rectangle</span> </span>&#123;...&#125; <span class="hljs-comment">//只允许 CirCle 和 Rectangle 继承自己</span><br> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Circle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125; <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125; <span class="hljs-comment">// OK</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Triangle</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Shape</span> </span>&#123;...&#125; <span class="hljs-comment">// Compile error</span><br> <br><span class="hljs-comment">// No need for default case if all permitted types are covered</span><br><span class="hljs-keyword">double</span> area = <span class="hljs-keyword">switch</span> (shape) &#123;<br>    <span class="hljs-keyword">case</span> Circle c    -&gt; Math.pow(c.radius(), <span class="hljs-number">2</span>) * Math.PI<br>    <span class="hljs-keyword">case</span> Rectangle r -&gt; r.a() * r.b()<br>&#125;;<br></code></pre></td></tr></table></figure>

<h4 id="2、Record-Classes"><a href="#2、Record-Classes" class="headerlink" title="2、Record Classes"></a>2、Record Classes</h4><p>一种简洁且安全的方式来创建不可变的数据携带对象，无需手动编写get/set/toString方法</p>
<p>使用场景：任何需要用到不可变特性的地方，主要用户数据传输如DTO</p>
<h4 id="3、instanceof-增强"><a href="#3、instanceof-增强" class="headerlink" title="3、instanceof  增强"></a>3、instanceof  增强</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (obj <span class="hljs-keyword">instanceof</span> String s &amp;&amp; s.length() &gt; <span class="hljs-number">5</span>) &#123;<br>    <span class="hljs-comment">//注意，但 obj 为 String 类型时，变量 s 替代了 obj 变量。避免了丑陋的类型转换</span><br>    System.out.println(<span class="hljs-string">&quot;obj is a String with more than 5 characters: &quot;</span> + s.toUpperCase());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、try with resources 增强</p>
<p>5、var 声明变量</p>
<p>6、switch 增强</p>
<p>7、接口可以定义私有方法</p>
]]></content>
      <categories>
        <category>集合</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>List</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S简介及概念介绍</title>
    <url>/2025/01/25/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="K8S简介及概念介绍"><a href="#K8S简介及概念介绍" class="headerlink" title="K8S简介及概念介绍"></a>K8S简介及概念介绍</h1><h2 id="认识-Kubernetes"><a href="#认识-Kubernetes" class="headerlink" title="认识 Kubernetes"></a>认识 Kubernetes</h2><h3 id="什么是Kubernetes"><a href="#什么是Kubernetes" class="headerlink" title="什么是Kubernetes"></a>什么是Kubernetes</h3><p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250125184932012.png" alt="image-20250125184932012"></p>
<p>​    如图所见，k8s是一个船舵的logo，联想docker的logo：装满集装箱的船，预示着k8s是用来管理容器的。kubernetes简称k8s，因为k和s间隔着8个字符。<strong>Google</strong> 在 2014 年开源了 Kubernetes 项目。 Kubernetes 建立在 Google 大规模运行生产工作负载十几年经验的基础上， 结合了社区中最优秀的想法和实践。最初由谷歌开发，后贡献给云原生计算基金会（CNCF）进行维护和发展。</p>
<p>​    一句话来说，k8s是一个开源的容器编排和管理平台。</p>
<p>​    对标的产品有<strong>Docker Swarm、Apache Mesos</strong></p>
<h3 id="为什么需要Kubernetes"><a href="#为什么需要Kubernetes" class="headerlink" title="为什么需要Kubernetes"></a>为什么需要Kubernetes</h3><h4 id="应用部署的三个阶段"><a href="#应用部署的三个阶段" class="headerlink" title="应用部署的三个阶段"></a>应用部署的三个阶段</h4><p>传统部署：购买物理机，环境不隔离</p>
<p>虚拟化部署：通过虚拟机隔离不同的应用，资源隔离了，但是虚拟机过重占用资源过多</p>
<p>容器化部署：环境隔离，不像虚拟机那么重</p>
<p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250125191219282.png" alt="image-20250125191219282"></p>
<h4 id="K8S的特点"><a href="#K8S的特点" class="headerlink" title="K8S的特点"></a>K8S的特点</h4><ul>
<li>自动化部署<ul>
<li>Kubernetes可以根据预定定义好的YAML配置文件，自动创建部署容器服务，在不同的环境<strong>一致地</strong>运行同一套代码</li>
</ul>
</li>
<li>弹性伸缩<ul>
<li>能够根据应用的负载情况（cpu使用率，内存使用率）自动调整应用实例的数量以满足业务使用需求，提高资源利用率</li>
</ul>
</li>
<li>服务发现和负载均衡<ul>
<li>服务发现<ul>
<li>k8s为每个应用程序定义了一个稳定的网络地址，使得不同容器之间能通过这个地址或者域名来互相通信，无需手动配置ip和端口</li>
</ul>
</li>
<li>负载均衡<ul>
<li>将外部请求均匀地发到多个实力上，避免单点故障</li>
</ul>
</li>
</ul>
</li>
<li>自我修复<ul>
<li>会持续检测容器运行状态，当容器崩溃或者不可用时，会自动重启，并且把请求流量调度到其他健康的节点上。</li>
</ul>
</li>
<li>存储编排<ul>
<li>支持多种存储系统（如 NFS、iSCSI、Ceph 等），可以为容器化应用动态地挂载和管理存储卷，确保数据的持久化和可访问性</li>
</ul>
</li>
<li>滚动更新与回滚<ul>
<li>滚动更新<ul>
<li>在更新应用程序时，Kubernetes 可以逐步替换旧版本的容器为新版本的容器，确保在更新过程中应用的正常运行，减少停机时间。比如容器实例是2，发布时容器实例会这样演变 2旧 -&gt; 2旧1新（启动中） -&gt; 1旧1新(已更新) -&gt;  1旧1新（已更新）1新（启动中） -&gt; 2新（已更新）</li>
</ul>
</li>
<li>版本回滚<ul>
<li>如果更新过程中出现问题，可以快速将应用程序回滚到上一个稳定版本，回滚过程与发布更新类型</li>
</ul>
</li>
</ul>
</li>
<li>机密和配置管理<ul>
<li>k8s提供了配置管理服务，并且支持对敏感数据加密</li>
</ul>
</li>
</ul>
<h2 id="集群架构与组件"><a href="#集群架构与组件" class="headerlink" title="集群架构与组件"></a>集群架构与组件</h2><h3 id="控制面板组件（Master）"><a href="#控制面板组件（Master）" class="headerlink" title="控制面板组件（Master）"></a>控制面板组件（Master）</h3><ul>
<li><strong>kube-apiserver</strong><ul>
<li>API 服务器是 Kubernetes 控制平面的组件， 该组件负责公开了 Kubernetes API，负责处理接受请求的工作。 API 服务器是 Kubernetes 控制平面的前端。</li>
</ul>
</li>
<li><strong>kube-controller-manager</strong><ul>
<li>kube-controller-manager 是控制平面的组件， 负责运行控制器进程。<ul>
<li>节点控制器（Node Controller）：负责在节点出现故障时进行通知和响应</li>
<li>任务控制器（Job Controller）：监测代表一次性任务的 Job 对象，然后创建 Pods 来运行这些任务直至完成</li>
<li>端点分片控制器（EndpointSlice controller）：填充端点分片（EndpointSlice）对象（以提供 Service 和 Pod 之间的链接）。</li>
<li>服务账号控制器（ServiceAccount controller）：为新的命名空间创建默认的服务账号（ServiceAccount）。</li>
</ul>
</li>
</ul>
</li>
<li>cloud-controller-manager<ul>
<li>嵌入了特定于云平台的控制逻辑。 云控制器管理器（Cloud Controller Manager）允许你将你的集群连接到云提供商的 API 之上， 并将与该云平台交互的组件同与你的集群交互的组件分离开来。</li>
</ul>
</li>
<li><strong>kube-scheduleer</strong><ul>
<li>scheduler 负责资源的调度，按照预定的调度策略将 Pod 调度到相应的机器上；</li>
</ul>
</li>
<li><strong>etcd</strong><ul>
<li>一致且高度可用的<strong>键值存储</strong>，用作 Kubernetes 的所有集群数据的后台数据库。</li>
</ul>
</li>
</ul>
<h3 id="节点组件"><a href="#节点组件" class="headerlink" title="节点组件"></a>节点组件</h3><ul>
<li>kubelet<ul>
<li>kubelet 负责维护容器的生命周期，同时也负责 Volume（CVI）和网络（CNI）的管理；</li>
</ul>
</li>
<li>kube-proxy<ul>
<li>kube-proxy 负责为 Service 提供 cluster 内部的服务发现和负载均衡；</li>
</ul>
</li>
<li>containner-runtime<ul>
<li>Container runtime 负责镜像管理以及 Pod 和容器的真正运行（CRI）；</li>
<li>Kubernetes 支持许多容器运行环境，例如 containerd、 CRI-O 以及 Kubernetes CRI (容器运行环境接口) 的其他任何实现。</li>
</ul>
</li>
</ul>
<h3 id="附加组件"><a href="#附加组件" class="headerlink" title="附加组件"></a>附加组件</h3><ul>
<li>kube-dns<ul>
<li>kube-dns 负责为整个集群提供 DNS 服务</li>
</ul>
</li>
<li>Ingress Controller<ul>
<li>Ingress Controller 为服务提供外网入口</li>
</ul>
</li>
<li>Prometheus<ul>
<li>Prometheus 提供资源监控</li>
</ul>
</li>
<li>Dashboard<ul>
<li>Dashboard 提供 GUI</li>
</ul>
</li>
<li>Federation<ul>
<li>Federation 提供跨可用区的集群</li>
</ul>
</li>
<li>Fluentd-elasticsearch<ul>
<li>Fluentd-elasticsearch 提供集群日志采集、存储与查询</li>
</ul>
</li>
</ul>
<p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250125204106849.png" alt="image-20250125204106849"></p>
<h2 id="核心概念与专业术语"><a href="#核心概念与专业术语" class="headerlink" title="核心概念与专业术语"></a>核心概念与专业术语</h2><h3 id="服务的分类"><a href="#服务的分类" class="headerlink" title="服务的分类"></a>服务的分类</h3><h4 id="有状态"><a href="#有状态" class="headerlink" title="有状态"></a>有状态</h4><p>​    服务存在状态，一般指服务需要存储数据，这种服务就是有状态的，比如redis，mysql这些。</p>
<p><strong>优点：</strong>可以独立存储数据，实现数据管理</p>
<p><strong>缺点：</strong>集群环境下需要实现主从、数据同步、备份、水平扩容复杂</p>
<h4 id="无状态"><a href="#无状态" class="headerlink" title="无状态"></a>无状态</h4><p>​    nginx等，重启前后不影响服务的正常运行</p>
<p><strong>优点：</strong>对客户端透明，无依赖关系，可以高效实现扩容、迁移</p>
<p><strong>缺点：</strong>不能存储数据，需要额外的数据服务支撑</p>
<h1 id="资源和对象"><a href="#资源和对象" class="headerlink" title="资源和对象"></a>资源和对象</h1><h2 id="资源分类"><a href="#资源分类" class="headerlink" title="资源分类"></a>资源分类</h2><p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250206220209341.png" alt="image-20250206220209341"></p>
<p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250206221035336.png" alt="image-20250206221035336"></p>
<h3 id="元数据级"><a href="#元数据级" class="headerlink" title="元数据级"></a>元数据级</h3><h4 id="Horizontal-Pod-Autoscaler（HPA）"><a href="#Horizontal-Pod-Autoscaler（HPA）" class="headerlink" title="Horizontal Pod Autoscaler（HPA）"></a>Horizontal Pod Autoscaler（HPA）</h4><p>​    <strong>Pod 自动扩容缩容</strong>：可以根据 CPU 使用率或自定义指标（metrics）自动对 Pod 进行扩/缩容。<br>控制管理器每隔30s（可以通过–horizontal-pod-autoscaler-sync-period修改）查询metrics的资源使用情况<br>支持三种metrics类型<br>​    预定义metrics（比如Pod的CPU）以利用率的方式计算<br>​    自定义的Pod metrics，以原始值（raw value）的方式计算<br>​    自定义的object metrics</p>
<p>支持两种metrics查询方式：Heapster和自定义的REST API，支持多metrics</p>
<h4 id="PodTemplate"><a href="#PodTemplate" class="headerlink" title="PodTemplate"></a>PodTemplate</h4><p>​    顾名思义：pod创建的模版，是关于 Pod 的定义，但是被包含在其他的 Kubernetes 对象中（例如 Deployment、StatefulSet、DaemonSet 等控制器）。控制器通过 Pod Template 信息来创建 Pod</p>
<h4 id="LimitRange"><a href="#LimitRange" class="headerlink" title="LimitRange"></a>LimitRange</h4><p>​    可以对集群内 Request 和 Limits 的配置做一个全局的统一的限制，相当于批量设置了某一个范围内（某个命名空间）的 Pod 的<strong>资源使用限制</strong>。</p>
<h3 id="集群级"><a href="#集群级" class="headerlink" title="集群级"></a>集群级</h3><h4 id="Namespace"><a href="#Namespace" class="headerlink" title="Namespace"></a>Namespace</h4><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">Kubernetes 支持多个虚拟集群，它们底层依赖于同一个物理集群，这些虚拟集群被称为命名空间。<br>作用是用于实现多团队/环境的资源隔离。命名空间 namespace 是 k8s 集群级别的资源，可以给不同的用户、租户、环境或项目创建对应的命名空间。<br></code></pre></td></tr></table></figure>

<p>默认 namespace：</p>
<ul>
<li>kube-system 主要用于运行系统级资源，存放 k8s 自身的组件</li>
<li>kube-public 此命名空间是自动创建的，并且可供所有用户（包括未经过身份验证的用户）读取。此命名空间主要用于集群使用，关联的一些资源在集群中是可见的并且可以公开读取。此命名空间的公共方面知识一个约定，但不是非要这么要求。</li>
<li>default 未指定名称空间的资源就是 default，即你在创建pod 时如果没有指定 namespace，则会默认使用 default</li>
</ul>
<h4 id="Node："><a href="#Node：" class="headerlink" title="Node："></a>Node：</h4><h4 id="ClusterRole"><a href="#ClusterRole" class="headerlink" title="ClusterRole"></a>ClusterRole</h4><p>​    ClusterRole 是一组权限的集合，但与 Role 不同的是，ClusterRole 可以在包括所有 Namespace 和集群级别的资源或非资源类型进行鉴权。</p>
<h4 id="ClusterRoleBinding"><a href="#ClusterRoleBinding" class="headerlink" title="ClusterRoleBinding"></a>ClusterRoleBinding</h4><p>​    ClusterRoleBinding：将 Subject 绑定到 ClusterRole，ClusterRoleBinding 将使规则在所有命名空间中生效。</p>
<h3 id="命名空间别"><a href="#命名空间别" class="headerlink" title="命名空间别"></a>命名空间别</h3><p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250206221652637.png" alt="image-20250206221652637"></p>
<h4 id="工作负载型"><a href="#工作负载型" class="headerlink" title="工作负载型"></a>工作负载型</h4><h5 id="Pod"><a href="#Pod" class="headerlink" title="Pod"></a>Pod</h5><p>​    pod大致分为副本（replicas）和控制器</p>
<p>​    Pod（容器组）是 Kubernetes 中最小的可部署单元。一个 Pod（容器组）包含了一个应用程序容器（某些情况下是多个容器）、存储资源、一个唯一的网络 IP 地址、以及一些确定容器该如何运行的选项。Pod 容器组代表了 Kubernetes 中一个独立的应用程序运行实例，该实例可能由单个容器或者几个紧耦合在一起的容器组成。</p>
<p>​    Docker 是 Kubernetes Pod 中使用最广泛的容器引擎；Kubernetes Pod 同时也支持其他类型的容器引擎。</p>
<p>Kubernetes 集群中的 Pod 存在如下两种使用途径：</p>
<ol>
<li>一个 Pod 中只运行一个容器。”one-container-per-pod” 是 Kubernetes 中最常见的使用方式。此时，您可以认为 Pod 容器组是该容器的 wrapper，Kubernetes 通过 Pod 管理容器，而不是直接管理容器。</li>
<li>一个 Pod 中运行多个需要互相协作的容器。您可以将多个紧密耦合、共享资源且始终在一起运行的容器编排在同一个 Pod 中</li>
</ol>
<h5 id="副本"><a href="#副本" class="headerlink" title="副本"></a>副本</h5><blockquote>
<p>先引入“副本”的概念——一个 Pod 可以被复制成多份，每一份可被称之为一个“副本”，这些“副本”除了一些描述性的信息（Pod 的名字、uid 等）不一样以外，其它信息都是一样的，譬如 Pod 内部的容器、容器数量、容器里面运行的应用等的这些信息都是一样的，这些副本提供同样的功能。</p>
<p>Pod 的“控制器”通常包含一个名为 “replicas” 的属性。“replicas”属性则指定了特定 Pod 的副本的数量，当当前集群中该 Pod 的数量与该属性指定的值不一致时，k8s 会采取一些策略去使得当前状态满足配置的要求。</p>
</blockquote>
<h5 id="控制器"><a href="#控制器" class="headerlink" title="控制器"></a>控制器</h5><p><strong>ReplicationController（RC）</strong>：动态保证副本数<br><strong>ReplicaSet（RS）：</strong>打标签，支持selector<br><strong>Deployment：</strong>Deployment 为 Pod 和 Replica Set 提供声明式更新。你只需要在 Deployment 中描述你想要的目标状态是什么，Deployment controller 就会帮你将 Pod 和 Replica Set 的实际状态改变到你的目标状态。你可以定义一个全新的 Deployment，也可以创建一个新的替换旧的 Deployment。</p>
<p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250206222211431.png" alt="image-20250206222211431"></p>
<p><strong>StatefulSet：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">StatefulSet 中每个 Pod 的 DNS 格式为 <br>statefulSetName-&#123;0..N-1&#125;.serviceName.namespace.svc.cluster.local<br>serviceName 为 Headless Service 的名字0..N-1 为 Pod 所在的序号，从 0 开始到 N-1<br>statefulSetName 为 StatefulSet 的名字namespace 为服务所在的 namespace，Headless Servic 和 StatefulSet 必须在相同的 namespace<br>.cluster.local 为 Cluster Domain<br></code></pre></td></tr></table></figure>

<p><strong>Daemonet：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">DaemonSet 保证在每个 Node 上都运行一个容器副本，常用来部署一些集群的日志、监控或者其他系统管理应用。典型的应用包括：<br>日志收集，比如 fluentd，logstash 等<br>系统监控，比如 Prometheus Node Exporter，collectd，New Relic agent，Ganglia gmond 等<br>系统程序，比如 kube-proxy, kube-dns, glusterd, ceph 等<br></code></pre></td></tr></table></figure>

<p><strong>Job和CronJob：</strong></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">Job:一次性任务，运行完成后Pod销毁，不再重新启动新容器。<br>CronJob:CronJob 是在 Job 基础上加上了定时功能。<br></code></pre></td></tr></table></figure>



<p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250206222946057.png" alt="image-20250206222946057"></p>
<h4 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h4><h5 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h5><pre><code>“Service” 简写 “svc”。Pod 不能直接提供给外网访问，而是应该使用 service。Service 就是把 Pod 暴露出来提供服务，Service 才是真正的“服务”，它的中文名就叫“服务”。
</code></pre>
<p>​    可以说 Service 是一个应用服务的抽象，定义了 Pod 逻辑集合和访问这个 Pod 集合的策略。Service 代理 Pod 集合，对外表现为一个访问入口，访问该入口的请求将经过负载均衡，转发到后端 Pod 中的容器。</p>
<h5 id="Ingress"><a href="#Ingress" class="headerlink" title="Ingress"></a>Ingress</h5><pre><code>Ingress 可以提供外网访问 Service 的能力。可以把某个请求地址映射、路由到特定的 service。
</code></pre>
<p>​    ingress 需要配合 ingress controller 一起使用才能发挥作用，ingress 只是相当于路由规则的集合而已，真正实现路由功能的，是 Ingress Controller，ingress controller 和其它 k8s 组件一样，也是在 Pod 中运行。</p>
<p><img src="/images/K8S%E7%AE%80%E4%BB%8B%E5%8F%8A%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/image-20250206224859211.png" alt="image-20250206224859211"></p>
<h4 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h4><h5 id="Volume"><a href="#Volume" class="headerlink" title="Volume"></a>Volume</h5><p>​    数据卷，共享 Pod 中容器使用的数据。用来放持久化的数据，比如数据库数据。</p>
<h5 id="CSI"><a href="#CSI" class="headerlink" title="CSI"></a>CSI</h5><pre><code>Container Storage Interface 是由来自 Kubernetes、Mesos、Docker 等社区成员联合制定的一个行业标准接口规范，旨在将任意存储系统暴露给容器化应用程序。
CSI 规范定义了存储提供商实现 CSI 兼容的 Volume Plugin 的最小操作集和部署建议。CSI 规范的主要焦点是声明 Volume Plugin 必须实现的接口。
</code></pre>
<h4 id="特殊类型配置"><a href="#特殊类型配置" class="headerlink" title="特殊类型配置"></a>特殊类型配置</h4><h5 id="ConfigMap"><a href="#ConfigMap" class="headerlink" title="ConfigMap"></a>ConfigMap</h5><p>​    用来放配置，与 Secret 是类似的，只是 ConfigMap 放的是明文的数据，Secret 是密文存放。</p>
<h5 id="Secret"><a href="#Secret" class="headerlink" title="Secret"></a>Secret</h5><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">Secret 解决了密码、token、密钥等敏感数据的配置问题，而不需要把这些敏感数据暴露到镜像或者 Pod Spec 中。Secret 可以以 Volume 或者环境变量的方式使用。<br>Secret 有三种类型：<br>Service Account：用来访问 Kubernetes API，由 Kubernetes 自动创建，并且会自动挂载到 Pod 的 /run/secrets/kubernetes.io/serviceaccount 目录中；<br>Opaque：base64 编码格式的 Secret，用来存储密码、密钥等；<br>kubernetes.io/dockerconfigjson：用来存储私有 docker registry 的认证信息。<br></code></pre></td></tr></table></figure>

<h5 id="DownwardAPI"><a href="#DownwardAPI" class="headerlink" title="DownwardAPI"></a>DownwardAPI</h5><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">downwardAPI 这个模式和其他模式不一样的地方在于它不是为了存放容器的数据也不是用来进行容器和宿主机的数据交换的，而是让 pod 里的容器能够直接获取到这个 pod 对象本身的一些信息。<br>downwardAPI 提供了两种方式用于将 pod 的信息注入到容器内部：<br>环境变量：用于单个变量，可以将 pod 信息和容器信息直接注入容器内部<br>volume 挂载：将 pod 信息生成为文件，直接挂载到容器内部中去<br></code></pre></td></tr></table></figure>

<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>Role:</p>
<p>​    Role 是一组权限的集合，例如 Role 可以包含列出 Pod 权限及列出 Deployment 权限，Role 用于给某个 Namespace 中的资源进行鉴权。</p>
<p>RoleBinding</p>
<p>​    RoleBinding将Subject 绑定到 Role，RoleBinding 使规则在命名空间内生效。</p>
<h4 id="资源清单"><a href="#资源清单" class="headerlink" title="资源清单"></a>资源清单</h4><h3 id="对象规约和状态"><a href="#对象规约和状态" class="headerlink" title="对象规约和状态"></a>对象规约和状态</h3><h4 id="规约（Spec）"><a href="#规约（Spec）" class="headerlink" title="规约（Spec）"></a>规约（Spec）</h4><h4 id="状态-Status"><a href="#状态-Status" class="headerlink" title="状态(Status)"></a>状态(Status)</h4>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>k8s</tag>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 入门简介</title>
    <url>/2021/02/14/MyArticle/</url>
    <content><![CDATA[<p>学习笔记！2020年2月5日13点13分<br>—    #安装Nodejs<br>node -v    #查看node版本<br>npm -v    #查看npm版本<br>npm install -g cnpm –registry=<a href="http://registry.npm.taobao.org/">http://registry.npm.taobao.org</a>    #安装淘宝的cnpm 管理器<br>cnpm -v    #查看cnpm版本<br>cnpm install -g hexo-cli    #安装hexo框架<br>hexo -v    #查看hexo版本<br>mkdir blog    #创建blog目录<br>cd blog     #进入blog目录<br>sudo hexo init     #生成博客 初始化博客<br>hexo s    #启动本地博客服务<br><a href="http://localhost:4000/">http://localhost:4000/</a>    #本地访问地址<br>hexo n “我的第一篇文章” #创建新的文章<br>#返回blog目录<br>hexo clean #清理<br>hexo g #生成<br>#Github创建一个新的仓库 YourGithubName.github.io<br>cnpm install –save hexo-deployer-git #在blog目录下安装git部署插件<br>-—<br>#配置_config.yml<br>-—-</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
</code></pre>
<p>​    deploy:<br>          type: git<br>         repo: <a href="https://github.com/YourGithubName/YourGithubName.github.io.git">https://github.com/YourGithubName/YourGithubName.github.io.git</a><br>          branch: master<br>-—-<br>hexo d    #部署到Github仓库里<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #访问这个地址可以查看博客</p>
<p> git clone <a href="https://github.com/litten/hexo-theme-yilia.git">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia  #下载yilia主题到本地</p>
<p>#修改hexo根目录下的 _config.yml 文件 ： theme: yilia</p>
<p>hexo c    #清理一下<br>hexo g    #生成<br>hexo d    #部署到远程Github仓库<br><a href="https://yourgithubname.github.io/">https://YourGithubName.github.io/</a>  #查看博客</p>
]]></content>
      <categories>
        <category>随心记</category>
      </categories>
      <tags>
        <tag>测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-01-工厂类与常用注解</title>
    <url>/2021/06/14/Spring-01-%E5%B7%A5%E5%8E%82%E7%B1%BB%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Spring框架功能整体介绍"><a href="#Spring框架功能整体介绍" class="headerlink" title="Spring框架功能整体介绍"></a>Spring框架功能整体介绍</h1><img src="/images/Spring-01-工厂类与常用注解/image-20210614232348569.png" alt="image-20210614232348569" style="zoom: 67%;">

<h2 id="Spring-Core-Container"><a href="#Spring-Core-Container" class="headerlink" title="Spring Core Container"></a>Spring Core Container</h2><p>​    Core 和 Beans 模块是框架的基础部分，提供 IoC （转控制）和依赖注入特性。 这里的基础概念是 BeanFactory，它提供对 Factory 模式的经典实现来消除对程序对单例模式的需要，并真正地允许你从程序逻辑中分离出依赖关系和配置</p>
<p>​    <strong>Core</strong>：主要包含 Spring 框架基本的核心工具类， Spring 的其他组件都要用到这个包 里的类， Core模块是其他组件的基 本核心。</p>
<p>​    <strong>Beans</strong> (BeanFacotry)：它包含访问配直文件、创建和管理 bean 以及进行 Inversion of Control I Dependency Injection ( IoC/DI ）操作相关的所有类</p>
<p>​    <strong>Context</strong>(处理BeanFactory，一般还是ApplicationContext起作用)：构建于 Core 和 Beans 模块基础之上，提供了一种类似JNDI注册器的框架式的对象访问方法。Context模块继承了Beans的特性，为Spring核心提供了大量扩展，添加了对国际化（例如资源绑定）、事件传播、资源加载和对Context的透明创建的支持。Context模块同时也支持J2EE的一些特性，ApplicationContext接口是Context模块的关键</p>
<p>​    Expression Language：模块提供了强大的表达式语言，用于在运行时查询和操纵对象。它是JSP2.1规范中定义的unifed expression language 的扩展。该语言支持设直／获取属性的值，属性的分配，方法的调用，访问数组上下文（accessiong the context of arrays）、容器和索引器、逻辑和算术运算符、命名变量以及从Spring的IoC容器中根据名称检索对象。它也支持list投影、选择和一般的list聚合</p>
<h2 id="Spring-Data-Access-Integration"><a href="#Spring-Data-Access-Integration" class="headerlink" title="Spring Data Access/Integration"></a>Spring Data Access/Integration</h2><p>​    <strong>JDBC：</strong>模块提供了一个JDBC抽象层，它可以消除冗长的JDBC编码和解析数据库厂商特有的错误代码。这个模块包含了Spring对JDBC数据访问进行封装的所有类</p>
<p>​    <strong>ORM：</strong>模块为流行的对象－关系映射API，如JPA、JDO、Hibernate、iBatis等，提供了一个交互层。利用ORM封装包，可以混合使用所有Spring提供的特性进行O/R映射，如前边提到的简单声明性事务管理。</p>
<p>​    <strong>OXM：</strong>模块提供了一个对<strong>Object 与 XML</strong>映射实现的抽象层</p>
<p>​    <strong>JMS(Java Messaging Service )：</strong>模块主要包含了 一些制造和消 费消息的特性。</p>
<p>​    <strong>Transaction：</strong>支持编程和声明性的事务管理，这些事务类必须实现特定的接口，并且对所有的 POJO 都适用</p>
<h2 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h2><p>​    Web模块：提供了基础的面向Web的集成特性，例如，多文件上传、使用servlet listeners 初始化IoC 容器以及一个面向 Web 的应用上下文。 它还包含 Spring 远程支持中 Web 的相关部分。</p>
<h2 id="Spring-Aop"><a href="#Spring-Aop" class="headerlink" title="Spring Aop"></a>Spring Aop</h2><p>​    <strong>Aspects</strong> 模块提供了对 AspectJ 的集成支持。</p>
<p>​    <strong>Instrumentation</strong> 模块提供了 class instrumentation 支持和classloader 实现，使得可以在特定的应用服务器上使用</p>
<h2 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h2><p>Test 模块支持使用 JUnit 和 TestNG 对 Spring 组件进行测试</p>
<h2 id="Spring容器继承图"><a href="#Spring容器继承图" class="headerlink" title="Spring容器继承图"></a>Spring容器继承图</h2><p><img src="/images/Spring-01-%E5%B7%A5%E5%8E%82%E7%B1%BB%E4%B8%8E%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3/BeanFactory.png"></p>
<h2 id="IOC和DI-控制反转和依赖注入"><a href="#IOC和DI-控制反转和依赖注入" class="headerlink" title="IOC和DI(控制反转和依赖注入)"></a>IOC和DI(控制反转和依赖注入)</h2><p>​        <strong>DI：</strong>软件设计的一个重要思想：依赖倒置原则（Dependency Inversion Principle ）</p>
<p>​        <strong>IOC：</strong>的思想最核心的地方在于，资源不由使用资源的双方管理，而由不使用资源的第三方管理，这可以带来很多好处。第一，资源集中管理，实现资源的可配置和易管理。第二，降低了使用资源双方的依赖程度，也就是我们说的耦合度</p>
<h1 id="SpringIOC容器底层注解使用"><a href="#SpringIOC容器底层注解使用" class="headerlink" title="SpringIOC容器底层注解使用"></a>SpringIOC容器底层注解使用</h1><h2 id="往容器中定义bean信息的方式"><a href="#往容器中定义bean信息的方式" class="headerlink" title="往容器中定义bean信息的方式"></a>往容器中定义bean信息的方式</h2><p>在标有@Configuration的类上</p>
<ol>
<li>@Bean(<strong>适用于导入第三方组件的类</strong>)</li>
<li>通过@CompentScan +@Controller @Service @Respository @compent<ol>
<li>排除用法 excludeFilters(排除@Controller注解的,和TulingService的)</li>
<li>包含用法 includeFilters ,注意，若使用包含的用法，需要把useDefaultFilters属性设置为false（true表<br>示扫描全部的）</li>
<li>@ComponentScan.Filter type的类型<ol>
<li>注解形式的FilterType.ANNOTATION @Controller @Service @Repository @Compent</li>
<li>指定类型的 FilterType.ASSIGNABLE_TYPE @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,value = {TulingService.class})</li>
<li>aspectj类型的 FilterType.ASPECTJ(不常用) d)正则表达式的 FilterType.REGEX(不常用)</li>
<li>e)自定义的 FilterType.CUSTOM</li>
</ol>
</li>
<li>适用场景: 针对我们自己写的组件可以通过该方式来进行加载到容器中。</li>
</ol>
</li>
<li>@Import<strong>（导入组件的</strong>id<strong>为全类名路径）</strong><ol>
<li>ImportSeletor</li>
<li>ImportBeanDefinitionRegister</li>
</ol>
</li>
<li>@BeanFactory（创建复杂对象如SqlSessionFactoryBean）</li>
</ol>
<h2 id="配置Bean的作用域对象"><a href="#配置Bean的作用域对象" class="headerlink" title="配置Bean的作用域对象"></a>配置Bean的作用域对象</h2><h3 id="Scope指定的作用域方法取值"><a href="#Scope指定的作用域方法取值" class="headerlink" title="@Scope指定的作用域方法取值"></a>@Scope指定的作用域方法取值</h3><ul>
<li>singleton 单实例的(默认)</li>
<li>prototype 多实例的</li>
<li>request 同一次请求</li>
<li>session 同一个会话级别</li>
</ul>
<h2 id="bean的生命周期"><a href="#bean的生命周期" class="headerlink" title="bean的生命周期"></a>bean的生命周期</h2><p>​    bean的创建—–&gt;初始化    &gt;销毁方法</p>
<h3 id="bean的初始化和销毁"><a href="#bean的初始化和销毁" class="headerlink" title="bean的初始化和销毁"></a>bean的初始化和销毁</h3><p>由容器管理Bean的生命周期，我们可以通过自己指定bean的初始化方法和bean的销毁方法</p>
<p>​    <strong>针对单实例bean的话，容器启动的时候，bean的对象就创建了，而且容器销毁的时候，也会调用Bean的销毁方法</strong></p>
<p>​    <strong>针对多实例bean的话,容器启动的时候，bean是不会被创建的而是在获取bean的时候被创建，而且bean的销毁不受IOC容器的管理.</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> </span>&#123;<br><span class="hljs-comment">//指定了bean的生命周期的初始化方法和销毁方法.</span><br>	<span class="hljs-meta">@Bean(initMethod = &quot;init&quot;,destroyMethod = &quot;destroy&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> Car <span class="hljs-title">car</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Car();<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过 InitializingBean和DisposableBean接口</strong></p>
<p><strong>通过 @PostConstruct和@PreDestroy注解</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span> <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Book</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Book</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book 的构造方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book 的PostConstruct标志的方法&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destory</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;book 的PreDestory标注的方法&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>通过Spring的BeanPostProcessor的 bean的后置处理器会拦截所有bean初始化过程</strong></p>
<p>​    postProcessBeforeInitialization 在init方法之前调用</p>
<p>​    postProcessAfterInitialization 在init方法之后调用</p>
<h2 id="组件赋值"><a href="#组件赋值" class="headerlink" title="组件赋值"></a>组件赋值</h2><p><strong>通过@Value +@PropertySource来给组件赋值</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-comment">//通过普通的方式@Value(&quot;司马&quot;)</span><br>    <span class="hljs-keyword">private</span> String firstName;<br><br>    <span class="hljs-comment">//spel方式来赋值@Value(&quot;#&#123;28-8&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>    通过读取外部配置文件的值<br>    <span class="hljs-meta">@Value(&quot;$&#123;person.lastName&#125;&quot;)</span> <br>    <span class="hljs-keyword">private</span> String lastName;<br><br>    &#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(value = &#123;&quot;classpath:person.properties&quot;&#125;)</span> <span class="hljs-comment">//指定外部文件的位置public class MainConfig &#123;</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span> </span>&#123; <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person();           <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="自动装配"><a href="#自动装配" class="headerlink" title="自动装配"></a><strong>自动装配</strong></h2><h3 id="AutoWired的使用"><a href="#AutoWired的使用" class="headerlink" title="@AutoWired的使用"></a>@AutoWired的使用</h3><ul>
<li><p>自动装配首先时按照类型进行装配，若在IOC容器中发现了多个相同类型的组件，那么就按照<strong>属性名称</strong>来进行装配</p>
<ul>
<li><p>比如，我容器中有2个TulingDao类型的组件 一个叫tulingDao 一个叫tulingDao2</p>
<p>那么我们通过@AutoWired 来修饰的属性名称时tulingDao，那么拿就加载容器的tulingDao组件，若属性名称为<br>tulignDao2 那么他就加载的时tulingDao2组件</p>
</li>
</ul>
</li>
<li><p>假设我们需要指定特定的组件来进行装配，我们可以通过使用@Qualifier(“tulingDao”)来指定装配的组件或者在配置类上的@Bean加上@Primary注解</p>
</li>
<li><p>假设我们容器中即没有tulingDao 和tulingDao2,那么在装配的时候就会抛出异常No qualifying bean of type ‘com.tuling.testautowired.TulingDao’ available 若我们想不抛异常 ，我们需要指定 required为false的时候可以了</p>
</li>
<li><p>使用autowired </p>
<ul>
<li>可以标注在方法上标注在set方法上</li>
<li>标注在构造方法上</li>
<li>成员属性上</li>
<li>标注在配置类上的入参中（可以不写）</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTulingLog</span><span class="hljs-params">(TulingLog tulingLog)</span> </span>&#123; <br>    <span class="hljs-keyword">this</span>.tulingLog = tulingLog;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TulingAspect</span><span class="hljs-params">(TulingLog tulingLog)</span> </span>&#123; <br>    <span class="hljs-keyword">this</span>.tulingLog = tulingLog;<br>&#125;<br><br><span class="hljs-comment">//标注在配置类上的入参中（可以不写）</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TulingAspect <span class="hljs-title">tulingAspect</span><span class="hljs-params">(<span class="hljs-meta">@Autowired</span> TulingLog tulingLog)</span> </span>&#123; <br>    TulingAspect tulingAspect = <span class="hljs-keyword">new</span> TulingAspect(tulingLog);<br>    <span class="hljs-keyword">return</span> tulingAspect;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="Resource-JSR250规范"><a href="#Resource-JSR250规范" class="headerlink" title="@Resource(JSR250规范)"></a>@Resource(JSR250规范)</h3><p>功能和@AutoWired的功能差不多一样，但是不支持@Primary 和@Qualifier</p>
<p>来源：@Autowired来源Spring，@Resource来源JavaEE</p>
<p>必要性：@Resource注入的属性必须存在，否则抛错</p>
<p>顺序：</p>
<p>@Resource默认按注解属性名注入，熟悉名为空时，默认按标注的字段名或者方法名找bean，最后再根据类型匹配</p>
<p>@Autowired默认先按类型，存在多个时才根据@Qualifier或者@Primary，然后才根据名称</p>
<h3 id="InJect（JSR330规范）"><a href="#InJect（JSR330规范）" class="headerlink" title="@InJect（JSR330规范）"></a>@InJect（JSR330规范）</h3><p>需要导入jar包依赖<br>功能和支持@Primary功能 ,但是没有Require=false的功能</p>
<p>使用autowired 可以标注在方法上标注在set方法上</p>
<p>标注在构造方法上</p>
<p>标注在配置类上的入参中（可以不写）</p>
<h2 id="XXXAware接口-内部组件赋值"><a href="#XXXAware接口-内部组件赋值" class="headerlink" title="XXXAware接口(内部组件赋值)"></a>XXXAware接口(内部组件赋值)</h2><p>​    我们自己的组件 需要使用spring ioc的底层组件的时候,比如 ApplicationContext等我们可以通过实现XXXAware接口来实现</p>
<h2 id="Profile环境激活"><a href="#Profile环境激活" class="headerlink" title="@Profile环境激活"></a>@Profile环境激活</h2><p>来根据环境来激活标识不同的Bean </p>
<ol>
<li>@Profile标识在类上，那么只有当前环境匹配，整个配置类才会生效</li>
<li>@Profile标识在Bean上 ，那么只有当前环境的Bean才会被激活</li>
<li>没有标志为@Profile的bean 不管在什么环境都可以被激活</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(value = &#123;&quot;classpath:ds.properties&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EmbeddedValueResolverAware</span> </span>&#123;<br><br>	<span class="hljs-meta">@Value(&quot;$&#123;ds.username&#125;&quot;)</span> <br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;ds.password&#125;&quot;)</span> <br>    <span class="hljs-keyword">private</span> String password;<br>    <span class="hljs-keyword">private</span> String jdbcUrl; <br>    <span class="hljs-keyword">private</span> String classDriver; <br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEmbeddedValueResolver</span><span class="hljs-params">(StringValueResolver resolver)</span> </span>&#123;<br>    	<span class="hljs-keyword">this</span>.jdbcUrl = resolver.resolveStringValue(<span class="hljs-string">&quot;$&#123;ds.jdbcUrl&#125;&quot;</span>); <br>        <span class="hljs-keyword">this</span>.classDriver = resolver.resolveStringValue(<span class="hljs-string">&quot;$&#123;ds.classDriver&#125;&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//标识为测试环境才会被装配@Bean</span><br>    <span class="hljs-meta">@Profile(value = &quot;test&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">testDs</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> buliderDataSource(<span class="hljs-keyword">new</span> DruidDataSource());<br>    &#125;<br><br>    <span class="hljs-comment">//标识开发环境才会被激活@Bean</span><br>    <span class="hljs-meta">@Profile(value = &quot;dev&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">devDs</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> buliderDataSource(<span class="hljs-keyword">new</span> DruidDataSource());<br>    &#125;<br><br>    <span class="hljs-comment">//标识生产环境才会被激活@Bean</span><br>    <span class="hljs-meta">@Profile(value = &quot;prod&quot;)</span> <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">prodDs</span><span class="hljs-params">()</span> </span>&#123;<br>    	<span class="hljs-keyword">return</span> buliderDataSource(<span class="hljs-keyword">new</span> DruidDataSource());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> DataSource <span class="hljs-title">buliderDataSource</span><span class="hljs-params">(DruidDataSource dataSource)</span> </span>&#123; <br>        dataSource.setUsername(userName); dataSource.setPassword(password); <br>        dataSource.setDriverClassName(classDriver); dataSource.setUrl(jdbcUrl);<br>    	<span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring03-容器创建bean的过程.</title>
    <url>/2021/06/20/Spring03-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p><img src="/images/Spring03-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean%E7%9A%84%E8%BF%87%E7%A8%8B/springBean%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B.svg" alt="springBean创建过程"></p>
<p><img src="/images/Spring03-%E5%AE%B9%E5%99%A8%E5%88%9B%E5%BB%BAbean%E7%9A%84%E8%BF%87%E7%A8%8B/springBean%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B-1624458985065.svg"></p>
<p>比如我们容器中 TulingLog tulingLog = tcx.getBean(TulingLog.class); 容器中的过程是什么？         </p>
<p><strong>容器中的过程是什么？</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i1:&gt;org.springframework.beans.factory.support.AbstractBeanFactory#getBean(java.lang.String) <br>i2&gt;org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean <br>i3&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBean <br>    创建bean的方法 <br>i4&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#doCreateBean <br>    真正的创建bean的逻辑 <br>i5&gt;:org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingleton <br>    把创建好的实例化好的bean加载缓存中 <br>i6&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance<br>    对创建的bean进行后续的加工 <br></code></pre></td></tr></table></figure>

<p>doGetBean创建主要过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i2.1&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#transformedBeanName <br>    转换beanName <br>i2.2&gt;:org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton <br>    去缓存中获取bean <br>i2.3&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getObjectForBeanInstance <br>    对缓存中的获取的bean进行后续处理 <br>i2.4&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#isPrototypeCurrentlyInCreation <br>    判断原型bean的依赖注入 <br>i2.5&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getParentBeanFactory <br>    检查父容器加载bean <br>i2.6&gt;:org.springframework.beans.factory.support.AbstractBeanFactory#getMergedLocalBeanDefinition<br>    将bean定义转为RootBeanDifination <br>i2<span class="hljs-number">.7</span>&gt;:检查bean的依赖（bean加载顺序的依赖） <br>i2.8&gt;:org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#getSingleton<br>    根据scope的添加来创建bean <br></code></pre></td></tr></table></figure>

<p>doCreateBean具体创建流程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i4.1&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#createBeanInstance <br>    调用构造函数创建对象 <br>i4<span class="hljs-number">.2</span>&gt;:判断是否需要提早暴露对象(mbd.isSingleton() &amp;&amp; <span class="hljs-keyword">this</span>.allowCircularReferences &amp;&amp; <span class="hljs-function">i <span class="hljs-title">sSingletonCurrentlyInCreation</span><span class="hljs-params">(beanName)</span>)</span>; <br>i4.3&gt;org.springframework.beans.factory.support.DefaultSingletonBeanRegistry#addSingletonFactory <br>    暴露对象解决循环依赖 <br>i4.4&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#populateBean <br>    给创建的bean进行赋值 i4.5&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#initializeBean<br>        对bean进行初始化 <br></code></pre></td></tr></table></figure>

<p>initializeBean初始化bean过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">i4.5.1&gt;:org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeAwareMethods <br>    调用XXAware接口 <br>i4<span class="hljs-number">.5</span><span class="hljs-number">.2</span>&gt;applyBeanPostProcessorsBeforeInitialization 调用bean的后置处理器进行对处理<br>i4.5.3&gt;org.springframework.beans.factory.support.AbstractAutowireCapableBeanFactory#invokeInitMethods <br>    对象的初始化方法 <br>i4.5.3.1&gt;:org.springframework.beans.factory.InitializingBean#afterPropertiesSet <br>    调用InitializingBean的方法<br>i4<span class="hljs-number">.5</span><span class="hljs-number">.3</span><span class="hljs-number">.2</span>&gt;:String initMethodName = mbd.getInitMethodName();<br>	自定义的初始化方法 <br></code></pre></td></tr></table></figure>







]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>创建单例bean</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot01-基础</title>
    <url>/2021/08/05/SpringBoot01-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="SpringBoot-概述"><a href="#SpringBoot-概述" class="headerlink" title="SpringBoot 概述"></a>SpringBoot 概述</h1><p>​    SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻</p>
<p>辑业务之间进行思维的切换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度</p>
<p>上缩短了项目周期。2014 年 4 月，Spring Boot 1.0.0 发布。Spring的顶级项目之一(<a href="https://spring.io)./">https://spring.io)。</a></p>
<p><img src="/images/SpringBoot01-%E5%9F%BA%E7%A1%80/image-20210806213835019.png" alt="image-20210806213835019"></p>
<h2 id="Spring-缺点"><a href="#Spring-缺点" class="headerlink" title="Spring 缺点"></a>Spring 缺点</h2><h3 id="配置繁琐"><a href="#配置繁琐" class="headerlink" title="配置繁琐"></a>配置繁琐</h3><p>​    虽然Spring的组件代码是轻量级的，但它的<strong>配置</strong>却是重量级的。</p>
<p>​    一开始，Spring用XML配置，而且是很多XML配置。Spring 2.5引入了基于注解的组件扫描，这消除了大量针对应用程序自身组件的显式XML配置。Spring 3.0引入了基于Java的配置，这是一种类型安全的可重构配置方式，可以代替XML。所有这些配置都代表了开发时的损耗。</p>
<p>​    因为在思考Spring特性配置和解决业务问题之间需要进行思维切换，所以<strong>编写配置挤占了编写应用程序逻辑的时间</strong>。和所有框架一样，Spring实用，但它要求的回报也不少。</p>
<h3 id="依赖繁琐-依赖传递"><a href="#依赖繁琐-依赖传递" class="headerlink" title="依赖繁琐:依赖传递"></a>依赖繁琐:依赖传递</h3><p>​    项目的依赖管理也是一件耗时耗力的事情。在环境搭建时，需要分析要导入哪些库的坐标，而且还需要分析导入与之有依赖关系的其他库的坐标，一旦选错了依赖的版本，随之而来的不兼容问题就会严重阻碍项目的开发<br>进度。</p>
<h2 id="SpringBoot-功能"><a href="#SpringBoot-功能" class="headerlink" title="SpringBoot 功能"></a>SpringBoot 功能</h2><h3 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h3><p>​    Spring Boot的自动配置是一个运行时（更准确地说，是应用程序启动时）的过程，考虑了众多因素，才决定</p>
<p>Spring配置应该用哪个，不该用哪个。该过程是Spring自动完成的。</p>
<p>​    启动时springBoot扫描自动配置的各组件自动配置类会，他们会自动根据环境中注入了那些组件来判断自动配置哪些东西</p>
<h3 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h3><p>​    起步依赖本质上是一个Maven项目对象模型（Project Object Model，POM），定义了对其他库的**<font style="background:yellow">传递依赖</font>**</p>
<p>，这些东西加在一起即支持某项功能。</p>
<p>​    简单来说，<strong>起步依赖就是将具备某种功能的坐标打包到一起，并提供一些默认的功能</strong></p>
<h3 id="辅助功能"><a href="#辅助功能" class="headerlink" title="辅助功能"></a>辅助功能</h3><p>​    提供了一些大型项目中常见的非功能性特性，如<strong>嵌入式服务器、安全、指标，健康检测、外部配置</strong>等。</p>
<h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>​    SpringBoot提供了一种快速开发Spring项目的方式，而不是对Spring功能上的增强。</p>
<p>​    Spring的缺点：<br>​         配置繁琐<br>​        依赖繁琐<br>​    SpringBoot功能：<br>​        自动配置<br>​        起步依赖：依赖传递<br>​        辅助功能</p>
<h1 id="SpringBoot-快速入门"><a href="#SpringBoot-快速入门" class="headerlink" title="SpringBoot 快速入门"></a>SpringBoot 快速入门</h1><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>需求 </p>
<p>​    搭建SpringBoot工程，定义UserController.hello()方法，返回”Hello SpringBoot!”。<br>实现步骤<br>​    ① 创建Maven项目<br>​    ② 导入SpringBoot起步依赖<br>​    ③ 定义Controller<br>​    ④ 编写引导类<br>​    ⑤ 启动测试</p>
<h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol>
<li>SpringBoot在创建项目时，使用jar（默认方式）的打包方式。（<strong>父类工程可以使用pom方式打包</strong>）</li>
<li>SpringBoot的引导类，是项目入口，运行main方法就可以启动项目。</li>
<li>使用SpringBoot和Spring构建的项目，业务代码编写方式完全一样，只是springboot自动根据我们导入的组件自动约定地配置和整合了一些组件</li>
</ol>
<h1 id="SpringBoot-起步依赖原理分析"><a href="#SpringBoot-起步依赖原理分析" class="headerlink" title="SpringBoot 起步依赖原理分析"></a>SpringBoot 起步依赖原理分析</h1><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot-01-simple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>springboot-01-simple<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>Demo project for Spring Boot<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br>	<span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="起步依赖原理分析"><a href="#起步依赖原理分析" class="headerlink" title="起步依赖原理分析"></a>起步依赖原理分析</h2><p><strong>1） spring-boot-starter-parent</strong></p>
<ul>
<li>​    父工程是spring-boot-dependencies，是版本仲裁中心，定义了各个技术组件的版本信息，组合了一套最优搭配的技术版本</li>
</ul>
<p><strong>2） spring-boot-starter-web</strong></p>
<ul>
<li>定义了完成该功能需要的依赖坐标合计，其中版本信息来源于父工程</li>
</ul>
<h1 id="SpringBoot-配置"><a href="#SpringBoot-配置" class="headerlink" title="SpringBoot 配置"></a>SpringBoot 配置</h1><h2 id="配置文件分类"><a href="#配置文件分类" class="headerlink" title="配置文件分类"></a>配置文件分类</h2><p>​    SpringBoot是基于约定的，所以很多配置都有默认值，但如果想使用自己的配置替换默认配置的话，就可以使用<strong>application.properties</strong>或者<strong>application.yml</strong>（application.yaml）进行配置。</p>
<ol>
<li><strong>SpringBoot提供了2种配置文件类型：properteis和yml/yaml</strong></li>
<li><strong>默认配置文件名称：application</strong> </li>
<li><strong>在同一级目录下优先级为：properties &gt; yml &gt; yaml</strong></li>
</ol>
<h2 id="yaml"><a href="#yaml" class="headerlink" title="yaml"></a>yaml</h2><p>​    YAML全称是 YAML Ain’t Markup Language 。YAML是一种直观的能够被电脑识别的的数据数据序列化格式，并且容易被人类阅读，容易和脚本语言交互的，可以被支持YAML库的不同的编程语言程序导入，比如： C/C++, Ruby, Python, Java, Perl, C#, PHP等。YML文件是以数据为核心的，比传统的xml方式更加简洁。</p>
<p>​    YAML文件的扩展名可以使用.yml或者.yaml。</p>
<p>⚫ properties:</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8080</span><br><span class="hljs-meta">server.address</span>=<span class="hljs-string">127.0.0.1</span><br></code></pre></td></tr></table></figure>

<p>⚫ xml:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">port</span>&gt;</span>8080<span class="hljs-tag">&lt;/<span class="hljs-name">port</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">address</span>&gt;</span>127.0.0.1<span class="hljs-tag">&lt;/<span class="hljs-name">address</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>⚫ yml:</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <br><span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br></code></pre></td></tr></table></figure>

<p>简洁，以数据为核心</p>
<h3 id="YAML：基本语法"><a href="#YAML：基本语法" class="headerlink" title="YAML：基本语法"></a>YAML：基本语法</h3><p>⚫ 大小写敏感</p>
<p>⚫ 数据值前边必须有空格，作为分隔符</p>
<p>⚫ 使用缩进表示层级关系</p>
<p>⚫ 缩进时不允许使用Tab键，只允许使用空格（各个系统 Tab对应的 空格数目可能不同，导致层次混乱）</p>
<p>⚫ 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</p>
<p>⚫ # 表示注释，从这个字符一直到行尾，都会被解析器忽略。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span> <br>	<span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>	<span class="hljs-attr">address:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">abc</span><br></code></pre></td></tr></table></figure>

<h3 id="YAML：数据格式"><a href="#YAML：数据格式" class="headerlink" title="YAML：数据格式"></a>YAML：数据格式</h3><p>对象(map)：键值对的集合</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">person:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span><br><span class="hljs-comment"># 行内写法</span><br><span class="hljs-attr">person:</span> &#123;<span class="hljs-attr">name:</span> <span class="hljs-string">zhangsan</span>&#125;<br></code></pre></td></tr></table></figure>

<p>数组：一组按次序排列的值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">address:</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">beijing</span><br><span class="hljs-bullet">-</span> <span class="hljs-string">shanghai</span><br><span class="hljs-comment"># 行内写法</span><br><span class="hljs-attr">address:</span> [<span class="hljs-string">beijing</span>,<span class="hljs-string">shanghai</span>]<br></code></pre></td></tr></table></figure>

<p>纯量：单个的、不可再分的值</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">msg1:</span> <span class="hljs-string">&#x27;hello \n world&#x27;</span> <span class="hljs-comment"># 单引忽略转义字符</span><br><span class="hljs-attr">msg2:</span> <span class="hljs-string">&quot;hello \n world&quot;</span> <span class="hljs-comment"># 双引识别转义字符</span><br></code></pre></td></tr></table></figure>

<h3 id="YAML：小结"><a href="#YAML：小结" class="headerlink" title="YAML：小结"></a>YAML：小结</h3><ol>
<li><strong>配置文件类型</strong><ol>
<li><strong>properties：和以前一样</strong></li>
<li><strong>yml/yaml：注意空格</strong></li>
</ol>
</li>
<li><strong>yaml：简洁，以数据为核心</strong><ol>
<li><strong>基本语法</strong><ol>
<li><strong>大小写敏感</strong></li>
<li><strong>数据值前边必须有空格，作为分隔符</strong></li>
<li><strong>使用空格缩进表示层级关系，相同缩进表示同一级</strong></li>
</ol>
</li>
<li> <strong>数据格式</strong></li>
<li><strong>对象</strong></li>
<li><strong>数组: 使用 “- ”表示数组每个元素</strong></li>
<li><strong>纯量</strong></li>
<li> <strong>参数引用</strong></li>
<li><strong>${key}</strong></li>
</ol>
</li>
</ol>
<h2 id="读取配置内容"><a href="#读取配置内容" class="headerlink" title="读取配置内容"></a>读取配置内容</h2><ul>
<li>@Value</li>
<li>Environment</li>
<li>@ConfigurationProperties (prefix=”配置文件前缀，如：swagger.spring”)</li>
</ul>
<h2 id="Profile"><a href="#Profile" class="headerlink" title="Profile"></a>Profile</h2><p>​    我们在开发Spring Boot应用时，通常同一套程序会被安装到不同环境，比如：开发、测试、生产等。其中数据库地址、服务器端口等等配置都不同，如果每次打包时，都要修改配置文件，那么非常麻烦。</p>
<p>​    profile功能就是来进行动态配置切换的。</p>
<p>1） profile配置方式</p>
<p>​        多profile文件方式</p>
<p>​        yml多文档方式</p>
<p>2） profile激活方式</p>
<p>​        配置文件</p>
<p>​        虚拟机参数</p>
<p>​        命令行参数</p>
<p>​        maven 选中</p>
<h3 id="Profile-小结"><a href="#Profile-小结" class="headerlink" title="Profile-小结"></a>Profile-小结</h3><p>1） profile是用来完成不同环境下，配置动态切换功能的。</p>
<p>2） profile配置方式</p>
<ul>
<li>多profile文件方式：提供多个配置文件，每个代表一种环境。<ul>
<li>application-dev.properties/yml 开发环境</li>
<li>application-test.properties/yml 测试环境</li>
<li>application-pro.properties/yml 生产环境</li>
</ul>
</li>
<li>yml多文档方式：<ul>
<li>在yml中使用 — 分隔不同配置</li>
</ul>
</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">dev</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8082</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">test</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8083</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span> <span class="hljs-string">pro</span><br><span class="hljs-meta">---</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure>

<p>3）profile激活方式</p>
<ul>
<li>配置文件： 再配置文件中配置：spring.profiles.active=dev</li>
<li>虚拟机参数：在VM options 指定：-Dspring.profiles.active=dev</li>
<li>命令行参数：java –jar xxx.jar –spring.profiles.active=dev</li>
<li>maven 选中 </li>
</ul>
<h2 id="内部配置加载顺序"><a href="#内部配置加载顺序" class="headerlink" title="内部配置加载顺序"></a>内部配置加载顺序</h2><p>Springboot程序启动时，会从以下位置加载配置文件：</p>
<ul>
<li>file:./config/：当前项目下的/config目录下</li>
<li>file:./ ：当前项目的根目录</li>
<li>classpath:/config/：classpath的/config目录</li>
<li>classpath:/ ：classpath的根目录</li>
</ul>
<p><strong>加载顺序为上文的排列顺序，高优先级配置的属性会生效</strong></p>
<h2 id="外部配置加载顺序"><a href="#外部配置加载顺序" class="headerlink" title="外部配置加载顺序"></a>外部配置加载顺序</h2><p>通过官网查看外部属性加载顺序：</p>
<p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html">https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html</a></p>
<h1 id="SpringBoot打包"><a href="#SpringBoot打包" class="headerlink" title="SpringBoot打包"></a>SpringBoot打包</h1><h2 id="打成指定的jar名称的"><a href="#打成指定的jar名称的" class="headerlink" title="打成指定的jar名称的"></a>打成指定的jar名称的</h2><h2 id="多个mainclass"><a href="#多个mainclass" class="headerlink" title="多个mainclass"></a>多个mainclass</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>		<span class="hljs-comment">&lt;!--		指定打包的文件名称		 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">finalName</span>&gt;</span>mySpringboot<span class="hljs-tag">&lt;/<span class="hljs-name">finalName</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>			<span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>				<span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>					<span class="hljs-comment">&lt;!-- 指定启动类 --&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>com.study.springboot01simple.Springboot01SimpleApplication<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>					<span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>						<span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>							<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>						<span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>					<span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>				<span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br><br>				<span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>repackage<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>			<span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>		<span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/SpringBoot01-%E5%9F%BA%E7%A1%80/image-20210811220220670.png" alt="image-20210811220220670"></p>
<h2 id="打war包"><a href="#打war包" class="headerlink" title="打war包"></a>打war包</h2><h3 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h3><p>​    指定springboot pom中的打包方式 由jar改为war </p>
<p><img src="/images/SpringBoot01-%E5%9F%BA%E7%A1%80/image-20220924162006490.png" alt="image-20220924162006490"></p>
<h3 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h3><p>​    在spring-boot-starter-web模块打包比依赖于 tomcat</p>
<p>即这个依赖只在编译和测试阶段生效</p>
<p><img src="/images/SpringBoot01-%E5%9F%BA%E7%A1%80/image-20220924162121172.png" alt="image-20220924162121172"></p>
<h3 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h3><p>​    主启动类上 实现SpringBootServletInitializer 从写confiure方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot01SimpleApplication2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        SpringApplication.run(Springboot01SimpleApplication2.class,args);<br>        System.out.println(Springboot01SimpleApplication2.class.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(Springboot01SimpleApplication2.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h3><p>​    打成war包 放在tomcat上运行.</p>
<h1 id="SpringBoot-整合篇"><a href="#SpringBoot-整合篇" class="headerlink" title="SpringBoot-整合篇"></a>SpringBoot-整合篇</h1><h2 id="SpringBoot整合Junit"><a href="#SpringBoot整合Junit" class="headerlink" title="SpringBoot整合Junit"></a>SpringBoot整合Junit</h2><p>① 搭建SpringBoot工程</p>
<p>② 引入starter-test起步依赖</p>
<p>③ 编写测试类</p>
<p>④ 添加测试相关注解</p>
<p>​    @RunWith(SpringRunner.class)</p>
<p>​    @SpringBootTest(classes = 启动类.class)</p>
<p>⑤ 编写测试方法</p>
<h2 id="SpringBoot整合Redis"><a href="#SpringBoot整合Redis" class="headerlink" title="SpringBoot整合Redis"></a>SpringBoot整合Redis</h2><h2 id="SpringBoot整合MyBatis"><a href="#SpringBoot整合MyBatis" class="headerlink" title="SpringBoot整合MyBatis"></a>SpringBoot整合MyBatis</h2><h2 id="SpringBoot整合RabbitMQ"><a href="#SpringBoot整合RabbitMQ" class="headerlink" title="SpringBoot整合RabbitMQ"></a>SpringBoot整合RabbitMQ</h2><h2 id="…"><a href="#…" class="headerlink" title="…"></a>…</h2><h1 id="自定义redis-spring-boot-starter"><a href="#自定义redis-spring-boot-starter" class="headerlink" title="自定义redis-spring-boot-starter"></a>自定义redis-spring-boot-starter</h1><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot02-webmvc</title>
    <url>/2021/08/11/SpringBoot02-webmvc/</url>
    <content><![CDATA[<h1 id="SpringBoot的web开发"><a href="#SpringBoot的web开发" class="headerlink" title="SpringBoot的web开发"></a>SpringBoot的web开发</h1><h2 id="webJar"><a href="#webJar" class="headerlink" title="webJar"></a>webJar</h2><p>​    以jar包的形式来引入前端资源,比如jquery 或者是BootStrap：<a href="https://www.webjars.org/">https://www.webjars.org</a></p>
<p>前端资源映射规则 核心源代码:WebMvcAutoConfiguration.WebMvcAutoConfigurationAdapter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>          <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>              logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>              <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>              <span class="hljs-keyword">this</span>.addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>                  registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>                  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>) &#123;<br>                      ServletContextResource resource = <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, <span class="hljs-string">&quot;/&quot;</span>);<br>                      registration.addResourceLocations(<span class="hljs-keyword">new</span> Resource[]&#123;resource&#125;);<br>                  &#125;<br><br>              &#125;);<br>          &#125;<br>      &#125;<br></code></pre></td></tr></table></figure>

<p>访问：<a href="http://localhost:8080//webjars/jquery/3.3.1-2/jquery.js">http://localhost:8080//webjars/jquery/3.3.1-2/jquery.js</a></p>
<p>控制台打印：</p>
<p><img src="/images/SpringBoot02-webmvc/image-20210811233641951.png" alt="image-20210811233641951"></p>
<p>源码追踪：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.springframework.web.servlet.resource.ResourceHttpRequestHandler#handleRequest方法 &gt;org.springframework.web.servlet.resource.ResourceHttpRequestHandler#getResource &gt;org.springframework.web.servlet.resource.ResourceResolverChain#resolveResource &gt;org.springframework.web.servlet.resource.PathResourceResolver#resolveResourceInternal &gt;org.springframework.web.servlet.resource.PathResourceResolver#getResource(真正的资源映射 处理逻辑)<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function"><span class="hljs-keyword">private</span> Resource <span class="hljs-title">getResource</span><span class="hljs-params">(String resourcePath, <span class="hljs-meta">@Nullable</span> HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">			List&lt;? extends Resource&gt; locations)</span> </span>&#123;<br><br>		<span class="hljs-keyword">for</span> (Resource location : locations) &#123;<br>			<span class="hljs-keyword">try</span> &#123;<br>				String pathToUse = encodeOrDecodeIfNecessary(resourcePath, request, location);<br>				Resource resource = getResource(pathToUse, location);<br>				<span class="hljs-keyword">if</span> (resource != <span class="hljs-keyword">null</span>) &#123;<br>					<span class="hljs-keyword">return</span> resource;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>					String error = <span class="hljs-string">&quot;Skip location [&quot;</span> + location + <span class="hljs-string">&quot;] due to error&quot;</span>;<br>					<span class="hljs-keyword">if</span> (logger.isTraceEnabled()) &#123;<br>						logger.trace(error, ex);<br>					&#125;<br>					<span class="hljs-keyword">else</span> &#123;<br>						logger.debug(error + <span class="hljs-string">&quot;: &quot;</span> + ex.getMessage());<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h2 id="静态页面映射"><a href="#静态页面映射" class="headerlink" title="静态页面映射"></a>静态页面映射</h2><p>我们直接把静态页面放在static的目录下，直接可以在路径直接访问</p>
<p><img src="/images/SpringBoot02-webmvc/image-20210814182837595.png" alt="image-20210814182837595"></p>
<h1 id="Springboot整合springmvc"><a href="#Springboot整合springmvc" class="headerlink" title="Springboot整合springmvc"></a>Springboot整合springmvc</h1><h2 id="自动装配的组件"><a href="#自动装配的组件" class="headerlink" title="自动装配的组件"></a>自动装配的组件</h2><p>①:ContentNegotiatingViewResolver 和 BeanNameViewResolver 视图解析器 视图解析器的作用:根据方法的值找到对应的视图</p>
<p>②:Support for serving static resources, including support for WebJars 支持静态资源和webJars </p>
<p>③:Converter ,日期格式化器 Formatter</p>
<p>④:消息装换器: HttpMessageConverters</p>
<p>⑤:首页设置index.html </p>
<p>⑥:图标支持 Favicon</p>
<h2 id="拓展SpringBoot的mvc配置"><a href="#拓展SpringBoot的mvc配置" class="headerlink" title="拓展SpringBoot的mvc配置"></a>拓展SpringBoot的mvc配置</h2><p>​    自己写一个配置类 继承 WebMvcConfigurer 需要什么组件 就注册什么组件 </p>
<p><strong>如何往容器中添加一个拦截器</strong> </p>
<p><strong>往容器中增加一个过滤器</strong> </p>
<p><strong>往容器中增加一个</strong>servlet </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        HandlerInterceptor handlerInterceptor = <span class="hljs-keyword">new</span> HandlerInterceptor() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;myHandlerInterceptor...前置拦截器:...&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;;<br>        registry.addInterceptor(handlerInterceptor).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>).excludePathPatterns(<span class="hljs-string">&quot;/index.html&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span></span>&#123;<br>        Filter filter = <span class="hljs-keyword">new</span> Filter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;myFilter 的 doFilter方法&quot;</span>);<br>                filterChain.doFilter(servletRequest,servletResponse);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br><br>            &#125;<br>        &#125;;<br><br>        FilterRegistrationBean filterRegistrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean();<br>        filterRegistrationBean.setFilter(filter);<br>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>); <span class="hljs-keyword">return</span> filterRegistrationBean;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean <span class="hljs-title">myHttpServlet</span><span class="hljs-params">()</span></span>&#123;<br><br>        HttpServlet httpServlet =  <span class="hljs-keyword">new</span> HttpServlet() &#123;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;myHttpServlet&quot;</span>);<br>                <span class="hljs-keyword">super</span>.doPost(req,resp);<br>            &#125;<br>        &#125;;<br>        ServletRegistrationBean  servletRegistration = <span class="hljs-keyword">new</span> ServletRegistrationBean(httpServlet);<br>        servletRegistration.addUrlMappings(<span class="hljs-string">&quot;/hello1&quot;</span>);<br><br>        <span class="hljs-keyword">return</span> servletRegistration;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="接管springboot的mvc配置"><a href="#接管springboot的mvc配置" class="headerlink" title="接管springboot的mvc配置"></a>接管springboot的mvc配置</h2><p><strong>方式</strong>：</p>
<p>​    使用一个@EnableWebMvc来标识到配置类上,就会导致配置失效</p>
<p><strong>原理：</strong></p>
<p>​    @EnableWebMvc 为容器中导入了DelegatingWebMvcConfiguration的组件,是WebMvcConfigurationSupport的实现类，而WebMvcAutoConfiguration在WebMvcConfigurationSupport不存在时才会自动配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span></span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-meta">@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">		ValidationAutoConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span></span><br></code></pre></td></tr></table></figure>



<h2 id="SpringBoot错误处理机制"><a href="#SpringBoot错误处理机制" class="headerlink" title="SpringBoot错误处理机制"></a>SpringBoot错误处理机制</h2><p>postman 请求 <a href="http://localhost:8080/hello3">http://localhost:8080/hello3</a></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-number">1629035261980</span>,<br>    <span class="hljs-attr">&quot;status&quot;</span>: <span class="hljs-number">404</span>,<br>    <span class="hljs-attr">&quot;error&quot;</span>: <span class="hljs-string">&quot;Not Found&quot;</span>,<br>    <span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;/hello3&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>浏览器</p>
<p><img src="/images/SpringBoot02-webmvc/image-20210815215334258.png" alt="image-20210815215334258"></p>
<h3 id="如何跳转到-error"><a href="#如何跳转到-error" class="headerlink" title="如何跳转到/error"></a>如何跳转到/error</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">DispatchServlet</span>.</span></span>doDispatch 找不到 返回<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">StandardHostValve</span>.</span></span>custom<br><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">ApplicationDispatcher</span>.</span></span>doForward 转发 到 /error<br></code></pre></td></tr></table></figure>

<h3 id="自动配置的异常处理的一些bean"><a href="#自动配置的异常处理的一些bean" class="headerlink" title="自动配置的异常处理的一些bean"></a>自动配置的异常处理的一些bean</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">DefaultErrorAttributes<br> 	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> DefaultErrorAttributes <span class="hljs-title">errorAttributes</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultErrorAttributes();<br>	&#125;<br><br>BasicErrorController:/error请求处理控制器<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> BasicErrorController <span class="hljs-title">basicErrorController</span><span class="hljs-params">(ErrorAttributes errorAttributes,</span></span><br><span class="hljs-function"><span class="hljs-params">			ObjectProvider&lt;ErrorViewResolver&gt; errorViewResolvers)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicErrorController(errorAttributes, <span class="hljs-keyword">this</span>.serverProperties.getError(),<br>				errorViewResolvers.orderedStream().collect(Collectors.toList()));<br>	&#125;<br><br>ErrorPageCustomizer:错误页面定制器<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> ErrorPageCustomizer <span class="hljs-title">errorPageCustomizer</span><span class="hljs-params">(DispatcherServletPath dispatcherServletPath)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ErrorPageCustomizer(<span class="hljs-keyword">this</span>.serverProperties, dispatcherServletPath);<br>	&#125;<br><br><br>DefaultErrorViewResolver<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnBean(DispatcherServlet.class)</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(ErrorViewResolver.class)</span><br>    <span class="hljs-function">DefaultErrorViewResolver <span class="hljs-title">conventionErrorViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultErrorViewResolver(<span class="hljs-keyword">this</span>.applicationContext, <span class="hljs-keyword">this</span>.resources);<br>    &#125;<br>   <br>注入默认错误页面 defaultErrorView<br>	<span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>	<span class="hljs-meta">@ConditionalOnProperty(prefix = &quot;server.error.whitelabel&quot;, name = &quot;enabled&quot;, matchIfMissing = true)</span><br>	<span class="hljs-meta">@Conditional(ErrorTemplateMissingCondition.class)</span><br>	<span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhitelabelErrorViewConfiguration</span> </span>&#123;<br><br>		<span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> StaticView defaultErrorView = <span class="hljs-keyword">new</span> StaticView();<br><br>		<span class="hljs-meta">@Bean(name = &quot;error&quot;)</span><br>		<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;error&quot;)</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">defaultErrorView</span><span class="hljs-params">()</span> </span>&#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.defaultErrorView;<br>		&#125;<br><br>		<span class="hljs-comment">// If the user adds @EnableWebMvc then the bean name view resolver from</span><br>		<span class="hljs-comment">// WebMvcAutoConfiguration disappears, so add it back in to avoid disappointment.</span><br>		<span class="hljs-meta">@Bean</span><br>		<span class="hljs-meta">@ConditionalOnMissingBean</span><br>		<span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameViewResolver <span class="hljs-title">beanNameViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>			BeanNameViewResolver resolver = <span class="hljs-keyword">new</span> BeanNameViewResolver();<br>			resolver.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">10</span>);<br>			<span class="hljs-keyword">return</span> resolver;<br>		&#125;<br><br>	&#125;<br></code></pre></td></tr></table></figure>

<p>处理/error请求的过程，以浏览器请求为例</p>
<ol>
<li><p>org.springframework.web.servlet.DispatcherServlet#doDispatch</p>
<ol>
<li>org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter<ol>
<li>org.springframework.boot.autoconfigure.web.servlet.error.BasicErrorController.errorHtml <strong>（基础错误控制器）</strong> <ol>
<li>org.springframework.boot.autoconfigure.web.servlet.error.AbstractErrorController#resolveErrorView 遍历errorViewResolver 解析错误视图<ol>
<li>org.springframework.boot.autoconfigure.web.servlet.error.DefaultErrorViewResolver#resolveErrorView //查找error/“ + viewName视图是否存在，如果没有对应的解析精确匹配的状态码 使用模糊匹配比如4XX 5XX</li>
</ol>
</li>
<li>return (modelAndView != null) ? modelAndView : new ModelAndView(“error”, model);找不到对应解析器，则查找 error 对应的model</li>
</ol>
</li>
</ol>
</li>
<li>mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); 解析error视图View </li>
</ol>
</li>
</ol>
<h2 id="定制错误异常信息"><a href="#定制错误异常信息" class="headerlink" title="定制错误异常信息"></a>定制错误异常信息</h2><p><img src="/images/SpringBoot02-webmvc/image-20210816095205231.png" alt="image-20210816095205231"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExcepctionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BasicResponse <span class="hljs-title">handlerException</span><span class="hljs-params">(Exception e)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> BasicResponse.failed();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicResponse</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> code;<br>    <span class="hljs-keyword">private</span> String msg;<br>    <span class="hljs-keyword">private</span> T info;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer SUCCESS_CODE = <span class="hljs-number">200</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String SUCCESS_MSG = <span class="hljs-string">&quot;请求成功&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer FAIL_CODE = <span class="hljs-number">500</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String FAIL_MSG = <span class="hljs-string">&quot;服务器报错&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">success</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(SUCCESS_CODE,SUCCESS_MSG);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">success</span><span class="hljs-params">(String successMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(SUCCESS_CODE, successMsg);<br>    &#125;<br><br>   <br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(FAIL_CODE, FAIL_MSG);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">(String failedMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(FAIL_CODE, failedMsg);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">(String failedMsg,T object)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(FAIL_CODE, failedMsg,object);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> BasicResponse <span class="hljs-title">failed</span><span class="hljs-params">(Integer code,String failedMsg)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicResponse&lt;&gt;(code, failedMsg);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BasicResponse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BasicResponse</span><span class="hljs-params">(<span class="hljs-keyword">int</span> code, String msg, T info)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>(code, msg);<br>        <span class="hljs-keyword">this</span>.info = info;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>web</tag>
        <tag>webmvc</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot04-自定义starter</title>
    <url>/2021/08/18/SpringBoot04-%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    <content><![CDATA[<h1 id="自定义SpringBoot-starter"><a href="#自定义SpringBoot-starter" class="headerlink" title="自定义SpringBoot-starter"></a>自定义SpringBoot-starter</h1><h2 id="套路（模板来源mybatis-spring-boot-starter）"><a href="#套路（模板来源mybatis-spring-boot-starter）" class="headerlink" title="套路（模板来源mybatis-spring-boot-starter）"></a>套路（模板来源mybatis-spring-boot-starter）</h2><p>​    1、创建一个xxx-spring-boot-autoconfigure项目:声明配置类xxxAutoConfiguration并且加入到Springboot的EnableAutoConfiguration的扫描范围中</p>
<p>​    2、创建一个xxx-spring-boot-starter项目:啥事也不干，只在pom中引入xxx-spring-boot-autoconfigure的坐标</p>
<p>​    3、在第三方项目中，直接引入starter，即可自动配置，即xxxAutoConfiguration起作用</p>
<h2 id="自定义redis-spring-boot-starter"><a href="#自定义redis-spring-boot-starter" class="headerlink" title="自定义redis-spring-boot-starter"></a>自定义redis-spring-boot-starter</h2><h3 id="redis-spring-boot-autoconfigure"><a href="#redis-spring-boot-autoconfigure" class="headerlink" title="redis-spring-boot-autoconfigure"></a>redis-spring-boot-autoconfigure</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>		<span class="hljs-comment">&lt;!-- 依赖不想上传递 可以利用此配置 来根据引入的组件选择性注入（如springboot内置tomcat） --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 只在编译阶段起作用 --&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 是自定义配置在 application.properties 编辑时有提示 --&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>		<span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>	<span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>定义自动配置类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;redis&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisProperties</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String localHost = <span class="hljs-string">&quot;localhost&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> Integer port = <span class="hljs-number">6379</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getLocalHost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> localHost;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Integer <span class="hljs-title">getPort</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalHost</span><span class="hljs-params">(String localHost)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.localHost = localHost;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPort</span><span class="hljs-params">(Integer port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnClass(Jedis.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(value = RedisProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean(Jedis.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Jedis <span class="hljs-title">jedis</span><span class="hljs-params">(RedisProperties redisProperties)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Jedis(redisProperties.getLocalHost(),redisProperties.getPort());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="redis-spring-boot-starter"><a href="#redis-spring-boot-starter" class="headerlink" title="redis-spring-boot-starter"></a>redis-spring-boot-starter</h3><p>只做坐标和依赖引入</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>redis.clients<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jedis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="springboot-03-use-my-starter"><a href="#springboot-03-use-my-starter" class="headerlink" title="springboot-03-use-my-starter"></a>springboot-03-use-my-starter</h3><p>引入redis-spring-boot-starter 即自动配置注入了jedis组件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.study<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>redis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Springboot03UseMyStarterApplication</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ConfigurableApplicationContext ioc = SpringApplication.run(Springboot03UseMyStarterApplication.class, args);<br>        Jedis redis = ioc.getBean(Jedis.class);<br>        redis.set(<span class="hljs-string">&quot;abc&quot;</span>,<span class="hljs-string">&quot;123&quot;</span>);<br>        System.out.println(redis.get(<span class="hljs-string">&quot;abc&quot;</span>));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>starter配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot06-启动原理</title>
    <url>/2021/08/22/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="SpringBoot-启动原理"><a href="#SpringBoot-启动原理" class="headerlink" title="SpringBoot-启动原理"></a>SpringBoot-启动原理</h1><p>Spring启动时做了哪些事</p>
<img src="/images/SpringBoot06-启动原理/SpringBoot启动流程.png" alt="SpringBoot启动流程" style="zoom:200%;">

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">return</span> (<span class="hljs-keyword">new</span> SpringApplication(primarySources)).run(args);<br></code></pre></td></tr></table></figure>

<p>可以看出SpringBoot启动的过程可以分成2步</p>
<p>1、new SpringApplication()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SpringApplication</span><span class="hljs-params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> </span>&#123;<br>   <span class="hljs-keyword">this</span>.resourceLoader = resourceLoader;<br>   Assert.notNull(primarySources, <span class="hljs-string">&quot;PrimarySources must not be null&quot;</span>);<br>   <span class="hljs-keyword">this</span>.primarySources = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(Arrays.asList(primarySources));<br>   <span class="hljs-keyword">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();<br>   <span class="hljs-keyword">this</span>.bootstrapRegistryInitializers = getBootstrapRegistryInitializersFromSpringFactories();<br>   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));<br>   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));<br>   <span class="hljs-keyword">this</span>.mainApplicationClass = deduceMainApplicationClass();<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>记录springboot启动类</li>
<li>判断SpringBoot启动环境是否web</li>
<li>从META-INF/spring.factories 获取应用BootstrapRegistryInitializer初始化器</li>
<li>从META-INF/spring.factories 获取应用上下文ApplicationContextInitializer初始化器</li>
<li>从META-INF/spring.factories 获取应用监听器</li>
<li>获取springboot启动类main方法所在类</li>
</ol>
<p>2、SpringApplication.run</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ConfigurableApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>    <span class="hljs-comment">//计时器</span><br>   StopWatch stopWatch = <span class="hljs-keyword">new</span> StopWatch();<br>   stopWatch.start();<br>   DefaultBootstrapContext bootstrapContext = createBootstrapContext();<br>   <span class="hljs-comment">//声明容器</span><br>   ConfigurableApplicationContext context = <span class="hljs-keyword">null</span>;<br>   configureHeadlessProperty();<br>   <span class="hljs-comment">//获取所有SpringApplicationRunListener，用于监听spiringboot生命周期 </span><br>   SpringApplicationRunListeners listeners = getRunListeners(args);<br>    <span class="hljs-comment">//启动-发布启动事件</span><br>   listeners.starting(bootstrapContext, <span class="hljs-keyword">this</span>.mainApplicationClass);<br>   <span class="hljs-keyword">try</span> &#123;<br>      ApplicationArguments applicationArguments = <span class="hljs-keyword">new</span> DefaultApplicationArguments(args);<br>      <span class="hljs-comment">//准备容器环境-发布环境准备事件</span><br>      ConfigurableEnvironment environment = prepareEnvironment(listeners, bootstrapContext, applicationArguments);<br>      configureIgnoreBeanInfo(environment);<br>      <span class="hljs-comment">//打印springboot的图标</span><br>      Banner printedBanner = printBanner(environment);<br>      <span class="hljs-comment">//创建容器 根据webApplicationType 来创建容器 通过反射创建</span><br>      context = createApplicationContext();<br>      context.setApplicationStartup(<span class="hljs-keyword">this</span>.applicationStartup);<br>      <span class="hljs-comment">//准备环境</span><br>      <span class="hljs-comment">//1：把环境设置到容器中 </span><br>      <span class="hljs-comment">//2: 循环调用AppplicationInitnazlier 进行容器初始化工作 </span><br>      <span class="hljs-comment">//3:发布容器上下文准备完成事件 </span><br>      <span class="hljs-comment">//4:注册关于springboot特性的相关单例Bean </span><br>      <span class="hljs-comment">//5:发布容器上下文加载完毕事件</span><br>      prepareContext(bootstrapContext, context, environment, listeners, applicationArguments, printedBanner);<br>      refreshContext(context);<br>      afterRefresh(context, applicationArguments);<br>      stopWatch.stop();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.logStartupInfo) &#123;<br>         <span class="hljs-keyword">new</span> StartupInfoLogger(<span class="hljs-keyword">this</span>.mainApplicationClass).logStarted(getApplicationLog(), stopWatch);<br>      &#125;<br>      listeners.started(context);<br>      <span class="hljs-comment">//运行 ApplicationRunner 和CommandLineRunner</span><br>      callRunners(context, applicationArguments);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, ex, listeners);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>   &#125;<br><br>   <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">//发布容器启动事件</span><br>      listeners.running(context);<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>      handleRunFailure(context, ex, <span class="hljs-keyword">null</span>);<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(ex);<br>   &#125;<br>   <span class="hljs-keyword">return</span> context;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="SpringBoot启动的2种方式"><a href="#SpringBoot启动的2种方式" class="headerlink" title="SpringBoot启动的2种方式"></a>SpringBoot启动的2种方式</h1><h2 id="jar包"><a href="#jar包" class="headerlink" title="jar包"></a>jar包</h2><p>​    本质：SpringBoot启动带动内置tomcat启动</p>
<p>​    简述：SpringApplication.run </p>
<p>​                -&gt;新建ioc</p>
<p>​                     -&gt; 容器刷新</p>
<p>​                         -&gt; onrefresh方法</p>
<p>​                            -&gt;ServletWebServerApplicationContext</p>
<p>​                                ServletWebServerFactory factory = getWebServerFactory();</p>
<p>​                                factory.getWebServer(getSelfInitializer());</p>
<h2 id="jar启动流程"><a href="#jar启动流程" class="headerlink" title="jar启动流程"></a>jar启动流程</h2><p><img src="/images/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/springboot%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E5%9B%BE-1629645466779.svg" alt="springboot启动流程图"></p>
<h2 id="war包"><a href="#war包" class="headerlink" title="war包"></a>war包</h2><p>​    本质：tomcat启动带动SpringBoot启动（Servlet3.0特性 tomcat启动会创建）</p>
<blockquote>
<p>8.2.4 Shared libraries / runtimes pluggability<br>    The ServletContainerInitializer class is looked up via the jar services API. For each application, an instance of the ServletContainerInitializer is created by the container at application startup time. The framework providing an implementation of the ServletContainerInitializer MUST bundle in the META-INF/services directory of the jar file a file called javax.servlet.ServletContainerInitializer, as per the jar services API,that points to the implementation class of the ServletContainerInitializer. In addition to the ServletContainerInitializer we also have an annotation -HandlesTypes. The HandlesTypes annotation on the implementation of the ServletContainerInitializer is used to express interest in classes that may have annotations (type, method or field level annotations) specified in the value of the HandlesTypes or if it extends / implements one those classes anywhere in the class’ super types. The HandlesTypes annotation is applied irrespective of the setting of metadata-complete. </p>
<p><strong>1.1)web应用启动，会创建当前Web应用导入jar包中 的 ServletContainerInitializer类的实例</strong> </p>
<p><strong>1.2)ServletContainerInitializer 类必须放在jar包的 META-INF/services目录 下,文件名称为 javax.servlet.ServletContainerInitializer</strong> </p>
<p><strong>1.3)文件的内容指向ServletContainerInitializer实现类的全路径</strong></p>
<p><strong>1.4)使用@HandlesTypes 在我们应用启动的时候，加载我们感兴趣的类</strong></p>
<p><strong>1.5)spring-web 配置了tomcat启动时要创建的实例类</strong></p>
</blockquote>
<p><img src="/images/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/image-20210822230438231.png"></p>
<blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<br></code></pre></td></tr></table></figure>


</blockquote>
<p>​    简述：Tomcat启动-&gt;</p>
<p>​                    SpringServletContainerInitializer.onStartup </p>
<p>​                        -&gt;SpringBootServletInitializer.onStartup</p>
<p>​                            -&gt;WebApplicationContext rootApplicationContext = createRootApplicationContext(servletContext)</p>
<p>​                                 -&gt;run(application) 触发SpringBoot启动</p>
<h2 id="war启动流程"><a href="#war启动流程" class="headerlink" title="war启动流程"></a>war启动流程</h2><p><img src="/images/SpringBoot06-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/springboot%E5%90%AF%E5%8A%A8War%E5%8C%85.svg" alt="springboot启动War包"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>启动原理</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot03-自动配置</title>
    <url>/2021/08/17/SpringBoot03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="SpringBoot自动配置原理"><a href="#SpringBoot自动配置原理" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h1><h2 id="Spring注解方式整合redis"><a href="#Spring注解方式整合redis" class="headerlink" title="Spring注解方式整合redis"></a>Spring注解方式整合redis</h2><p>redis.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">redis.hostname</span>=<span class="hljs-string">127.0.0.1</span><br><br><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><br><br><span class="hljs-meta">redis.database</span>=<span class="hljs-string">0</span><br><br><span class="hljs-meta">redis.pool.maxActive</span>=<span class="hljs-string">600</span><br><br><span class="hljs-meta">redis.pool.maxIdle</span>=<span class="hljs-string">300</span><br><br><span class="hljs-meta">redis.pool.maxWait</span>=<span class="hljs-string">3000</span><br><br><span class="hljs-meta">redis.pool.testOnBorrow</span>=<span class="hljs-string">true</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:redis.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.hostname&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String hostname;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.database&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> database;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.maxActive&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxActive;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.maxIdle&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxIdle;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.maxWait&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxWait;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;redis.pool.testOnBorrow&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> testOnBorrow;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisPoolConfig <span class="hljs-title">jedisPoolConfig</span><span class="hljs-params">()</span></span>&#123;<br>        JedisPoolConfig poolConfig = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        poolConfig.setMaxTotal(maxActive);<br>        poolConfig.setMaxIdle(maxIdle);<br>        poolConfig.setMaxWaitMillis(maxWait);<br>        poolConfig.setTestOnBorrow(testOnBorrow);<br>        <span class="hljs-keyword">return</span> poolConfig;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JedisConnectionFactory <span class="hljs-title">jedisConnectionFactory</span><span class="hljs-params">()</span></span>&#123;<br>        JedisConnectionFactory factory = <span class="hljs-keyword">new</span> JedisConnectionFactory();<br>        factory.setHostName(hostname);<br>        factory.setPort(port);<br>        factory.setPoolConfig(jedisPoolConfig());<br>        factory.setDatabase(database);<br>        <span class="hljs-keyword">return</span> factory;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;String,Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//使用Jackson2JsonRedisSerializer来序列化和反序列化redis的value值（默认使用JDK的序列化方式）</span><br>        Jackson2JsonRedisSerializer jacksonSeial = <span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class);<br><br>        RedisTemplate&lt;String,Object&gt; redisTemplate = <span class="hljs-keyword">new</span> RedisTemplate();<br>        redisTemplate.setKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setValueSerializer(jacksonSeial);<br>        redisTemplate.setHashKeySerializer(<span class="hljs-keyword">new</span> StringRedisSerializer());<br>        redisTemplate.setHashValueSerializer(jacksonSeial);<br>        redisTemplate.setEnableTransactionSupport(<span class="hljs-keyword">true</span>);<br>        redisTemplate.setConnectionFactory(jedisConnectionFactory());<br>        <span class="hljs-keyword">return</span> redisTemplate;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs pom">&lt;dependency&gt;<br>    &lt;groupId&gt;redis.clients&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;jedis&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.10.2&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.springframework.data&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;spring-data-redis&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;2.1.5.RELEASE&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<h2 id="SpringBoot自动装配整合redis"><a href="#SpringBoot自动装配整合redis" class="headerlink" title="SpringBoot自动装配整合redis"></a>SpringBoot自动装配整合redis</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>        RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>        template.setDefaultSerializer(<span class="hljs-keyword">new</span> Jackson2JsonRedisSerializer(Object.class));<br>        template.setConnectionFactory(redisConnectionFactory);<br>        <span class="hljs-keyword">return</span> template;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h2 id="传统整合和springboot自动装配对比"><a href="#传统整合和springboot自动装配对比" class="headerlink" title="传统整合和springboot自动装配对比"></a>传统整合和springboot自动装配对比</h2><p><img src="/images/SpringBoot03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/image-20210816124943642.png" alt="image-20210816124943642"></p>
<p>传统整合：</p>
<p>​    自己引入依赖</p>
<p>​    版本冲突</p>
<p>​    配置复杂</p>
<p>自动装配</p>
<p>​    起步依赖</p>
<p>​    自动配置</p>
<p>​    约定 &gt; 配置 &gt; 编码</p>
<h2 id="SpringBoot自动配置原理-1"><a href="#SpringBoot自动配置原理-1" class="headerlink" title="SpringBoot自动配置原理"></a>SpringBoot自动配置原理</h2><h3 id="Condition"><a href="#Condition" class="headerlink" title="@Condition"></a>@Condition</h3><p>​    Condition 是在Spring 4.0 增加的条件判断功能，通过这个可以功能可以<strong>根据系统中已有组件实现动态选择性的创建 Bean 操作</strong>，从而达到自动配置的目的。</p>
<h4 id="思考："><a href="#思考：" class="headerlink" title="思考："></a>思考：</h4><p>​    SpringBoot是如何知道要创建哪个Bean的？比如SpringBoot是如何知道要创建RedisTemplate的？</p>
<p>SpringBoot引入spring-data-redis坐标后，RedisAutoConfiguration配置类起作用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="模仿使用"><a href="#模仿使用" class="headerlink" title="模仿使用"></a>模仿使用</h4><p>​    <strong>判断是否存在哪些类而注入当前类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span>、定义一个Condtion实现类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCondition</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Condition</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata)</span> </span>&#123;<br>        Map&lt;String, Object&gt; map =<br>                annotatedTypeMetadata.getAnnotationAttributes(MyConditionOnClass.class.getName());<br>        String[] className = (String[]) map.get(<span class="hljs-string">&quot;value&quot;</span>);<br>        System.out.println(className);<br>        <span class="hljs-keyword">for</span> (String s : className) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; aClass = Class.forName(s);<br>            &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br><span class="hljs-number">2</span>、声明一个注解，用来接收要判断是否存在的类<br><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Conditional(value = MyCondition.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyConditionOnClass &#123;<br>    String [] value();<br>&#125;<br><br><span class="hljs-number">3</span>、<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@MyConditionOnClass(&quot;com.study.springboot.Springboot02AutoconfigApplication&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Person <span class="hljs-title">person</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;小帅&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Person&#123;&quot;</span> +<br>                    <span class="hljs-string">&quot;name=&#x27;&quot;</span> + name + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                    <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><h5 id="自定义条件："><a href="#自定义条件：" class="headerlink" title="自定义条件："></a>自定义条件：</h5><p>​    第一步 定义条件类：</p>
<p>​        自定义类实现Condition接口，重写 matches 方法，在 matches 方法中进行逻辑判断，返回boolean值 。 matches 方法两个参数：</p>
<p>​            context：上下文对象，可以获取属性值，获取类加载器，获取BeanFactory等。</p>
<p>​            metadata：元数据对象，用于获取注解属性。</p>
<p>​    第二步 充当判断条件： </p>
<p>​        在初始化Bean时，使用 @Conditional(条件类.class)注解</p>
<h5 id="SpringBoot-提供的常用条件注解："><a href="#SpringBoot-提供的常用条件注解：" class="headerlink" title="SpringBoot 提供的常用条件注解："></a>SpringBoot 提供的常用条件注解：</h5><p>​        <strong>ConditionalOnProperty</strong>：判断配置文件中是否有对应属性和值才初始化Bean</p>
<p>​        <strong>ConditionalOnClass</strong>：判断环境中是否有对应字节码文件才初始化Bean</p>
<p>​        <strong>ConditionalOnMissingBean</strong>：判断环境中没有对应Bean实例才初始化Bean</p>
<h2 id="Enable"><a href="#Enable" class="headerlink" title="@Enable*"></a>@Enable*</h2><p>​    SpringBoot中提供了很多Enable开头的注解，这些注解都是用于动态启用某些功能的。而其底层原理是使用@Import注解导入一些配置类，实现Bean的动态加载</p>
<h2 id="Import注解"><a href="#Import注解" class="headerlink" title="@Import注解"></a>@Import注解</h2><p>​    @Enable底层依赖于@Import注解导入一些类，使用@Import导入的类会被Spring加载到IOC容器中。而@Import提供4中用法：</p>
<ol>
<li>导入配置类（最先注入）</li>
<li>导入 ImportSelector 实现类。一般用于加载配置文件中的类（返回new String[] 可以返回配置文件的key）</li>
<li>直接注入类</li>
<li>导入 ImportBeanDefinitionRegistrar 实现类（最后注入）。</li>
</ol>
<h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><ol>
<li>@EnableAutoConfiguration 注解内部使用 @Import(AutoConfigurationImportSelector.class)来加载配置类。</li>
<li>配置文件位置：<font style="background:yellow;font-weight:bold">META-INF/spring.factories</font>，该配置文件中定义了大量的配置类，当 SpringBoot 应用启动时，会自动加载这些配置类，初始化Bean</li>
<li>并不是所有的Bean都会被初始化，在配置类中使用Condition来加载满足条件的Bean</li>
</ol>
<p>在本版本中（2.5.3）AutoConfigurationImportSelector实际起作用的是process()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector)</span> </span>&#123;<br>       Assert.state(deferredImportSelector <span class="hljs-keyword">instanceof</span> AutoConfigurationImportSelector,<br>                    () -&gt; String.format(<span class="hljs-string">&quot;Only %s implementations are supported, got %s&quot;</span>,<br>                                        AutoConfigurationImportSelector.class.getSimpleName(),<br>                                        deferredImportSelector.getClass().getName()));<br>       <span class="hljs-comment">//去mata-inf/spring.factories文件中 查询org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的值</span><br>       AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)<br>           .getAutoConfigurationEntry(annotationMetadata);<br>       <span class="hljs-keyword">this</span>.autoConfigurationEntries.add(autoConfigurationEntry);<br>       <span class="hljs-comment">//去除重复的配置类，若我们自己写的starter 可能存主重复的</span><br>       <span class="hljs-keyword">for</span> (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;<br>           <span class="hljs-keyword">this</span>.entries.putIfAbsent(importClassName, annotationMetadata);<br>       &#125;<br>   &#125;<br><br><br><br></code></pre></td></tr></table></figure>

<p>SpringFactoriesLoader:去spring.factories 中去查询EnableAutoConfirution类 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;String&gt; <span class="hljs-title">loadFactoryNames</span><span class="hljs-params">(Class&lt;?&gt; factoryType, <span class="hljs-meta">@Nullable</span> ClassLoader classLoader)</span> </span>&#123;<br>	ClassLoader classLoaderToUse = classLoader;<br>	<span class="hljs-keyword">if</span> (classLoaderToUse == <span class="hljs-keyword">null</span>) &#123;<br>		classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();<br>	&#125;<br>	String factoryTypeName = factoryType.getName();<br>	<span class="hljs-keyword">return</span> loadSpringFactories(classLoaderToUse).getOrDefault(factoryTypeName, Collections.emptyList());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>最终筛选出需要自动配置的类</p>
<p><img src="/images/SpringBoot03-%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/image-20210817001324502.png" alt="image-20210817001324502"></p>
<h3 id="RedisAutoConfiguration"><a href="#RedisAutoConfiguration" class="headerlink" title="RedisAutoConfiguration"></a>RedisAutoConfiguration</h3><p>​    导入了三个组件 </p>
<p>​        RedisTemplate </p>
<p>​        StringRedisTemplate </p>
<p>​        JedisConnectionConfiguration</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(RedisOperations.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(RedisProperties.class)</span><br><span class="hljs-meta">@Import(&#123; LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisAutoConfiguration</span> </span>&#123;<br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> RedisTemplate&lt;Object, Object&gt; <span class="hljs-title">redisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		RedisTemplate&lt;Object, Object&gt; template = <span class="hljs-keyword">new</span> RedisTemplate&lt;&gt;();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>	<span class="hljs-meta">@ConditionalOnMissingBean</span><br>	<span class="hljs-meta">@ConditionalOnSingleCandidate(RedisConnectionFactory.class)</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> StringRedisTemplate <span class="hljs-title">stringRedisTemplate</span><span class="hljs-params">(RedisConnectionFactory redisConnectionFactory)</span> </span>&#123;<br>		StringRedisTemplate template = <span class="hljs-keyword">new</span> StringRedisTemplate();<br>		template.setConnectionFactory(redisConnectionFactory);<br>		<span class="hljs-keyword">return</span> template;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​    SpringBoot自动配置原理：简单来说就是通过</p>
<p>​    @SpringBootApplication -&gt; </p>
<p>​        @EnableAutoConfiguration -&gt;</p>
<p>​            @Import(AutoConfigurationImportSelector.class)</p>
<p>​                    导入项目所有 META-INF/spring.factories 中所有org.springframework.boot.autoconfigure.EnableAutoConfiguration的值，再通过@condition、import，@ConfigurationProperties @EnableConfigurationProperties等系列注解达到根据环境自动注入配置的目的。</p>
<p>​    <strong>具体例子可见SpringBoot04篇章</strong></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>自动配置</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot05-监听与监控</title>
    <url>/2021/08/21/SpringBoot05-%E7%9B%91%E5%90%AC%E4%B8%8E%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h1 id="SpringBoot-监听机制"><a href="#SpringBoot-监听机制" class="headerlink" title="SpringBoot-监听机制"></a>SpringBoot-监听机制</h1><h2 id="Java-监听机制"><a href="#Java-监听机制" class="headerlink" title="Java 监听机制"></a>Java 监听机制</h2><p>SpringBoot 的监听机制，其实是对Java提供的事件监听机制的封装。</p>
<p>​    Java中的事件监听机制定义了以下几个角色：</p>
<p>​        ① 事件：Event，继承 java.util.EventObject 类的对象</p>
<p>​        ② 事件源：Source ，任意对象Object</p>
<p>​        ③ 监听器：Listener，实现 java.util.EventListener 接口 的对象</p>
<p>​    SpringBoot 在项目启动时，会对几个监听器进行回调，我们可以实现这些监听器接口，在项目启动时完成一些操作。</p>
<p>​    ApplicationContextInitializer：SpringBoot 初始化时触发</p>
<p>​    SpringApplicationRunListener：SpringBoot整个生命周期</p>
<p>​    CommandLineRunner（无需注册）：SpringBoot启动后触发</p>
<p>​    ApplicationRunner（无需注册）：SpringBoot启动后触发</p>
<p>定义各种监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ApplicationArguments args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyApplicationRunner .. &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyCommandLineRunner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CommandLineRunner</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(String... args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyCommandLineRunner ...&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationContextInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContextInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ConfigurableApplicationContext applicationContext)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyApplicationContextInitializer ...&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MySpringApplicationRunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SpringApplicationRunListener</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">starting</span><span class="hljs-params">(ConfigurableBootstrapContext bootstrapContext)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...starting&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">environmentPrepared</span><span class="hljs-params">(ConfigurableBootstrapContext bootstrapContext, ConfigurableEnvironment environment)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...environmentPrepared&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextPrepared</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...contextPrepared&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoaded</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...contextLoaded&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">started</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...started&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">running</span><span class="hljs-params">(ConfigurableApplicationContext context)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...running&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(ConfigurableApplicationContext context, Throwable exception)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MySpringApplicationRunListener ...failed&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MySpringApplicationRunListener</span><span class="hljs-params">(SpringApplication application, String[] args)</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>META-INF/spring.factories：注册SpringApplicationRunListener和ApplicationContextInitializer</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.SpringApplicationRunListener</span>=<span class="hljs-string">\</span><br><span class="hljs-attr">com.study.springboot01simple.listenerr.MySpringApplicationRunListener</span><br><span class="hljs-meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="hljs-string">\</span><br><span class="hljs-attr">com.study.springboot01simple.listenerr.MyApplicationContextInitializer</span><br></code></pre></td></tr></table></figure>

<p>启动过程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">MySpringApplicationRunListener ...starting<br>MySpringApplicationRunListener ...environmentPrepared<br><br>  .   ____          _            __ _ _<br> /\\ / ___<span class="hljs-string">&#x27;_ __ _ _(_)_ __  __ _ \ \ \ \</span><br><span class="hljs-string">( ( )\___ | &#x27;</span>_ | <span class="hljs-string">&#x27;_| | &#x27;</span>_ \/ _` | \ \ \ \<br> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )<br>  <span class="hljs-string">&#x27;  |____| .__|_| |_|_| |_\__, | / / / /</span><br><span class="hljs-string"> =========|_|==============|___/=/_/_/_/</span><br><span class="hljs-string"> :: Spring Boot ::                (v2.5.3)</span><br><span class="hljs-string"></span><br><span class="hljs-string">MyApplicationContextInitializer ...</span><br><span class="hljs-string">MySpringApplicationRunListener ...contextPrepared</span><br><span class="hljs-string">2021-08-20 22:49:22.105  INFO 18552 --- [           main] c.s.s.Springboot01SimpleApplication      : Starting Springboot01SimpleApplication using Java 1.8.0_171 on LAPTOP-87U6TGC3 with PID 18552 (D:\git\code\study\springboot-itheima-2021\springboot-01-simple\target\classes started by 81566 in D:\git\code\study\springboot-itheima-2021)</span><br><span class="hljs-string">2021-08-20 22:49:22.117  INFO 18552 --- [           main] c.s.s.Springboot01SimpleApplication      : No active profile set, falling back to default profiles: default</span><br><span class="hljs-string">MySpringApplicationRunListener ...contextLoaded</span><br><span class="hljs-string">2021-08-20 22:49:25.313  INFO 18552 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat initialized with port(s): 8080 (http)</span><br><span class="hljs-string">2021-08-20 22:49:25.336  INFO 18552 --- [           main] o.apache.catalina.core.StandardService   : Starting service [Tomcat]</span><br><span class="hljs-string">2021-08-20 22:49:25.336  INFO 18552 --- [           main] org.apache.catalina.core.StandardEngine  : Starting Servlet engine: [Apache Tomcat/9.0.50]</span><br><span class="hljs-string">2021-08-20 22:49:25.578  INFO 18552 --- [           main] o.a.c.c.C.[Tomcat].[localhost].[/]       : Initializing Spring embedded WebApplicationContext</span><br><span class="hljs-string">2021-08-20 22:49:25.578  INFO 18552 --- [           main] w.s.c.ServletWebServerApplicationContext : Root WebApplicationContext: initialization completed in 3255 ms</span><br><span class="hljs-string">2021-08-20 22:49:26.463  INFO 18552 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path &#x27;</span><span class="hljs-string">&#x27;</span><br><span class="hljs-string">2021-08-20 22:49:26.494  INFO 18552 --- [           main] c.s.s.Springboot01SimpleApplication      : Started Springboot01SimpleApplication in 5.848 seconds (JVM running for 8.709)</span><br><span class="hljs-string">MySpringApplicationRunListener ...started</span><br><span class="hljs-string">MyApplicationRunner .. </span><br><span class="hljs-string">MyCommandLineRunner ...</span><br><span class="hljs-string">MySpringApplicationRunListener ...running</span><br><span class="hljs-string">com.study.springboot01simple.Springboot01SimpleApplication</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<h1 id="SpringBoot监控-actuator"><a href="#SpringBoot监控-actuator" class="headerlink" title="SpringBoot监控-actuator"></a>SpringBoot监控-actuator</h1><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="①-导入依赖坐标"><a href="#①-导入依赖坐标" class="headerlink" title="① 导入依赖坐标"></a>① 导入依赖坐标</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-actuator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>de.codecentric<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-admin-starter-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="②application-properties"><a href="#②application-properties" class="headerlink" title="②application.properties"></a>②application.properties</h3><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#开放健康信息检测</span><br><span class="hljs-meta">management.endpoint.health.show-details</span>=<span class="hljs-string">always</span><br><span class="hljs-meta">management.endpoints.web.exposure.include</span>=<span class="hljs-string">*</span><br><span class="hljs-comment">#配置Spring Boot Admin 服务端</span><br><span class="hljs-meta">spring.boot.admin.client.url</span>=<span class="hljs-string">http://localhost:9000</span><br><span class="hljs-meta">spring.boot.admin.client.instance.name</span>=<span class="hljs-string">client-01</span><br><span class="hljs-meta">server.address</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">info.username</span>=<span class="hljs-string">小帅哥</span><br><span class="hljs-meta">info.age</span> = <span class="hljs-string">24</span><br><span class="hljs-meta">server.port</span>=<span class="hljs-string">9001</span><br></code></pre></td></tr></table></figure>

<h3 id="③-访问http-127-0-0-1-9001-acruator"><a href="#③-访问http-127-0-0-1-9001-acruator" class="headerlink" title="③ 访问http://127.0.0.1:9001/acruator"></a>③ 访问<a href="http://127.0.0.1:9001/acruator">http://127.0.0.1:9001/acruator</a></h3><p>/beans     描述应用程序上下文里全部的Bean，以及它们的关系</p>
<p>/env     获取全部环境属性</p>
<p>/env/{name}     根据名称获取特定的环境属性值</p>
<p>/health     报告应用程序的健康指标，这些值由HealthIndicator的实现类提供</p>
<p>/info     获取应用程序的定制信息，这些信息由info打头的属性提供</p>
<p>/mappings     描述全部的URI路径，以及它们和控制器(包含Actuator端点)的映射关系</p>
<p>/metrics     报告各种应用程序度量信息，比如内存用量和HTTP请求计数</p>
<p>/metrics/{name}     报告指定名称的应用程序度量值</p>
<p>/trace     提供基本的HTTP请求跟踪信息(时间戳、HTTP头等)</p>
<h3 id="④利用spring-boot-admin展示客户端监控信息"><a href="#④利用spring-boot-admin展示客户端监控信息" class="headerlink" title="④利用spring boot admin展示客户端监控信息"></a>④利用spring boot admin展示客户端监控信息</h3><p>​    Spring Boot Admin是一个开源社区项目，用于管理和监控SpringBoot应用程序。</p>
<p>​    Spring Boot Admin 有两个角色，客户端(Client)和服务端(Server)。 </p>
<p>​    应用程序作为Spring Boot Admin Client向为Spring Boot Admin Server注册</p>
<p>​    Spring Boot Admin Server 的UI界面将Spring Boot Admin Client的Actuator Endpoint上的一些监控信息。</p>
<p>admin-server： </p>
<p>① 创建 admin-server 模块</p>
<p>② 导入依赖坐标 admin-starter-server</p>
<p>③ 在引导类上启用监控功能**@EnableAdminServer**</p>
<p>admin-client： </p>
<p>① 创建 admin-client 模块</p>
<p>② 导入依赖坐标 admin-starter-client</p>
<p>③ 配置相关信息：server地址等</p>
<h3 id="⑤-启动server和client服务，访问server"><a href="#⑤-启动server和client服务，访问server" class="headerlink" title="⑤ 启动server和client服务，访问server"></a>⑤ 启动server和client服务，访问server</h3><p><a href="http://localhost:9000/applications">http://localhost:9000/applications</a></p>
<p><img src="/images/SpringBoot05-%E5%90%AF%E5%8A%A8%E5%8E%9F%E7%90%86/image-20210822172511981.png" alt="image-20210822172511981"></p>
]]></content>
      <categories>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>SpringBoot</tag>
        <tag>监听与监控</tag>
      </tags>
  </entry>
  <entry>
    <title>TCP介绍</title>
    <url>/2022/02/22/TCP/</url>
    <content><![CDATA[<h1 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    TCP是在IP网络层之上的传输层协议，用于提供port到port面向连接的可靠的字节流传输</p>
<h2 id="TCP结构"><a href="#TCP结构" class="headerlink" title="TCP结构"></a>TCP结构</h2><p><img src="/images/TCP/image-20220216155444211.png" alt="image-20220216155444211"></p>
<p>序列号：<strong>在初次建立连接的时候，客户端和服务端都会为「本次的连接」随机初始化一个序列号。</strong>（纵观整个TCP流程中，序列号可以用来解决网络包乱序的问题）</p>
<p>确认号：<strong>该字段表示「接收端」告诉「发送端」对上一个数据包已经成功接收</strong>，一般而言确认号等于上一次接收到的[序列号+1]（确认号可以⽤来解决网络包丢失的问题）</p>
<p>flag标志位：</p>
<p>​    SYN=1，表示希望创建连接</p>
<p>​    ACK=1，表示接收到消息，确认号字段有效</p>
<p>​    FIN=1，表示希望断开连接</p>
<p>​    RST=1，表示TCP连接出现异常，需要断开</p>
<h2 id="TCP三次握手"><a href="#TCP三次握手" class="headerlink" title="TCP三次握手"></a>TCP三次握手</h2><p>​    <strong>TCP三次握手的目的</strong>：确认客户端和服务端通信双方的序列号</p>
<p><img src="/images/TCP/image-20220216161823436.png" alt="image-20220216161823436"></p>
<p>过程如下：</p>
<p>1、在最开始的时候，客户端和服务端都处于 CLOSE 状态</p>
<p>2、客户端：SYN    seq=client_isn(ISN:internal statement number序列号随机生成)，状态变成 SYN_SEND</p>
<p>3、服务端：SYN、ACK     seq=server_isn，ack=client_isn+1    状态变成 SYN-REVD</p>
<p>4、客户端 ：ACK    ack=server_isn+1    进入 ESTABLISHED 状态<br>    明确server端接收到了我的序列号（从ack=client_isn+1得知），需要让服务端也知道我能接收到他的消息。</p>
<p>5、服务端：服务端接收到客户端的报文之后，也进入 ESTABLISHED 状态</p>
<p><strong>TCP连接两次握手行吗？</strong></p>
<p>​    不行，两次握手只能保证客户端知道自己的序列号同步给服务端了，但服务端不清楚自己的序列号能否被客户端接受</p>
<p><strong>序列号为什么是随机的？</strong></p>
<p>​    1、安全性考虑 2、方便通信双方丢弃非本连接的报文</p>
<p><strong>网络是不可靠的，那建立连接不是会经过三次握手吗？那要是在中途丢了，怎么办？</strong></p>
<ul>
<li>第一个包丢了<ul>
<li>客户端迟迟没接收到服务端的ACK包，会周期性超时重传，直到收到服务端的ACK</li>
</ul>
</li>
<li>第二个包丢了<ul>
<li>服务端迟迟没接收到客户端的SYN、ACK包，会周期性超时重传，直到收到客户端的ACK</li>
</ul>
</li>
<li>第三个包丢了，客户端单方面进入ESTABLISHED <ul>
<li>客户端和服务端都没有发送数据<ul>
<li>服务端周期性超时重传</li>
</ul>
</li>
<li>如果这时候客户端已经要发送数据了，服务端接收到了ACK + Data数据包，那自然就切换到 ESTABLISHED 状态下，并且接收客户端的Data数据包</li>
<li>如果此时服务端要发送数据了，但发送不了，会一直周期性超时重传SYN + ACK，直到接收到客户端的ACK包</li>
</ul>
</li>
</ul>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p><img src="/images/TCP/image-20220221145750654.png" alt="image-20220221145750654"></p>
<p><strong>四次挥手的过程</strong></p>
<p>​    （客户端说我要断开了，服务端说收到，等等，马上，服务端说来吧断开吧，客户端 收到）</p>
<p>1、建立连接后，客户端和服务端都处于ESTABLISHED状态，双方都可以发起断开连接，以客户端为例</p>
<p>2、客户端：FIN，然后进入FIN_WAIT_1状态</p>
<p>3、服务端：ACK，然后进入CLOSE_WAIT状态</p>
<p>4、客户单：接收到ACK后，进入FIN_WAIT_2状态</p>
<p>5、服务端确认完没有待发送数据后，发送 FIN ACK ，自己进入LAST_WAIT状态</p>
<p>6、客户端：ACK，然后进入FIN_WAIT_1状态</p>
<p>7、服务端：进入CLOSE状态</p>
<p>9、客户端：等待2MSL（Maximum Segment Lifetime：最长报文段寿命）后，进入close状态</p>
<p> <strong>TIME_WAIT （等待 2MSL）状态的作用</strong></p>
<p>1、连接断开后，创建新连接时，网络中的残余数据都丢失了，不会影响到新连接</p>
<p>2、确保服务端能接受到最后一个ACK报文段，从而进入都进入CLOSE状态(如果server接受不到client的ACK，会超时重发 FIN+ACK)，客户端重新等待2MSL，知道服务端接受成功，双方都进入CLOSE状态</p>
<p><strong>TCP连接到底是什么？如何理解</strong></p>
<p>TCP连接其实是客户端服务端双方之间确认状态信息，比如建立连接时序列号等等，本质上是维持一个一个状态，具有连接特性</p>
<p><strong>为什么TCP4次挥手时等待的时间是2MSL</strong></p>
<p>1、为了让此次 TCP 连接中的所有报文在网络中消失、避免对下一次的连接造成影响：1、如果B迟迟收不到A的ACK，B会重发FIN。2、假设极端情况下A的ACK在MSL时到达了B，B在接收到的前一刻重传了FIN，这个FIN会在MSL内消失，所以A等待2MSL是为了处理所有的来自B的报文。</p>
]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>TCP</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-jenkins部署</title>
    <url>/2025/02/10/docker-jenkins%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>​    Jenkins 是一个开源的<strong>持续集成和持续交付（CI/CD）工具</strong>，用于自动化软件开发过程中的构建、测试和部署任务。它帮助开发团队更高效地管理代码变更，确保软件质量。</p>
<h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ol>
<li><strong>持续集成（CI continous intergration）</strong>：自动构建和测试代码，快速发现并修复问题。</li>
<li><strong>持续交付/部署（CD continous deliver/deployment）</strong>：自动化部署流程，确保软件能快速、可靠地发布。</li>
<li><strong>插件支持</strong>：通过丰富的插件扩展功能，支持多种开发工具和平台。</li>
<li><strong>分布式构建</strong>：支持在多台机器上并行构建，提升效率。</li>
<li><strong>流水线（Pipeline）</strong>：通过定义流水线脚本，实现复杂工作流的自动化管理。</li>
</ol>
<h3 id="核心目标"><a href="#核心目标" class="headerlink" title="核心目标"></a>核心目标</h3><p>1、提高效率：自动化构建、测试、部署，减少手动繁琐的操作</p>
<p>2、快速交付：缩短从开发到部署的时间，更快响应需求</p>
<p>3、提升质量：通过频繁部署测试和快速反馈，降低错误率</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><p><a href="https://www.bilibili.com/video/BV1We411q7FS/?spm_id_from=333.337.search-card.all.click&vd_source=41042e45d4153dbeef9497c29d126b3e">参考视频</a></p>
<p>方便演示，我们采用docker安装jenkins，并且以下效果：<br>1、github项目main有新提交时触发构建<br>2、构建时达成jar包<br>3、调用宿主机的docker生成jar包的镜像<br>4、docker启动镜像</p>
<p><strong>1、安装</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker pull jenkins/jenkins<br></code></pre></td></tr></table></figure>

<p><strong>2、启动jenkins</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 启动jenkins<br>docker run -u root -itd --name jenkins -p <span class="hljs-number">6001</span>:<span class="hljs-number">8080</span> -v $(which docker):/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock -e TZ=&quot;Asia/Shanghai&quot; -v /etc/localtime:/etc/localtime:ro -v /volume1/docker/jenkins:/var/jenkins_home jenkins/jenkins<br># 进入jenkins<br>docker exec -it jenkins bash<br># 查看密码<br>cat /var/jenkins_home/secrets/initialAdminPassword<br></code></pre></td></tr></table></figure>

<p><code>-p 6001:8080</code></p>
<p>​    Jenkins默认网页访问端口为8080，将端口映射到外部主机</p>
<p><code>-v $(which docker):/usr/bin/docker -v /var/run/docker.sock:/var/run/docker.sock</code>\</p>
<p>​    使Jenkins内部可以使用docker命令</p>
<p><code>-e TZ=&quot;Asia/Shanghai&quot; -v /etc/localtime:/etc/localtime:ro</code></p>
<p>​    配置Jenkins容器的时区</p>
<p><code>-v /volume1/docker/jenkins:/var/jenkins_home</code> </p>
<p>​    将Jenkins的配置映射到外部主机卷，容器删除仍可保留配置，且可以把jdk、maven等软件挂载进来</p>
<p><strong>3、初始化jenkins</strong></p>
<p>1、登录 宿主机ip:6001进入jenkins页面，输入密码、设置第一个管理员密码root/root</p>
<p>2、安装推荐的插件</p>
<p>3、安装 Maven 、Publish Over SSH（用于把产物包通过ssh方式传给部署机器并配置执行命令，本次举例就是本机，所以没用到）</p>
<p>4、配置jdk、maven（虽然jenkins docker方式已内置jdk和git，但jdk版本比较高，我们实例项目用的jdk8，所以要配置）<br>设置maven目录和setting文件，<strong>注意文件目录其实就是挂载的目录</strong></p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250210232437245.png" alt="image-20250210232437245"></p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250210232504857.png" alt="image-20250210232504857"></p>
<p>配置jdk</p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250210232643009.png" alt="image-20250210232643009"></p>
<p>5、新建任务：maven项目</p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/43e1138df1b94af094d749d52f010a0f.webp" alt="1650643032247-9bc9e23e-bdcf-4966-a279-8810560b2cbe.png"></p>
<p>6、配置任务</p>
<p><strong>源码管理</strong></p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250210233023160.png" alt="image-20250210233023160"></p>
<p><strong>触发器（可选）</strong></p>
<p>可以配置push后自动触发构建，由于是本机内网演示</p>
<p>1、利用natap生成一个内网穿透地址</p>
<p>2、在github仓库上设置钩子</p>
<pre><code>进入 GitHub 仓库 → Settings → Webhooks → Add webhook:
Payload URL: http://&lt;JENKINS-IP&gt;/github-webhook/
Content Type: application/json
事件：Just the push event
</code></pre>
<p>3、在github上生成acces s token拿到token</p>
<p>4、配置github server secret text的value=token的值</p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250213000134265.png" alt="image-20250213000134265"></p>
<p><strong>编译</strong></p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250210233134170.png" alt="image-20250210233134170"><strong>编译后触发脚本</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 进入项目工作区<br><span class="hljs-built_in">cd</span> /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker<br># 检查文件是否存在<br>ls -l Dockerfile               # 应存在<br>ls -l target/*.jar             # 应存在<br># 打印 JAR 包路径，方便调试<br><span class="hljs-built_in">echo</span> &quot;JAR 包路径: $(<span class="hljs-built_in">find</span> target -name &#x27;*.jar&#x27;)&quot;<br><br># 构建 Docker 镜像<br>docker build -t docker-jenkins-test-pkg-runindocker:latest .<br><br># 停止并删除之前运行的容器（如果存在）<br>docker stop docker-jenkins-test-pkg-runindocker || true<br>docker rm docker-jenkins-test-pkg-runindocker || true<br><br># 运行新的 Docker 容器<br>docker run -d -p <span class="hljs-number">18080</span>:<span class="hljs-number">8080</span> --name docker-jenkins-test-pkg-runindocker docker-jenkins-test-pkg-runindocker:latest<br></code></pre></td></tr></table></figure>

<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250210233256531.png" alt="image-20250210233256531"></p>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>项目push后自动触发构建</p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250213000422054.png" alt="image-20250213000422054"></p>
<p>控制台日志</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">Started by GitHub push by Callme24kHandsome<br>Running as SYSTEM<br>Building in workspace /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker<br>The recommended git tool is: NONE<br>No credentials specified<br> &gt; git rev-parse --resolve-git-dir /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/.git # timeout=10<br>Fetching changes from the remote Git repository<br> &gt; git config remote.origin.url https://xxxx/docker-jenkins-test.git # timeout=10<br>Fetching upstream changes from https://xxxx/docker-jenkins-test.git<br> &gt; git --version # timeout=10<br> &gt; git --version # &#x27;git version 2.39.5&#x27;<br> &gt; git fetch --tags --force --progress -- https://github.com/Callme24kHandsome/docker-jenkins-test.git +refs/heads/*:refs/remotes/origin/* # timeout=10<br> &gt; git rev-parse refs/remotes/origin/main^&#123;commit&#125; # timeout=10<br>Checking out Revision e02733c6cbff85d5622ede2327dc48549a63bbd8 (refs/remotes/origin/main)<br> &gt; git config core.sparsecheckout # timeout=10<br> &gt; git checkout -f e02733c6cbff85d5622ede2327dc48549a63bbd8 # timeout=10<br>Commit message: &quot;修改Dockerfile&quot;<br> &gt; git rev-list --no-walk 840813635c7d52b9aa354a225f9eea7feb2a3243 # timeout=10<br>Parsing POMs<br>Established TCP socket on 37200<br>[docker-jenkins-test-pkg-runInDocker] $ /var/jenkins_home/gzip/jdk1.8.0_152/bin/java -cp /var/jenkins_home/plugins/maven-plugin/WEB-INF/lib/maven35-agent-1.14.jar:/var/jenkins_home/gzip/apache-maven-3.8.1/boot/plexus-classworlds-2.6.0.jar:/var/jenkins_home/gzip/apache-maven-3.8.1/conf/logging jenkins.maven3.agent.Maven35Main /var/jenkins_home/gzip/apache-maven-3.8.1 /var/jenkins_home/war/WEB-INF/lib/remoting-3283.v92c105e0f819.jar /var/jenkins_home/plugins/maven-plugin/WEB-INF/lib/maven35-interceptor-1.14.jar /var/jenkins_home/plugins/maven-plugin/WEB-INF/lib/maven3-interceptor-commons-1.14.jar 37200<br>Exception in thread &quot;main&quot; java.lang.UnsupportedClassVersionError: hudson/remoting/Launcher has been compiled by a more recent version of the Java Runtime (class file version 55.0), this version of the Java Runtime only recognizes class file versions up to 52.0<br>	at java.lang.ClassLoader.defineClass1(Native Method)<br>	at java.lang.ClassLoader.defineClass(ClassLoader.java:763)<br>	at java.security.SecureClassLoader.defineClass(SecureClassLoader.java:142)<br>	at java.net.URLClassLoader.defineClass(URLClassLoader.java:467)<br>	at java.net.URLClassLoader.access$100(URLClassLoader.java:73)<br>	at java.net.URLClassLoader$1.run(URLClassLoader.java:368)<br>	at java.net.URLClassLoader$1.run(URLClassLoader.java:362)<br>	at java.security.AccessController.doPrivileged(Native Method)<br>	at java.net.URLClassLoader.findClass(URLClassLoader.java:361)<br>	at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClassFromSelf(ClassRealm.java:425)<br>	at org.codehaus.plexus.classworlds.strategy.SelfFirstStrategy.loadClass(SelfFirstStrategy.java:42)<br>	at org.codehaus.plexus.classworlds.realm.ClassRealm.unsynchronizedLoadClass(ClassRealm.java:271)<br>	at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:247)<br>	at org.codehaus.plexus.classworlds.realm.ClassRealm.loadClass(ClassRealm.java:239)<br>	at jenkins.maven3.agent.Maven35Main.main(Maven35Main.java:136)<br>	at jenkins.maven3.agent.Maven35Main.main(Maven35Main.java:66)<br>ERROR: ================================================================================<br>ERROR: Invalid project setup: Connection reset<br>ERROR: [JENKINS-18403][JENKINS-28294] JDK &#x27;jdk8&#x27; not supported to run Maven projects.<br>ERROR: Maven projects have to be launched with a Java version greater or equal to the minimum version required by the controller.<br>ERROR: Use the Maven JDK Toolchains (plugin) to build your maven project with an older JDK.<br>ERROR: Retrying with agent Java and setting compile/test properties to point to /var/jenkins_home/gzip/jdk1.8.0_152.<br>ERROR: ================================================================================<br>Established TCP socket on 42399<br>[docker-jenkins-test-pkg-runInDocker] $ /opt/java/openjdk/bin/java -cp /var/jenkins_home/plugins/maven-plugin/WEB-INF/lib/maven35-agent-1.14.jar:/var/jenkins_home/gzip/apache-maven-3.8.1/boot/plexus-classworlds-2.6.0.jar:/var/jenkins_home/gzip/apache-maven-3.8.1/conf/logging jenkins.maven3.agent.Maven35Main /var/jenkins_home/gzip/apache-maven-3.8.1 /var/jenkins_home/war/WEB-INF/lib/remoting-3283.v92c105e0f819.jar /var/jenkins_home/plugins/maven-plugin/WEB-INF/lib/maven35-interceptor-1.14.jar /var/jenkins_home/plugins/maven-plugin/WEB-INF/lib/maven3-interceptor-commons-1.14.jar 42399<br>&lt;===[JENKINS REMOTING CAPACITY]===&gt;���channel started<br>Executing Maven:  -B -f /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/pom.xml clean package -Dmaven.test.skip=true<br>[INFO] Scanning for projects...<br>[INFO] <br>[INFO] ------------------&lt; org.example:docker-jenkins-test &gt;-------------------<br>[INFO] Building docker-jenkins-test 1.0-SNAPSHOT<br>[INFO] --------------------------------[ jar ]---------------------------------<br>[INFO] <br>[INFO] --- maven-clean-plugin:3.1.0:clean (default-clean) @ docker-jenkins-test ---<br>[INFO] Deleting /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/target<br>[INFO] <br>[INFO] --- maven-resources-plugin:3.2.0:resources (default-resources) @ docker-jenkins-test ---<br>[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered resources.<br>[INFO] Using &#x27;UTF-8&#x27; encoding to copy filtered properties files.<br>[INFO] skip non existing resourceDirectory /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/src/main/resources<br>[INFO] skip non existing resourceDirectory /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/src/main/resources<br>[INFO] <br>[INFO] --- maven-compiler-plugin:3.8.1:compile (default-compile) @ docker-jenkins-test ---<br>[INFO] Changes detected - recompiling the module!<br>[INFO] Compiling 2 source files to /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/target/classes<br>[INFO] <br>[INFO] --- maven-resources-plugin:3.2.0:testResources (default-testResources) @ docker-jenkins-test ---<br>[INFO] Not copying test resources<br>[INFO] <br>[INFO] --- maven-compiler-plugin:3.8.1:testCompile (default-testCompile) @ docker-jenkins-test ---<br>[INFO] Not compiling test sources<br>[INFO] <br>[INFO] --- maven-surefire-plugin:2.22.2:test (default-test) @ docker-jenkins-test ---<br>[INFO] Tests are skipped.<br>[INFO] <br>[INFO] --- maven-jar-plugin:3.2.0:jar (default-jar) @ docker-jenkins-test ---<br>[INFO] Building jar: /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/target/docker-jenkins-test-1.0-SNAPSHOT.jar<br>[INFO] <br>[INFO] --- spring-boot-maven-plugin:2.5.6:repackage (repackage) @ docker-jenkins-test ---<br>[INFO] Replacing main artifact with repackaged archive<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Total time:  55.754 s<br>[INFO] Finished at: 2025-02-12T23:57:02+08:00<br>[INFO] ------------------------------------------------------------------------<br>Waiting for Jenkins to finish collecting data<br>[JENKINS] Archiving /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/pom.xml to org.example/docker-jenkins-test/1.0-SNAPSHOT/docker-jenkins-test-1.0-SNAPSHOT.pom<br>[JENKINS] Archiving /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker/target/docker-jenkins-test-1.0-SNAPSHOT.jar to org.example/docker-jenkins-test/1.0-SNAPSHOT/docker-jenkins-test-1.0-SNAPSHOT.jar<br>[docker-jenkins-test-pkg-runInDocker] $ /bin/sh -xe /tmp/jenkins5156680462021271743.sh<br>channel stopped<br>+ cd /var/jenkins_home/workspace/docker-jenkins-test-pkg-runInDocker<br>+ ls -l Dockerfile<br>-rw-r--r--. 1 root root 120 Feb  9 23:21 Dockerfile<br>+ ls -l target/docker-jenkins-test-1.0-SNAPSHOT.jar<br>-rw-r--r--. 1 root root 17490950 Feb 12 23:56 target/docker-jenkins-test-1.0-SNAPSHOT.jar<br>+ find target -name *.jar<br>+ echo JAR 包路径: target/docker-jenkins-test-1.0-SNAPSHOT.jar<br>JAR 包路径: target/docker-jenkins-test-1.0-SNAPSHOT.jar<br>+ docker build -t docker-jenkins-test-pkg-runindocker:latest .<br>DEPRECATED: The legacy builder is deprecated and will be removed in a future release.<br>            Install the buildx component to build images with BuildKit:<br>            https://docs.docker.com/go/buildx/<br><br>Sending build context to Docker daemon  17.63MB<br><br>Step 1/5 : FROM openjdk:8<br> ---&gt; b273004037cc<br>Step 2/5 : COPY target/*.jar /app.jar<br> ---&gt; d8d778b1aa35<br>Step 3/5 : CMD [&quot;--server.port=8080&quot;]<br> ---&gt; Running in d1f198c573e4<br> ---&gt; Removed intermediate container d1f198c573e4<br> ---&gt; 30daec3524db<br>Step 4/5 : EXPOSE 8080<br> ---&gt; Running in 720318661c76<br> ---&gt; Removed intermediate container 720318661c76<br> ---&gt; 86fb695a5c0c<br>Step 5/5 : ENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]<br> ---&gt; Running in dd1f1629bc7a<br> ---&gt; Removed intermediate container dd1f1629bc7a<br> ---&gt; 88bb368191f9<br>Successfully built 88bb368191f9<br>Successfully tagged docker-jenkins-test-pkg-runindocker:latest<br>+ docker stop docker-jenkins-test-pkg-runindocker<br>docker-jenkins-test-pkg-runindocker<br>+ docker rm docker-jenkins-test-pkg-runindocker<br>docker-jenkins-test-pkg-runindocker<br>+ docker run -d -p 18080:8080 --name docker-jenkins-test-pkg-runindocker docker-jenkins-test-pkg-runindocker:latest<br>b983b6731e7c15730605d53681235195bbbb45be4c9bb11d5e74f21743763359<br>Finished: SUCCESS<br></code></pre></td></tr></table></figure>

<p>3、部署成功</p>
<p><img src="/images/docker-jenkins%E9%83%A8%E7%BD%B2/image-20250213000630844.png" alt="image-20250213000630844"></p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>jenkins</tag>
        <tag>CICD</tag>
      </tags>
  </entry>
  <entry>
    <title>docker使用及安装</title>
    <url>/2024/12/22/docker%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%AE%89%E8%A3%85/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><h2 id="1、安装DOCKER和DOCKER-COMPOSE"><a href="#1、安装DOCKER和DOCKER-COMPOSE" class="headerlink" title="1、安装DOCKER和DOCKER-COMPOSE"></a>1、安装DOCKER和DOCKER-COMPOSE</h2><p>首先我们需要安装GCC相关的环境</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum -y install gcc<br>yum -y install gcc-c++<br></code></pre></td></tr></table></figure>

<p>安装Docker需要的依赖软件包：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum install -y yum-utils device-mapper-persistent-data lvm2<br></code></pre></td></tr></table></figure>

<p>设置国内的镜像（提高速度）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo<br></code></pre></td></tr></table></figure>

<p>更新yum软件包索引：</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">yum makecache fast</span><br></code></pre></td></tr></table></figure>

<p>安装DOCKER CE(注意：Docker分为CE版和EE版，一般我们用CE版就够用了.)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">yum -y install docker-ce<br></code></pre></td></tr></table></figure>

<p>启动Docker：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">systemctl start docker<br></code></pre></td></tr></table></figure>

<p>下载回来的Docker版本：:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker version<br></code></pre></td></tr></table></figure>

<p>运行以下命令以下载 Docker Compose 的当前稳定版本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.24.1/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<br>or<br>sudo curl -L <span class="hljs-string">&quot;https://github.com/docker/compose/releases/download/1.29.2/docker-compose-<span class="hljs-subst">$(uname -s)</span>-<span class="hljs-subst">$(uname -m)</span>&quot;</span> -o /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<br><br><br></code></pre></td></tr></table></figure>

<p>将可执行权限应用于二进制文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo chmod +x /usr/<span class="hljs-built_in">local</span>/bin/docker-compose<br></code></pre></td></tr></table></figure>

<p>创建软链：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">sudo ln -s /usr/<span class="hljs-built_in">local</span>/bin/docker-compose /usr/bin/docker-compose<br></code></pre></td></tr></table></figure>

<p>测试是否安装成功：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose --version<br></code></pre></td></tr></table></figure>

<h2 id="2、docker镜像仓库及代理配置"><a href="#2、docker镜像仓库及代理配置" class="headerlink" title="2、docker镜像仓库及代理配置"></a>2、docker镜像仓库及代理配置</h2><p>解决：Get “<a href="https://registry-1.docker.io/v2/%E2%80%9C">https://registry-1.docker.io/v2/“</a>: net/http: request canceled while waiting for connection</p>
<p>1、配置docker镜像仓库地址</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim /etc/docker/daemon.json	<br><br>&#123;<br>  <span class="hljs-string">&quot;registry-mirrors&quot;</span>: [<br>    <span class="hljs-string">&quot;https://xx4bwyg2.mirror.aliyuncs.com&quot;</span>,<br>    <span class="hljs-string">&quot;http://f1361db2.m.daocloud.io&quot;</span>,<br>    <span class="hljs-string">&quot;https://registry.docker-cn.com&quot;</span>,<br>    <span class="hljs-string">&quot;http://hub-mirror.c.163.com&quot;</span>,<br>    <span class="hljs-string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>,<br>    <span class="hljs-string">&quot;https://w14ki3ju.mirror.aliyuncs.com&quot;</span><br>    ]<br>&#125;<br><span class="hljs-comment"># 加载配置</span><br>systemctl daemon-reload<br>systemctl restart docker<br><br></code></pre></td></tr></table></figure>

<p>解决：VMware、Docker - 让虚拟机走主机代理，解决镜像封禁问题</p>
<p>2、配置docker代理</p>
<p>192.168.136.10是安装vmware的宿主机</p>
<p>7890是科学上网的clash for window的端口</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">vim /etc/systemd/system/docker.service.d/proxy.conf<br><br>[Service]<br>Environment=<span class="hljs-string">&quot;HTTP_PROXY=http://192.168.136.10:7890&quot;</span><br>Environment=<span class="hljs-string">&quot;HTTPS_PROXY=http://192.168.136.10:7890&quot;</span><br><br><span class="hljs-comment"># 加载配置</span><br>systemctl daemon-reload<br><span class="hljs-comment"># 重启docker</span><br>systemctl restart docker<br><span class="hljs-comment"># 查看代理配置是否生效</span><br>systemctl show --property=Environment docker<br></code></pre></td></tr></table></figure>

<h2 id="3、docker-compse-安装zookeeper、kafka、kafka-manager"><a href="#3、docker-compse-安装zookeeper、kafka、kafka-manager" class="headerlink" title="3、docker compse 安装zookeeper、kafka、kafka-manager"></a>3、docker compse 安装zookeeper、kafka、kafka-manager</h2><p>kafka manager添加集群报错：KeeperErrorCode = Unimplemented for /kafka-manager/mutex Try again</p>
<p><a href="https://www.jianshu.com/p/9d7f64b49d51">https://www.jianshu.com/p/9d7f64b49d51</a></p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
        <tag>docker-compose</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2021/02/13/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server本地启动"><a href="#Run-server本地启动" class="headerlink" title="Run server本地启动"></a>Run server本地启动</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
<h3 id="生成并部署到远端"><a href="#生成并部署到远端" class="headerlink" title="生成并部署到远端"></a>生成并部署到远端</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">hexo g -d<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>随心记</category>
      </categories>
      <tags>
        <tag>随心记</tag>
      </tags>
  </entry>
  <entry>
    <title>单元测试-junit5</title>
    <url>/2021/03/14/junit5/</url>
    <content><![CDATA[<h1 id="07、单元测试"><a href="#07、单元测试" class="headerlink" title="07、单元测试"></a>07、单元测试</h1><h1 id="1、JUnit5-的变化"><a href="#1、JUnit5-的变化" class="headerlink" title="1、JUnit5 的变化"></a>1、JUnit5 的变化</h1><p><strong>Spring Boot 2.2.0 版本开始引入 JUnit 5 作为单元测试默认库</strong></p>
<p>作为最新版本的JUnit框架，JUnit5与之前版本的Junit框架有很大的不同。由三个不同子项目的几个不同模块组成。</p>
<blockquote>
<p><strong>JUnit 5 = JUnit Platform + JUnit Jupiter + JUnit Vintage</strong></p>
</blockquote>
<p><strong>JUnit Platform</strong>: Junit Platform是在JVM上启动测试框架的基础，不仅支持Junit自制的测试引擎，其他测试引擎也都可以接入。</p>
<p><strong>JUnit Jupiter</strong>: JUnit Jupiter提供了JUnit5的新的编程模型，是JUnit5新特性的核心。内部 包含了一个<strong>测试引擎</strong>，用于在Junit Platform上运行。</p>
<p><strong>JUnit Vintage</strong>: 由于JUint已经发展多年，为了照顾老的项目，JUnit Vintage提供了兼容JUnit4.x,Junit3.x的测试引擎。</p>
<p><img src="/images/junit5/afeae670-6be9-11e9-8b0d-d3a853e66b8e-1617453264093" alt="img"></p>
<p>注意：</p>
<p><strong>SpringBoot 2.4 以上版本移除了默认对 Vintage 的依赖。如果需要兼容junit4需要自行引入（不能使用junit4的功能 @Test）</strong></p>
<p><strong>JUnit 5’s Vintage Engine Removed from</strong> <strong><code>spring-boot-starter-test,如果需要继续兼容junit4需要自行引入vintage</code></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.junit.vintage<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit-vintage-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hamcrest<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hamcrest-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p><img src="/images/junit5/image-1617453444332.png" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>现在版本：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Boot05WebAdminApplicationTests</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以前：</p>
<p><strong>@SpringBootTest + @RunWith(SpringTest.class)</strong></p>
<p>SpringBoot整合Junit以后。</p>
<ul>
<li>编写测试方法：@Test标注（注意需要使用junit5版本的注解）</li>
<li>Junit类具有Spring的功能，@Autowired、比如 @Transactional 标注测试方法，测试完成后自动回滚</li>
</ul>
<h1 id="2、JUnit5常用注解"><a href="#2、JUnit5常用注解" class="headerlink" title="2、JUnit5常用注解"></a>2、JUnit5常用注解</h1><p>JUnit5的注解与JUnit4的注解有所变化</p>
<p><a href="https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations">https://junit.org/junit5/docs/current/user-guide/#writing-tests-annotations</a></p>
<ul>
<li>**@Test **:表示方法是测试方法。但是与JUnit4的@Test不同，他的职责非常单一不能声明任何属性，拓展的测试将会由Jupiter提供额外测试</li>
<li>**@ParameterizedTest **:表示方法是参数化测试，下方会有详细介绍</li>
<li>**@RepeatedTest **:表示方法可重复执行，下方会有详细介绍</li>
<li>**@DisplayName **:为测试类或者测试方法设置展示名称</li>
<li><strong>@BeforeEach</strong> :表示在每个单元测试之前执行</li>
<li>**@AfterEach **:表示在每个单元测试之后执行</li>
<li>**@BeforeAll :**表示在所有单元测试之前执行</li>
<li>**@AfterAll :**表示在所有单元测试之后执行</li>
<li>**@Tag :**表示单元测试类别，类似于JUnit4中的@Categories</li>
<li>**@Disabled :**表示测试类或测试方法不执行，类似于JUnit4中的@Ignore</li>
<li>**@Timeout :**表示测试方法运行如果超过了指定时间将会返回错误</li>
<li>**@ExtendWith :**为测试类或测试方法提供扩展类引用</li>
</ul>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">import</span> <span class="hljs-selector-tag">org</span><span class="hljs-selector-class">.junit</span><span class="hljs-selector-class">.jupiter</span><span class="hljs-selector-class">.api</span><span class="hljs-selector-class">.Test</span>; <span class="hljs-comment">//注意这里使用的是jupiter的Test注解！！</span><br><br><br><span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">class</span> <span class="hljs-selector-tag">TestDemo</span> &#123;<br><br>  <span class="hljs-variable">@Test</span><br>  <span class="hljs-variable">@DisplayName</span>(<span class="hljs-string">&quot;第一次测试&quot;</span>)<br>  public void firstTest() &#123;<br>      <span class="hljs-selector-tag">System</span><span class="hljs-selector-class">.out</span><span class="hljs-selector-class">.println</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>  &#125;<br></code></pre></td></tr></table></figure>



<h1 id="3、断言（assertions）"><a href="#3、断言（assertions）" class="headerlink" title="3、断言（assertions）"></a>3、断言（assertions）</h1><p>断言（assertions）是测试方法中的核心部分，用来对测试需要满足的条件进行验证。<strong>这些断言方法都是 org.junit.jupiter.api.Assertions 的静态方法</strong>。JUnit 5 内置的断言可以分成如下几个类别：</p>
<p><strong>检查业务逻辑返回的数据是否合理。</strong></p>
<p><strong>所有的测试运行结束以后，会有一个详细的测试报告；</strong></p>
<h2 id="1、简单断言"><a href="#1、简单断言" class="headerlink" title="1、简单断言"></a>1、简单断言</h2><p>用来对单个值进行简单的验证。如：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>assertEquals</td>
<td>判断两个对象或两个原始类型是否相等</td>
</tr>
<tr>
<td>assertNotEquals</td>
<td>判断两个对象或两个原始类型是否不相等</td>
</tr>
<tr>
<td>assertSame</td>
<td>判断两个对象引用是否指向同一个对象</td>
</tr>
<tr>
<td>assertNotSame</td>
<td>判断两个对象引用是否指向不同的对象</td>
</tr>
<tr>
<td>assertTrue</td>
<td>判断给定的布尔值是否为 true</td>
</tr>
<tr>
<td>assertFalse</td>
<td>判断给定的布尔值是否为 false</td>
</tr>
<tr>
<td>assertNull</td>
<td>判断给定的对象引用是否为 null</td>
</tr>
<tr>
<td>assertNotNull</td>
<td>判断给定的对象引用是否不为 null</td>
</tr>
</tbody></table>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;simple assertion&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simple</span><span class="hljs-params">()</span> </span>&#123;<br>     assertEquals(<span class="hljs-number">3</span>, <span class="hljs-number">1</span> + <span class="hljs-number">2</span>, <span class="hljs-string">&quot;simple math&quot;</span>);<br>     assertNotEquals(<span class="hljs-number">3</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>);<br><br>     assertNotSame(<span class="hljs-keyword">new</span> Object(), <span class="hljs-keyword">new</span> Object());<br>     Object obj = <span class="hljs-keyword">new</span> Object();<br>     assertSame(obj, obj);<br><br>     assertFalse(<span class="hljs-number">1</span> &gt; <span class="hljs-number">2</span>);<br>     assertTrue(<span class="hljs-number">1</span> &lt; <span class="hljs-number">2</span>);<br><br>     assertNull(<span class="hljs-keyword">null</span>);<br>     assertNotNull(<span class="hljs-keyword">new</span> Object());<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2、数组断言"><a href="#2、数组断言" class="headerlink" title="2、数组断言"></a>2、数组断言</h2><p>通过 assertArrayEquals 方法来判断两个对象或原始类型的数组是否相等</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;array assertion&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">array</span><span class="hljs-params">()</span> </span>&#123;<br> assertArrayEquals(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;, <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[] &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3、组合断言"><a href="#3、组合断言" class="headerlink" title="3、组合断言"></a>3、组合断言</h2><p>assertAll 方法接受多个 org.junit.jupiter.api.Executable 函数式接口的实例作为要验证的断言，可以通过 lambda 表达式很容易的提供这些断言</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;assert all&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">all</span><span class="hljs-params">()</span> </span>&#123;<br> assertAll(<span class="hljs-string">&quot;Math&quot;</span>,<br>    () -&gt; assertEquals(<span class="hljs-number">2</span>, <span class="hljs-number">1</span> + <span class="hljs-number">1</span>),<br>    () -&gt; assertTrue(<span class="hljs-number">1</span> &gt; <span class="hljs-number">0</span>)<br> );<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4、异常断言"><a href="#4、异常断言" class="headerlink" title="4、异常断言"></a>4、异常断言</h2><p>在JUnit4时期，想要测试方法的异常情况时，需要用**@Rule<strong>注解的ExpectedException变量还是比较麻烦的。而JUnit5提供了一种新的断言方式</strong>Assertions.assertThrows()** ,配合函数式编程就可以进行使用。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;异常测试&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionTest</span><span class="hljs-params">()</span> </span>&#123;<br>    ArithmeticException exception = Assertions.assertThrows(<br>           <span class="hljs-comment">//扔出断言异常</span><br>            ArithmeticException.class, () -&gt; System.out.println(<span class="hljs-number">1</span> % <span class="hljs-number">0</span>));<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="5、超时断言"><a href="#5、超时断言" class="headerlink" title="5、超时断言"></a>5、超时断言</h2><p>Junit5还提供了<strong>Assertions.assertTimeout()</strong> 为测试方法设置了超时时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;超时测试&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">timeoutTest</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//如果测试方法时间超过1s将会异常</span><br>    Assertions.assertTimeout(Duration.ofMillis(<span class="hljs-number">1000</span>), () -&gt; Thread.sleep(<span class="hljs-number">500</span>));<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6、快速失败"><a href="#6、快速失败" class="headerlink" title="6、快速失败"></a>6、快速失败</h2><p>通过 fail 方法直接使得测试失败</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-meta">@DisplayName(&quot;fail&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shouldFail</span><span class="hljs-params">()</span> </span>&#123;<br> fail(<span class="hljs-string">&quot;This should fail&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="4、前置条件（assumptions）"><a href="#4、前置条件（assumptions）" class="headerlink" title="4、前置条件（assumptions）"></a>4、前置条件（assumptions）</h1><p>JUnit 5 中的前置条件（<strong>assumptions【假设】</strong>）类似于断言，不同之处在于<strong>不满足的断言会使得测试方法失败</strong>，而不满足的<strong>前置条件只会使得测试方法的执行终止</strong>。前置条件可以看成是测试方法执行的前提，当该前提不满足时，就没有继续执行的必要。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DisplayName(&quot;前置条件&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AssumptionsTest</span> </span>&#123;<br> <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String environment = <span class="hljs-string">&quot;DEV&quot;</span>;<br> <br> <span class="hljs-meta">@Test</span><br> <span class="hljs-meta">@DisplayName(&quot;simple&quot;)</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">simpleAssume</span><span class="hljs-params">()</span> </span>&#123;<br>    assumeTrue(Objects.equals(<span class="hljs-keyword">this</span>.environment, <span class="hljs-string">&quot;DEV&quot;</span>));<br>    assumeFalse(() -&gt; Objects.equals(<span class="hljs-keyword">this</span>.environment, <span class="hljs-string">&quot;PROD&quot;</span>));<br> &#125;<br> <br> <span class="hljs-meta">@Test</span><br> <span class="hljs-meta">@DisplayName(&quot;assume then do&quot;)</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assumeThenDo</span><span class="hljs-params">()</span> </span>&#123;<br>    assumingThat(<br>       Objects.equals(<span class="hljs-keyword">this</span>.environment, <span class="hljs-string">&quot;DEV&quot;</span>),<br>       () -&gt; System.out.println(<span class="hljs-string">&quot;In DEV&quot;</span>)<br>    );<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>assumeTrue 和 assumFalse 确保给定的条件为 true 或 false，不满足条件会使得测试执行终止。assumingThat 的参数是表示条件的布尔值和对应的 Executable 接口的实现对象。只有条件满足时，Executable 对象才会被执行；当条件不满足时，测试执行并不会终止。</p>
<h1 id="5、嵌套测试"><a href="#5、嵌套测试" class="headerlink" title="5、嵌套测试"></a>5、嵌套测试</h1><p>JUnit 5 可以通过 Java 中的内部类和@Nested 注解实现嵌套测试，从而可以更好的把相关的测试方法组织在一起。在内部类中可以使用@BeforeEach 和@AfterEach 注解，而且嵌套的层次没有限制。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DisplayName(&quot;A stack&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestingAStackDemo</span> </span>&#123;<br><br>    Stack&lt;Object&gt; stack;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-meta">@DisplayName(&quot;is instantiated with new Stack()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isInstantiatedWithNew</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Nested</span><br>    <span class="hljs-meta">@DisplayName(&quot;when new&quot;)</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WhenNew</span> </span>&#123;<br><br>        <span class="hljs-meta">@BeforeEach</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">createNewStack</span><span class="hljs-params">()</span> </span>&#123;<br>            stack = <span class="hljs-keyword">new</span> Stack&lt;&gt;();<br>        &#125;<br><br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-meta">@DisplayName(&quot;is empty&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>            assertTrue(stack.isEmpty());<br>        &#125;<br><br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-meta">@DisplayName(&quot;throws EmptyStackException when popped&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwsExceptionWhenPopped</span><span class="hljs-params">()</span> </span>&#123;<br>            assertThrows(EmptyStackException.class, stack::pop);<br>        &#125;<br><br>        <span class="hljs-meta">@Test</span><br>        <span class="hljs-meta">@DisplayName(&quot;throws EmptyStackException when peeked&quot;)</span><br>        <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">throwsExceptionWhenPeeked</span><span class="hljs-params">()</span> </span>&#123;<br>            assertThrows(EmptyStackException.class, stack::peek);<br>        &#125;<br><br>        <span class="hljs-meta">@Nested</span><br>        <span class="hljs-meta">@DisplayName(&quot;after pushing an element&quot;)</span><br>        <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AfterPushing</span> </span>&#123;<br><br>            String anElement = <span class="hljs-string">&quot;an element&quot;</span>;<br><br>            <span class="hljs-meta">@BeforeEach</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pushAnElement</span><span class="hljs-params">()</span> </span>&#123;<br>                stack.push(anElement);<br>            &#125;<br><br>            <span class="hljs-meta">@Test</span><br>            <span class="hljs-meta">@DisplayName(&quot;it is no longer empty&quot;)</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">isNotEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>                assertFalse(stack.isEmpty());<br>            &#125;<br><br>            <span class="hljs-meta">@Test</span><br>            <span class="hljs-meta">@DisplayName(&quot;returns the element when popped and is empty&quot;)</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnElementWhenPopped</span><span class="hljs-params">()</span> </span>&#123;<br>                assertEquals(anElement, stack.pop());<br>                assertTrue(stack.isEmpty());<br>            &#125;<br><br>            <span class="hljs-meta">@Test</span><br>            <span class="hljs-meta">@DisplayName(&quot;returns the element when peeked but remains not empty&quot;)</span><br>            <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">returnElementWhenPeeked</span><span class="hljs-params">()</span> </span>&#123;<br>                assertEquals(anElement, stack.peek());<br>                assertFalse(stack.isEmpty());<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="6、参数化测试"><a href="#6、参数化测试" class="headerlink" title="6、参数化测试"></a>6、参数化测试</h1><p>参数化测试是JUnit5很重要的一个新特性，它使得用不同的参数多次运行测试成为了可能，也为我们的单元测试带来许多便利。</p>
<p>利用**@ValueSource**等注解，指定入参，我们将可以使用不同的参数进行多次单元测试，而不需要每新增一个参数就新增一个单元测试，省去了很多冗余代码。</p>
<p>**<br>**</p>
<p><strong>@ValueSource</strong>: 为参数化测试指定入参来源，支持八大基础类以及String类型,Class类型</p>
<p><strong>@NullSource</strong>: 表示为参数化测试提供一个null的入参</p>
<p><strong>@EnumSource</strong>: 表示为参数化测试提供一个枚举入参</p>
<p><strong>@CsvFileSource</strong>：表示读取指定CSV文件内容作为参数化测试入参</p>
<p><strong>@MethodSource</strong>：表示读取指定方法的返回值作为参数化测试入参(注意方法返回需要是一个流)</p>
<blockquote>
<p>当然如果参数化测试仅仅只能做到指定普通的入参还达不到让我觉得惊艳的地步。让我真正感到他的强大之处的地方在于他可以支持外部的各类入参。如:CSV,YML,JSON 文件甚至方法的返回值也可以作为入参。只需要去实现<strong>ArgumentsProvider</strong>接口，任何外部文件都可以作为它的入参。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ParameterizedTest</span><br><span class="hljs-meta">@ValueSource(strings = &#123;&quot;one&quot;, &quot;two&quot;, &quot;three&quot;&#125;)</span><br><span class="hljs-meta">@DisplayName(&quot;参数化测试1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parameterizedTest1</span><span class="hljs-params">(String string)</span> </span>&#123;<br>    System.out.println(string);<br>    Assertions.assertTrue(StringUtils.isNotBlank(string));<br>&#125;<br><br><br><span class="hljs-meta">@ParameterizedTest</span><br><span class="hljs-meta">@MethodSource(&quot;method&quot;)</span>    <span class="hljs-comment">//指定方法名</span><br><span class="hljs-meta">@DisplayName(&quot;方法来源参数&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWithExplicitLocalMethodSource</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    System.out.println(name);<br>    Assertions.assertNotNull(name);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">static</span> Stream&lt;String&gt; <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Stream.of(<span class="hljs-string">&quot;apple&quot;</span>, <span class="hljs-string">&quot;banana&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="7、迁移指南"><a href="#7、迁移指南" class="headerlink" title="7、迁移指南"></a>7、迁移指南</h1><p>在进行迁移的时候需要注意如下的变化：</p>
<ul>
<li>注解在 org.junit.jupiter.api 包中，断言在 org.junit.jupiter.api.Assertions 类中，前置条件在 org.junit.jupiter.api.Assumptions 类中。</li>
<li>把@Before 和@After 替换成@BeforeEach 和@AfterEach。</li>
<li>把@BeforeClass 和@AfterClass 替换成@BeforeAll 和@AfterAll。</li>
<li>把@Ignore 替换成@Disabled。</li>
<li>把@Category 替换成@Tag。</li>
<li>把@RunWith、@Rule 和@ClassRule 替换成@ExtendWith。</li>
</ul>
<h1 id="8、参考来源："><a href="#8、参考来源：" class="headerlink" title="8、参考来源："></a>8、参考来源：</h1><p><a href="https://www.yuque.com/atguigu/springboot/ksndgx">https://www.yuque.com/atguigu/springboot/ksndgx</a></p>
]]></content>
      <categories>
        <category>单元测试</category>
      </categories>
      <tags>
        <tag>单元测试</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis整合Spring</title>
    <url>/2021/05/15/myBatis%20%E7%AC%AC%E4%B8%89%E6%96%B9%E6%A1%86%E6%9E%B6%E9%9B%86%E6%88%90/</url>
    <content><![CDATA[<ol>
<li>spring 集成myBatis</li>
<li>动态化SQL与脚本解析器</li>
</ol>
<h2 id="一、spring-集成myBatis"><a href="#一、spring-集成myBatis" class="headerlink" title="一、spring 集成myBatis"></a><strong>一、spring 集成myBatis</strong></h2><hr>
<h3 id="核心使用："><a href="#核心使用：" class="headerlink" title="核心使用："></a><strong>核心使用：</strong></h3><p>基础集成使用：</p>
<p>1、配置 SqlSessionFactoryBean</p>
<p>2、配置 MapperFactoryBean</p>
<p>3、获取mapper 对像执行业务方法</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dateSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">constructor-arg</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dateSource&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userMapper&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.mapper.MapperFactoryBean&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperInterface&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.study.mapper.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>对像说明：</p>
<h3 id="FactoryBean："><a href="#FactoryBean：" class="headerlink" title="FactoryBean："></a>FactoryBean：</h3><p>工厂Bean 用于 自定义生成Bean对像，当在ioc 中配置FactoryBean 的实例时，最终通过bean id 对应的是FactoryBean.getObject()实例，而非FactoryBean 实例本身</p>
<h3 id="SqlSessionFactoryBean："><a href="#SqlSessionFactoryBean：" class="headerlink" title="SqlSessionFactoryBean："></a>SqlSessionFactoryBean：</h3><p>生成SqlSessionFactory 实例，该为单例对像，作用于整个应用生命周期。常用属性如下：</p>
<ul>
<li>dataSource：数据源(必填)</li>
<li>configLocation：指定mybatis-config.xml 的内容，但其设置的<dataSource> <properties> <environments> 将会失效(选填)</environments></properties></dataSource></li>
<li>mapperLocations：指定mapper.xml 的路径，相当于mybatis-config.xml 中<mappers> 元素配置，(选填)</mappers></li>
</ul>
<h3 id="MapperFactoryBean："><a href="#MapperFactoryBean：" class="headerlink" title="MapperFactoryBean："></a>MapperFactoryBean：</h3><p>生成对应的Mapper对像，通常为单例，作用于整个应用生命周期。常用属性如下：</p>
<ul>
<li>mapperInterface：mapper 接口      (必填)</li>
<li>sqlSessionFactory：会话工厂实例 引用 (必填)</li>
</ul>
<h3 id="关于Mapper-单例情况下是否存在线程安全的问题"><a href="#关于Mapper-单例情况下是否存在线程安全的问题" class="headerlink" title="关于Mapper 单例情况下是否存在线程安全的问题?"></a>关于Mapper 单例情况下是否存在线程安全的问题?</h3><p>在原生的myBatis 使用中mapper 对像的生命期是与SqlSession同步的，不会存在线程安全问题，现在单例的mapper 是如何解决线程安全的问题的呢？</p>
<h3 id="核心流程解析："><a href="#核心流程解析：" class="headerlink" title="核心流程解析："></a><strong>核心流程解析：</strong></h3><p>SQL session 集成结构：</p>
<p>![image1](/images/myBatis 第三方框架集成/image1.png)</p>
<h4 id="初始化流程"><a href="#初始化流程" class="headerlink" title="初始化流程"></a>初始化流程</h4><h5 id="创建会话模板-SqlSessionTemplate"><a href="#创建会话模板-SqlSessionTemplate" class="headerlink" title="创建会话模板 SqlSessionTemplate"></a>创建会话模板 SqlSessionTemplate</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.mybatis.spring.mapper.MapperFactoryBean#MapperFactoryBean()<br>&gt; org.mybatis.spring.support.SqlSessionDaoSupport#setSqlSessionFactory<br>&gt; org.mybatis.spring.SqlSessionTemplate#SqlSessionTemplate()<br>&gt;org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor <br>    <span class="hljs-comment">//sqlSessionProxy被SqlSessionInterceptor代理拦截</span><br></code></pre></td></tr></table></figure>

<h5 id="创建接口"><a href="#创建接口" class="headerlink" title="创建接口"></a>创建接口</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.mybatis.spring.mapper.MapperFactoryBean#getObject<br>org.mybatis.spring.SqlSessionTemplate#getMapper<br>org.apache.ibatis.session.Configuration#getMapper<br>org.apache.ibatis.binding.MapperProxyFactory#newInstance(org.apache.ibatis.binding.MapperProxy&lt;T&gt;) //最终获取到的userMapper是已经代理过的<br></code></pre></td></tr></table></figure>



<h5 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h5><figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">com.tuling.mybatis.dao.UserMapper#selectByid<br>org.apache.ibatis.binding.MapperProxy#invoke<br>org.mybatis.spring.SqlSessionTemplate#selectOne(java.lang.String)<br>org.mybatis.spring.SqlSessionTemplate#sqlSessionProxy#selectOne(java.lang.String)<br>org.mybatis.spring.SqlSessionTemplate.SqlSessionInterceptor#invoke<br>   <span class="hljs-comment">//重新获取sqlsession</span><br>     SqlSession sqlSession = getSqlSession(<br>          SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory,<br>          SqlSessionTemplate.<span class="hljs-keyword">this</span>.executorType,<br>          SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator);<br>org.mybatis.spring.SqlSessionUtils#getSqlSession()<br>org.apache.ibatis.session.SqlSessionFactory#openSession()<br>org.apache.ibatis.session.defaults.DefaultSqlSession#selectOne()<br></code></pre></td></tr></table></figure>

<p>每次查询都会创建一个新的 SqlSession 会话，一级缓存还会生效吗？</p>
<p>通过前几次课我们了解到 一级缓存的条件是必须相同的会话.</p>
<p><strong>所以缓存通过和spring 集成之后就不会生效了。除非使用spring 事物 这时就不会在重新创建会话。</strong></p>
<h3 id="事务使用"><a href="#事务使用" class="headerlink" title="事务使用 :"></a><strong>事务使用 :</strong></h3><p>spring 事物没有针对myBatis的配置，都是一些常规事物配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加事物配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-comment">&lt;!--事物注解配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>添加事物注解：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        User user = userMapper.selectById(id);<br>        User user1 = userMapper.selectById(id);<br><br>        System.out.println(user);<br>        System.out.println(user1);<br><br>    &#125;<br></code></pre></td></tr></table></figure>



<p>执行测试发现 当调用selectById方法时两次查询不在重复创建 sqlSession。而是共用一个直到selectById方法结束。</p>
<h5 id="事务与SqlSession-集成原理："><a href="#事务与SqlSession-集成原理：" class="headerlink" title="事务与SqlSession 集成原理："></a>事务与SqlSession 集成原理：</h5><p>其原理前面讲查询流程时有所涉及。每次执行SQL操作前都会通过 getSqlSession 来获取会话。其主要逻辑是</p>
<p>​     如果当前线程存在事物，并且存在相关会话，就从ThreadLocal中取出 。如果没就从创建一个 SqlSession 并存储到ThreadLocal 当中，共下次查询使用。</p>
<p>相关源码：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.mybatis.spring.SqlSessionUtils#getSqlSession()<br>org.springframework.transaction.support.TransactionSynchronizationManager#getResource<br>org.mybatis.spring.SqlSessionUtils#sessionHolder<br>org.apache.ibatis.session.SqlSessionFactory#openSession()<br>org.mybatis.spring.SqlSessionUtils#registerSessionHolder<br>org.springframework.transaction.support.TransactionSynchronizationManager#isSynchronizationActive<br>org.springframework.transaction.support.TransactionSynchronizationManager#bindResource<br></code></pre></td></tr></table></figure>

<h3 id="简化Mapper-配置"><a href="#简化Mapper-配置" class="headerlink" title="简化Mapper 配置"></a><strong>简化Mapper 配置</strong></h3><p>如果每个mapper 接口都配置<em>MapperFactoryBean</em>相当麻烦 可以通过 如下配置进行自动扫描</p>
<p>&lt;mybatis:scan base-package=”com.tuling.mybatis.dao”/&gt;</p>
<p>其与 spring bean 注解扫描机制类似，所以得加上注解扫描开关的配置</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:annotation-config</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="重点问题："><a href="#重点问题：" class="headerlink" title="重点问题："></a>重点问题：</h2><h3 id="MyBatis-的多级缓存机制"><a href="#MyBatis-的多级缓存机制" class="headerlink" title="MyBatis 的多级缓存机制"></a>MyBatis 的多级缓存机制</h3><ol>
<li><strong>一级缓存（Local Cache）</strong>：<ul>
<li>一级缓存是基于 SqlSession 的缓存，在同一个 SqlSession 中执行的查询会将结果缓存起来。</li>
<li>一级缓存是<strong>默认开启</strong>的，且无法关闭，它对于减少重复的查询操作非常有效。</li>
<li>一级缓存的作用范围是当前的 SqlSession，当 SqlSession 关闭时，一级缓存也会被清空。</li>
</ul>
</li>
<li><strong>二级缓存（Global Cache）</strong>：<ul>
<li>二级缓存是基于 Mapper 的缓存，多个 SqlSession 共享同一个 Mapper 的缓存。</li>
<li>二级缓存可以跨 SqlSession 和事务，因此可以在不同的 SqlSession 中共享缓存。</li>
<li>二级缓存是<strong>默认关闭</strong>的，需要手动配置开启，并且需要注意缓存的有效性和并发访问的问题。</li>
<li>二级缓存的配置是在 Mapper.xml 文件中进行的，在 Mapper 接口中添加 `` 标签并配置相应的属性。</li>
</ul>
</li>
<li><strong>刷新失效（Flush Cache）</strong>：<ul>
<li>MyBatis 提供了在增删改操作时自动删除缓存的功能。</li>
<li>当执行了增删改操作后，MyBatis 会自动清空一级缓存和二级缓存中与该操作相关的缓存数据，保证数据的一致性。</li>
</ul>
</li>
</ol>
<p>需要注意的是，虽然多级缓存可以有效提高性能，但也存在一些需要注意的问题：</p>
<ul>
<li>缓存的有效性：缓存中的数据应该与数据库中的数据保持一致，需要注意缓存的更新机制。</li>
<li>缓存的并发访问：多个线程同时访问缓存时可能会出现并发问题，需要采取措施保证缓存的正确性。</li>
<li>缓存的大小和清理策略：需要根据实际情况配置合适的缓存大小和清理策略，避免内存溢出等问题。</li>
</ul>
<h3 id="MyBatis-整合Spring一二级缓存的使用问题"><a href="#MyBatis-整合Spring一二级缓存的使用问题" class="headerlink" title="MyBatis 整合Spring一二级缓存的使用问题"></a>MyBatis 整合Spring一二级缓存的使用问题</h3><h4 id="一级缓存："><a href="#一级缓存：" class="headerlink" title="一级缓存："></a>一级缓存：</h4><p>如果未开启事务，线程安全的SqlSessionTemplate在每次需要 SqlSession 时创建新的实例，并且每次使用之后都关闭。<strong>线程安全，但无法使用一级缓存，缓存失效；</strong></p>
<p>如果开启事务，并且存在相关会话，就从ThreadLocal中取出 。如果没就从创建一个 SqlSession 并存储到ThreadLocal 当中，共下次查询使用。能够使用到一级缓存。</p>
<p>二级缓存：</p>
<p>整合Spring后，mapper是单例的，多个线程共享二级缓存，因此存在相同的复杂线程安全问题。分布式时代，不会使用二级缓存。</p>
]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>vmware虚拟机</title>
    <url>/2024/11/07/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h1 id="VMvare-Workstation"><a href="#VMvare-Workstation" class="headerlink" title="VMvare Workstation"></a>VMvare Workstation</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    vmware workstation是常用的虚拟机软件，可用来在window操作系统上安装Linux，模拟linux操作系统，继而基于linux安装日常工作学习中的各种组件，如docker、redis、mysql等等用途。</p>
<p>​    主要是免费，不用花钱就能搭建自己的环境。。</p>
<h2 id="VM三种网络工作模式"><a href="#VM三种网络工作模式" class="headerlink" title="VM三种网络工作模式"></a>VM三种网络工作模式</h2><p><strong>Bridged（桥接模式）</strong>、</p>
<p><strong>NAT（网络地址转换模式）</strong>、</p>
<p><strong>Host-Only（仅主机模式）</strong></p>
<p>​    打开vmware虚拟机，我们可以在选项栏的“编辑”下的“虚拟网络编辑器”中看到VMnet0（桥接模式）、VMnet1（仅主机模式）、VMnet8（NAT模式），那么这些都是有什么作用呢？其实，我们现在看到的</p>
<p>​    VMnet0表示的是用于桥接模式下的虚拟交换机；<br>​    VMnet1表示的是用于仅主机模式下的虚拟交换机；<br>​    VMnet8表示的是用于NAT模式下的虚拟交换机</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107225733583.png" alt="image-20241107225733583"></p>
<p>​    并且在主机上对应的有VMware Network Adapter VMnet1和VMware Network Adapter VMnet8两块虚拟网卡，它们分别作用于仅主机模式与NAT模式下。在“网络连接”中我们可以看到这两块虚拟网卡，如果将这两块卸载了，可以在vmware的“编辑”下的“虚拟网络编辑器”中点击“还原默认设置”，可重新将虚拟网卡还原。</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107225924189.png" alt="image-20241107225924189"></p>
<h2 id="Bridged（桥接模式）"><a href="#Bridged（桥接模式）" class="headerlink" title="Bridged（桥接模式）"></a>Bridged（桥接模式）</h2><p>​    什么是桥接模式？桥接模式就是将主机网卡与虚拟机虚拟的网卡利用虚拟网桥进行通信。在桥接的作用下，类似于把物理主机虚拟为一个交换机，所有桥接设置的虚拟机连接到这个交换机的一个接口上，物理主机也同样插在这个交换机当中，所以所有桥接下的网卡与网卡都是交换模式的，相互可以访问而不干扰。在桥接模式下，虚拟机ip地址需要与主机在同一个网段。</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/20160408184441387" alt="NAT模式"></p>
<p><strong>正常来说，如果宿主机使用的电脑wifi，使用桥接模式，虚拟机ip配置无法固定，故而我们一般使用NAT（地址转换模式）网络模式</strong></p>
<h2 id="NAT（地址转换模式）"><a href="#NAT（地址转换模式）" class="headerlink" title="NAT（地址转换模式）"></a>NAT（地址转换模式）</h2><p>​    NAT模式借助虚拟NAT设备和虚拟DHCP服务器，使得虚拟机可以联网。在NAT模式中，主机网卡直接与虚拟NAT设备相连，然后虚拟NAT设备与虚拟DHCP服务器一起连接在虚拟交换机VMnet8上，这样就实现了虚拟机联网</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/20160408185234834" alt="Host-Only模式"></p>
<h2 id="Host-Only（仅主机模式）"><a href="#Host-Only（仅主机模式）" class="headerlink" title="Host-Only（仅主机模式）"></a>Host-Only（仅主机模式）</h2><p>Host-Only模式其实就是NAT模式去除了虚拟NAT设备，然后使用VMware Network Adapter VMnet1虚拟网卡连接VMnet1虚拟交换机来与虚拟机通信的，Host-Only模式将虚拟机与外网隔开，使得虚拟机成为一个独立的系统，只与主机相互通讯。其网络结构如下图所示：</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/20160408185234834-1730992166779" alt="Host-Only模式"></p>
<h2 id="NAT模式搭建3台固定ip的虚拟机"><a href="#NAT模式搭建3台固定ip的虚拟机" class="headerlink" title="NAT模式搭建3台固定ip的虚拟机"></a>NAT模式搭建3台固定ip的虚拟机</h2><p><strong>重点是宿主机的网络配置、vmware虚拟机网络配置、linux虚拟机网卡配置信息保持一致</strong></p>
<p>1、设置本地VMware Virtual Ethernet Adapter for VMnet8适配器的网络配置</p>
<p>​    <strong>宿主机本机IP</strong></p>
<p>​    <strong>子网掩码</strong></p>
<p>​    <strong>默认网关</strong></p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107231139881.png" alt="image-20241107231139881"></p>
<p>2、设置VMware 软件的网络配置</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107231724518.png" alt="image-20241107231724518"></p>
<p>网关ip需要与上面的默认网关保持一致，子网ip、掩码也要相同</p>
<p>3、新建虚拟机，设置网卡网络配置信息</p>
<p>vim /etc/sysconfig/network-scripts/ifcfg-ens33</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107232144868.png" alt="image-20241107232144868"></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">TYPE=<span class="hljs-string">&quot;Ethernet&quot;</span><br>PROXY_METHOD=<span class="hljs-string">&quot;none&quot;</span><br>BROWSER_ONLY=<span class="hljs-string">&quot;no&quot;</span><br>BOOTPROTO=<span class="hljs-string">&quot;static&quot;</span> //开启静态ip模式<br>DEFROUTE=<span class="hljs-string">&quot;yes&quot;</span><br>IPV4_FAILURE_FATAL=<span class="hljs-string">&quot;no&quot;</span><br>IPV6INIT=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_AUTOCONF=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_DEFROUTE=<span class="hljs-string">&quot;yes&quot;</span><br>IPV6_FAILURE_FATAL=<span class="hljs-string">&quot;no&quot;</span><br>IPV6_ADDR_GEN_MODE=<span class="hljs-string">&quot;stable-privacy&quot;</span><br>NAME=<span class="hljs-string">&quot;ens33&quot;</span><br><span class="hljs-comment">#UUID=&quot;f8e1b7b3-4aaf-487a-9c91-a883fe938397&quot;</span><br>DEVICE=<span class="hljs-string">&quot;ens33&quot;</span><br>ONBOOT=<span class="hljs-string">&quot;yes&quot;</span> //是否激活网卡，激活后就可以连接到外网了<br>IPADDR=192.168.136.3 // linux机器的固定ip，最好不要与网关ip冲突<br>NETMASK=255.255.255.0 // 子网掩码<br>GATEWAY=192.168.136.5 // 子网网关ip<br>DNS1=114.114.114.114<br><span class="hljs-comment">#HWADDR=&quot;00:0c:29:22:d0:42&quot;</span><br></code></pre></td></tr></table></figure>

<p>保存后通过 systemctl restart network 重新加载网卡</p>
<p>1、ipconfig查看虚拟机ip</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107232731729.png" alt="image-20241107232731729"></p>
<p>2、虚拟机ping通宿主机</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107232831191.png" alt="image-20241107232831191"></p>
<p>3、虚拟机ping通外网</p>
<p><img src="images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107232858669.png" alt="image-20241107232858669"></p>
<p>4、宿主机ping通虚拟机</p>
<p><img src="/images/vmware%E8%99%9A%E6%8B%9F%E6%9C%BA/image-20241107233010378.png" alt="image-20241107233010378"></p>
<p>至此已经搭建成功一台固定ip的虚拟机，且和宿主机网络互通，且能上网，再重复搭建192.168.136.2，192.168.136.1即可。</p>
<h2 id="YUM换源"><a href="#YUM换源" class="headerlink" title="YUM换源"></a>YUM换源</h2><p><a href="https://blog.csdn.net/2301_80687933/article/details/143675579">https://blog.csdn.net/2301_80687933/article/details/143675579</a></p>
<p>yum下载报错：Could not retrieve mirrorlist <a href="http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock">http://mirrorlist.centos.org/?release=7&amp;arch=x86_64&amp;repo=os&amp;infra=stock</a> </p>
<p>原因：centos7和centos8 均在 2024年6月30号停止维护</p>
<p>解决：只要修改默认镜像地址即可。按照如下步骤设置镜像后即可重新下载yum了</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">mv /etc/yum.repos.d/CentOS-Base.repo /etc/yum.repos.d/CentOS-Base.repo.backup<br>curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo<br>yum clean all<br>yum makecache<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>vmware</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>vmware</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-MQ-04RocketMQ特性详解&amp;场景介绍</title>
    <url>/2022/06/08/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-04RocketMQ%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&amp;%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="RocketMQ特性详解-amp-场景介绍"><a href="#RocketMQ特性详解-amp-场景介绍" class="headerlink" title="RocketMQ特性详解&amp;场景介绍"></a>RocketMQ特性详解&amp;场景介绍</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h3><p>RocketMQ主要由 Producer、Broker、Consumer 三部分组成，其中Producer 负责 生产消息，Consumer 负责消费消息，Broker 负责存储消息。 </p>
<h3 id="消息生产者-producer"><a href="#消息生产者-producer" class="headerlink" title="消息生产者(producer)"></a>消息生产者(producer)</h3><p>负责生产消息，一般由业务系统负责生产消息。一个消息生产者会把业务应用系统里产 生的消息发送到broker服务器。RocketMQ提供多种发送方式，同步发送、异步发送、顺序发送、单向发送。同步和异步方式均需要Broker返回确认信息，单向发送不需要。</p>
<h3 id="消息消费者（Consumer）"><a href="#消息消费者（Consumer）" class="headerlink" title="消息消费者（Consumer）"></a>消息消费者（Consumer）</h3><p>负责消费消息，一般是后台系统负责异步消费。一个消息消费者会从Broker服务器拉 取消息、并将其提供给应用程序。从用户应用的角度而言提供了两种消费形式：<strong>拉取式消费</strong> (pull consumer)、<strong>推动式消费</strong>(push consumer)。</p>
<h3 id="主题（Topic）"><a href="#主题（Topic）" class="headerlink" title="主题（Topic）"></a>主题（Topic）</h3><p>表示一类消息的集合，每个主题包含若干条消息，每条消息只能属于一个主题，是 RocketMQ进行消息订阅的基本单位。</p>
<h3 id="代理服务器（Broker-Server）"><a href="#代理服务器（Broker-Server）" class="headerlink" title="代理服务器（Broker Server）"></a>代理服务器（Broker Server）</h3><p>消息中转角色，负责存储消息、转发消息。代理服务器在RocketMQ系统中负责接收从生产者发送来的消息并存储、同时为消费者的拉取请求作准备。代理服务器也存储消息相关的元数据，包括消费者组、消费进度偏移和主题和队列消息等。</p>
<h3 id="名字服务（Name-Server）"><a href="#名字服务（Name-Server）" class="headerlink" title="名字服务（Name Server）"></a>名字服务（Name Server）</h3><p>名称服务充当路由消息的提供者。生产者或消费者能够通过名字服务查找各主题相应的 Broker IP列表。多个Namesrv实例组成集群，但相互独立，没有信息交换。</p>
<p>NameServer是一个非常简单的Topic路由注册中心，其角色类似Dubbo中的 zookeeper，支持Broker的动态注册与发现。主要包括两个功能：</p>
<p>​     <strong>Broker管理</strong>，NameServer接受Broker集群的注册信息并且保存下来作为路由信息的基本数据。然后提供心跳检测机制，检查Broker是否还存活； </p>
<p>​    <strong>路由信息管理</strong>，每个NameServer将保存关于Broker集群的整个路由信息和用于客户端 查询的队列信息。然后Producer和Conumser通过NameServer就可以知道整个Broker集群的路由信息，从而进行消息的投递和消费。NameServer通常也是集群的方式部署，各实例间相互不进行信息通讯。Broker是向每一台NameServer注册自己的路由信息，所以每一 个NameServer实例上面都保存一份完整的路由信息。当某个NameServer因某种原因下线 了，Broker仍然可以向其它NameServer同步其路由信息，Producer,Consumer仍然可以 动态感知Broker的路由的信息。</p>
<h3 id="拉取式消费（Pull-Consumer）"><a href="#拉取式消费（Pull-Consumer）" class="headerlink" title="拉取式消费（Pull Consumer）"></a>拉取式消费（Pull Consumer）</h3><p>Consumer消费的一种类型，应用通常主动调用Consumer的拉消息方法从Broker服务 器拉消息、主动权由应用控制。一旦获取了批量消息，应用就会启动消费过程。 </p>
<h3 id="推动式消费（Push-Consumer）"><a href="#推动式消费（Push-Consumer）" class="headerlink" title="推动式消费（Push Consumer）"></a>推动式消费（Push Consumer）</h3><p> Consumer消费的一种类型，该模式下Broker收到数据后会主动推送给消费端，**==该消费模式一般实时性较高==**</p>
<h3 id="生产者组（Producer-Group）"><a href="#生产者组（Producer-Group）" class="headerlink" title="生产者组（Producer Group）"></a>生产者组（Producer Group）</h3><p>同一类Producer的集合，这类Producer发送同一类消息且发送逻辑一致。如果发送的是事物消息且原始生产者在发送之后崩溃，则Broker服务器会联系同一生产者组的其他生 产者实例以提交或回溯消费</p>
<h3 id="消费者组（Consumer-Group）"><a href="#消费者组（Consumer-Group）" class="headerlink" title="消费者组（Consumer Group）"></a>消费者组（Consumer Group）</h3><p>同一类Consumer的集合，这类Consumer通常消费同一类消息且消费逻辑一致。消费者组使得在消息消费方面，实现负载均衡和容错的目标变得非常容易。要注意的是，消费者组的消费者实例必须订阅完全相同的Topic。<strong>RocketMQ 支持两种消息模式：集群消费 （Clustering）和广播消费（Broadcasting）。</strong></p>
<h3 id="集群消费（Clustering）"><a href="#集群消费（Clustering）" class="headerlink" title="集群消费（Clustering）"></a>集群消费（Clustering）</h3><p>集群消费模式下,相同Consumer Group的每个Consumer实例平均分摊消息。</p>
<h3 id="广播消费（Broadcasting）"><a href="#广播消费（Broadcasting）" class="headerlink" title="广播消费（Broadcasting）"></a>广播消费（Broadcasting）</h3><p>广播消费模式下，相同Consumer Group的每个Consumer实例都接收全量的消息。</p>
<h3 id="普通顺序消息（Normal-Ordered-Message）"><a href="#普通顺序消息（Normal-Ordered-Message）" class="headerlink" title="普通顺序消息（Normal Ordered Message）"></a>普通顺序消息（Normal Ordered Message）</h3><p>普通顺序消费模式下，消费者通过同一个消费队列收到的消息是有顺序的，不同消息队 列收到的消息则可能是无顺序的。 </p>
<h3 id="严格顺序消息（Strictly-Ordered-Message）"><a href="#严格顺序消息（Strictly-Ordered-Message）" class="headerlink" title="严格顺序消息（Strictly Ordered Message）"></a>严格顺序消息（Strictly Ordered Message）</h3><p>严格顺序消息模式下，消费者收到的所有消息均是有顺序的。</p>
<h3 id="消息（Message）"><a href="#消息（Message）" class="headerlink" title="消息（Message）"></a>消息（Message）</h3><p>消息系统所传输信息的物理载体，生产和消费数据的最小单位，每条消息必须属于一个 主题。RocketMQ中每个消息拥有唯一的Message ID，且可以携带具有业务标识的Key。 ==<strong>系统提供了通过Message ID和Key查询消息的功能。</strong>==</p>
<h3 id="标签（Tag）"><a href="#标签（Tag）" class="headerlink" title="标签（Tag）"></a>标签（Tag）</h3><p><strong>为消息设置的标志，用于同一主题下区分不同类型的消息</strong>。来自同一业务单元的消息， 可以根据不同业务目的在同一主题下设置不同标签。标签能够有效地保持代码的清晰度和连 贯性，并优化RocketMQ提供的查询系统。消费者可以根据Tag实现对不同子主题的不同消 费逻辑，实现更好的扩展性</p>
<h2 id="RabbitMQ整体架构"><a href="#RabbitMQ整体架构" class="headerlink" title="RabbitMQ整体架构"></a>RabbitMQ整体架构</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-04RocketMQ%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220608221627118.png" alt="image-20220608221627118"></p>
<h2 id="Rocketmq特性"><a href="#Rocketmq特性" class="headerlink" title="Rocketmq特性"></a>Rocketmq特性</h2><h3 id="Producer端"><a href="#Producer端" class="headerlink" title="Producer端"></a>Producer端</h3><h4 id="发送方式"><a href="#发送方式" class="headerlink" title="发送方式"></a>发送方式</h4><p><strong>Sync</strong>：同步的发送方式，会等待发送结果后才返回 </p>
<p><strong>Async</strong>：异步的发送方式，发送完后，立刻返回。Client 在拿到 Broker 的响应结果后，会 回调指定的 callback. 这个 API 也可以指定 Timeout，不指定也是默认的 3000ms. </p>
<p><strong>Oneway</strong>：单向发送，比较简单，发出去后，什么都不管直接返回。</p>
<h4 id="发送结果"><a href="#发送结果" class="headerlink" title="发送结果"></a>发送结果</h4><p>class：org.apache.rocketmq.client.producer.SendStatus </p>
<p><strong>SEND_OK</strong> 消息发送成功。要注意的是消息发送成功也不意味着它是可靠的。要确保不会丢失任何 消息，还应启用同步Master服务器或同步刷盘，即SYNC_MASTER或SYNC_FLUSH。、</p>
<p><strong>FLUSH_DISK_TIMEOUT</strong> 消息发送成功但是服务器刷盘超时。此时消息已经进入服务器队列（内存），只有服务 器宕机，消息才会丢失。消息存储配置参数中可以设置刷盘方式和同步刷盘时间长度，如果 Broker服务器设置了刷盘方式为同步刷盘，即FlushDiskType=SYNC_FLUSH（默认为异步<br>刷盘方式），当Broker服务器未在同步刷盘时间内（默认为5s）完成刷盘，则将返回该状 态——刷盘超时。 </p>
<p><strong>FLUSH_SLAVE_TIMEOUT</strong> 消息发送成功，但是服务器同步到Slave时超时。此时消息已经进入服务器队列，只有 服务器宕机，消息才会丢失。如果Broker服务器的角色是同步Master，即 SYNC_MASTER（默认是异步Master即ASYNC_MASTER），并且从Broker服务器未在同 步刷盘时间（默认为5秒）内完成与主服务器的同步，则将返回该状态——数据同步到 Slave服务器超时。 </p>
<p><strong>SLAVE_NOT_AVAILABLE</strong> 消息发送成功，但是此时Slave不可用。如果Broker服务器的角色是同步Master，即 SYNC_MASTER（默认是异步Master服务器即ASYNC_MASTER），但没有配置slave Broker服务器，则将返回该状态——无Slave服务器可用。</p>
<h4 id="顺序消息"><a href="#顺序消息" class="headerlink" title="顺序消息"></a>顺序消息</h4><p>​    消息有序指的是可以按照消息的发送顺序来消费(FIFO)。RocketMQ可以严格的保证消 息有序，<strong>可以分为==分区有序或者全局有序==。</strong></p>
<p>​    顺序消费的原理解析，在默认的情况下消息发送会采取Round Robin轮询方式把消息发送到不同的queue(分区队列)；而消费消息的时候从多个queue上拉取消息，这种情况发送和消费是不能保证顺序。<strong>但是如果控制发送的顺序消息只依次发送到同一个queue中，消费的时候只从这个queue上依次拉取，则就保证了顺序。当发送和消费参与的queue只有一 个，则是全局有序；如果多个queue参与，则为分区有序，即相对每个queue，消息都是有序的。</strong>下面用订单进行分区有序的示例。一个订单的顺序流程是：创建、付款、推送、完成。 订单号相同的消息会被先后发送到同一个队列中，消费时，同一个OrderId获取到的肯定是 同一个队列。</p>
<h4 id="消息状态"><a href="#消息状态" class="headerlink" title="消息状态"></a>消息状态</h4><p>org.apache.rocketmq.client.consumer.listener.ConsumeOrderlyStatus </p>
<p>消费成功 SUCCESS </p>
<p>不能跳过消息，等待一下 SUSPEND_CURRENT_QUEUE_A_MOMENT </p>
<h4 id="延时消息"><a href="#延时消息" class="headerlink" title="延时消息"></a>延时消息</h4><p>定时消息是指消息发到 Broker 后，不能立刻被 Consumer 消费，要到特定的时间点 或者等待特定的时间后才能被消费。 使用场景：如电商里，提交了一个订单就可以发送一个延时消息，1h后去检查这个订单的 状态，如果还是未付款就取消订单释放库存。</p>
<p>延迟级别 </p>
<p>当前支持的延迟时间 </p>
<p>1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h </p>
<p>现在RocketMq并不支持任意时间的延时，需要设置几个固定的延时等级，从1s到2h 分别对应着等级1到18 消息消费失败会进入延时消息队列，消息发送时间与设置的延时等级和重试次数有关。</p>
<h4 id="批量消息"><a href="#批量消息" class="headerlink" title="批量消息"></a>批量消息</h4><p>批量发送消息能显著提高传递小消息的性能。限制是这些批量消息应该有相同的 topic，相同的waitStoreMsgOK，而且不能是延时消息。此外，这一批消息的总大小不应 超过4MB。rocketmq建议每次批量消息大小大概在1MB。 当消息大小超过4MB时，需要将消息进行分割</p>
<h4 id="过滤消息"><a href="#过滤消息" class="headerlink" title="过滤消息"></a>过滤消息</h4><p>大多数情况下，可以通过TAG来选择您想要的消息</p>
<h4 id="事务消息"><a href="#事务消息" class="headerlink" title="事务消息"></a>事务消息</h4><p>​    <strong>事务消息</strong>：消息队列 MQ 提供类似XA的<strong>分布式事务功能</strong>，通过消息队列 MQ 事务消息能达到分布式事务的最终一致。 </p>
<p>​    <strong>半事务消息</strong>：暂不能投递的消息，发送方已经成功地将消息发送到了消息队列 MQ 服务端，但是服务端未收到生产者对该消息的二次确认，此时该消息被标记 成“暂不能投递”状态，处于该种状态下的消息即半事务消息。 </p>
<p>​    <strong>消息回查</strong>：由于网络闪断、生产者应用重启等原因，导致某条事务消息的二次确 认丢失，消息队列 MQ 服务端通过扫描发现某条消息长期处于“半事务消息”时，需要主动向消息生产者询问该消息的最终状态（Commit 或是 Rollback），该询问过程即消息回查。 场景通过购物车进行下单的流程中，用户入口在购物车系统，交易下单入口在交易系统，两 个系统之间的数据需要保持最终一致，这时可以通过事务消息进行处理。交易系统下单之 后，发送一条交易下单的消息到消息队列 MQ，购物车系统订阅消息队列 MQ 的交易下单消 息，做相应的业务处理，更新购物车数据。 消息状态</p>
<p><strong>场景：</strong>通过购物车进行下单的流程中，用户入口在购物车系统，交易下单入口在交易系统，两 个系统之间的数据需要保持最终一致，这时可以通过事务消息进行处理。交易系统下单之 后，发送一条交易下单的消息到消息队列 MQ，购物车系统订阅消息队列 MQ 的交易下单消 息，做相应的业务处理，更新购物车数据。</p>
<p><strong>交互流程</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-04RocketMQ%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220608224559503.png" alt="image-20220608224559503"></p>
<p><strong>事务消息的限制：</strong></p>
<p>1、事务消息不支持延时消息和批量消息。 </p>
<p>2、为了避免单个消息被检查太多次而导致半队列消息累积，我们默认将单个消息的检查次 数限制为 15 次，但是用户可以通过 Broker 配置文件的 transactionCheckMax参数来修改此限制。如果已经检查某条消息超过 N 次的话（ N = transactionCheckMax ） 则 Broker将丢弃此消息，并在默认情况下同时打印错误日志。用户可以通过重写 AbstractTransactio nCheckListener 类来修改这个行为。 </p>
<p>3、事务消息将在 Broker 配置文件中的参数 transactionMsgTimeout 这样的特定时间长度之后被检查。当发送事务消息时，用户还可以通过设置用户属性 CHECK_IMMUNITY_TIME_I N_SECONDS 来改变这个限制，该参数优先于 transactionMsgTimeout 参数。</p>
<p>4、事务性消息可能不止一次被检查或消费。 </p>
<p>5、提交给用户的目标主题消息可能会失败，目前这依日志的记录而定。它的高可用性通过RocketMQ 本身的高可用性机制来保证，如果希望确保事务消息不丢失、并且事务完整性得到保证，建议使用同步的双重写入机制。 </p>
<p>6、事务消息的生产者 ID 不能与其他类型消息的生产者 ID 共享。与其他类型的消息不同，事务消息允许反向查询、MQ服务器能通过它们的生产者 ID 查询到消费者。</p>
<h3 id="Consumer端"><a href="#Consumer端" class="headerlink" title="Consumer端"></a>Consumer端</h3><h4 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h4><p> consumer有两种消费模型： </p>
<p> 1、广播消费，相同Consumer Group的每个Consumer实例都接收全量的消息 </p>
<p> org.apache.rocketmq.common.protocol.heartbeat.MessageModel#BROADCASTING </p>
<p> 2、集群消费,相同Consumer Group的每个Consumer实例平均分摊消息 </p>
<p> org.apache.rocketmq.common.protocol.heartbeat.MessageModel#CLUSTERING</p>
<h4 id="消费点位"><a href="#消费点位" class="headerlink" title="消费点位"></a>消费点位</h4><p> 当建立一个新的消费者组时，需要决定是否需要消费已经存在于 Broker 中的历史消息 </p>
<p> org.apache.rocketmq.common.consumer.ConsumeFromWhere </p>
<p> CONSUME_FROM_LAST_OFFSET 将会忽略历史消息，并消费之后生成的任何消息。 </p>
<p> CONSUME_FROM_FIRST_OFFSET 将会消费每个存在于 Broker 中的信息。你也可以使用 </p>
<p> CONSUME_FROM_TIMESTAMP 来消费在指定时间戳后产生的消息。 </p>
<h4 id="消息重复幂等"><a href="#消息重复幂等" class="headerlink" title="消息重复幂等"></a>消息重复幂等</h4><p>RocketMQ无法避免消息重复，所以如果业务对消费重复非常敏感，务必要在业务层 面去重 </p>
<p>幂等令牌是生产者和消费者两者中的既定协议，在业务中通常是具备唯一业务标识的字符 串，如：订单号、流水号等。且一般由生产者端生成并传递给消费者端。</p>
]]></content>
      <categories>
        <category>RocketMQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-MQ-06Kafka特性详解&amp;场景介绍(二)</title>
    <url>/2024/06/15/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-06Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&amp;%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D(%E4%BA%8C)/</url>
    <content><![CDATA[<h1 id="Kafka特性详解Q-amp-A"><a href="#Kafka特性详解Q-amp-A" class="headerlink" title="Kafka特性详解Q&amp;A"></a>Kafka特性详解Q&amp;A</h1><h2 id="1、HW、LW、LEO、ISR的含义和关系"><a href="#1、HW、LW、LEO、ISR的含义和关系" class="headerlink" title="1、HW、LW、LEO、ISR的含义和关系"></a>1、HW、LW、LEO、ISR的含义和关系</h2><p>LEO： Log end offset，Kafka 分区消息的终点，消息终止偏移，下一条消息的插入位置</p>
<p>HW：High water mark 高水位 用于控制消息可见性，HW <strong>以下</strong>的消息对外可见，HW 的位置可能对应一条消息，但是对外不可见不可以消费，HW 的最大值是 LEO，<strong>分区 HW 就是 leader 副本的 HW 值</strong>=整个ISR分区所有副本的的LEO</p>
<p>LW：Low water mark，用于控制消息可见性，LW <strong>及以上</strong>的消息对外可见</p>
<p>ISR：In sync replica 指满足副本同步要求的副本集合，包括领导者副本</p>
<h2 id="2、kafka的rebalance机制-是什么？"><a href="#2、kafka的rebalance机制-是什么？" class="headerlink" title="2、kafka的rebalance机制 是什么？"></a>2、kafka的rebalance机制 是什么？</h2><p>Kafka的rebalance（重新平衡）指的是Kafka消费者组内部的一种协议和过程，用于<strong>在消费者组成员发生变化或者分区发生变化时重新分配分区所有权</strong>。<strong>这个过程确保了每个分区都由消费者组中的一个成员来消费，并且当消费者加入或离开消费者组时，或者主题的分区数发生变化时，分区的分配关系能够自动调整</strong></p>
<h2 id="3、rebalance的触发条件"><a href="#3、rebalance的触发条件" class="headerlink" title="3、rebalance的触发条件"></a>3、rebalance的触发条件</h2><p>1、分区数发生变化（分区只能增不能减）<br>2、消费者加入或者离开<br>3、消费者失效：如果一个消费者由于网络原因、故障或其他原因失去联系，则该消费者拥有的分区将被重新分配给其他消费者。（session 超时和 pull超时）</p>
<h2 id="4、rebalance的过程"><a href="#4、rebalance的过程" class="headerlink" title="4、rebalance的过程"></a>4、rebalance的过程</h2><p>1、消费成员向coordinator发送请求加入cosummer group<br>2、coordinator选择一个consumer担任leader角色<br>3、leader分配消费方案，上报给coordinator<br>4、coordinator收到后同步方案给其他consumer</p>
<h2 id="5、rebalance的影响"><a href="#5、rebalance的影响" class="headerlink" title="5、rebalance的影响"></a>5、rebalance的影响</h2><p>1、重复消费，原consumer踢出前还没提交offset，rebalance后部分会重新消费，可以通过幂等解决<br>2、临时停顿，集群不稳定<br>3、频繁的rebalance影响整体的消费速度</p>
<h2 id="6、如何避免rebalance发生，减少rebalance的影响"><a href="#6、如何避免rebalance发生，减少rebalance的影响" class="headerlink" title="6、如何避免rebalance发生，减少rebalance的影响"></a>6、如何避免rebalance发生，减少rebalance的影响</h2><p>1、优雅退出close消费者<br>2、及时提交偏移量，每一条提交一次<br>3、避免消费者心跳和session超时或者消费拉取超时被踢出消费者组，从而rebalance</p>
<h2 id="7、比较常见的引起消费组成员的加入或离开导致rebanlance的原因"><a href="#7、比较常见的引起消费组成员的加入或离开导致rebanlance的原因" class="headerlink" title="7、比较常见的引起消费组成员的加入或离开导致rebanlance的原因"></a>7、比较常见的引起消费组成员的加入或离开导致rebanlance的原因</h2><p>（1）未能及时发送心跳而Rebalance<br>    session.timeout.ms 一次session的连接超时时间，heartbeat.interval.ms 心跳时间，一般为超时时间的1/3，Consumer在被判定为死亡之前，能够发送至少 3 轮的心跳请求。heartbeat.interval.ms 默认值 3000，也就是每3s发送一次心跳包。</p>
<p>（2）Consumer消费超时而Rebalance<br>     每隔多长时间去拉取消息。合理设置预期值，尽量但间隔时间消费者处理完业务逻辑，否则就会被coordinator判定为死亡，踢出Consumer Group，进行Rebalance。<br>    max.poll.records 一次从拉取出来的数据条数。根据消费业务处理耗费时长合理设置，如果max.poll.interval.ms 设置的时间较短，可以max.poll.records设置小点儿，少拉取些，这样不会超时。<br>    <strong>总之，尽可能在max.poll.interval.ms时间间隔内处理完max.poll.records条消息，让Coordinator认为消费Consumer还活着</strong></p>
<h2 id="8、几个时间配置的定义和影响"><a href="#8、几个时间配置的定义和影响" class="headerlink" title="8、几个时间配置的定义和影响"></a>8、几个时间配置的定义和影响</h2><ol>
<li>request.timeout.ms<br>定义：这个配置参数指定了客户端等待Kafka服务端响应的最长时间。如果请求在这个时间内没有收到响应，客户端会重试发送请求（根据重试策略）。<br>影响：设置太短可能导致在正常的负载和轻微网络延迟情况下出现不必要的重试。设置太长，可能在服务端处理出现问题时，导致客户端长时间等待响应，影响客户端处理效率。</li>
<li>session.timeout.ms<br>定义：这个配置参数用于控制消费者被认为是存活的最小时间间隔。如果在这个时间间隔内，消费者没有向Kafka集群发送心跳，则认为该消费者已经死亡，会从它所在的消费者组中移除。<br>影响：设置太短可能导致在正常的网络波动或者处理较大消息时，消费者被误认为已经死亡。设置太长，当消费者真的失败时，Kafka集群需要更长的时间来检测到这一点，并进行重新平衡，影响消息的及时消费。</li>
<li>heartbeat.interval.ms<br>定义：这个配置参数指定了消费者发送心跳给Kafka协调者的频率。心跳是用来表明消费者存活的状态、加入和退出消费者组的机制。<br>影响：设置太短会导致消费者发送过多的心跳，增加Kafka集群的负载。设置太长，可能会导致Kafka协调者在session.timeout.ms时间内检测不到消费者的存活状态，导致消费者被误判为已经死亡。</li>
<li>max.poll.interval.ms<br>定义：这个配置参数指定了消费者在两次调用poll()方法之间的最大时间间隔。如果超过这个时间没有调用poll()，Kafka会认为消费者已经死亡，将其从消费者组中移除，并触发重新平衡。<br>影响：设置太短可能会导致在处理大批量消息、网络延迟或系统负载高的情况下，无法在时间间隔内完成poll()调用。设置太长，就像session.timeout.ms一样，影响故障检测和重新平衡的响应速度。</li>
</ol>
<p><strong>结论</strong></p>
<p>​    这些配置参数之间的关系非常密切，需要根据实际使用场景和Kafka集群的性能来合理设置。session.timeout.ms、heartbeat.interval.ms和max.poll.interval.ms特别关系到消费者的健康检测和消费者组的稳定性。request.timeout.ms更多的影响到客户端与服务端之间通信的效率和稳定性。合理配置这些参数可帮助保证Kafka消费者服务的高可用性和消息的及时处理。</p>
<h2 id="9、kafka生产者发送消息的同步机制"><a href="#9、kafka生产者发送消息的同步机制" class="headerlink" title="9、kafka生产者发送消息的同步机制"></a>9、kafka生产者发送消息的同步机制</h2><p>（1）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消 息。大数据统计报表场景，对性能要求很高，对数据丢失不敏感的情况可以用这种。</p>
<p>（2）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消 息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。 </p>
<p>（3）acks=-1或all： 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志，这种策略会保证只要有一 个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然如果 min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。</p>
<p>在分区存在副本的情况下，使用leader-follower，leader负责读写请求，follower从分区leader那复制数据</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">（1）、在分区存在副本的情况下，使用leader-follower，leader负责读写请求，follower从分区leader那复制数据<br>（2）、复制数据时：leader接收到写请求，写入到本地日志，紧接着folloer从leader获取数据并将其写入到自己的日志。<br>（3）、一旦超过Kafka Broker端的配置min.insync.replicas数量的ISR副本都成功复制了数据，leader则认为数据已被成功复制。<br>（4）、Kafka设计了复制延迟的容忍机制，如果Follower与Leader之间的复制延迟超过配置的阈值，则Follower会被认为是落后的，并可能从ISR列表中移除。<br></code></pre></td></tr></table></figure>

<h2 id="10、什么是ISR（In-Sync-Replicas）"><a href="#10、什么是ISR（In-Sync-Replicas）" class="headerlink" title="10、什么是ISR（In-Sync Replicas）"></a>10、什么是ISR（In-Sync Replicas）</h2><p>1、ISR是一组保持与Leader同步的副本列表<br>2、如果Follower太久没有从Leader复制数据，或者跟不上Leader的数据同步速度，它会从ISR中移除。<br>3、ISR确保只有那些与Leader保持同步的副本才能被选举为Leader，从而确保数据不会丢失</p>
<p>​    replica.lag.time.max.ms：决定了一个副本被认为是落后（并可能从ISR中移除）的最大时间。如果副本在该时间内未同步数据，它会被认为是落后的。<br>​    min.insync.replicas：这是针对每个主题可以设置的参数，指定了一个生产者在考虑写入请求成功之前，必须有多少ISR副本确认接收到数据。</p>
<p>结论：kafka通过分区来提升并发度，利用分区副本和leader-follower+ISR来保障高可用性和一致性。</p>
<h2 id="11、Kafka消费发布流程"><a href="#11、Kafka消费发布流程" class="headerlink" title="11、Kafka消费发布流程"></a>11、Kafka消费发布流程</h2><p>1、producer先根据路由规则，把消息发送到指定partition的leader<br>2、leader将消息写入本地log<br>3、folloer从leader pull消息，写入本地log后leader发送ack<br>4、leader接受到一定数量的ISR中的分区副本的ack后，增加HW（hight watermark，最后后一条commit的offset ），并向producer发送ack</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-06Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D(%E4%BA%8C)/image-20240615230628783.png" alt="image-20240615230628783"></p>
<h2 id="12、消息丢失"><a href="#12、消息丢失" class="headerlink" title="12、消息丢失"></a>12、消息丢失</h2><p>1、生产者-&gt;server：设置重试，重试间隔，设置ack=alls(实际采用ISR机制)，如果额外设置min.insync.replicas，则要求ISR中至少多少个副本成功写入<br>2、消费者：手动提交+消费完再提交</p>
<h2 id="13、消息重复消费"><a href="#13、消息重复消费" class="headerlink" title="13、消息重复消费"></a>13、消息重复消费</h2><p>1、生产者重复投递-消费者支持幂等<br>2、消费超时等失败场景导致重复投递：加快单条消费速度+适当调整max.poll.interval.ms和调小max.poll.records，避免消费太多无法及时poll从而触发rebalance。一般而言max.poll.interval.ms &gt; session.timeout.ms</p>
<h2 id="14、消息积压"><a href="#14、消息积压" class="headerlink" title="14、消息积压"></a>14、消息积压</h2><p>1、增加分区，增加消费者数量<br>2、分析堆积原因，通过设置消费偏移量解决<br>3、kafka不适合长任务，避免引起重平衡，长耗时任务丢给异步任务处理<br>4、1个分区时，临时调整，根据需要开多个消费组处理特定逻辑<br>5、临时增加消息保留时间<br>6、评估多个分区，局部有序的方案</p>
<h2 id="15、Kafka相较于其他平台比如RabbitMQ的优势，为什么支持大数据量"><a href="#15、Kafka相较于其他平台比如RabbitMQ的优势，为什么支持大数据量" class="headerlink" title="15、Kafka相较于其他平台比如RabbitMQ的优势，为什么支持大数据量"></a>15、Kafka相较于其他平台比如RabbitMQ的优势，为什么支持大数据量</h2><p><strong>优点：</strong></p>
<p>A、分布式架构：扩展性和可靠性</p>
<p>B、持久化存储：持久化在磁盘上保存一段时间，单个broker支持TB级别数据</p>
<p>C、高性能高吞吐：采用磁盘顺序写，比随机写效率高、支持批量发消息和消费消息、partition机制：topic分为多个分区，挺高并行度也提高吞吐量</p>
<p>D、leader-follow + ISR机制，保障快速写入和数据不丢失</p>
<p><strong>缺点：</strong></p>
<p>1、消费者数量受到分区数限制</p>
<p>2、不支持事务</p>
<p>3、运维成本高</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-Mysql读写分离及高可用方案</title>
    <url>/2022/06/18/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="Mysql读写分离及高可用方案"><a href="#Mysql读写分离及高可用方案" class="headerlink" title="Mysql读写分离及高可用方案"></a>Mysql读写分离及高可用方案</h1><h2 id="主从架构"><a href="#主从架构" class="headerlink" title="主从架构"></a>主从架构</h2><h3 id="为什么要主从架构？"><a href="#为什么要主从架构？" class="headerlink" title="为什么要主从架构？"></a>为什么要主从架构？</h3><p>1、如果主服务器出现问题，可以快速切换到从服务器提供的服务<br>2、可以在从服务器上执行查询操作，降低主服务器的访问压力<br>3、可以在从服务器上执行备份，以避免备份期间影响主服务器的服务</p>
<h3 id="主从方案"><a href="#主从方案" class="headerlink" title="主从方案"></a>主从方案</h3><p>1、M-S：一主一从</p>
<p>2、M-M-M-S：多主一从</p>
<p>3、M-S-S-S：一主多级从</p>
<p>4、M-M（MMM方案）：双主</p>
<p>5、S-S-S-S :环型主从</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618130943529.png" alt="image-20220618130943529"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618131342230.png" alt="image-20220618131342230"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618131452475.png" alt="image-20220618131452475"></p>
<h3 id="主从复制：延时问题"><a href="#主从复制：延时问题" class="headerlink" title="主从复制：延时问题"></a>主从复制：延时问题</h3><p><strong>relay log</strong></p>
<p>​    从数据库Slave服务的I/O线程从主数据库Master服务的二进制日志中读取数据库的更改记录并写入到中继日志中，然后在Slave数据库执行修改操作。这就是中继日志Relay Log</p>
<p><strong>有哪些主从复制方式</strong></p>
<p>1、同步复制</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618131927913.png" alt="image-20220618131927913"></p>
<p>2、半同步复制</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618132228890.png" alt="image-20220618132228890"></p>
<p>3、异步复制(mysql默认的复制方式)</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618131956141.png" alt="image-20220618131956141"></p>
<h3 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20220618132510112.png" alt="image-20220618132510112"></p>
<p>数据同步方式：</p>
<p>1、GTID </p>
<p>2、bin-log</p>
<h2 id="高可用方案"><a href="#高可用方案" class="headerlink" title="高可用方案"></a>高可用方案</h2><h3 id="MMM（业界已弃用）"><a href="#MMM（业界已弃用）" class="headerlink" title="MMM（业界已弃用）"></a>MMM（业界已弃用）</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20221012224040530.png" alt="image-20221012224040530"></p>
<p><strong>1.1 优点</strong> </p>
<p>1、高可用性，扩展性好，出现故障自动转移，对于主主同步，在同一时间只提供一台数 </p>
<p>据库写操作，保证数据的一致性。 </p>
<p>2、配置简单，容易操作。 </p>
<p><strong>1.2 缺点</strong> </p>
<p>1、需要一台备份服务器，<strong>浪费资源</strong> </p>
<p>2、需要多个虚拟IP </p>
<p>3、agent可能意外终止，引起<strong>裂脑</strong>。 </p>
<h3 id="MHA"><a href="#MHA" class="headerlink" title="MHA"></a>MHA</h3><p><a href="https://www.kancloud.cn/devops-centos/centos-linux-devops/385181">MHA</a>(Mysql一主两从) + proxySql(代理2台) + 读写分离</p>
<p>如果需要分库分表：采用<strong>shardingsphere</strong>,sync_binlog = 1 设置binlog强制刷盘,默认主从采用的异步复制 </p>
<p>MHA服务，有两种角色， MHA Manager(管理节点)和 MHA Node(数据节点)。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20221012224018805.png" alt="image-20221012224018805"></p>
<p><strong>2.1 优点</strong> </p>
<p>（1）不需要备份服务器 </p>
<p>（2）不改变现有环境 </p>
<p>（3）操作非常简单 </p>
<p>（4）可以进行日志的差异修复 </p>
<p>（5）可以将任意slave提升为master </p>
<p><strong>2.2 缺点</strong> </p>
<p>（1）需要全部节点做ssh秘钥 </p>
<p>（2）MHA出现故障后配置文件会被修改，如果再次故障转移需要重新修改配置文件。 </p>
<p>（3）自带的脚本还需要进一步补充完善，且用perl开发，二次开发困难。 </p>
<h1 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h1><p><a href="https://blog.51cto.com/u_15072910/4333307">为什么要分库分表？</a></p>
<p><strong>什么是分库分表？</strong> </p>
<p>将一个表拆分多张表(库内分表与分库分表) </p>
<p><strong>为什么需要分库分表？</strong></p>
<p>1、数据量大，单表数据量超过千万容易出现性能瓶颈，即便索引优化也提升不了速度（B+树）树高过高，IO次数增加）</p>
<p>2、物理服务器的CPU、内存、存储、连接数等资源存在限制，某个时段大量连接执行操作，会导致数据库处理时遇到性能瓶颈</p>
<p>因此出现了分而治之的思想，对大表进行切割，实施更好地控制和管理，同时使用多台机器的CPU、内存、存储，提供更好的性能。而分而治之则有两种方式：<strong>垂直拆分和水平拆分</strong>。</p>
<h2 id="垂直拆分"><a href="#垂直拆分" class="headerlink" title="垂直拆分"></a>垂直拆分</h2><h3 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h3><p>对不同的表进行分库：垂直分库其实是一种简单逻辑分割。比如我们的数据库中有商品表Products、还有对订单表Orders，还有积分表Scores。接下来我们就可以创建三个数据库，一个数据库存放商品，一个数据库存放订单，一个数据库存放积分。如下图所示：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Mysql%E8%AF%BB%E5%86%99%E5%88%86%E7%A6%BB%E5%8F%8A%E9%AB%98%E5%8F%AF%E7%94%A8%E6%96%B9%E6%A1%88/image-20221012224710606.png" alt="image-20221012224710606"></p>
<h3 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h3><p>对宽表进行字段拆分：比较适用于那种字段比较多的表，假设我们一张表有100个字段，我们分析了一下当前业务执行的SQL语句，有20个字段是经常使用的，而另外80个字段使用比较少。</p>
<p>这样我们就可以把20个字段放在主表里面，我们在创建一个辅助表，存放另外80个字段。当然主表和辅助表都是有主键的。他们通过主键进行关联合并，就可以凑成100个字段的表</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>1、跟随业务进行分割，和最近流行的微服务概念相似，方便解耦之后的管理及扩展。</p>
<p>2、高并发的场景下，垂直拆分使用多台服务器的CPU、I/O、内存能提升性能，同时对单机数据库连接数、一些资源限制也得到了提升。<br>3、能实现冷热数据的分离</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>1、部分业务表无法join，应用层需要很大的改造，只能通过聚合的方式来实现。增加了开发的难度。<br>2、当单库中的表数据量增大的时候依然没有得到有效的解决。<br>3、分布式事务也是一个难题</p>
<h2 id="水平拆分"><a href="#水平拆分" class="headerlink" title="水平拆分"></a>水平拆分</h2><h3 id="库内分表"><a href="#库内分表" class="headerlink" title="库内分表"></a>库内分表</h3><p>​    假设当我们的Orders表达到了5000万行记录的时候，非常影响数据库的读写效率，怎么办呢？我们可以考虑按照订单编号的order_id进行rang分区,就是把订单编号在1-1000万的放在order1表中，将编号在1000万-2000万的放在order2中，以此类推，每个表中存放1000万数据。</p>
<p>​    虽然我们可以通过库内分表把单表的容量固定在1000万，但是这些表的数据仍然存放在一个库内，使用的是该主机的CPU、IO、内存。单库的连接数也有限制。并不能完全的降低系统的压力。此时，我们就要考虑另外一种技术叫分库分表。</p>
<h3 id="分库分表-1"><a href="#分库分表-1" class="headerlink" title="分库分表"></a>分库分表</h3><p>​    分库分表在库内分表的基础上，将分的表挪动到不同的主机和数据库上。可以充分的使用其他主机的CPU、内存和IO资源。并且分库之后，单库的连接数限制也不在成为瓶颈。</p>
<p>但是“成也萧何败也萧何”，如果你执行一个扫描不带分片键，则需要在每个库上查一遍。刚刚我们按照order_id分成了5个库，但是我们查询是name=’AAA’的条件并且不带order_id字段时，它并不知道在哪个分片上查，则会创建5个连接，然后每个库都检索一遍。这种广播查询则会造成连接数增多。</p>
<p>因为它需要在每个库上都创立连接。如果是高并发的系统，执行这种广播查询，系统的thread很快就会告警</p>
<h3 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、水平扩展能持续扩展。不存在某个库某个表过大的情况。<br>2、能够较好的应对高并发，同时可以将热点数据打散。</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>1、增加程序复杂度，增加一成路由选择计算，对一些统计类查询要查询多个库多个表才能聚合出结果</p>
<p>2、市面上的分库分表插件对此存在限制，join、分页性能差，功能存在限制</p>
<p>3、分布式事务的一致性问题</p>
<p>4、横向扩充时，数据迁移问题</p>
<h2 id="分库分表组件"><a href="#分库分表组件" class="headerlink" title="分库分表组件"></a>分库分表组件</h2><p>shardingsphere（京东数科）在apache孵化 </p>
<p>Mycat（阿里巴巴-基于cobar）不是阿里的 </p>
<p>Atlas （奇虎360） </p>
<p><a href="https://juejin.cn/post/7085132195190276109">参考：https://juejin.cn/post/7085132195190276109</a></p>
<h2 id="什么场景需要分库分表"><a href="#什么场景需要分库分表" class="headerlink" title="什么场景需要分库分表"></a>什么场景需要分库分表</h2><h2 id="分库分表后存在的问题："><a href="#分库分表后存在的问题：" class="headerlink" title="分库分表后存在的问题："></a>分库分表后存在的问题：</h2><ul>
<li>事务问题</li>
<li>跨库关联</li>
<li>排序问题</li>
<li>分页问题</li>
<li>分布式ID</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>主从架构、高可用</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-Redis03-分布式锁实战</title>
    <url>/2022/04/13/%E5%88%86%E5%B8%83%E5%BC%8F-Redis03-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="分布式锁实战"><a href="#分布式锁实战" class="headerlink" title="分布式锁实战"></a>分布式锁实战</h1><h2 id="分布式锁应用场景"><a href="#分布式锁应用场景" class="headerlink" title="分布式锁应用场景"></a>分布式锁应用场景</h2><p>1、互联网秒杀</p>
<p>2、抢优惠券</p>
<p>3、接口幂等性校验</p>
<h2 id="redis实现分布式锁"><a href="#redis实现分布式锁" class="headerlink" title="redis实现分布式锁"></a>redis实现分布式锁</h2><h3 id="1-0"><a href="#1-0" class="headerlink" title="1.0"></a>1.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/deduct_stock&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String lockKey = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    String locKValue = <span class="hljs-string">&quot;product_001&quot;</span>;<br><br>    Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, locKValue);<br>    <span class="hljs-keyword">if</span>(!lock)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fail&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>    <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">int</span> realStock = stock - <span class="hljs-number">1</span>;<br>        stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key,value)</span><br>        System.out.println(<span class="hljs-string">&quot;扣减成功，剩余库存:&quot;</span> + realStock + <span class="hljs-string">&quot;&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;扣减失败，库存不足&quot;</span>);<br>    &#125;<br><br>    stringRedisTemplate.delete(lockKey);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>存在问题：</p>
<p>1、没有设置锁过期时间</p>
<p>2、锁不保证得到释放</p>
<h3 id="2-0"><a href="#2-0" class="headerlink" title="2.0"></a>2.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/deduct_stock_2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock2</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String lockKey = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    String locKValue = <span class="hljs-string">&quot;product_001&quot;</span>;<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, locKValue,<span class="hljs-number">15</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span>(!lock)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fail&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> realStock = stock - <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key,value)</span><br>            System.out.println(<span class="hljs-string">&quot;扣减成功，剩余库存:&quot;</span> + realStock + <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;扣减失败，库存不足&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        stringRedisTemplate.delete(lockKey);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>存在问题：</p>
<p>1、高并发场景下，可能释放了别人的锁</p>
<h3 id="3-0"><a href="#3-0" class="headerlink" title="3.0"></a>3.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/deduct_stock_3&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock3</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String lockKey = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    String locKValue = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    locKValue = UUID.randomUUID().toString();<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        Boolean lock = stringRedisTemplate.opsForValue().setIfAbsent(lockKey, locKValue,<span class="hljs-number">15</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span>(!lock)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fail&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> realStock = stock - <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key,value)</span><br>            System.out.println(<span class="hljs-string">&quot;扣减成功，剩余库存:&quot;</span> + realStock + <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;扣减失败，库存不足&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span>(locKValue.equals(stringRedisTemplate.opsForValue().get(lockKey)))&#123;<br>            stringRedisTemplate.delete(lockKey);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>存在问题：</p>
<p><strong>1、释放锁时，存在非原子操作</strong></p>
<p>对于释放锁时的非原子操作问题，可以使用 Redis 的 Lua 脚本确保释放锁的操作是原子性（Lua脚本内能保证redis命令连续且完整的执行）的。例如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String script = <span class="hljs-string">&quot;if redis.call(&#x27;get&#x27;, KEYS[1]) == ARGV[1] then return redis.call(&#x27;del&#x27;, KEYS[1]) else return 0 end&quot;</span>;<br>DefaultRedisScript&lt;Long&gt; redisScript = <span class="hljs-keyword">new</span> DefaultRedisScript&lt;&gt;(script, Long.class);<br>Long result = stringRedisTemplate.execute(redisScript, Arrays.asList(lockKey),locKValue);<br></code></pre></td></tr></table></figure>

<p>2、线程1还没跑完，锁就释放了，线程2获取到锁，分布式锁失效（不知道该设置锁超时时间多少合适）</p>
<p>解决办法：</p>
<p>1、使用已经封装好的<strong>Redisson</strong>，自动续期key失效时间</p>
<p>2、合理定义超时时间，减少耗时，且设置锁过期时间稍稍长一点</p>
<p>3、自己实现第一点逻辑，采用“看门狗”机制：启动一个单独的线程或定时任务，在锁快要过期时自动为锁续期，只要业务操作还未完成</p>
<p>4、监控和告警：在finally之前获取锁成功，释放锁失败时，告警异常情况。</p>
<h3 id="4-0"><a href="#4-0" class="headerlink" title="4.0"></a>4.0</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/deduct_stock_4&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock4</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String lockKey = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    RLock redissonLock = redisson.getLock(lockKey);<br>    <span class="hljs-keyword">try</span> &#123;<br>        redissonLock.lock();<br>        <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> realStock = stock - <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key,value)</span><br>            System.out.println(<span class="hljs-string">&quot;扣减成功，剩余库存:&quot;</span> + realStock + <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;扣减失败，库存不足&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        redissonLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>存在问题：</p>
<p>1、其他线程获取不到锁超过一定时间，获取锁失败</p>
<p>解决办法：设置获取锁尝试时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/deduct_stock_5&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">deductStock5</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String lockKey = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    RLock redissonLock = redisson.getLock(lockKey);<br>    <span class="hljs-keyword">try</span> &#123;<br>        redissonLock.tryLock(<span class="hljs-number">10</span>,TimeUnit.SECONDS);<br>        <span class="hljs-keyword">int</span> stock = Integer.parseInt(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;stock&quot;</span>)); <span class="hljs-comment">// jedis.get(&quot;stock&quot;)</span><br>        <span class="hljs-keyword">if</span> (stock &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">int</span> realStock = stock - <span class="hljs-number">1</span>;<br>            stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;stock&quot;</span>, realStock + <span class="hljs-string">&quot;&quot;</span>); <span class="hljs-comment">// jedis.set(key,value)</span><br>            System.out.println(<span class="hljs-string">&quot;扣减成功，剩余库存:&quot;</span> + realStock + <span class="hljs-string">&quot;&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;扣减失败，库存不足&quot;</span>);<br>        &#125;<br>    &#125;<span class="hljs-keyword">finally</span> &#123;<br>        redissonLock.unlock();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Redisson分布式锁实现原理"><a href="#Redisson分布式锁实现原理" class="headerlink" title="Redisson分布式锁实现原理"></a>Redisson分布式锁实现原理</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis03%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-/image-20220413213955415.png" alt="image-20220413213955415"></p>
<h2 id="Redis实现分布式的问题"><a href="#Redis实现分布式的问题" class="headerlink" title="Redis实现分布式的问题"></a>Redis实现分布式的问题</h2><p>1、redis集群元数据的维护采用gossip协议通信</p>
<p>master消息没同步给slave前，master挂了，导致另一线程获取锁也成功</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis03%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81-/image-20220413214958142.png" alt="image-20220413214958142"></p>
<h3 id="RedLock"><a href="#RedLock" class="headerlink" title="RedLock"></a>RedLock</h3><p>所有节点获取锁成功才成功，优点类似zookeeper（过半节点成功才成功）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/redlock&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redlock</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    String lockKey = <span class="hljs-string">&quot;product_001&quot;</span>;<br>    <span class="hljs-comment">//这里需要自己实例化不同redis实例的redisson客户端连接，这里只是伪代码用一个redisson客户端简化了</span><br>    RLock lock1 = redisson.getLock(lockKey);<br>    RLock lock2 = redisson.getLock(lockKey);<br>    RLock lock3 = redisson.getLock(lockKey);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据多个 RLock 对象构建 RedissonRedLock （最核心的差别就在这里）</span><br><span class="hljs-comment">     */</span><br>    RedissonRedLock redLock = <span class="hljs-keyword">new</span> RedissonRedLock(lock1, lock2, lock3);<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 4.尝试获取锁</span><br><span class="hljs-comment">         * waitTimeout 尝试获取锁的最大等待时间，超过这个值，则认为获取锁失败</span><br><span class="hljs-comment">         * leaseTime   锁的持有时间,超过这个时间锁会自动失效（值应设置为大于业务处理的时间，确保在锁有效期内业务能处理完）</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">boolean</span> res = redLock.tryLock(<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (res) &#123;<br>            <span class="hljs-comment">//成功获得锁，在这里处理业务</span><br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;lock fail&quot;</span>);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//无论如何, 最后都要解锁</span><br>        redLock.unlock();<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="分布锁的三种实现"><a href="#分布锁的三种实现" class="headerlink" title="分布锁的三种实现"></a><a href="https://blog.csdn.net/qq_43640119/article/details/123778284#Zookeeper_269"><strong>分布锁的三种实现</strong></a></h2><p>1、redis实现分布式锁（redisson）</p>
<p>2、Zookeeper实现分布式锁（集中式集群管理，性能较差）</p>
<p>3、基于数据库实现分布式锁</p>
<p>1、利用唯一索引（lock:借助唯一索引保证插入某个key的记录成功 unlock:删除记录）</p>
<p>2、行锁-利用乐观锁 update set xxx= xxx where xxx=xxx，根据返回的影响行数来判断是否获取锁成功 （<a href="https://blog.csdn.net/qq_19801061/article/details/119146521%EF%BC%89">https://blog.csdn.net/qq_19801061/article/details/119146521）</a></p>
<h2 id="分布式锁总结"><a href="#分布式锁总结" class="headerlink" title="分布式锁总结"></a>分布式锁总结</h2><p>在目前分布式锁实现方案中，比较成熟、主流的方案有两种：</p>
<p>（1）基于Redis的分布式锁：适合并发量高，性能要求很高，对数据一致性要求较低，允许最终一致性的场景</p>
<p>（2）基于ZooKeeper的分布式锁：适合对数据一致性要求较高且并发量较低的场景</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-异步延时任务</title>
    <url>/2023/03/14/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%BC%82%E6%AD%A5%E5%BB%B6%E6%97%B6%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>​    实际业务研发中，存在需要异步执行、或者延时执行某些操作，且这些操作支持重试，需要一个异步延时任务来支撑</p>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><p>方案组合：Mysql持久化 + RabbitMQ异步解耦 + 定时任务定时轮询 </p>
<p>1、状态流转图</p>
 <img src="/images/分布式-异步延时任务/image-20230314224717884.png" alt="image-20230314224717884" style="zoom:50%;">

<p>2、数据库设计</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE &#96;sup_task&#96;<br>(<br>    &#96;id&#96;               bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;任务id&#39;,<br>    &#96;task_type&#96;        tinyint         NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;任务类型&#39;,<br>    &#96;task_param&#96;       text COMMENT &#39;任务参数&#39;,<br>    &#96;task_keyword&#96;     varchar(128)    NOT NULL DEFAULT &#39;&#39; COMMENT &#39;关键字&#39;,<br>    &#96;task_state&#96;       int             NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;任务状态 1 待执行 2 执行中 3 执行成功 4 执行失败 &#39;,<br>    &#96;max_retry_count&#96;  int             NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;最大重试次数&#39;,<br>    &#96;next_runtime&#96;     datetime        NOT NULL DEFAULT &#39;1970-01-01 12:01:01&#39; COMMENT &#39;下次执行时间&#39;,<br>    &#96;retry_count&#96;      int             NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;已重试次数&#39;,<br>    &#96;run_rate&#96;         int             NOT NULL DEFAULT &#39;0&#39; COMMENT &#39;执行频率 单位分钟&#39;,<br>    PRIMARY KEY (&#96;id&#96;) USING BTREE,<br>    KEY &#96;idx_sup_task_2&#96; (&#96;task_type&#96;) USING BTREE,<br>    KEY &#96;idx_sup_task_3&#96; (&#96;task_keyword&#96;) USING BTREE,<br>    KEY &#96;idx_sup_task_4&#96; (&#96;system_type&#96;, &#96;task_state&#96;, &#96;task_type&#96;)<br>) ENGINE &#x3D; InnoDB COMMENT &#x3D;&#39;任务管理表&#39;;<br></code></pre></td></tr></table></figure>

<p>3、RabbitMQ队列：声明一个队列专门用于监听触发任务执行</p>
<h2 id="使用举例"><a href="#使用举例" class="headerlink" title="使用举例"></a>使用举例</h2><p>1、声明异步任务类型和对应消费实现</p>
<p>2、业务代码发布异步任务事件</p>
<p>3、异步任务执行</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>排队任务</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-排队任务</title>
    <url>/2023/03/14/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%8E%92%E9%98%9F%E4%BB%BB%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>目前的<strong>延时任务组件</strong>赋予了我们系统<strong>异步任务执行器</strong>或者<strong>延迟任务执行器</strong>的功能，但是对于一些业务场景，异步触发的某种类型的任务，这个异步任务本身需要根据某些限定条件<strong>单线程排队执行</strong></p>
<p>比如：调用A接口后，调用异步执行B方法，B方法会维护A的相关业务的统计，耗时较久。如果触发多次A接口，这些异步任务B可能会产生后触发的被先触发的覆盖掉，即并发中的<strong>ABA</strong>问题。这个时候就需要有一个排队任务的机制，根据某些业务id和业务类型进行任务排队，在排队队列中逐个执行。</p>
<h2 id="方案设计"><a href="#方案设计" class="headerlink" title="方案设计"></a>方案设计</h2><h3 id="1、表设计"><a href="#1、表设计" class="headerlink" title="1、表设计:"></a>1、表设计:</h3><p>通过新增排队任务表来承载和记录排队任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">CREATE TABLE &#96;sup_queue_task&#96;<br>(<br>    &#96;id&#96;               bigint unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;任务id&#39;,<br>    &#96;queue_biz_type&#96;   int             NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;排队任务类型&#39;,<br>    &#96;task_param&#96;       text COMMENT &#39;任务参数&#39;,<br>    &#96;task_keyword&#96;     varchar(128)    NOT NULL DEFAULT &#39;&#39; COMMENT &#39;关键字&#39;,<br>    &#96;task_state&#96;       int             NOT NULL DEFAULT &#39;1&#39; COMMENT &#39;任务状态 1 待执行 2 执行中 3 执行成功 4 执行失败&#39;,<br>    PRIMARY KEY (&#96;id&#96;) USING BTREE,<br>    KEY &#96;idx_sup_queue_task_2&#96; (&#96;queue_biz_type&#96;) USING BTREE,<br>    KEY &#96;idx_sup_queue_task_3&#96; (&#96;task_keyword&#96;) USING BTREE,<br>    KEY &#96;idx_sup_queue_task_4&#96; (&#96;queue_biz_type&#96;, &#96;task_keyword&#96;, &#96;task_state&#96;)<br>) ENGINE &#x3D; InnoDB COMMENT &#x3D;&#39;排队任务管理表&#39;;<br></code></pre></td></tr></table></figure>

<h3 id="2、执行流程"><a href="#2、执行流程" class="headerlink" title="2、执行流程"></a>2、执行流程</h3><p><strong>排队任务状态流转图</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%8E%92%E9%98%9F%E4%BB%BB%E5%8A%A1/image-20230314092853724.png" alt="image-20230314092853724"></p>
<h4 id="1、任务生成"><a href="#1、任务生成" class="headerlink" title="1、任务生成"></a>1、任务生成</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%8E%92%E9%98%9F%E4%BB%BB%E5%8A%A1/image-20230314093309554.png" alt="image-20230314093309554"></p>
<h4 id="2、任务排队（定时任务定时轮询）"><a href="#2、任务排队（定时任务定时轮询）" class="headerlink" title="2、任务排队（定时任务定时轮询）"></a>2、任务排队（定时任务定时轮询）</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%8E%92%E9%98%9F%E4%BB%BB%E5%8A%A1/image-20230314093319109.png" alt="image-20230314093319109"></p>
<h4 id="3、任务状态更新（定时任务定时轮询）"><a href="#3、任务状态更新（定时任务定时轮询）" class="headerlink" title="3、任务状态更新（定时任务定时轮询）"></a>3、任务状态更新（定时任务定时轮询）</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E6%8E%92%E9%98%9F%E4%BB%BB%E5%8A%A1/image-20230314093339599.png" alt="image-20230314093339599"></p>
<h3 id="3、使用示例"><a href="#3、使用示例" class="headerlink" title="3、使用示例"></a>3、使用示例</h3><p>1、定义异步任务枚举实例，编写异步任务逻辑</p>
<p>2、定义排队任务枚举，关联异步任务枚举实例</p>
<p>3、业务代码直接发布排队任务事件</p>
<p>4、排队任务排队执行</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>排队任务</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程02Synchronized</title>
    <url>/2021/10/25/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&amp;AQS/</url>
    <content><![CDATA[<h1 id="并发编程之synchronized-amp-Lock-amp-AQS详解"><a href="#并发编程之synchronized-amp-Lock-amp-AQS详解" class="headerlink" title="并发编程之synchronized&amp;Lock&amp;AQS详解"></a>并发编程之synchronized&amp;Lock&amp;AQS详解</h1><h2 id="为什么加锁"><a href="#为什么加锁" class="headerlink" title="为什么加锁"></a>为什么加锁</h2><p><strong>加锁目的：</strong>序列化访问临界资源，即同一时刻只能有一个线程访问临界资源(同步互斥访问)</p>
<p><strong>显示锁与隐示锁</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024180413679.png" alt="image-20211024180413679"></p>
<h2 id="锁的分类"><a href="#锁的分类" class="headerlink" title="锁的分类"></a>锁的分类</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/%E6%8C%A8%E8%B8%A2%E5%B7%A5%E7%A8%8B%E5%B8%88%E4%B8%8D%E5%BE%97%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84java%E9%94%81.jpg"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Unsafe工具类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeInstance</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="synchronized使用与原理"><a href="#synchronized使用与原理" class="headerlink" title="synchronized使用与原理"></a>synchronized使用与原理</h2><p><strong>使用方式</strong></p>
<p>1、类的静态方法，锁当前类对象</p>
<p>2、实例方法，锁当前实例对象</p>
<p>3、同步代码块，锁代码里的对象</p>
<p><strong>底层原理</strong>：</p>
<p>​    JVM内置锁通过synchronized使用，通过内部对象Monitor(监视器锁)实现，<strong>基于进入与退出Monitor对象实现方法与代码块同步</strong>，监视器锁的实现依赖底层操作系统的<strong>Mutex lock</strong>（互斥锁）实现，它是一个重量级锁性能较低。简单的说时基于JMM8大操作里的lock和unlock，MonitorEnter和MonitorExit</p>
<h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p><strong>每个对象都有一个自己的Monitor(监视器锁)</strong></p>
<p><strong>锁的定义</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024220009143.png" alt="image-20211024220009143"></p>
<h3 id="加锁过程"><a href="#加锁过程" class="headerlink" title="加锁过程"></a>加锁过程</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024215853709.png" alt="image-20211024215853709"></p>
<h3 id="对象内存结构"><a href="#对象内存结构" class="headerlink" title="对象内存结构"></a>对象内存结构</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024222345420.png" alt="image-20211024222345420"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024231911266.png" alt="image-20211024231911266"></p>
<ol>
<li>对象头（哈希code、锁状态、当前持有线程、jvm年龄、偏向变量、MetaDate元数据指针）</li>
<li>实例数据</li>
<li>对齐填充</li>
</ol>
<h3 id="实例对象内存存储在哪？线程逃逸分析"><a href="#实例对象内存存储在哪？线程逃逸分析" class="headerlink" title="实例对象内存存储在哪？线程逃逸分析"></a>实例对象内存存储在哪？线程逃逸分析</h3><p>如果实例对象存储在堆时：实例对象内存存在堆区，实例引用存在栈上，实例的元数据class存在元空间中<br>如果存在逃逸分析，对象实例内存可能开辟在线程栈上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackAllocTest</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 进行两种测试</span><br><span class="hljs-comment">     * 关闭逃逸分析，同时调大堆空间，避免堆内GC的发生，如果有GC信息将会被打印出来</span><br><span class="hljs-comment">     * VM运行参数：-Xmx4G -Xms4G -XX:-DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 开启逃逸分析</span><br><span class="hljs-comment">     * VM运行参数：-Xmx4G -Xms4G -XX:+DoEscapeAnalysis -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 执行main方法后</span><br><span class="hljs-comment">     * jps 查看进程</span><br><span class="hljs-comment">     * jmap -histo 进程ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-comment">//查看执行时间</span><br>        System.out.println(<span class="hljs-string">&quot;cost-time &quot;</span> + (end - start) + <span class="hljs-string">&quot; ms&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e1) &#123;<br>            e1.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TulingStudent <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//Jit对编译时会对代码进行 逃逸分析</span><br>        <span class="hljs-comment">//并不是所有对象存放在堆区，有的一部分存在线程栈空间</span><br>        TulingStudent student = <span class="hljs-keyword">new</span> TulingStudent();<br>        <span class="hljs-keyword">return</span> student;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TulingStudent</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String name;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>通过jmap -histo pid 查看jvm内存实例情况</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024232528178.png" alt="image-20211024232528178"></p>
<h3 id="锁的优化与升级"><a href="#锁的优化与升级" class="headerlink" title="锁的优化与升级"></a>锁的优化与升级</h3><h4 id="锁的粗化（Lock-Coarsening）"><a href="#锁的粗化（Lock-Coarsening）" class="headerlink" title="锁的粗化（Lock Coarsening）"></a>锁的粗化（Lock Coarsening）</h4><p>锁的粗化是JVM为了减少线程获取锁和释放锁的次数，从而优化性能的一种策略。当JVM检测到一连串连续的对同一锁进行的加锁和解锁操作时，它会将这一连串的锁操作合并成一个较大的锁块，从而减少线程获取锁和释放锁的开销。</p>
<h4 id="锁的消除（Lock-Elimination）"><a href="#锁的消除（Lock-Elimination）" class="headerlink" title="锁的消除（Lock Elimination）"></a>锁的消除（Lock Elimination）</h4><p>锁的消除是JVM在运行时根据逃逸分析（Escape Analysis）的结果，确定一个对象不会被外部线程访问到，从而将其同步操作消除的一种优化策略。如果JVM通过逃逸分析发现某个同步块中的对象不会“逃逸”到同步块之外，即该对象不会被其他线程访问到，那么JVM就可以安全地消除这个同步块中的锁操作。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    StringBuffer stb = <span class="hljs-keyword">new</span> StringBuffer();<br><br>		<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//jvm的优化，锁的粗化</span><br>        stb.append(<span class="hljs-string">&quot;1&quot;</span>);<br><br>        stb.append(<span class="hljs-string">&quot;2&quot;</span>);<br><br>        stb.append(<span class="hljs-string">&quot;3&quot;</span>);<br><br>        stb.append(<span class="hljs-string">&quot;4&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁的消除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//jvm的优化，JVM不会对同步块进行加锁</span><br>        <span class="hljs-comment">//因为 new Object()这种匿名对象不会被别的线程使用到</span><br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">new</span> Object()) &#123;<br>            <span class="hljs-comment">//伪代码：很多逻辑</span><br>            <span class="hljs-comment">//jvm是否会加锁？</span><br>            <span class="hljs-comment">//jvm会进行逃逸分析</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Test test = <span class="hljs-keyword">new</span> Test();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="JVM内置锁的优化升级过程"><a href="#JVM内置锁的优化升级过程" class="headerlink" title="JVM内置锁的优化升级过程"></a>JVM内置锁的优化升级过程</h4><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20211024234942906.png" alt="image-20211024234942906"></p>
<p><img src="images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/synchronized%E9%94%81%E5%AE%9E%E7%8E%B0%E4%B8%8E%E5%8D%87%E7%BA%A7%E8%BF%87%E7%A8%8B.png"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/JVM%E9%94%81%E7%9A%84%E8%86%A8%E8%83%80%E5%8D%87%E7%BA%A7.jpg"></p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p><strong>偏向锁，它会偏向于第一个访问锁的线程</strong></p>
<ul>
<li>如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。线程第二次到达同步代码块时，会判断此时持有锁的线程是否就是自己，如果是则正常往下执行。由于之前没有释放锁，这里也就不需要重新加锁。如果自始至终使用锁的线程只有一个，很明显偏向锁几乎没有额外开销，性能极高。</li>
<li>如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。偏向锁通过消除资源无竞争情况下的同步原语，进一步提高了程序的运行性能。一旦有第二个线程加入<code>锁竞争</code>，偏向锁就升级为轻量级锁（自旋锁）。升级为轻量级锁的时候需要撤销偏向锁，撤销偏向锁的时候会导致<code>STW(stop the word)</code>操作；</li>
</ul>
<h4 id="轻量级锁（自旋锁）"><a href="#轻量级锁（自旋锁）" class="headerlink" title="轻量级锁（自旋锁）"></a>轻量级锁（自旋锁）</h4><p><strong>自旋锁：自旋锁原理非常简单，如果持有锁的线程能在很短时间内释放锁资源，那么那些等待竞争锁的线程就不需要做内核态和用户态之间的切换进入阻塞挂起状态，它们只需要等一等（自旋），等持有锁的线程释放锁后即可立即获取锁，这样就避免用户线程和内核的切换的消耗。</strong></p>
<ul>
<li>在轻量级锁状态下继续锁竞争，<strong>没有抢到锁的线程将自旋</strong>，即不停地循环判断锁是否能够被成功获取。长时间的自旋操作是非常消耗资源的，一个线程持有锁，其他线程就只能在原地空耗CPU，执行不了任何有效的任务，这种现象叫做<strong>忙等（busy-waiting）</strong>。如果锁竞争情况严重，某个达到最大自旋次数的线程，会将轻量级锁升级为<code>重量级锁</code>。</li>
</ul>
<h4 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h4><p><strong>重量级锁：其他线程试图获取锁时，都会被阻塞，只有持有锁的线程释放锁之后才会唤醒这些线程。</strong></p>
<p>当后续线程尝试获取锁时，发现被占用的锁是重量级锁，则直接将自己挂起，等待将来被唤醒。对比JDK1.6之前，synchronized直接加重量级锁，现在很明显现在得到了很好的优化</p>
<p>依靠java内置对象monitor实现的锁</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>使用场景</th>
</tr>
</thead>
<tbody><tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，线程上下文切换耗费资源大，响应时间缓慢</td>
<td>追求吞吐量。同步块执行速度较长。</td>
</tr>
</tbody></table>
<h4 id="锁升级场景"><a href="#锁升级场景" class="headerlink" title="锁升级场景"></a>锁升级场景</h4><blockquote>
<p>场景1： 经常只有某一个线程来加锁。</p>
</blockquote>
<ul>
<li>加锁过程：也许获取锁的经常为同一个线程，这种情况下为了避免加锁造成的性能开销，加<strong>偏向锁</strong>。</li>
<li>偏向锁的执行流程如下：<ul>
<li>1、线程首先检查该对象头的线程ID是否为当前线程；</li>
<li>2、<code>A：</code>如果对象头的线程ID和当前线程ID一直，则直接执行代码；<code>B：</code>如果不是当前线程ID则使用CAS方式替换对象头中的线程ID，如果使用CAS替换不成功则说明有线程正在执行，存在锁的竞争，这时需要撤销偏向锁，升级为<strong>轻量级锁</strong>。</li>
<li>3、如果CAS替换成功，则把对象头的线程ID改为自己的线程ID，然后执行代码。</li>
<li>4、执行代码完成之后释放锁，把对象头的线程ID修改为空。</li>
</ul>
</li>
</ul>
<blockquote>
<p>场景2： 有线程来参与锁的竞争，但是获取锁的冲突时间很短。</p>
</blockquote>
<ul>
<li><strong>当开始有锁的竞争了，那么偏向锁就会升级到轻量级锁；</strong></li>
<li>线程获取锁出现冲突时，线程必须做出决定是继续在这里等，还是先去做其他事情，等会再来看看，而轻量级锁的采用了继续在这里等的方式。当发现有锁竞争，线程首先会使用自旋的方式循环在这里获取锁，因为使用自旋的方式非常消耗CPU。当一定时间内通过自旋的方式无法获取到锁的话，那么锁就开始升级为重量级锁了。</li>
</ul>
<blockquote>
<p>场景3： 有大量的线程参与锁的竞争，冲突性很高。</p>
</blockquote>
<ul>
<li>当获取锁冲突多，时间越长的时候，线程肯定无法继续在这里死等了，所以只好先挂起，然后等前面获取锁的线程释放了锁之后，再开启下一轮的锁竞争，而这种形式就是我们的重量级锁。</li>
</ul>
<p>CHL同步队列与条件队列</p>
<p>公平锁与非公平锁</p>
<p>reentrantLock是独占锁</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210907225841711.png" alt="image-20210907225841711"></p>
<p>AQS节点的唤醒，唤醒的是同步队列的head指向的next节点。</p>
<p>Reentrantlock.lock 分析</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">public final void acquire(<span class="hljs-built_in">int</span> arg) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">try</span><span class="hljs-constructor">Acquire(<span class="hljs-params">arg</span>)</span> &amp;&amp;<br>        acquire<span class="hljs-constructor">Queued(<span class="hljs-params">addWaiter</span>(Node.EXCLUSIVE)</span>, arg))<br>        self<span class="hljs-constructor">Interrupt()</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Semaphore的使用 acquire方法分析</p>
<p>park、unpark方法阻塞线程 </p>
<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><p>HashMap 1.7 = 数组 + 单向链表<br>扩容时可能会产生死锁，多线程扩容时链表倒插可能产生闭环</p>
<p>ConcurrentHashMap 1.7 = Segment数组（继承ReentrantLock） + hashEntry数组 + 链表,从而实现分段锁，支持并发</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210927235446858.png" alt="image-20210927235446858"></p>
<p>HashMap 1.8 = 数组 + 单向链表。扩容时不会倒插，而是采用高低位插入，Node的hash 值&amp;（扩容后-1）最高位=1则扩容后下标=扩容前大小+原下标，否则=原下标</p>
<p>ConcurrentHashMap 1.8 = Node数组 +  链表，区别在于每次插入，都synchronize第一个节点，相同于锁一条链表，并且通过CAS的算法插入每个链表的第一个阶段，从而达到并发，锁的粒度较小，灵活</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210928000406955.png" alt="image-20210928000406955"></p>
<h1 id="线程池原理与解读"><a href="#线程池原理与解读" class="headerlink" title="线程池原理与解读"></a>线程池原理与解读</h1><p>线程池的优势：</p>
<p>1、重用存在的线程，减少线程创建，消亡的开销（开辟的空间处理，操作内核空间时间的消耗），提高性能</p>
<p>2、提高响应速度（直接取，无需等待)</p>
<p>3、提高对线程的管理，方便进行统一分配、调优和监控</p>
<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><h2 id="线程池的工作原理"><a href="#线程池的工作原理" class="headerlink" title="线程池的工作原理"></a>线程池的工作原理</h2><p>核心线程</p>
<p>阻塞队列</p>
<p>非核心线程</p>
<p>拒绝策略</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B02Synchronize&AQS/image-20210928233525697.png" alt="image-20210928233525697"></p>
<h3 id="线程池重点属性"><a href="#线程池重点属性" class="headerlink" title="线程池重点属性"></a>线程池重点属性</h3><h3 id="线程池状态流转"><a href="#线程池状态流转" class="headerlink" title="线程池状态流转"></a>线程池状态流转</h3><h3 id="fork-join-分发线程池"><a href="#fork-join-分发线程池" class="headerlink" title="fork/join 分发线程池"></a>fork/join 分发线程池</h3><h3 id="定时任务-定时任务线程池"><a href="#定时任务-定时任务线程池" class="headerlink" title="定时任务/定时任务线程池"></a>定时任务/定时任务线程池</h3>]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Synchronized</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程04-juc-Tools</title>
    <url>/2021/10/31/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B04-juc-Tools/</url>
    <content><![CDATA[<h1 id="Juc-Tools"><a href="#Juc-Tools" class="headerlink" title="Juc-Tools"></a>Juc-Tools</h1><p>以下都是共享模式</p>
<h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p>​    public Semaphore(int permits) </p>
<p>​    public Semaphore(int permits, boolean fair) </p>
<p>permits 表示许可线程的数量 fair 表示公平性，如果这个设为 true 的话，下次执行的线程会是等待最久的线 程 </p>
<h3 id="重要方法"><a href="#重要方法" class="headerlink" title="重要方法"></a>重要方法</h3><pre><code> public void acquire()
</code></pre>
<p>​     public void release() </p>
<p>​     public tryAcquire（long timeout, TimeUnit unit） </p>
<p>acquire() 表示阻塞并获取许可 release() 表示释放许可 </p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>​    <strong>需求场景</strong>:资源访问，服务限流。</p>
<h3 id="example"><a href="#example" class="headerlink" title="example"></a>example</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SemaphoreSample</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Semaphore semaphore = <span class="hljs-keyword">new</span> Semaphore(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++)&#123;<br>            <span class="hljs-keyword">new</span> Task(semaphore,<span class="hljs-string">&quot;handsome+&quot;</span>+i).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Thread</span></span>&#123;<br>        Semaphore semaphore;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Task</span><span class="hljs-params">(Semaphore semaphore,String tname)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.semaphore = semaphore;<br>            <span class="hljs-keyword">this</span>.setName(tname);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                semaphore.acquire();<br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:aquire() at time:&quot;</span>+System.currentTimeMillis());<br>                Thread.sleep(<span class="hljs-number">1000</span>);<br><br>                System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;:release() at time:&quot;</span>+System.currentTimeMillis());<br>                semaphore.release();<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>有主次之分，注重对分支线程的结果在主线程汇总处理</p>
<p>例如多excel处理多个sheet，最后对每个sheet的处理结果汇总处理</p>
<h3 id="CountDownLatch是什么？"><a href="#CountDownLatch是什么？" class="headerlink" title="CountDownLatch是什么？"></a>CountDownLatch是什么？</h3><p>​    CountDownLatch这个类能够使一个线程等待其他线程完成各自的工作后再执行。例如，应用程序的主线程希望在负责启动框架服务的线程已经启动所有的框架服务之后再执行</p>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><p>​    CountDownLatch.countDown() </p>
<p>​    CountDownLatch.await();</p>
<h3 id="CountDownLatch应用场景例子"><a href="#CountDownLatch应用场景例子" class="headerlink" title="CountDownLatch应用场景例子"></a>CountDownLatch应用场景例子</h3><p>​    比如陪媳妇去看病。 医院里边排队的人很多，如果一个人的话，要先看大夫，看完大夫再去排队交钱取药。 现在我们是双核，可以同时做这两个事（多线程）。 </p>
<p>​    假设看大夫花3秒钟，排队交费取药花5秒钟。我们同时搞的话，5秒钟我们就能完成，然后 一起回家（回到主线程）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLaunchSample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> now = System.currentTimeMillis();<br>        CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> SeeDoctorTask(countDownLatch)).start();<br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> QueueTask(countDownLatch)).start();<br>        <span class="hljs-comment">//等待线程池中的2个任务执行完毕，否则一直</span><br>        countDownLatch.await();<br>        System.out.println(<span class="hljs-string">&quot;over，回家 cost:&quot;</span>+(System.currentTimeMillis()-now));<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">QueueTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">QueueTask</span><span class="hljs-params">(CountDownLatch countDownLatch)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.countDownLatch = countDownLatch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始在医院药房排队买药....&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            System.out.println(<span class="hljs-string">&quot;排队成功，可以开始缴费买药&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (countDownLatch != <span class="hljs-keyword">null</span>)<br>                countDownLatch.countDown();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeeDoctorTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SeeDoctorTask</span><span class="hljs-params">(CountDownLatch countDownLatch)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.countDownLatch = countDownLatch;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;开始看医生&quot;</span>);<br>            Thread.sleep(<span class="hljs-number">2000</span>);<br>            System.out.println(<span class="hljs-string">&quot;看医生结束，准备离开病房&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (countDownLatch != <span class="hljs-keyword">null</span>)<br>                countDownLatch.countDown();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="原理解析"><a href="#原理解析" class="headerlink" title="原理解析"></a>原理解析</h3><p>CountDownLatch内部结构</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B04-juc-Tools/image-20221102084938034.png" alt="image-20221102084938034"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CountDownLatch</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Sync sync;<br>   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">4982264981922014374L</span>;<br>        Sync(<span class="hljs-keyword">int</span> count) &#123;<br>            setState(count);<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState();<br>        &#125;<br>        <br>        <span class="hljs-comment">//当state状态值变成0时,表示获取锁失败</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> <span class="hljs-title">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> (getState() == <span class="hljs-number">0</span>) ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        <span class="hljs-comment">//释放锁，减法后state=0，返回true, &gt;1返回false</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>            <span class="hljs-comment">// Decrement count; signal when transition to zero</span><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> c = getState();<br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">int</span> nextc = c-<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(c, nextc))<br>                    <span class="hljs-keyword">return</span> nextc == <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CountDownLatch</span><span class="hljs-params">(<span class="hljs-keyword">int</span> count)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (count &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;count &lt; 0&quot;</span>);<br>        <span class="hljs-keyword">this</span>.sync = <span class="hljs-keyword">new</span> Sync(count);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//共享模式入队等待获取锁</span><br>        sync.acquireSharedInterruptibly(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">await</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, TimeUnit unit)</span></span><br><span class="hljs-function">        <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.tryAcquireSharedNanos(<span class="hljs-number">1</span>, unit.toNanos(timeout));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">countDown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//1、释放一个资源 2、如果释放后state=0,则唤醒所有共享模式的排队节点</span><br>        sync.releaseShared(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> sync.getCount();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>调用链路</strong></p>
<p>图中浅黄色部分为CountDownLatch的方法调用，浅绿色为AQS，浅蓝色为内部类Sync。这里模拟了在主线程中提交两个子任务。</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B04-juc-Tools/image-20221102090927183.png" alt="image-20221102090927183"></p>
<p>​    至此为止，我们就从头到尾将CountDownLatch从应用到源码都讲解了一遍。在应用演示部分，只是举了一个很简单的例子，但足够具有代表性。在对源码的解读部分，主要还是基于对AQS中共享模式的理解。我个人认为，AQS是一个抽象程度比较高的框架，CountDownLatch是利用这种抽象实现了一种具体的功能。所以，如果业务中出现了某种特殊的应用场景，又没有通用的组件可以直接使用，那么从什么角度去利用AQS的抽象，将是我们需要思考的问题。</p>
<h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>​    栅栏屏障，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程 到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。 CyclicBarrier默认的构造方法是CyclicBarrier（int parties），其参数表示屏障拦截的线 程数量，每个线程调用await方法告CyclicBarrier我已经到达了屏障，然后当前线程被阻塞。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CyclicBarrierTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> CyclicBarrier cyclicBarrier;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index ;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CyclicBarrierTest</span><span class="hljs-params">(CyclicBarrier cyclicBarrier, <span class="hljs-keyword">int</span> index)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cyclicBarrier = cyclicBarrier;<br>        <span class="hljs-keyword">this</span>.index = index;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;index: &quot;</span> + index +  <span class="hljs-string">&quot;准备就绪&quot;</span>);<br>            cyclicBarrier.await();<br>            System.out.println(<span class="hljs-string">&quot;index: &quot;</span> + index +  <span class="hljs-string">&quot;开始干活&quot;</span>);<br>            <br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CyclicBarrier cyclicBarrier = <span class="hljs-keyword">new</span> CyclicBarrier(<span class="hljs-number">10</span>, <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;所有特工到达屏障，准备开始执行秘密任务&quot;</span>);<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> CyclicBarrierTest(cyclicBarrier, i)).start();<br>        &#125;<br>    &#125;<br><br>&#125;<br>index: <span class="hljs-number">1</span>准备就绪<br>index: <span class="hljs-number">2</span>准备就绪<br>index: <span class="hljs-number">0</span>准备就绪<br>index: <span class="hljs-number">5</span>准备就绪<br>index: <span class="hljs-number">6</span>准备就绪<br>index: <span class="hljs-number">4</span>准备就绪<br>index: <span class="hljs-number">3</span>准备就绪<br>index: <span class="hljs-number">7</span>准备就绪<br>index: <span class="hljs-number">8</span>准备就绪<br>index: <span class="hljs-number">9</span>准备就绪<br>所有特工到达屏障，准备开始执行秘密任务<br>index: <span class="hljs-number">9</span>开始干活<br>index: <span class="hljs-number">0</span>开始干活<br>index: <span class="hljs-number">4</span>开始干活<br>index: <span class="hljs-number">2</span>开始干活<br>index: <span class="hljs-number">1</span>开始干活<br>index: <span class="hljs-number">8</span>开始干活<br>index: <span class="hljs-number">7</span>开始干活<br>index: <span class="hljs-number">3</span>开始干活<br>index: <span class="hljs-number">6</span>开始干活<br>index: <span class="hljs-number">5</span>开始干活<br></code></pre></td></tr></table></figure>

<h4 id="CyclicBarrier和CountDownLatch的区别"><a href="#CyclicBarrier和CountDownLatch的区别" class="headerlink" title="CyclicBarrier和CountDownLatch的区别"></a>CyclicBarrier和CountDownLatch的区别</h4><p>​    <strong>CountDownLatch</strong>(基于AQS)：有主次之分，注重对分支线程的结果在主线程汇总处理；一旦计数器归零，就无法重置，因此不能重用。</p>
<p>​    <strong>CyclicBarrier</strong>(基于ReentrantLock)：基本具备CountDownLatch的能力，且可重复触发的。比如3个线程想斗地主，得凑齐3个人才能进行，一轮结束后，继续凑够三人又可以进行下一轮，无需重复触发，像CountDownLatch需要从新await才能起作用。</p>
<table>
<thead>
<tr>
<th></th>
<th>CountDownLatch</th>
<th>CyclicBarrier</th>
</tr>
</thead>
<tbody><tr>
<td>底层实现</td>
<td>基于AQS，CAS操作将state</td>
<td>基于Reentranlock，Condition等待唤醒</td>
</tr>
<tr>
<td>可重用性</td>
<td>一次性</td>
<td>可重用（触发一次屏障操作后，计数器重新初始化）</td>
</tr>
<tr>
<td>使用场景</td>
<td>子任务全部执行完，主任务汇总</td>
<td>所有任务等待达到某个状态，再一起开始执行</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程09-定时任务&amp;定时线程池(非重点)</title>
    <url>/2021/11/28/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&amp;%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/</url>
    <content><![CDATA[<h1 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h1><h2 id="定时线程池类的类结构图"><a href="#定时线程池类的类结构图" class="headerlink" title="定时线程池类的类结构图"></a>定时线程池类的类结构图</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128162622219.png" alt="image-20211128162622219"></p>
<h2 id="内部原理"><a href="#内部原理" class="headerlink" title="内部原理"></a>内部原理</h2><p>​    它用来处理延时任务或定时任务。</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128162931788.png" alt="image-20211128162931788"></p>
<p>它接收<strong>SchduledFutureTask</strong>类型的任务，是线程池调度任务的最小单位，有三 种提交任务的方式：</p>
<ol>
<li>schedule </li>
<li> scheduledAtFixedRate (固定频率，无论任务有没完成，都生成新的任务待执行)</li>
<li>scheduledWithFixedDelay(固定延迟时间，任务完成后才都生成新的延迟任务)</li>
</ol>
<p>它采用DelayQueue存储等待的任务 </p>
<pre><code>1. DelayQueue内部封装了一个PriorityQueue，它会根据time的先后时间排序，若time相同则根据sequenceNumber排序； 
 2. DelayQueue也是一个无界队列；
</code></pre>
<h2 id="SchduledFutureTask"><a href="#SchduledFutureTask" class="headerlink" title="SchduledFutureTask"></a>SchduledFutureTask</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128163755450.png" alt="image-20211128163755450"></p>
<p>工作线程的执行过程： </p>
<p>​    工作线程会从DelayQueue取已经到期的任务去执行； 执行结束后重新设置任务的到期时间，再次放回DelayQueue<br>​    ScheduledThreadPoolExecutor会把待执行的任务放到工作队列 DelayQueue中，DelayQueue封装了一个PriorityQueue，PriorityQueue会对 队列中的ScheduledFutureTask进行排序</p>
<h3 id="SchduledFutureTask之run方法实现"><a href="#SchduledFutureTask之run方法实现" class="headerlink" title="SchduledFutureTask之run方法实现"></a>SchduledFutureTask之run方法实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> periodic = isPeriodic();<br>    <span class="hljs-keyword">if</span> (!canRunInCurrentRunState(periodic))<br>        cancel(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!periodic)<br>        ScheduledFutureTask.<span class="hljs-keyword">super</span>.run();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ScheduledFutureTask.<span class="hljs-keyword">super</span>.runAndReset()) &#123;<br>        setNextRunTime();<br>        reExecutePeriodic(outerTask);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ol>
<li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行 步骤2； </li>
<li>如果不是周期性任务，调用FutureTask中的run方法执行，会设置执行结果，然后 直接返回，否则执行步骤3； </li>
<li>如果是周期性任务，调用FutureTask中的runAndReset方法执行，不会设置执行 结果，然后直接返回，否则执行步骤4和步骤5； </li>
<li>计算下次执行该任务的具体时间； </li>
<li>重复执行任务。    </li>
</ol>
<h2 id="线程池任务的提交"><a href="#线程池任务的提交" class="headerlink" title="线程池任务的提交"></a>线程池任务的提交</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ScheduledExecutorService scheduler =<br>                Executors.newScheduledThreadPool(<span class="hljs-number">10</span>);<br>        scheduler.schedule(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;schedule只执行一次的任务&quot;</span>);<br>        &#125;, <span class="hljs-number">0</span>, TimeUnit.SECONDS );<br><br>        scheduler.scheduleAtFixedRate(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;scheduleAtFixedRate固定频率执行&quot;</span>);<br>        &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br><br>        scheduler.scheduleWithFixedDelay(()-&gt;&#123;<br>            System.out.println(<span class="hljs-string">&quot;scheduleAtFixedRate固定延迟执行&quot;</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">1000L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;,<span class="hljs-number">1</span>,<span class="hljs-number">5</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br>schedule只执行一次的任务<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行 - 固定频率<br>scheduleAtFixedRate固定频率执行 - 固定频率<br>scheduleAtFixedRate固定延迟执行<br>scheduleAtFixedRate固定频率执行<br>......<br></code></pre></td></tr></table></figure>

<h2 id="DelayedWorkQueue"><a href="#DelayedWorkQueue" class="headerlink" title="DelayedWorkQueue"></a>DelayedWorkQueue</h2><p>​    ScheduledThreadPoolExecutor之所以要自己实现阻塞的工作队列，是因为 ScheduledThreadPoolExecutor要求的工作队列有些特殊。 DelayedWorkQueue是一个基于堆的数据结构，类似于DelayQueue和 PriorityQueue。在执行定时任务的时候，每个任务的执行时间都不同，所以 DelayedWorkQueue的工作就是按照执行时间的升序来排列，执行时间距离当前时间越近 的任务在队列的前面（注意：这里的顺序并不是绝对的，堆中的排序只保证了子节点的下次 执行时间要比父节点的下次执行时间要大，而叶子节点之间并不一定是顺序的，下文中会说明）。</p>
<p>堆结构如下图：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128172423526.png" alt="image-20211128172423526"></p>
<p>可见，DelayedWorkQueue是一个基于最小堆结构的队列。堆结构可以使用数 组表示，可以转换成如下的数组：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B09-%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1&%E5%AE%9A%E6%97%B6%E7%BA%BF%E7%A8%8B%E6%B1%A0/image-20211128172520637.png" alt="image-20211128172520637"></p>
<p>在这种结构中，可以发现有如下特性： 假设，索引值从0开始，子节点的索引值为k，父节点的索引值为p，则： 1     一个节点的左子节点的索引为：k = p * 2 + 1；</p>
<p>​    一个节点的右子节点的索引为：k = (p + 1) * 2； </p>
<p>​     一个节点的父节点的索引为：p = (k - 1) / 2。</p>
<h2 id="如何保证每次取出的任务是优先级最大的"><a href="#如何保证每次取出的任务是优先级最大的" class="headerlink" title="如何保证每次取出的任务是优先级最大的"></a>如何保证每次取出的任务是优先级最大的</h2><p>​    答：在任务提交进入队列时，保持DelayedWorkQueue的第一个总是最小的,通过递归对比即将插入下标结点的父节点，将最小结点层层上移，最终保证队列的第一个元素始终是最小的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">siftUp</span><span class="hljs-params">(<span class="hljs-keyword">int</span> k, RunnableScheduledFuture&lt;?&gt; key)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (k &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">//即将插入下标结点的父节点下标</span><br>        <span class="hljs-keyword">int</span> parent = (k - <span class="hljs-number">1</span>) &gt;&gt;&gt; <span class="hljs-number">1</span>;<br>        RunnableScheduledFuture&lt;?&gt; e = queue[parent];<br>        <span class="hljs-keyword">if</span> (key.compareTo(e) &gt;= <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>        queue[k] = e;<br>        setIndex(e, k);<br>        k = parent;<br>    &#125;<br>    queue[k] = key;<br>    setIndex(key, k);<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>定时任务</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优01Mysql索引底层原理</title>
    <url>/2021/11/29/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="深入理解Mysql索引底层数据结构与算法"><a href="#深入理解Mysql索引底层数据结构与算法" class="headerlink" title="深入理解Mysql索引底层数据结构与算法"></a>深入理解Mysql索引底层数据结构与算法</h1><h2 id="索引是什么"><a href="#索引是什么" class="headerlink" title="索引是什么"></a>索引是什么</h2><p>​    <strong>索引</strong>是帮助MySQL高效获取数据的<strong>排好序的数据结构</strong></p>
<h2 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206223233336.png" alt="image-20211206223233336"></p>
<p>缺点：</p>
<ul>
<li>索引树的高度 &gt;= log2N + 1 高度可能较高，不可控</li>
<li>索引步骤同样不可控，效率较低</li>
<li>可能形成单向链表、索引效果底下</li>
</ul>
<h3 id="红黑树-效率比二叉树高"><a href="#红黑树-效率比二叉树高" class="headerlink" title="红黑树 (效率比二叉树高)"></a>红黑树 (效率比二叉树高)</h3><p>缺点：</p>
<ul>
<li>可能存在自旋，维护复杂</li>
<li>高度不可控（千万级别数据，层数高）</li>
</ul>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206231403113.png" alt="image-20211206231403113"></p>
<h3 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h3><p>特点：</p>
<ul>
<li>叶节点具有相同的深度</li>
<li>索引元素不重复</li>
<li>节点从左到右递增</li>
</ul>
<p>缺点：</p>
<ul>
<li>索引树的高度依旧不可控（因为mysql一般规定一个节点16kb，如果使用InnoDB存储引擎且是主建索引，则value存储的可能就是整个表数据，这会导致每个节点存储的接口个数较少，导致层数增大）</li>
</ul>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206231426218.png" alt="image-20211206231426218"></p>
<h3 id="Mysql的B-Tree-原B-Tree叶子结点是单向指针"><a href="#Mysql的B-Tree-原B-Tree叶子结点是单向指针" class="headerlink" title="Mysql的B+Tree(原B+Tree叶子结点是单向指针)"></a>Mysql的B+Tree(原B+Tree叶子结点是单向指针)</h3><p>特点</p>
<ul>
<li>非叶子节点不存储data，只存储索引（叶子结点会冗余），因此可以放更多的索引</li>
<li>叶子结点包含所有的索引字段</li>
<li>叶子结点之间通过指针双向连接，提高区间访问的性能</li>
</ul>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206233052712.png" alt="image-20211206233052712"></p>
<h3 id="Mysql的Hash索引"><a href="#Mysql的Hash索引" class="headerlink" title="Mysql的Hash索引"></a>Mysql的Hash索引</h3><p>维护索引列值的hash值和所在行的磁盘空间地址的关系表，可以快速查询出某个值所在行。</p>
<h4 id="存在什么问题："><a href="#存在什么问题：" class="headerlink" title="存在什么问题："></a>存在什么问题：</h4><p>​    不支持范围查询、模糊查询，排序，</p>
<h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><p>单等值查询非常快</p>
<h2 id="索引是怎么支撑千万级表的快速查找"><a href="#索引是怎么支撑千万级表的快速查找" class="headerlink" title="索引是怎么支撑千万级表的快速查找"></a>索引是怎么支撑千万级表的快速查找</h2><p>使用B+树缩影，假设树的高度 h = 3，一个节点大小限制16k，主建索引，bigint = 8B,指针连接</p>
<p>=6B。总叶子结点 = （16<em>1024/14） *  （16</em>1024/14） * 16 = 21902400 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211206233732916.png" alt="image-20211206233732916"></p>
<h2 id="InnoDB存储引擎索引实现"><a href="#InnoDB存储引擎索引实现" class="headerlink" title="InnoDB存储引擎索引实现"></a>InnoDB存储引擎索引实现</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207232002050.png" alt="image-20211207232002050"></p>
<h3 id="MYSQL5-7"><a href="#MYSQL5-7" class="headerlink" title="MYSQL5.7"></a>MYSQL5.7</h3><h4 id="MYISAM存储引擎"><a href="#MYISAM存储引擎" class="headerlink" title="MYISAM存储引擎"></a>MYISAM存储引擎</h4><p>​        .frm 表结构</p>
<p>​        .MYD 表数据</p>
<p>​        .MYI 表索引</p>
<h4 id="MyISAM索引文件和数据文件是分离的-非聚集"><a href="#MyISAM索引文件和数据文件是分离的-非聚集" class="headerlink" title="MyISAM索引文件和数据文件是分离的(非聚集)"></a>MyISAM索引文件和数据文件是分离的(非聚集)</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207235410948.png" alt="image-20211207235410948"></p>
<h3 id="INNODB存储引擎"><a href="#INNODB存储引擎" class="headerlink" title="INNODB存储引擎"></a>INNODB存储引擎</h3><p>​        .frm 表结构</p>
<p>​        .ibd 表数据</p>
<h4 id="InnoDB的主建索引（聚簇索引）"><a href="#InnoDB的主建索引（聚簇索引）" class="headerlink" title="InnoDB的主建索引（聚簇索引）"></a>InnoDB的主建索引（聚簇索引）</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207235514358.png" alt="image-20211207235514358"></p>
<h4 id="InnoDB的非主键索引（非聚簇索引）"><a href="#InnoDB的非主键索引（非聚簇索引）" class="headerlink" title="InnoDB的非主键索引（非聚簇索引）"></a>InnoDB的非主键索引（非聚簇索引）</h4><p>​    通过检索二级索引树查到对应主建，在检索主建索引树</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207235521058.png" alt="image-20211207235521058"></p>
<h3 id="什么是聚簇索引和非聚簇索引"><a href="#什么是聚簇索引和非聚簇索引" class="headerlink" title="什么是聚簇索引和非聚簇索引"></a>什么是聚簇索引和非聚簇索引</h3><p>​    聚簇索引：索引结构和表数据存储在一起的索引</p>
<p>​    非聚簇索引：索引结构和表数据存储分开存储的索引</p>
<h3 id="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"><a href="#为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？" class="headerlink" title="为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？"></a>为什么InnoDB表必须有主键，并且推荐使用整型的自增主键？</h3><p>1、为什么推荐声明主建</p>
<p>答：B+树索引数据结构就是根据某个唯一索引组装而成的，就算不声明主建，Mysql也会自动生成一个唯一序列号作为key去构建整棵树</p>
<p>2、为什么推荐整形</p>
<p>答：如果用字符串，还得统一装换成ASCALL码进行比较大小，如果是整形则比较更加便捷<br>3、为什么推荐自增</p>
<p>答：B+树在逐步构建时都是某个节点满了才向右扩充，如果这个时候插入某一个值且这个值要放在已经满了的节点，则容易造成B+树频繁调整，维护麻烦。（自增插入的话，只会影响右下角区域的数据调整）</p>
<h3 id="为什么非主键索引结构叶子节点存储的是主键值？-一致性和节省存储空间"><a href="#为什么非主键索引结构叶子节点存储的是主键值？-一致性和节省存储空间" class="headerlink" title="为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)"></a>为什么非主键索引结构叶子节点存储的是主键值？(一致性和节省存储空间)</h3><p>1、节省存储空间，存在多个索引时，只有主键索引才包含所有数据，其他索引只冗余主建id，这样可以大大节约空间</p>
<p>2、如果多个索引都维护所有数据，那势必会有维护复杂，数据一致性问题，事倍功半。</p>
<h3 id="联合索引的底层存储结构长什么样"><a href="#联合索引的底层存储结构长什么样" class="headerlink" title="联合索引的底层存储结构长什么样"></a>联合索引的底层存储结构长什么样</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9801Mysql%E7%B4%A2%E5%BC%95%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/image-20211207234827138.png" alt="image-20211207234827138"></p>
<h3 id="InnoDB-和-MyIsam-引擎的区别"><a href="#InnoDB-和-MyIsam-引擎的区别" class="headerlink" title="InnoDB 和 MyIsam 引擎的区别"></a>InnoDB 和 MyIsam 引擎的区别</h3><table>
<thead>
<tr>
<th>特性</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td><strong>事务支持</strong></td>
<td>是 支持ACID</td>
<td>否</td>
</tr>
<tr>
<td><strong>锁定级别</strong></td>
<td>行级锁定</td>
<td>表级锁定</td>
</tr>
<tr>
<td><strong>外键支持</strong></td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>崩溃恢复</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>全文本搜索</td>
<td>是（复杂）</td>
<td>是（简单）</td>
</tr>
<tr>
<td>读性能</td>
<td>一般</td>
<td>较好</td>
</tr>
<tr>
<td>写性能</td>
<td>一般</td>
<td>较差</td>
</tr>
<tr>
<td>适用场景</td>
<td>OLTP应用，事务处理</td>
<td>读密集型应用，全文本搜索</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能调优</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优05-Mysql8的优化</title>
    <url>/2024/09/22/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="Mysql8与5-7的对比"><a href="#Mysql8与5-7的对比" class="headerlink" title="Mysql8与5.7的对比"></a>Mysql8与5.7的对比</h1><p>参考资料：</p>
<p>1、<a href="https://cloud.tencent.com/developer/article/2244537">MySQL 8.0 新特性解读(上)</a></p>
<p>2、<a href="https://cloud.tencent.com/developer/article/2244538">MySQL 8.0 新特性解读(下)</a></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241013230924304.png" alt="image-20241013230924304"></p>
<h2 id><a href="#" class="headerlink" title></a></h2><h2 id="系统表更换为InnoDB引擎"><a href="#系统表更换为InnoDB引擎" class="headerlink" title="系统表更换为InnoDB引擎"></a>系统表更换为InnoDB引擎</h2><p>​    系统表全部换成事务型的innodb表，默认的MySQL实例将不包含任何MyISAM表，除非手动创建MyISAM表</p>
<h2 id="默认字符集由latin1变为utf8mb4"><a href="#默认字符集由latin1变为utf8mb4" class="headerlink" title="默认字符集由latin1变为utf8mb4"></a>默认字符集由latin1变为utf8mb4</h2><p>​    在8.0版本之前，默认字符集为latin1，utf8指向的是utf8mb3，8.0版本默认字符集为utf8mb4，utf8默认指向的也是utf8mb4</p>
<h2 id="DDL原子化"><a href="#DDL原子化" class="headerlink" title="DDL原子化"></a>DDL原子化</h2><p>​    InnoDB表的DDL支持事务完整性，要么成功要么回滚，将DDL操作回滚日志写入到data dictionary 数据字典表 mysql.innodb_ddl_log 中用于回滚操作，该表是隐藏的表，通过show tables无法看到。通过设置参数，可将ddl操作日志打印输出到mysql错误日志中</p>
<h2 id="DDL秒加列"><a href="#DDL秒加列" class="headerlink" title="DDL秒加列"></a>DDL秒加列</h2><p>​    MySQL 8.0.12 开始，引入新的 DDL 算法 INSTANT ，支持快速加列，但需要注意的是，该版本仅支持将列添加到表的最后一列。</p>
<p>​    MySQL 8.0.29 开始，INSTANT 作为默认算法（在 8.0.29 之前，默认算法仍为 INPLACE ），支持将新列添加到表中的任何位置，同时支持快速删除列。</p>
<p>​    此外，INSTANT DDL 也有一个限制：一个表支持 64 次即时更改。如果超过 64 次 INSTANT 变更后的 DDL 需要“重建”表。</p>
<p>在 5.7、8.0 版本上测试对比 DDL 加列效率。</p>
<p><strong>5.7 （5.7.19）上测试如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"># MySQL <span class="hljs-number">5.7</span><br># 表结构<br>create table `t1` (<br>  `id` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> null auto_increment,<br>  `c1` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">default</span> null,<br>  `c2` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">default</span> null,<br>  `c3` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">default</span> null,<br>  primary key (`id`)<br>);<br><br># 创建存储过程 idata ，导入测试数据<br>drop procedure <span class="hljs-keyword">if</span> exists idata;<br><br>delimiter ;;<br><span class="hljs-function">create procedure <span class="hljs-title">idata</span><span class="hljs-params">()</span></span><br><span class="hljs-function">begin</span><br><span class="hljs-function">  declare i <span class="hljs-keyword">int</span></span>;<br>  <span class="hljs-built_in">set</span> i=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i&lt;=<span class="hljs-number">1000000</span>) <span class="hljs-keyword">do</span><br>    <span class="hljs-function">insert into <span class="hljs-title">t1</span> <span class="hljs-params">(c1,c2,c3)</span> <span class="hljs-title">values</span> <span class="hljs-params">(i, i+<span class="hljs-number">1</span>, i+<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-built_in">set</span> i=i+<span class="hljs-number">1</span>;<br>  end <span class="hljs-keyword">while</span>;<br>end;;<br>delimiter ;<br><br>## 设置 sync_binlog、innodb_flush_log_at_trx_commit 参数，加快后续存储过程执行写入数据<br><span class="hljs-built_in">set</span> global sync_binlog=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">set</span> global innodb_flush_log_at_trx_commit=<span class="hljs-number">2</span>;<br><br>## 导入测试数据<br><span class="hljs-function">call <span class="hljs-title">idata</span><span class="hljs-params">()</span></span>;<br><br>mysql&gt; <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(*)</span> from t1</span>;<br>+----------+<br>| count(*) |<br>+----------+<br>|  <span class="hljs-number">1000000</span> |<br>+----------+<br><span class="hljs-number">1</span> <span class="hljs-function">row in <span class="hljs-title">set</span> <span class="hljs-params">(<span class="hljs-number">0.20</span> sec)</span></span><br><span class="hljs-function"></span><br># 添加列 c4 、c5<br>mysql&gt; <span class="hljs-function">alter table t1 add column c4 <span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">11</span>)</span> <span class="hljs-keyword">default</span> null</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-function">rows <span class="hljs-title">affected</span> <span class="hljs-params">(<span class="hljs-number">1.63</span> sec)</span></span><br><span class="hljs-function">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="hljs-function"></span><br><span class="hljs-function">mysql&gt; alter table t1 add column c5 <span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">11</span>)</span> <span class="hljs-keyword">default</span> null</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-function">rows <span class="hljs-title">affected</span> <span class="hljs-params">(<span class="hljs-number">1.64</span> sec)</span></span><br><span class="hljs-function">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="hljs-function"></span><br># 删除列 c4 、c5<br>mysql&gt; alter table t1 drop column c4;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-function">rows <span class="hljs-title">affected</span> <span class="hljs-params">(<span class="hljs-number">1.75</span> sec)</span></span><br><span class="hljs-function">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="hljs-function"></span><br><span class="hljs-function">mysql&gt; alter table t1 drop column c5</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-function">rows <span class="hljs-title">affected</span> <span class="hljs-params">(<span class="hljs-number">1.63</span> sec)</span></span><br><span class="hljs-function">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="hljs-function">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span><br></code></pre></td></tr></table></figure>

<p><strong>8.0 （8.0.34）上测试如下：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"># MySQL <span class="hljs-number">8.0</span><br># 表结构<br>create table `t8` (<br>  `id` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">not</span> null auto_increment,<br>  `c1` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">default</span> null,<br>  `c2` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">default</span> null,<br>  `c3` <span class="hljs-keyword">int</span>(<span class="hljs-number">11</span>) <span class="hljs-keyword">default</span> null,<br>  primary key (`id`)<br>);<br><br># 创建存储过程 idata ，导入测试数据<br>drop procedure <span class="hljs-keyword">if</span> exists idata8;<br><br>delimiter ;;<br><span class="hljs-function">create procedure <span class="hljs-title">idata8</span><span class="hljs-params">()</span></span><br><span class="hljs-function">begin</span><br><span class="hljs-function">  declare i <span class="hljs-keyword">int</span></span>;<br>  <span class="hljs-built_in">set</span> i=<span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">while</span> (i&lt;=<span class="hljs-number">1000000</span>) <span class="hljs-keyword">do</span><br>    <span class="hljs-function">insert into <span class="hljs-title">t8</span> <span class="hljs-params">(c1,c2,c3)</span> <span class="hljs-title">values</span> <span class="hljs-params">(i, i+<span class="hljs-number">1</span>, i+<span class="hljs-number">2</span>)</span></span>;<br>    <span class="hljs-built_in">set</span> i=i+<span class="hljs-number">1</span>;<br>  end <span class="hljs-keyword">while</span>;<br>end;;<br>delimiter ;<br><br>## 同样设置 sync_binlog、innodb_flush_log_at_trx_commit 参数，加快后续存储过程执行写入数据<br><span class="hljs-built_in">set</span> global sync_binlog=<span class="hljs-number">0</span>;<br><span class="hljs-built_in">set</span> global innodb_flush_log_at_trx_commit=<span class="hljs-number">2</span>;<br><br>## 导入测试数据<br><span class="hljs-function">call <span class="hljs-title">idata8</span><span class="hljs-params">()</span></span>;<br><br>mysql&gt; <span class="hljs-function">select <span class="hljs-title">count</span><span class="hljs-params">(*)</span> from t8</span>;<br>+----------+<br>| count(*) |<br>+----------+<br>|  <span class="hljs-number">1000000</span> |<br>+----------+<br><span class="hljs-number">1</span> <span class="hljs-function">row in <span class="hljs-title">set</span> <span class="hljs-params">(<span class="hljs-number">0.06</span> sec)</span></span><br><span class="hljs-function"></span><br># 添加列 c4 、c5<br>mysql&gt; <span class="hljs-function">alter table t8 add column c4 <span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">11</span>)</span> <span class="hljs-keyword">default</span> null</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.01</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">1</span><br><br>mysql&gt; <span class="hljs-function">alter table t8 add column c5 <span class="hljs-title">int</span><span class="hljs-params">(<span class="hljs-number">11</span>)</span> <span class="hljs-keyword">default</span> null</span>;<br>Query OK, <span class="hljs-number">0</span> rows affected, <span class="hljs-number">1</span> warning (<span class="hljs-number">0.01</span> sec)<br>Records: <span class="hljs-number">0</span>  Duplicates: <span class="hljs-number">0</span>  Warnings: <span class="hljs-number">1</span><br><br># 删除列 c4 、c5<br>mysql&gt; alter table t8 drop column c4;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-function">rows <span class="hljs-title">affected</span> <span class="hljs-params">(<span class="hljs-number">0.01</span> sec)</span></span><br><span class="hljs-function">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="hljs-function"></span><br><span class="hljs-function">mysql&gt; alter table t8 drop column c5</span>;<br>Query OK, <span class="hljs-number">0</span> <span class="hljs-function">rows <span class="hljs-title">affected</span> <span class="hljs-params">(<span class="hljs-number">0.01</span> sec)</span></span><br><span class="hljs-function">Records: 0  Duplicates: 0  Warnings: 0</span><br><span class="hljs-function">123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657</span><br></code></pre></td></tr></table></figure>

<p><strong>结果对比：</strong></p>
<table>
<thead>
<tr>
<th>add/drop column</th>
<th>MySQL 5.7</th>
<th>MySQL 8.0</th>
</tr>
</thead>
<tbody><tr>
<td>add column c4</td>
<td>1.63 sec</td>
<td>0.01 sec</td>
</tr>
<tr>
<td>add column c5</td>
<td>1.64 sec</td>
<td>0.01 sec</td>
</tr>
<tr>
<td>drop column c4</td>
<td>1.75 sec</td>
<td>0.01 sec</td>
</tr>
<tr>
<td>drop column c5</td>
<td>1.63 sec</td>
<td>0.01 sec</td>
</tr>
</tbody></table>
<h2 id="通用表表达式（CTE-Common-Table-Expression）"><a href="#通用表表达式（CTE-Common-Table-Expression）" class="headerlink" title="通用表表达式（CTE:Common Table Expression）"></a>通用表表达式（CTE:Common Table Expression）</h2><p>​    CTE(Common Table Expression)可以认为是派生表(derived table)或者视图的替代，在一定程度上，CTE简化了复杂的join查询和子查询，另外CTE可以很方便地实现递归查询，提高了SQL的可读性和执行性能。CTE是ANSI SQL 99标准的一部分，在MySQL 8.0.1版本被引入。CTE和派生表最大的区别在于，CTE先定义，后续可以无限嵌套使用前面定义的CTE</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20240922171104532.png" alt="image-20240922171104532"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20240922171704769.png" alt="image-20240922171704769"></p>
<p>cte1(id) 表示这个派生表或者表达式内有一个字段 id</p>
<h3 id="递归表达式"><a href="#递归表达式" class="headerlink" title="递归表达式"></a>递归表达式</h3><p>使用递归CET的使用需要注意递归终止条件，mysql默认内置了最大的递归执行深度和执行时间</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241013232258426.png" alt="image-20241013232258426"></p>
<p>举例：递归查询员工的上级路径</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241013233551420.png" alt="image-20241013233551420"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241013233614243.png" alt="image-20241013233614243"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241013233634348.png" alt="image-20241013233634348"> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241013234426514.png" alt="image-20241013234426514"></p>
<p>利用CTE实现斐波那契数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">with recursive fib (n1, n2) as (<br>select 0, 1<br>union all<br>select n2, n1 + n2 from fib where n1 &lt; 10000<br>)<br>select n1 from fib;<br></code></pre></td></tr></table></figure>

<h2 id="窗口函数（重要）"><a href="#窗口函数（重要）" class="headerlink" title="窗口函数（重要）"></a>窗口函数（重要）</h2><p>​    在每一条记录都执行窗口内的函数。有点类似在select 的查询字段里写子查询，它可以用来实现若干新的查询方式。窗口函数与 SUM()、COUNT() 这种聚合函数类似，但它不会将多行查询结果合并为一行，而是将结果放回多行当中。即窗口函数不需要 GROUP BY，比如</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241015235313494.png" alt="image-20241015235313494"></p>
<p>还有其他专用窗口函数，用的比较少。</p>
<p>​    <img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/0766334f6c0f454e989e422a6c25324c.png" alt="img"></p>
<h2 id="角色管理"><a href="#角色管理" class="headerlink" title="角色管理"></a>角色管理</h2><p>​    角色可以认为是一些权限的集合，为用户赋予统一的角色，权限的修改直接通过角色来进行，无需为每个用户单独授权。</p>
<h2 id="索引增强（重要）"><a href="#索引增强（重要）" class="headerlink" title="索引增强（重要）"></a>索引增强（重要）</h2><h3 id="1、降序索引"><a href="#1、降序索引" class="headerlink" title="1、降序索引"></a>1、降序索引</h3><h3 id="2、隐藏索引"><a href="#2、隐藏索引" class="headerlink" title="2、隐藏索引"></a>2、隐藏索引</h3><h3 id="3、函数索引"><a href="#3、函数索引" class="headerlink" title="3、函数索引"></a>3、函数索引</h3><h2 id="锁定语句选项"><a href="#锁定语句选项" class="headerlink" title="锁定语句选项"></a>锁定语句选项</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241017222908369.png" alt="image-20241017222908369">select for update跳过锁等待</p>
<h2 id="自适应参数"><a href="#自适应参数" class="headerlink" title="自适应参数"></a>自适应参数</h2><p>将innodb_dedicated_server开启的时候，它可以自动的调整下面这四个参数的值：</p>
<p>innodb_buffer_pool_size 总内存大小<br>innodb_log_file_size redo文件大小<br>innodb_log_files_in_group redo文件数量<br>innodb_flush_method 数据刷新方法</p>
<h2 id="JSON增强"><a href="#JSON增强" class="headerlink" title="JSON增强"></a>JSON增强</h2><p>​    MySQL 8 大幅改进了对 JSON 的支持，添加了基于路径查询参数从 JSON 字段中抽取数据的 JSON_EXTRACT() 函数，以及用于将数据分别组合到 JSON 数组和对象中的 JSON_ARRAYAGG() 和 JSON_OBJECTAGG() 聚合函数。</p>
<p>​    在主从复制中，新增参数 binlog_row_value_options，控制JSON数据的传输方式，允许对于Json类型部分修改，在binlog中只记录修改的部分，减少json大数据在只有少量修改的情况下，对资源的占用。</p>
<h2 id="join连接增强"><a href="#join连接增强" class="headerlink" title="join连接增强"></a>join连接增强</h2><p>已有连接算法：</p>
<p>1、Nested-Loop Join 算法——嵌套循环连接（有索引时快）</p>
<p>2、Block Nested-Loop Join 算法——基于块的嵌套循环连接（无索引时快）</p>
<h3 id="Hash-Join"><a href="#Hash-Join" class="headerlink" title="Hash Join"></a>Hash Join</h3><p>​    Hash Join是针对equal-join场景的优化，基本思想是，将外表数据load到内存，并建立hash表，这样只需要遍历一遍内表，就可以完成join操作，输出匹配的记录。如果数据能全部load到内存当然好，逻辑也简单，一般称这种join为CHJ(Classic Hash Join)，之前MariaDB就已经实现了这种HashJoin算法。如果数据不能全部load到内存，就需要分批load进内存，然后分批join。</p>
<p>​    <strong>一般要求join且连接条件是=的场景才能用，且必须全表扫描驱动表和被驱动表完成hash表的构建，并非银弹</strong></p>
<h3 id="anti-join"><a href="#anti-join" class="headerlink" title="anti join"></a>anti join</h3><p>​    MySQL 8.0.17版本引入了一个anti join的优化，这个优化能够将where条件中的not in(subquery)， not exists(subquery)，in(subquery) is not true，exists(subquery) is not true，在内部把subquery子查询转化成一个anti join（用explain可以体现），这个优化在某些场景下，能够将性能提升20%左右。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">select * from t_group t where not exists (select 1 from employees e where e.emp_no &#x3D; t.emp_no) ;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9805-Mysql8%E7%9A%84%E4%BC%98%E5%8C%96/image-20241021231003098.png" alt="image-20241021231003098"></p>
<p>anti join适用的场景案例通常如下：</p>
<ul>
<li>找出在集合A且不在集合B中的数据</li>
<li>找出在当前季度里没有购买商品的客户</li>
<li>找出今年没有通过考试的学生</li>
<li>找出过去3年，某个医生的病人中没有进行医学检查的部分</li>
</ul>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能调优</tag>
        <tag>事务</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优11-JVM及JVM内存模型</title>
    <url>/2022/03/05/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="JVM内存模型介绍"><a href="#JVM内存模型介绍" class="headerlink" title="JVM内存模型介绍"></a>JVM内存模型介绍</h1><h2 id="JDK体系结构"><a href="#JDK体系结构" class="headerlink" title="JDK体系结构"></a>JDK体系结构</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>​    JDK(Java SE Development Kit):Java开发标准包，它提供了编译、运行Java程序所需的各种工具和资源，包括Java编译器、Java运行时环境，以及常用的Java类库等。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1362965-20190114160755933-897193066.png" alt="img"></p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>​    JRE(Java Runtime Environment):Java运行环境，用于解释执行Java的字节码文件。普通用户而只需要安装 JRE来运行 Java 程序。而程序开发者必须安装JDK来编译、调试程序。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/1362965-20190114161959489-1682755970.png" alt="img"></p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>​    JVM(Java Virtual Machine ):Java虚拟机，是JRE的一部分。它是整个java实现跨平台的最核心的部分(一次编译，到处运行)，负责解释执行字节码文件，是可运行java字节码文件的虚拟计算机。所有平台的上的JVM向编译器提供相同的接口，而编译器只需要面向虚拟机，生成虚拟机能识别的代码，然后由虚拟机来解释执行。</p>
<h3 id="区别与联系"><a href="#区别与联系" class="headerlink" title="区别与联系"></a>区别与联系</h3><ol>
<li>JDK 用于开发，JRE 用于运行java程序 ；如果只是运行Java程序，可以只安装JRE，无序安装JDK。</li>
<li>JDk包含JRE，JDK 和 JRE 中都包含 JVM。</li>
<li>JVM 是 java 编程语言的核心并且具有平台独立性。</li>
</ol>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/clipboard.png"></p>
<h2 id="Java语言的跨平台特性"><a href="#Java语言的跨平台特性" class="headerlink" title="Java语言的跨平台特性"></a>Java语言的跨平台特性</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/clipboard-1646465093453.png"></p>
<h2 id="JVM内存模型（运行时数据区）"><a href="#JVM内存模型（运行时数据区）" class="headerlink" title="JVM内存模型（运行时数据区）"></a>JVM内存模型（运行时数据区）</h2><h3 id="内存模型结构"><a href="#内存模型结构" class="headerlink" title="内存模型结构"></a>内存模型结构</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B.png"></p>
<p><strong>在minor gc过程中对象挪动后，引用如何修改？</strong><br>    对象在堆内部挪动的过程其实是复制，原有区域对象还在，一般不直接清理，JVM内部清理过程只是将对象分配指针移动到区域的头位置即可，比如扫描s0区域，扫到gcroot引用的非垃圾对象是将这些对象复制到s1或老年代，最后扫描完了将s0区域的对象分配指针移动到区域的起始位置即可，s0区域之前对象并不直接清理，当有新对象分配了，原有区域里的对象也就被清除了。<br>    minor gc在根扫描过程中会记录所有被扫描到的对象引用(在年轻代这些引用很少，因为大部分都是垃圾对象不会扫描到)，如果引用的对象被复制到新地址了，最后会一并更新引用指向新地址。<br>这里面内部算法比较复杂，感兴趣可以参考R大的这篇文章：<br><a href="https://www.zhihu.com/question/42181722/answer/145085437">https://www.zhihu.com/question/42181722/answer/145085437</a><br><a href="https://hllvm-group.iteye.com/group/topic/39376#post-257329">https://hllvm-group.iteye.com/group/topic/39376#post-257329</a></p>
<h3 id="JVM内存参数设置"><a href="#JVM内存参数设置" class="headerlink" title="JVM内存参数设置"></a>JVM内存参数设置</h3><p>Spring Boot程序的JVM参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M <br>    -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar<br></code></pre></td></tr></table></figure>

<p>1、-Xms(memory size-内存大小)：堆初始化可用大小，默认物理内存的1/64</p>
<p>2、-Xmx(memory max-内存最大)：堆最大可用大小，默认物理内存的1/64</p>
<p>3、-Xmn(memory new-新生代内存)：新生代大小</p>
<p>4、-Xss(stack size-栈大小)：每个线程栈的大小（一般而言，每个线程栈大小与支持的并发线程数成反比）</p>
<p>5、-XX:MetaspaceSize：元空间触发full gc的初始阈值</p>
<p>6、-XX:MaxMetaspaceSize:，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。</p>
<p>7、-XX:NewRatio：默认2表示新生代占年老代的1/2，占整个堆内存的1/3。</p>
<p>8、-XX:SurvivorRatio：默认8表示一个survivor区占用1/8的Eden内存，即1/10的新生代内存。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/clipboard-1646472706335.png"></p>
<p><strong>StackOverflowError示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> *  JVM设置 -Xss128k(默认1M)</span><br><span class="hljs-comment"> *  默认1M时:count = 17069</span><br><span class="hljs-comment"> *  128k时:count = 1079</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StackOverflowTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">redo</span><span class="hljs-params">()</span> </span>&#123;<br>        count++;<br>        redo();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            redo();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            t.printStackTrace();<br>            System.out.println(count);<br>        &#125;<br>    &#125;<br>&#125;<br>-- 运行结果<br>java.lang.StackOverflowError<br>	at memorymodel.StackOverflowTest.redo(StackOverflowTest.java:<span class="hljs-number">13</span>)<br><br></code></pre></td></tr></table></figure>

<p><strong>结论：</strong></p>
<p>-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p>
<h2 id="JVM内存参数大小设置举例"><a href="#JVM内存参数大小设置举例" class="headerlink" title="JVM内存参数大小设置举例"></a>JVM内存参数大小设置举例</h2><p>​    JVM参数大小设置并没有固定标准，需要根据实际项目情况分析，给大家举个例子</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%B3%BB%E7%BB%9FJVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE%E4%BC%98%E5%8C%96.png"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9811-JVM%E5%8F%8AJVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20240325210337112.png" alt="image-20240325210337112"></p>
<p>其实调优后最大的区别是设置年轻代的大小为2G，老年代变为1G，eden有1600M，S1,S2 = 200M，这样需要 1600 / 60  约定于27秒才能把Eden放满，这样即便是高峰期，也很少有对象存活15次后进到老年代亦或者存货区放不下直接移动到老年代。</p>
<h2 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h2><p>JVM的运行模式有三种：</p>
<p>1、解释器模式：只使用解释器，执行一行jvm字节码就解释一行为机器码</p>
<p>2、编译模式：只使用编译模式，先将所有jvm字节码一次性编译为机器码，然后一次性执行所有机器码</p>
<p>3、混合模式：混合模式，依然使用解释器模式执行代码，但是对于一些“热点”代码采用编译模式执行，JVM一般采用编译模式执行,JVM默认采用混合模式执行代码</p>
<p>​    <strong>解释模式</strong>启动快，对于只需要执行部分代码，并且大多数代码只会执行一次的情况比较适合；</p>
<p>​    <strong>编译模式</strong>启动慢，但是后期执行速度快，而且比较占用内存，因为机器码的数量至少是JVM字节码的十倍以上，这种模式适合代码可能会被反复执行的场景；    </p>
<p>​    <strong>混合模式</strong>是JVM默认采用的执行代码方式，一开始还是解释执行，但是对于少部分 “热点 ”代码会采用编译模式执行，这些热点代码对应的机器码会被缓存起来，下次再执行无需再编译，这就是我们常见的<strong>JIT(Just In Time Compiler)即时编译技术</strong>。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">test1</span><span class="hljs-params">()</span> </span>&#123;<br>   User user = <span class="hljs-keyword">new</span> User();<br>   user.setId(<span class="hljs-number">1</span>);<br>   user.setName(<span class="hljs-string">&quot;zhuge&quot;</span>);<br>   <span class="hljs-comment">//TODO 保存到数据库</span><br>   <span class="hljs-keyword">return</span> user;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span> </span>&#123;<br>   User user = <span class="hljs-keyword">new</span> User();<br>   user.setId(<span class="hljs-number">1</span>);<br>   user.setName(<span class="hljs-string">&quot;zhuge&quot;</span>);<br>   <span class="hljs-comment">//TODO 保存到数据库</span><br></code></pre></td></tr></table></figure>

<p>​    <strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p>
<p>  很显然test1方法中的user对象被返回了，这个对象的作用域范围不确定，test2方法中的user对象我们可以确定当方法结束这个对象就可以认为是无效对象了.</p>
<p>​    对于这样的对象我们其实可以将其分配在栈内存里，让其在方法结束时跟随栈内存一起被回收掉,如果这时候栈内存不足，则再分配到堆上。</p>
<p>​    此外，线程逃逸分析通常是在 JVM 的编译阶段进行的。在编译阶段，JVM 会对代码进行分析和优化，包括对象的分配和内存管理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 栈上分配，标量替换</span><br><span class="hljs-comment"> * 代码调用了1亿次alloc()，如果是分配到堆上，大概需要1GB以上堆空间，如果堆空间小于该值，必然会触发GC。</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 使用如下参数不会发生GC</span><br><span class="hljs-comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br><span class="hljs-comment"> * 使用如下参数都会发生大量GC</span><br><span class="hljs-comment"> * -Xmx15m -Xms15m -XX:-DoEscapeAnalysis -XX:+PrintGC -XX:+EliminateAllocations</span><br><span class="hljs-comment"> * -Xmx15m -Xms15m -XX:+DoEscapeAnalysis -XX:+PrintGC -XX:-EliminateAllocations</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AllotOnStack</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000000</span>; i++) &#123;<br>            alloc();<br>        &#125;<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.println(end - start);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">alloc</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setId(<span class="hljs-number">1</span>);<br>        user.setName(<span class="hljs-string">&quot;zhuge&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>结论：<strong>栈上分配依赖于<font color="red">逃逸分析</font>和<font color="red">标量替换</font></strong>,逃逸分析和标量替换在JDK8默认开启</p>
<h2 id="Server模式和Client模式"><a href="#Server模式和Client模式" class="headerlink" title="Server模式和Client模式"></a>Server模式和Client模式</h2><p>JVM 有两种运行模式：Client 模式和 Server 模式。</p>
<ul>
<li><strong>Client 模式</strong>：<ul>
<li>特点：启动速度较快，占用内存较少，适用于桌面应用程序等对启动时间要求较高的场景。</li>
<li>编译器：使用 C1 编译器，进行简单和快速的优化。</li>
<li>应用场景：通常用于普通的桌面应用，如小型的 Java 应用程序。</li>
</ul>
</li>
<li><strong>Server 模式</strong>：<ul>
<li>特点：启动速度较慢，但运行时性能更好，适用于长时间运行的服务器端应用。</li>
<li>编译器：采用更复杂和强大的 C2 编译器，进行更深入和耗时的优化。</li>
<li>应用场景：常用于服务器端应用，如 Web 服务器、应用服务器等，能够处理高并发和大量的数据处理任务。</li>
</ul>
</li>
</ul>
<p><strong>C1 和 C2 编译器</strong></p>
<ul>
<li><strong>C1 编译器</strong>：也称为客户端编译器（Client Compiler）。它的优化策略相对简单和快速，主要关注代码的快速生成和较短的编译时间。适用于对启动速度要求较高的场景。<ul>
<li>例子：对于一些简单的循环和方法调用，C1 编译器可能会进行基本的常量折叠、消除一些冗余的计算等简单优化。</li>
</ul>
</li>
<li><strong>C2 编译器</strong>：也称为服务器端编译器（Server Compiler）。它执行更深入和耗时的优化，以生成更高效的机器码。<ul>
<li>例子：C2 编译器可能会进行更复杂的循环优化、内联函数、更精细的寄存器分配等，以提高代码的长期运行性能。</li>
</ul>
</li>
</ul>
<p><strong>服务端 JVM 通常采用 Server 模式启动，主要有以下好处：</strong></p>
<ol>
<li>更优的性能优化：Server 模式下的 JVM 采用了更复杂和强大的优化策略，能够生成更高效的机器码，从而提高程序的长期运行性能。</li>
<li>更好的内存管理：有助于更有效地管理大量的内存，处理高并发和大规模的数据处理任务。</li>
<li>高级的垃圾回收算法：例如更适合服务器端应用的垃圾回收算法，减少垃圾回收带来的暂停时间，提高系统的整体响应性。</li>
</ol>
<p>​    <strong>在 Server 模式启动后，同一段代码第一次运行时通常是解释执行，而不是立即编译成机器码。JVM 会通过热点探测来确定哪些代码是频繁执行的热点代码。只有被判定为热点的代码，才会在后续被编译成机器码。这样可以避免过早地对不常执行的代码进行编译，节省编译时间和资源。</strong></p>
<p>​    例如，一个复杂的计算函数在服务端应用中被频繁调用，经过一定次数的执行后，JVM 会将其识别为热点代码并编译成机器码，从而在后续的调用中直接执行机器码，提高执行效率。但如果是一个很少被调用的辅助函数，可能始终都是解释执行。</p>
<h2 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h2><h3 id="1、什么是内存泄露"><a href="#1、什么是内存泄露" class="headerlink" title="1、什么是内存泄露"></a>1、什么是内存泄露</h3><p>​    <strong>存在一些对象他们是可到达的GC无法回收，但是程序之后又不会用到这些对象，对于存在这种占用内存却不会被使用的现象就叫内存泄漏</strong></p>
<h3 id="2、内存泄露的场景"><a href="#2、内存泄露的场景" class="headerlink" title="2、内存泄露的场景"></a>2、内存泄露的场景</h3><p>1、静态集合类：如HashMap、LinkedList等静态容器，通常做缓存用，生命周期与程序一致，如果没有及时按策略清除容器中引用的对象，则会导致容器越积越大，白白占用大量内存空间（使用redis，ehcache等带LRU策略的缓存框架）</p>
<p>2、各种连接如数据库连接、网络连接、IO连接等等使用结束后没有及时关闭，导致连接对象无法回收</p>
<p>3、TreadLocal、内部类实例被引用导致外部类实例无法释放等等</p>
<p>4、定义太多无效类、枚举、静态常量、变量等，导致元空间占用。</p>
<h2 id="OOM的原因"><a href="#OOM的原因" class="headerlink" title="OOM的原因"></a>OOM的原因</h2><ol>
<li><strong>堆内存溢出（Heap Space OOM）</strong>：<ul>
<li>大量对象创建且未被及时回收：例如在程序中创建了大量的对象，尤其是大对象，而垃圾回收机制未能及时清理这些不再使用的对象，导致堆内存被耗尽。</li>
<li>内存泄漏：某些对象一直被引用，无法被垃圾回收，导致内存逐渐被占用完。</li>
<li>不合理的缓存：比如创建了一个过大的缓存，且缓存中的元素没有有效的过期策略。</li>
</ul>
</li>
<li><strong>线程栈溢出（StackOverflowError）</strong>：<ul>
<li>线程数量过多：创建了过多的线程（存咋死循环或者递归没有出口），每个线程都需要分配一定的栈空间。</li>
<li>单个线程栈空间过大：通过<code>-Xss</code>参数设置的线程栈大小过大，导致可用的线程栈数量减少。</li>
</ul>
</li>
<li>元空间（方法区）溢出<strong>（Metaspace OOM）</strong>：加大元空间<ul>
<li>加载了过多的类：在动态加载类的应用中，可能会加载大量的类，导致方法区空间不足（过多无效类，枚举）。</li>
<li>常量池过大：字符串常量过多或者其他常量占用了大量空间。</li>
</ul>
</li>
<li>直接内存溢出<strong>（Direct Buffer Memory OOM）</strong>：<ul>
<li>直接使用<code>ByteBuffer</code>分配了过大的本地内存，且没有合理的释放。</li>
<li>可以通过 <code>-XX:MaxDirectMemorySize</code> 来指定最大的直接内存大小。当直接内存的使用达到了阈值的时候，JVM 会尝试调用 <code>System.gc()</code> 来触发一次 FULL GC，从而完成可控的堆外内存回收</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringBoot下枚举治理方案</title>
    <url>/2021/11/14/%E6%9E%9A%E4%B8%BE%E6%B2%BB%E7%90%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="枚举治理"><a href="#枚举治理" class="headerlink" title="枚举治理"></a>枚举治理</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1、多版本运行开发枚举容易导致冲突，服务无感知</p>
<p>2、业务中使用枚举实例处理逻辑，API入参/返参的枚举类型，需要手动转换</p>
<p>3、API文档(Swagger)枚举描述需要手动列举枚举值，枚举添加/修改描述无法及时更新</p>
<p>4、数据库中的枚举字段，查询出来后需要根据枚举处理，得先转化实例判断，冗余复杂</p>
<p>5、API返回枚举展示值需要手动设置，重复代码较多</p>
<p>6、API接受枚举类型参数的校验场景，冗余复杂</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p><strong>1、系统启动检查枚举是否存在冲突</strong></p>
<p><strong>2、API入参/返参支持序列化枚举类型</strong></p>
<p><strong>3、Dao持久层框架（mybatis），出入参支持枚举类型</strong></p>
<p><strong>4、swagger文档定制枚举动态渲染</strong></p>
<p><strong>5、API返回枚举展示值需要手动设置，重复代码较多</strong></p>
<p><strong>6、基于Validation支持枚举类型校验</strong></p>
<h2 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h2><p><strong>系统启动检查枚举是否存在冲突</strong></p>
<ol>
<li>定义枚举注解，标识组件管理的枚举</li>
<li>实现BeanDefinitionRegistryPostProcessor，启动扫描所有枚举类</li>
<li>遍历枚举值，检测是否存在冲突</li>
</ol>
<p><img src="/images/%E6%9E%9A%E4%B8%BE%E6%B2%BB%E7%90%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20211105141116817.png" alt="image-20211105141116817"> </p>
<p><strong>API入参/返参支持序列化枚举类型（系统统一使用fastjson）</strong></p>
<ol>
<li><p>Fastjson调研：<br>默认枚举序列化器:com.alibaba.fastjson.serializer.EnumSerializer<br>默认枚举反序列化器:com.alibaba.fastjson.parser.deserializer.EnumDeserializer</p>
</li>
<li><p>自定义重写EnumSerializer、EnumDeserializer 序列化、反序列化器</p>
</li>
<li><p>覆盖fastjson FastJsonHttpMessageConverter默认配置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastJsonPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean,String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>&#123;<br>        <span class="hljs-keyword">if</span>(bean <span class="hljs-keyword">instanceof</span> FastJsonHttpMessageConverter)&#123;<br>            FastJsonHttpMessageConverter messageConverter = (FastJsonHttpMessageConverter)bean;<br>            FastJsonConfig fastJsonConfig = messageConverter.getFastJsonConfig();<br>            fastJsonConfig.setParserConfig(<span class="hljs-keyword">new</span> EnumParserConfig());<br>            fastJsonConfig.setSerializeConfig(<span class="hljs-keyword">new</span> EnumSerializeConfig());<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>Dao持久层框架（mybatis）出入参支持枚举类型</strong></p>
<ol>
<li>自定义枚举类型转换器TypeHandler</li>
<li>注入所有枚举类型转换器到mybatis的SqlSessionFactory</li>
</ol>
<p><strong>Swagger文档定制枚举动态渲染</strong></p>
<ol>
<li>重写ModelPropertyBuilderPlugin自定义枚举，动态列举枚举实例描述</li>
</ol>
<p><strong>API返回枚举展示值自动渲染输出</strong></p>
<ol>
<li><p>举类型字段abc序列化时，在同级目录自动输出abcStr展示字段 如：</p>
<p><img src="/images/%E6%9E%9A%E4%B8%BE%E6%B2%BB%E7%90%86%E8%AE%BE%E8%AE%A1%E6%96%87%E6%A1%A3/image-20211105110343791.png" alt="image-20211105110343791"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnumAnnotation</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">ServerType</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 1 - ISC</span><br><span class="hljs-comment">     */</span><br>    ISC(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;ISC&quot;</span>),<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 2 - 萤石</span><br><span class="hljs-comment">     */</span><br>    YS(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;萤石&quot;</span>),<br>    ;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@EnumValue</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer code;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@EnumName</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>    ServerType(Integer code, String name) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultEnumMatcher</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">EnumMatcher</span>&lt;<span class="hljs-title">VideoType</span>&gt;</span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(VideoType targetEnum)</span></span>&#123;<br>            <span class="hljs-keyword">return</span> Arrays.asList(VideoType.values()).contains(targetEnum);<br>        &#125;<br>    &#125;<br>&#125;<br>在序列化出参时，转化为<br>&#123;<br>    <span class="hljs-string">&quot;serverType&quot;</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-string">&quot;serverTypeStr&quot;</span>:<span class="hljs-string">&quot;ISC&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
<p><strong>基于Validation支持枚举类型校验</strong></p>
<ol>
<li>自定义@EnumValid注解，用于标注需要校验的枚举字段</li>
<li>自定义ConstraintValidator，校验@EnumValid</li>
<li>定义枚举时，定义默认枚举校验器如上文：ServerType.DefaultEnumMatcher</li>
</ol>
<h2 id="解决痛点"><a href="#解决痛点" class="headerlink" title="解决痛点"></a>解决痛点</h2><ol>
<li>API入参支持使用枚举类型接受</li>
<li>API入参枚举类型支持校验</li>
<li>API出参自动渲染枚举展示名称</li>
<li>持久层出入参支持枚举类型</li>
<li>API枚举入参支持swagger动态渲染</li>
<li>启动自动监测枚举冲突</li>
</ol>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>1、修改了实体的序列化反序列化方式，不支持序列化后反序列化或者反序列化后序列化操作</p>
<p>2、依赖FastJson、Swagger3.0、Mybatis，版本兼容性较低、普适性较低</p>
<p>3、API出参序列化输出枚举展示字段，但是暂不支持在Swagger上输出该字段</p>
<h2 id="后续优化"><a href="#后续优化" class="headerlink" title="后续优化"></a>后续优化</h2><p>1、API出参序列化输出枚举展示字段，支持在Swagger上输出该字段</p>
]]></content>
      <categories>
        <category>枚举治理</category>
      </categories>
      <tags>
        <tag>枚举治理</tag>
      </tags>
  </entry>
  <entry>
    <title>activiti整合Spring</title>
    <url>/2021/04/17/Activiti%E6%95%B4%E5%90%88/</url>
    <content><![CDATA[<h1 id="Activiti整合Spring"><a href="#Activiti整合Spring" class="headerlink" title="Activiti整合Spring"></a>Activiti整合Spring</h1><h1 id="一、Activiti与Spring整合开发"><a href="#一、Activiti与Spring整合开发" class="headerlink" title="一、Activiti与Spring整合开发"></a>一、Activiti与Spring整合开发</h1><h2 id="1-1-Activiti与Spring整合的配置"><a href="#1-1-Activiti与Spring整合的配置" class="headerlink" title="1.1 Activiti与Spring整合的配置"></a>1.1 Activiti与Spring整合的配置</h2><h3 id="1-、在pom-xml文件引入坐标"><a href="#1-、在pom-xml文件引入坐标" class="headerlink" title="1)、在pom.xml文件引入坐标"></a>1)、在pom.xml文件引入坐标</h3><p>如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.0.7.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log start --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-nop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log end --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alfresco<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Activiti Releases<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://artifacts.alfresco.com/nexus/content/repositories/activiti-releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在Activiti中核心类的是ProcessEngine流程引擎，与Spring整合就是让Spring来管理ProcessEngine</p>
<p>通过<strong>org.activiti.spring.SpringProcessEngineConfiguration</strong> 与Spring整合方式来创建ProcessEngine对象。 </p>
<p> 创建spring与activiti的整合配置文件：activiti-spring.xml（名称不固定）</p>
<h3 id="2-、创建activiti-spring-xml"><a href="#2-、创建activiti-spring-xml" class="headerlink" title="2)、创建activiti-spring.xml"></a>2)、创建activiti-spring.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/tx/spring-tx.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop</span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/aop/spring-aop.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/activiti&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 工作流引擎配置bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 使用spring事务管理器 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- 数据库策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;drop-create&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程引擎 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 资源服务service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;repositoryService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRepositoryService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程运行service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;runtimeService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span>  <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRuntimeService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 任务管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;taskService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getTaskService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 历史管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;historyService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getHistoryService&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通知 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- 传播行为 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;save*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 切面，根据具体项目修改切点配置</span><br><span class="hljs-comment">    &lt;aop:config proxy-target-class=&quot;true&quot;&gt;</span><br><span class="hljs-comment">        &lt;aop:advisor advice-ref=&quot;txAdvice&quot;</span><br><span class="hljs-comment">                     pointcut=&quot;execution(*com.itheima.service.impl..(..))&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/aop:config&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3-、aseSchemaUpdate的取值内容："><a href="#3-、aseSchemaUpdate的取值内容：" class="headerlink" title="3)、aseSchemaUpdate的取值内容："></a>3)、aseSchemaUpdate的取值内容：</h3><p><strong>flase：</strong>       默认值。activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常。（生产环境常用）<br><strong>true：</strong>        activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建。（开发时常用）<br><strong>create_drop</strong>： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）。（单元测试常用）<br><strong>drop-create</strong>： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）。</p>
<h2 id="1-2-测试Activiti与Spring整合"><a href="#1-2-测试Activiti与Spring整合" class="headerlink" title="1.2 测试Activiti与Spring整合"></a>1.2 测试Activiti与Spring整合</h2><h3 id="1）、测试代码"><a href="#1）、测试代码" class="headerlink" title="1）、测试代码"></a>1）、测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">   测试activiti与spring整合是否成功</span><br><span class="hljs-comment">**/</span><br><span class="hljs-meta">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="hljs-meta">@ContextConfiguration(locations = &quot;classpath:activiti-spring.xml&quot;)</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiTest</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> RepositoryService repositoryService;<br>     <br>     <span class="hljs-meta">@Test</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>         System.out.println(<span class="hljs-string">&quot;部署对象:&quot;</span>+repositoryService);<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>



<h3 id="2）、执行流程分析"><a href="#2）、执行流程分析" class="headerlink" title="2）、执行流程分析"></a>2）、执行流程分析</h3><p>下面我们一起来分析Activiti与Spring整合加载的过程。</p>
<p>1、加载activiti-spring.xml配置文件</p>
<p>2、加载SpringProcessEngineConfiguration对象，这个对象它需要依赖注入dataSource对象和transactionManager对象。</p>
<p>3、加载ProcessEngineFactoryBean工厂来创建ProcessEngine对象，而ProcessEngineFactoryBean工厂又需要依赖注入processEngineConfiguration对象。</p>
<p>4、processEngine对象来负责创建我们的Service对象，从而简化Activiti的开发过程。</p>
<h1 id="二、Activiti7与SpringBoot整合开发"><a href="#二、Activiti7与SpringBoot整合开发" class="headerlink" title="二、Activiti7与SpringBoot整合开发"></a>二、Activiti7与SpringBoot整合开发</h1><p>Activiti7发布正式版之后，它与SpringBoot2.x已经完全支持整合开发。</p>
<h2 id="2-1-SpringBoot整合Activiti7的配置"><a href="#2-1-SpringBoot整合Activiti7的配置" class="headerlink" title="2.1     SpringBoot整合Activiti7的配置"></a>2.1     SpringBoot整合Activiti7的配置</h2><p>为了能够实现SpringBoot与Activiti7整合开发，首先我们要引入相关的依赖支持。</p>
<p>在工程的pom.xml文件中引入相关的依赖，其中activiti的依赖是：activiti-spring-boot-starter。</p>
<p>具体依赖如下所示：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.reporting.outputEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过该pom.xml文件所导入的坐标，我们就可以实现activiti7与Springboot整合。</p>
<h2 id="2-2-SpringBoot的application-yml文件配置"><a href="#2-2-SpringBoot的application-yml文件配置" class="headerlink" title="2.2    SpringBoot的application.yml文件配置"></a>2.2    SpringBoot的application.yml文件配置</h2><p>为了能够实现Activiti7生成的表放到Mysql数据库中，需要在配置文件application.yml中添加相关的配置</p>
<p>注意：activiti7默认没有开启数据库历史记录，需要手动配置开启</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///activiti?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">activiti:</span><br>    <span class="hljs-comment">#1.flase：默认值。activiti在启动时，对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常</span><br>    <span class="hljs-comment">#2.true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建</span><br>    <span class="hljs-comment">#3.create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）</span><br>    <span class="hljs-comment">#4.drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）</span><br>    <span class="hljs-attr">database-schema-update:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#检测历史表是否存在 activiti7默认没有开启数据库历史记录 启动数据库历史记录</span><br>    <span class="hljs-attr">db-history-used:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#记录历史等级 可配置的历史级别有none, activity, audit, full</span><br>    <span class="hljs-comment">#none：不保存任何的历史数据，因此，在流程执行过程中，这是最高效的。</span><br>    <span class="hljs-comment">#activity：级别高于none，保存流程实例与流程行为，其他数据不保存。</span><br>    <span class="hljs-comment">#audit：除activity级别会保存的数据外，还会保存全部的流程任务及其属性。audit为history的默认值。</span><br>    <span class="hljs-comment">#full：保存历史数据的最高级别，除了会保存audit级别的数据外，还会保存其他全部流程相关的细节数据，包括一些流程参数等。</span><br>    <span class="hljs-attr">history-level:</span> <span class="hljs-string">full</span><br>    <span class="hljs-comment">#校验流程文件，默认校验resources下的processes文件夹里的流程文件</span><br>    <span class="hljs-attr">check-process-definitions:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h2 id="2-3-编写启动类"><a href="#2-3-编写启动类" class="headerlink" title="2.3 编写启动类"></a>2.3 编写启动类</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima;<br><br><span class="hljs-keyword">import</span> org.springframework.boot.SpringApplication;<br><span class="hljs-keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;<br><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(ActApplication.class,args);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="2-4-添加SpringSecurity安全框架整合配置"><a href="#2-4-添加SpringSecurity安全框架整合配置" class="headerlink" title="2.4    添加SpringSecurity安全框架整合配置"></a>2.4    添加SpringSecurity安全框架整合配置</h2><p>因为Activiti7与SpringBoot整合后，默认情况下，集成了SpringSecurity安全框架，这样我们就要去准备SpringSecurity整合进来的相关用户权限配置信息。</p>
<p>SpringBoot的依赖包已经将SpringSecurity的依赖包也添加进项目中。</p>
<h3 id="2-4-1-添加SecurityUtil类"><a href="#2-4-1-添加SecurityUtil类" class="headerlink" title="2.4.1  添加SecurityUtil类"></a>2.4.1  添加SecurityUtil类</h3><p>为了能够快速实现SpringSecurity安全框架的配置，所添加的一个组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.utils;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;<br><span class="hljs-keyword">import</span> org.springframework.security.core.Authentication;<br><span class="hljs-keyword">import</span> org.springframework.security.core.GrantedAuthority;<br><span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextHolder;<br><span class="hljs-keyword">import</span> org.springframework.security.core.context.SecurityContextImpl;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetails;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><br><span class="hljs-keyword">import</span> java.util.Collection;<br><br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecurityUtil</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(SecurityUtil.class);<br><br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-meta">@Qualifier(&quot;myUserDetailsService&quot;)</span><br>     <span class="hljs-keyword">private</span> UserDetailsService userDetailsService;<br> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logInAs</span><span class="hljs-params">(String username)</span> </span>&#123;<br>     UserDetails user = userDetailsService.loadUserByUsername(username);<br><br>     <span class="hljs-keyword">if</span> (user == <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;User &quot;</span> + username + <span class="hljs-string">&quot; doesn&#x27;t exist, please provide a valid user&quot;</span>);<br>     &#125;<br>     logger.info(<span class="hljs-string">&quot;&gt; Logged in as: &quot;</span> + username);<br><br>     SecurityContextHolder.setContext(<br>             <span class="hljs-keyword">new</span> SecurityContextImpl(<br>                     <span class="hljs-keyword">new</span> Authentication() &#123;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-keyword">public</span> Collection&lt;? extends GrantedAuthority&gt; getAuthorities() &#123;<br>                             <span class="hljs-keyword">return</span> user.getAuthorities();<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getCredentials</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user.getPassword();<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getDetails</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user;<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getPrincipal</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user;<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isAuthenticated</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                         &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAuthenticated</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isAuthenticated)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123; &#125;<br>                         <span class="hljs-meta">@Override</span><br>                         <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>                             <span class="hljs-keyword">return</span> user.getUsername();<br>                         &#125;<br>     &#125;));<br>     org.activiti.engine.impl.identity.Authentication.setAuthenticatedUserId(username);<br> &#125;<br>  &#125;<br></code></pre></td></tr></table></figure>
<p>这个类可以从我们下载的Activiti7官方提供的Example中找到。</p>
<h3 id="2-4-2-添加DemoApplicationConfig类"><a href="#2-4-2-添加DemoApplicationConfig类" class="headerlink" title="2.4.2  添加DemoApplicationConfig类"></a>2.4.2  添加DemoApplicationConfig类</h3><p>在Activiti7官方下载的Example中找到DemoApplicationConfig类，它的作用是为了实现SpringSecurity框架的用户权限的配置，这样我们就可以在系统中使用用户权限信息。</p>
<p>本次项目中基本是在文件中定义出来的用户信息，当然也可以是数据库中查询的用户权限信息。</p>
<p>后面处理流程时用到的任务负责人，需要添加在这里</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.config;<br><br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Bean;<br><span class="hljs-keyword">import</span> org.springframework.context.annotation.Configuration;<br><span class="hljs-keyword">import</span> org.springframework.security.core.authority.SimpleGrantedAuthority;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.User;<br><span class="hljs-keyword">import</span> org.springframework.security.core.userdetails.UserDetailsService;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;<br><span class="hljs-keyword">import</span> org.springframework.security.crypto.password.PasswordEncoder;<br><span class="hljs-keyword">import</span> org.springframework.security.provisioning.InMemoryUserDetailsManager;<br><br><span class="hljs-keyword">import</span> java.util.Arrays;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.stream.Collectors;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DemoApplicationConfiguration</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(DemoApplicationConfiguration.class);<br>     <span class="hljs-meta">@Bean</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> UserDetailsService <span class="hljs-title">myUserDetailsService</span><span class="hljs-params">()</span> </span>&#123;<br>         InMemoryUserDetailsManager inMemoryUserDetailsManager = <span class="hljs-keyword">new</span> InMemoryUserDetailsManager();<br>         <span class="hljs-comment">//这里添加用户，后面处理流程时用到的任务负责人，需要添加在这里</span><br>         String[][] usersGroupsAndRoles = &#123;<br>                 &#123;<span class="hljs-string">&quot;jack&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_activitiTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;rose&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_activitiTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_activitiTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;other&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>, <span class="hljs-string">&quot;GROUP_otherTeam&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_USER&quot;</span>&#125;,<br>                 &#123;<span class="hljs-string">&quot;admin&quot;</span>, <span class="hljs-string">&quot;password&quot;</span>, <span class="hljs-string">&quot;ROLE_ACTIVITI_ADMIN&quot;</span>&#125;,<br>         &#125;;<br><br>         <span class="hljs-keyword">for</span> (String[] user : usersGroupsAndRoles) &#123;<br>             List&lt;String&gt; authoritiesStrings = Arrays.asList(Arrays.copyOfRange(user, <span class="hljs-number">2</span>, user.length));<br>             logger.info(<span class="hljs-string">&quot;&gt; Registering new user: &quot;</span> + user[<span class="hljs-number">0</span>] + <span class="hljs-string">&quot; with the following Authorities[&quot;</span> + authoritiesStrings + <span class="hljs-string">&quot;]&quot;</span>);<br>             inMemoryUserDetailsManager.createUser(<span class="hljs-keyword">new</span> User(user[<span class="hljs-number">0</span>], passwordEncoder().encode(user[<span class="hljs-number">1</span>]),<br>                     authoritiesStrings.stream().map(s -&gt; <span class="hljs-keyword">new</span> SimpleGrantedAuthority(s)).collect(Collectors.toList())));<br>         &#125;<br><br>         <span class="hljs-keyword">return</span> inMemoryUserDetailsManager;<br>     &#125;<br>     <span class="hljs-meta">@Bean</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> PasswordEncoder <span class="hljs-title">passwordEncoder</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BCryptPasswordEncoder();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-5-创建Bpmn文件"><a href="#2-5-创建Bpmn文件" class="headerlink" title="2.5 创建Bpmn文件"></a>2.5 创建Bpmn文件</h2><p>Activiti7可以自动部署流程，前提是在resources目录下，创建一个新的目录processes，用来放置bpmn文件。</p>
<p>创建一个简单的Bpmn流程文件，并设置任务的用户组Candidate Groups。</p>
<p>Candidate Groups中的内容与上面DemoApplicationConfiguration类中出现的用户组名称要保持一致，可以填写：activitiTeam 或者 otherTeam。</p>
<p>这样填写的好处：当不确定到底由谁来负责当前任务的时候，只要是Groups内的用户都可以拾取这个任务</p>
<p><img src="/images/Activiti%E6%95%B4%E5%90%88/1578369213.png"></p>
<h2 id="2-6-使用Junit方式测试"><a href="#2-6-使用Junit方式测试" class="headerlink" title="2.6    使用Junit方式测试"></a>2.6    使用Junit方式测试</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> com.itheima.utils.SecurityUtil;<br><span class="hljs-keyword">import</span> org.activiti.api.process.model.ProcessInstance;<br><span class="hljs-keyword">import</span> org.activiti.api.process.model.builders.ProcessPayloadBuilder;<br><span class="hljs-keyword">import</span> org.activiti.api.process.runtime.ProcessRuntime;<br><span class="hljs-keyword">import</span> org.activiti.api.runtime.shared.query.Page;<br><span class="hljs-keyword">import</span> org.activiti.api.runtime.shared.query.Pageable;<br><span class="hljs-keyword">import</span> org.activiti.api.task.model.Task;<br><span class="hljs-keyword">import</span> org.activiti.api.task.model.builders.TaskPayloadBuilder;<br><span class="hljs-keyword">import</span> org.activiti.api.task.runtime.TaskRuntime;<br><span class="hljs-keyword">import</span> org.activiti.engine.repository.ProcessDefinition;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><span class="hljs-keyword">import</span> org.junit.runner.RunWith;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.boot.test.context.SpringBootTest;<br><span class="hljs-keyword">import</span> org.springframework.test.context.junit4.SpringRunner;<br><br><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest</span><br> <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Actviti7DemoApplicationTests</span> </span>&#123;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> ProcessRuntime processRuntime;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> TaskRuntime taskRuntime;<br>     <span class="hljs-meta">@Autowired</span><br>     <span class="hljs-keyword">private</span> SecurityUtil securityUtil;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testActBoot</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(taskRuntime);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查看流程定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        securityUtil.logInAs(<span class="hljs-string">&quot;system&quot;</span>);<br>        Page&lt;org.activiti.api.process.model.ProcessDefinition&gt; processDefinitionPage =<br>                processRuntime.processDefinitions(Pageable.of(<span class="hljs-number">0</span>, <span class="hljs-number">10</span>));<br>        System.out.println(<span class="hljs-string">&quot;可用的流程定义数量：&quot;</span> + processDefinitionPage.getTotalItems());<br>        <span class="hljs-keyword">for</span> (org.activiti.api.process.model.ProcessDefinition pd : processDefinitionPage.getContent()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span> + pd);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStartProcess</span><span class="hljs-params">()</span> </span>&#123;<br>        securityUtil.logInAs(<span class="hljs-string">&quot;system&quot;</span>);<br>        ProcessInstance pi = processRuntime.start(ProcessPayloadBuilder.<br>                start().<br>                withProcessDefinitionKey(<span class="hljs-string">&quot;myProcess&quot;</span>).<br>                build());<br>        System.out.println(<span class="hljs-string">&quot;流程实例ID：&quot;</span> + pi.getId());<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     **查询任务，并完成自己的任务</span><br><span class="hljs-comment">     **/</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTask</span><span class="hljs-params">()</span> </span>&#123;<br>        securityUtil.logInAs(<span class="hljs-string">&quot;jack&quot;</span>);<br>        Page&lt;Task&gt; taskPage=taskRuntime.tasks(Pageable.of(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">if</span> (taskPage.getTotalItems()&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">for</span> (Task task:taskPage.getContent())&#123;<br>                taskRuntime.claim(TaskPayloadBuilder.<br>                        claim().<br>                        withTaskId(task.getId()).build());<br>                System.out.println(<span class="hljs-string">&quot;任务：&quot;</span>+task);<br>                taskRuntime.complete(TaskPayloadBuilder.<br>                        complete().<br>                        withTaskId(task.getId()).build());<br>            &#125;<br>        &#125;<br>        Page&lt;Task&gt; taskPage2=taskRuntime.tasks(Pageable.of*(<span class="hljs-number">0</span>,<span class="hljs-number">10</span>));<br>        <span class="hljs-keyword">if</span> (taskPage2.getTotalItems()&gt;<span class="hljs-number">0</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;任务：&quot;</span>+taskPage2.getContent());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="三、activiti6整合springboot2"><a href="#三、activiti6整合springboot2" class="headerlink" title="三、activiti6整合springboot2"></a><strong>三、activiti6整合springboot2</strong></h1><p>参考我的github：<a href="https://gitee.com/Callme24kHandsome/springboot-parent">https://gitee.com/Callme24kHandsome/springboot-parent</a></p>
<p>的actSpringBoot moudle</p>
<p>​    整合原则，采用spring整合activiti的方式，个人认为整合springboot需要排除spring-security的相关配置，比较麻烦。顾此整合spring，更显得灵活</p>
<h2 id="1、ativitiConfig-java-注入组件"><a href="#1、ativitiConfig-java-注入组件" class="headerlink" title="1、ativitiConfig.java 注入组件"></a>1、ativitiConfig.java 注入组件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiConfig</span></span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ProcessEngineConfiguration <span class="hljs-title">processEngineConfiguration</span><span class="hljs-params">(DataSourceTransactionManager transactionManager,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                 <span class="hljs-meta">@Qualifier(&quot;dataSource&quot;)</span> DataSource dataSource,</span></span><br><span class="hljs-function"><span class="hljs-params">                                                                 Environment environment)</span> </span>&#123;<br>        SpringProcessEngineConfiguration configuration = <span class="hljs-keyword">new</span> SpringProcessEngineConfiguration();<br>        configuration.setTransactionManager(transactionManager);<br>        configuration.setDataSource(dataSource);<br>        configuration.setDatabaseSchemaUpdate(<span class="hljs-string">&quot;true&quot;</span>);<br>        configuration.setDbIdentityUsed(<span class="hljs-keyword">false</span>);<br>        configuration.setDatabaseType(<span class="hljs-string">&quot;mysql&quot;</span>);<br>        <span class="hljs-keyword">return</span> configuration;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ProcessEngine <span class="hljs-title">processEngine</span><span class="hljs-params">(ProcessEngineConfiguration processEngineConfiguration)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngineConfiguration.buildProcessEngine();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RepositoryService <span class="hljs-title">repositoryService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getRepositoryService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RuntimeService <span class="hljs-title">runtimeService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getRuntimeService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TaskService <span class="hljs-title">taskService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getTaskService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HistoryService <span class="hljs-title">historyService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getHistoryService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ManagementService <span class="hljs-title">managementService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getManagementService();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FormService <span class="hljs-title">formService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getFormService();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IdentityService <span class="hljs-title">identityService</span><span class="hljs-params">(ProcessEngine processEngine)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> processEngine.getIdentityService();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="2、aplication-yml文件"><a href="#2、aplication-yml文件" class="headerlink" title="2、aplication.yml文件"></a>2、aplication.yml文件</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql:///actdemo?useUnicode=true&amp;characterEncoding=utf8&amp;serverTimezone=GMT&amp;useSSL=false</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">123456</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>  <span class="hljs-attr">activiti:</span><br>    <span class="hljs-comment">#1.flase： 默认值。activiti在启动时，会对比数据库表中保存的版本，如果没有表或者版本不匹配，将抛出异常</span><br>    <span class="hljs-comment">#2.true： activiti会对数据库中所有表进行更新操作。如果表不存在，则自动创建</span><br>    <span class="hljs-comment">#3.create_drop： 在activiti启动时创建表，在关闭时删除表（必须手动关闭引擎，才能删除表）</span><br>    <span class="hljs-comment">#4.drop-create： 在activiti启动时删除原来的旧表，然后在创建新表（不需要手动关闭引擎）</span><br>    <span class="hljs-attr">database-schema-update:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#检测历史表是否存在 activiti7默认没有开启数据库历史记录 启动数据库历史记录</span><br>    <span class="hljs-attr">db-history-used:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#记录历史等级 可配置的历史级别有none, activity, audit, full</span><br>    <span class="hljs-attr">history-level:</span> <span class="hljs-string">full</span><br>    <span class="hljs-comment">#校验流程文件，默认校验resources下的processes文件夹里的流程文件</span><br>    <span class="hljs-attr">check-process-definitions:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure>

<h2 id="3、pom-xml"><a href="#3、pom-xml" class="headerlink" title="3、pom.xml"></a><strong>3、pom.xml</strong></h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- bpmn 模型处理 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- bpmn 转换 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 链接池 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>aspectj<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>aspectjweaver<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.5.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>transmittable-thread-local<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.12.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>activiti整合Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch 简介与使用</title>
    <url>/2022/01/15/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Elasticsearch-简介与使用"><a href="#Elasticsearch-简介与使用" class="headerlink" title="Elasticsearch 简介与使用"></a>Elasticsearch 简介与使用</h1><p><a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html">Elasticsearch: 权威指南</a></p>
<p><a href="https://blog.csdn.net/qq_37883866/article/details/106200618">ES入门</a></p>
<p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/6.4/query-filter-context.html">ES6.4官方文档</a></p>
<h2 id="什么是Elastic-Search"><a href="#什么是Elastic-Search" class="headerlink" title="什么是Elastic Search"></a>什么是Elastic Search</h2><p>​    ElasticSearch 简称 ES ，是基于Apache Lucene构建的<strong>开源搜索引擎</strong>，是当前流行的企业级搜索引擎。Lucene本身就可以被认为迄今为止性能最好的一款开源搜索引擎工具包，但是lucene的API相对复杂，需要深厚的搜索理论。很难集成到实际的应用中去。但是ES是采用java语言编写，提供了简单易用的<strong>RestFul API</strong>，开发者可以使用其简单的RestFul API，开发相关的搜索功能，从而避免lucene的复杂性。</p>
<p>同时ES还是一个<strong>分布式文档数据库</strong></p>
<p>​    </p>
<h2 id="ES的应用场景"><a href="#ES的应用场景" class="headerlink" title="ES的应用场景"></a>ES的应用场景</h2><p>​        ES主要以轻量级JSON作为数据存储格式，它被用作<strong>全文检索</strong>、<strong>结构化搜索</strong>、<strong>分析</strong>以及这三个功能的组合（ELK）</p>
<p>​    <strong>我们本次使用主要是使用ES的结构化搜索功能来替代Mysql搜索</strong></p>
<h2 id="ES相关概念介绍"><a href="#ES相关概念介绍" class="headerlink" title="ES相关概念介绍"></a>ES相关概念介绍</h2><table>
<thead>
<tr>
<th>ES</th>
<th>Mysql</th>
</tr>
</thead>
<tbody><tr>
<td>Index</td>
<td>数据库</td>
</tr>
<tr>
<td>Type</td>
<td>数据表</td>
</tr>
<tr>
<td>Document</td>
<td>行</td>
</tr>
<tr>
<td>Mapping</td>
<td>Schema</td>
</tr>
</tbody></table>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106005052880-1655773287895.png" alt="image-20220106005052880"></p>
<h3 id="1、索引（-index）"><a href="#1、索引（-index）" class="headerlink" title="1、索引（_index）"></a>1、索引（_index）</h3><p>​    类似MYSQL的数据库</p>
<h3 id="2、类型（-type）"><a href="#2、类型（-type）" class="headerlink" title="2、类型（_type）"></a>2、类型（_type）</h3><p>​    类似MYSQL的表</p>
<h3 id="3、字段（field）"><a href="#3、字段（field）" class="headerlink" title="3、字段（field）"></a>3、字段（field）</h3><p>​    类型里的字段，类似MYSQL的表字段</p>
<h3 id="4、文档（document）"><a href="#4、文档（document）" class="headerlink" title="4、文档（document）"></a>4、文档（document）</h3><p>​    类似MYSQL的行数据</p>
<h3 id="5、映射-mapping"><a href="#5、映射-mapping" class="headerlink" title="5、映射(mapping)"></a>5、映射(mapping)</h3><p>​    类似MYSQL的DDL，声明索引与类型的关系、类型与字段的关系，是json格式</p>
<h3 id="6、正向索引"><a href="#6、正向索引" class="headerlink" title="6、正向索引"></a>6、正向索引</h3><p>​    以文档的ID为关键字，表中记录文档中每个字的位置信息，查找时扫描表中每个文档中字的信息直到找出所有包含查询关键字的文档，比如Mysql的B+聚餐索引<br><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20211206233052712.png" alt="image-20211206233052712"></p>
<h3 id="7、倒排索引"><a href="#7、倒排索引" class="headerlink" title="7、倒排索引"></a>7、倒排索引</h3><p>​    倒排表以字或词为关键字进行索引，表中关键字所对应的记录表项记录了出现这个字或词的所有文档，一个表项就是一个字表段，它记录该文档的ID和字符在该文档中出现的位置情况，比如ES索引结构</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /dangdang             <br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;product&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>        	<span class="hljs-attr">&quot;title&quot;</span>:    &#123; <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>  &#125;,<br>        	<span class="hljs-attr">&quot;name&quot;</span>:     &#123; <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span>  &#125;,<br>       		<span class="hljs-attr">&quot;age&quot;</span>:      &#123; <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span> &#125;,<br>        	<span class="hljs-attr">&quot;created&quot;</span>:  &#123;<br>         		 <span class="hljs-attr">&quot;type&quot;</span>:   <span class="hljs-string">&quot;date&quot;</span><br>        		&#125;<br>      		&#125;<br>    	&#125;<br>  	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106005312913.png" alt="image-20220106005312913"></p>
<h3 id="8、面向文档"><a href="#8、面向文档" class="headerlink" title="8、面向文档"></a>8、面向文档</h3><p>​        应用中的对象很少只是简单的键值列表，更多时候它拥有复杂的数据结构，比如包含日期、地理位置、另一个对象或者数组。<br>​        总有一天你会想到把这些对象存储到数据库中。将这些数据保存到由行和列组成的关系数据库中，就好像是把一个丰富，信息表现力强的对象拆散了放入一个非常大的表格中：你不得不拆散对象以适应表模式（通常一列表示一个字段），然后又不得不在查询的时候重建它们。<br>​        Elasticsearch是面向文档(document oriented)的，这意味着它可以存储整个对象或文档(document)。然而它不仅仅是存储，还会索引(index)每个文档的内容使之可以被搜索。在Elasticsearch中，你可以对文档（而非成行成列的数据）进行索引、搜索、排序、过滤。这种理解数据的方式与以往完全不同，这也是Elasticsearch能够执行复杂的全文搜索的原因之一。</p>
<h3 id="9、节点-node-和集群-node"><a href="#9、节点-node-和集群-node" class="headerlink" title="9、节点(node)和集群(node)"></a>9、节点(node)和集群(node)</h3><p>Elasticsearch可以作为一个独立的单个搜索服务器。不过，为了能够处理大型数据集，实现容错和高可用性，Elasticsearch可以运行在许多互相合作的服务器上。这些服务器称为集群（cluster），形成集群的每个服务器称为节点（node）。</p>
<h3 id="10、分片-shards"><a href="#10、分片-shards" class="headerlink" title="10、分片(shards )"></a>10、分片(shards )</h3><p>当有大量的文档时，由于内存的限制、硬盘能力、处理能力不足、无法足够快地响应客户端请求等，一个节点可能不够。在这种情况下，数据可以分为较小的称为分片（shard）的部分（其中每个分片都是一个独立的Apache Lucene索引）。每个分片可以放在不同的服务器上，因此，数据可以在集群的节点中传播。当你查询的索引分布在多个分片上时，Elasticsearch会把查询发送给每个相关的分片，并将结果合并在一起，而应用程序并不知道分片的存在。此外，多个分片可以加快索引。</p>
<h3 id="11、副本-replicas"><a href="#11、副本-replicas" class="headerlink" title="11、副本(replicas)"></a>11、副本(replicas)</h3><p>为了提高查询吞吐量或实现高可用性，可以使用分片副本。副本（replica）只是一个分片的精确复制，每个分片可以有零个或多个副本。换句话说，Elasticsearch可以有许多相同的分片，其中之一被自动选择去更改索引操作。这种特殊的分片称为主分片（primary shard），其余称为副本分片（replica shard）。在主分片丢失时，例如该分片数据所在服务器不可用，集群将副本提升为新的主分片。</p>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106010538406.png" alt="image-20220106010538406"></p>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20220106011158094.png" alt="image-20220106011158094"></p>
<h3 id="12、字段类型"><a href="#12、字段类型" class="headerlink" title="12、字段类型"></a>12、字段类型</h3><p><strong>text:</strong><br>按规则分词，至少分词1个词，做全文检索（不要存放空值，会导致性能浪费）<br>默认分词器standard<br>应用场景：用于分词检索场景<br><strong>keyword:</strong><br>不分词，仅仅一个词，查询效率高，早期没有这个类型，用String代替，通过属性设置<br>应用场景：固定文本，无需全文检索，如姓名，省，商品类目<br><strong>整数</strong>：Long（64bit）、Integer（32bit、21亿）、short（16bit）、Byte（8bit）<br><strong>浮点</strong>：Double 、Float  、Half Float 、Scaled float(缩放浮点类型，解决浮点类型计算精度的错误问题)<br><strong>日期类型 date</strong><br>日期格式化 format（定义日期类型一定要定义format格式，防止后面一些不确定问题），建议使用UTC时间格式，因为时区问题可能导致查询失败<br>其他非常用字段：略</p>
<h2 id="ES查询"><a href="#ES查询" class="headerlink" title="ES查询"></a>ES查询</h2><p>​    ES官方提供了两中检索方式:一种是通过 URL 参数进行搜索,另一种是通过 DSL(Domain Specified Language) 进行搜索。官方更推荐使用第二种方式第二种方式是基于传递JSON作为请求体(request body)格式与ES进行交互，这种方式更强大，更简洁。</p>
<h1 id="ES数据同步方案"><a href="#ES数据同步方案" class="headerlink" title="ES数据同步方案"></a>ES数据同步方案</h1><h2 id="1、业务层同步"><a href="#1、业务层同步" class="headerlink" title="1、业务层同步"></a>1、业务层同步</h2><p>​    在业务层完成数据操作提交事务后，同步数据至ES，常见的做法是在ORM的hooks钩子里编写监听相关表的增删改操作落表记录，发起延时调度触发ES同步</p>
<p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/ES%E6%8E%A5%E5%85%A5%E6%96%B9%E6%A1%88.png"></p>
<p>优点：系统自身形成闭环，不依赖新的组件</p>
<p>缺点：ES不支持事务</p>
<p>风险点：从0到1开发，许多技术点待落实</p>
<h2 id="2、基于binlog的日志订阅"><a href="#2、基于binlog的日志订阅" class="headerlink" title="2、基于binlog的日志订阅"></a>2、基于binlog的日志订阅</h2><p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/Snipaste_2021-12-28_15-59-27.png"></p>
<p>介绍：模拟mysql原生主从模式，server端dump binlog并持久化到本地，即使源库down机，client端依然可以从server端正常接收已被持久化的binlog<br>优点：通过解析mysql的binlog同步数据的变更，适合实时性要求较高的场景<br>风险点：运维DB交互耗时<br>Binlogcenter(公司自研组件)：原理类似阿里的Canal<br><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image-20211228164415510.png" alt="image-20211228164415510"></p>
<p><strong>MQ消费方案</strong><br><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image2022-1-6_15-54-57.png" alt="image-20220106124238205"></p>
<h2 id="3、定时任务根据last-update-time字段同步"><a href="#3、定时任务根据last-update-time字段同步" class="headerlink" title="3、定时任务根据last_update_time字段同步"></a>3、定时任务根据last_update_time字段同步</h2><p><img src="/images/ES(ElasticSearch)%E7%AE%80%E4%BB%8B/image2021-9-2_10-55-18.png"></p>
<p>缺点：数据的更新存在一定的延迟，数据的删除无法同步更新，数据最终达成一致</p>
<p>优点：实现简单粗暴</p>
<h1 id="使用ES（6-4-0）"><a href="#使用ES（6-4-0）" class="headerlink" title="使用ES（6.4.0）"></a>使用ES（6.4.0）</h1><h2 id="Spring-Data接入方式使用demo"><a href="#Spring-Data接入方式使用demo" class="headerlink" title="Spring-Data接入方式使用demo"></a>Spring-Data接入方式使用demo</h2><p>1、创建demo实体</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Document(indexName = &quot;user-item&quot;,createIndex = false)</span><br><span class="hljs-meta">@Setting(settingPath = &quot;elasticsearch/settings.json&quot;)</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsUserItem</span></span>&#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;用户管理事项关系(获取详情的id)id&quot;)</span><br>    <span class="hljs-meta">@Id</span><br>    <span class="hljs-meta">@Field(type = FieldType.Keyword)</span><br>    <span class="hljs-keyword">private</span> String itemUserId;<br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;姓名&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;管理事项&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Text)</span><br>    <span class="hljs-keyword">private</span> String content;<br><br><br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;执行状态&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Integer)</span><br>    <span class="hljs-keyword">private</span> Integer performState;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;执行开始日期&quot;)</span><br>    <span class="hljs-meta">@Field(type = FieldType.Date, format = DateFormat.custom, pattern = &quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS&quot;)</span><br>    <span class="hljs-keyword">private</span> Date performStartDate;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;执行结束日期)</span><span class="hljs-string">&quot;)</span><br><span class="hljs-string">    @Field(type = FieldType.Date, format = DateFormat.custom, pattern = &quot;</span>yyyy-MM-dd HH:mm:ss<span class="hljs-string">&quot;)</span><br><span class="hljs-string">    private Date performEndDate;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>

<p>2、创建索引+设置映射+查询语句（DSL）</p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">PUT /mss_user_item<br>&#123;<br>  <span class="hljs-attr">&quot;mappings&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;UserItem&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;properties&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;itemUserId&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;userName&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;keyword&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;content&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;text&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;performState&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;integer&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;performStartDate&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>,<br>          <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS||epoch_millis&quot;</span><br>        &#125;,<br>        <span class="hljs-attr">&quot;performEndDate&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;type&quot;</span>: <span class="hljs-string">&quot;date&quot;</span>,<br>          <span class="hljs-attr">&quot;format&quot;</span>: <span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss||yyyy-MM-dd HH:mm:ss.SSS||epoch_millis&quot;</span><br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br><br>GET mss-user-item/UserItem/_search?<br>&#123;<br>  <span class="hljs-attr">&quot;query&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;bool&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;must&quot;</span>: [<br>        &#123;<br>          <span class="hljs-attr">&quot;terms&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;performState&quot;</span>: [<br>              <span class="hljs-number">2</span>,<br>              <span class="hljs-number">3</span>,<br>              <span class="hljs-number">4</span>,<br>              <span class="hljs-number">5</span>,<br>              <span class="hljs-number">6</span>,<br>              <span class="hljs-number">1</span><br>            ],<br>            <span class="hljs-attr">&quot;boost&quot;</span>: <span class="hljs-number">1</span><br>          &#125;<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">&quot;terms&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;userName&quot;</span>: [<br>              <span class="hljs-string">&quot;李1&quot;</span>,<br>              <span class="hljs-string">&quot;李2&quot;</span>,<br>              <span class="hljs-string">&quot;李3&quot;</span>,<br>              <span class="hljs-string">&quot;李4&quot;</span>,<br>              <span class="hljs-string">&quot;李5&quot;</span>,<br>              <span class="hljs-string">&quot;李6&quot;</span><br>            ],<br>            <span class="hljs-attr">&quot;boost&quot;</span>: <span class="hljs-number">1</span><br>          &#125;<br>        &#125;,<br>        &#123;<br>          <span class="hljs-attr">&quot;prefix&quot;</span>: &#123;<br>            <span class="hljs-attr">&quot;userName&quot;</span>: &#123;<br>              <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;李&quot;</span><br>            &#125;<br>          &#125;<br>        &#125;,<br>        &#123;<br>         <span class="hljs-attr">&quot;wildcard&quot;</span>: &#123;<br>           <span class="hljs-attr">&quot;userName&quot;</span>: &#123;<br>             <span class="hljs-attr">&quot;value&quot;</span>: <span class="hljs-string">&quot;李*&quot;</span><br>           &#125;<br>         &#125;<br>        &#125;<br>      ],<br>      <span class="hljs-attr">&quot;filter&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;range&quot;</span>: &#123;<br>          <span class="hljs-attr">&quot;performStartDate&quot;</span>: &#123;<br>          <br>            <span class="hljs-attr">&quot;lte&quot;</span>: <span class="hljs-string">&quot;2022-01-06 19:26:18&quot;</span><br>          &#125;<br>        &#125;<br>      &#125;<br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;sort&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;itemUserId&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;order&quot;</span>: <span class="hljs-string">&quot;asc&quot;</span><br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>索引文档的简单地增删改查–使用spring-data面向对象编程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ItemRepository</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ElasticsearchRepository</span>&lt;<span class="hljs-title">UserItem</span>,<span class="hljs-title">Long</span>&gt; </span>&#123;<br>&#125;<br><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsertById</span><span class="hljs-params">(String indexName)</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        UserItem userItem = <span class="hljs-keyword">new</span> UserItem().setItemUserId(<span class="hljs-number">1</span>).setUserName(<span class="hljs-string">&quot;李&quot;</span>).setContent(<span class="hljs-string">&quot;lallala&quot;</span>)<br>                .setPerformEndDate(<span class="hljs-keyword">new</span> Date())<br>                .setPerformStartDate(<span class="hljs-keyword">new</span> Date()).setPerformState(<span class="hljs-number">1</span>);<br>        UserItem save = itemRepository.save(userItem);<br>        UserItem UserItem = itemRepository.findById(<span class="hljs-string">&quot;1&quot;</span>).orElse(<span class="hljs-keyword">null</span>);<br>        log.info(UserItem.toString());<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="XXX列表页查询接入使用"><a href="#XXX列表页查询接入使用" class="headerlink" title="XXX列表页查询接入使用"></a>XXX列表页查询接入使用</h3><p><strong>查询入参</strong></p>
<figure class="highlight json"><table><tr><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;deptId&quot;</span>: [<br>        <span class="hljs-number">4102</span>,<br>        <span class="hljs-number">4107</span><br>    ],<br>    <span class="hljs-attr">&quot;gradeOrRoleId&quot;</span>: [<br>        <span class="hljs-number">498</span>,<br>        <span class="hljs-number">488</span><br>    ],<br>    <span class="hljs-attr">&quot;leaderUserId&quot;</span>: [<br>        <span class="hljs-number">28</span>,<br>        <span class="hljs-number">32</span><br>    ],<br>    <span class="hljs-attr">&quot;pageIndex&quot;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">&quot;pageSize&quot;</span>: <span class="hljs-number">20</span>,<br>    <span class="hljs-attr">&quot;performState&quot;</span>: [<br>        <span class="hljs-number">10</span>,<br>        <span class="hljs-number">5</span>,<br>        <span class="hljs-number">15</span>,<br>        <span class="hljs-number">20</span>,<br>        <span class="hljs-number">30</span>,<br>        <span class="hljs-number">35</span><br>    ],<br>    <span class="hljs-attr">&quot;performTimeEnd&quot;</span>: <span class="hljs-string">&quot;2022-01-01&quot;</span>,<br>    <span class="hljs-attr">&quot;performTimeStart&quot;</span>: <span class="hljs-string">&quot;2021-12-01&quot;</span>,<br>    <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">28</span>,<br>    <span class="hljs-attr">&quot;employeeId&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-attr">&quot;isPersonMark&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;isWorkMark&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-attr">&quot;ehrEmployeeId&quot;</span>: <span class="hljs-string">&quot;111111&quot;</span><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><strong>查询SQL</strong>：略</p>
<p>根据前端查询检索入参和原SQL查询条件得到索引类型结构</p>
<p>1、梳理用户点检项列表的索引字段</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">itemUserId <span class="hljs-comment">--用户点检id</span><br>ogDeptId <span class="hljs-comment">--部门id</span><br>leaderUserId <span class="hljs-comment">--上级id </span><br>manage_grade_id <span class="hljs-comment">--管理职级id</span><br>is_exist_personal_remark <span class="hljs-comment">--是否存在个人备注</span><br>is_exist_work_remark  <span class="hljs-comment">--是否存在工作备注</span><br>execute_role_id <span class="hljs-comment">--执行角色id</span><br>perform_start_time <span class="hljs-comment">--执行开始时间</span><br>perform_end_time <span class="hljs-comment">--执行结束时间</span><br>perform_state <span class="hljs-comment">--点检项状态</span><br></code></pre></td></tr></table></figure>

<h2 id="RestHighLevelClient接入-amp-封装"><a href="#RestHighLevelClient接入-amp-封装" class="headerlink" title="RestHighLevelClient接入&amp;封装"></a>RestHighLevelClient接入&amp;封装</h2><p>​    Java 高级 REST 客户端现在是 Elasticsearch 的默认客户端，它提供了对 TransportClient 的直接替代，因为它接受并返回完全相同的请求/响应对象，因此依赖于 Elasticsearch 核心项目。异步调用在客户端管理的线程池上进行操作，并且需要在请求完成时通知回调，总之SpringBoot项目使用它不会有那么多垃圾兼容问题</p>
<h3 id="1、说在前面"><a href="#1、说在前面" class="headerlink" title="1、说在前面"></a>1、说在前面</h3><p>1、因为博主公司对日志输出有限制，只有info级别以上的日志才会上传Kibana，所以需要对ES的日志打印进行调整</p>
<p>2、RestHighLevelClient没有提供链式调用的封装方法和字段名设置解耦（像spring-data-es封装），所以为了后续字段修改扩展和方便调用，需要对API进行一定的封装</p>
<h3 id="2、开始引入"><a href="#2、开始引入" class="headerlink" title="2、开始引入"></a>2、开始引入</h3><h4 id="1、maven依赖引入"><a href="#1、maven依赖引入" class="headerlink" title="1、maven依赖引入"></a>1、maven依赖引入</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.elasticsearch.client<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>elasticsearch-rest-high-level-client<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="2、封装ES-Service操作接口"><a href="#2、封装ES-Service操作接口" class="headerlink" title="2、封装ES Service操作接口"></a>2、封装ES Service操作接口</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">EsIService</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function">List&lt;T&gt; <span class="hljs-title">search</span><span class="hljs-params">(SearchRequest searchRequest)</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-function">MssRestHighLevelClient <span class="hljs-title">getRestHighLevelClient</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">lambdaQuery</span><span class="hljs-params">()</span></span>&#123;<br>        BaseEsQueryChainWrapper&lt;T&gt; wrapper = <span class="hljs-keyword">new</span> BaseEsQueryChainWrapper&lt;&gt;();<br>        wrapper.setIndex(getIndex());<br>        wrapper.setType(getType());<br>        wrapper.setClazz(getClazz());<br>        wrapper.setRestHighLevelClient(getRestHighLevelClient());<br>        <span class="hljs-keyword">return</span> wrapper;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取索引</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取类型</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getType</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Class&lt;T&gt; <span class="hljs-title">getClazz</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsIServiceImpl</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">EsIService</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>	<span class="hljs-comment">//记录T的Class</span><br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; clazz;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> MssRestHighLevelClient mssRestHighLevelClient;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EsIServiceImpl</span><span class="hljs-params">()</span> </span>&#123;<br>      clazz = (Class)((ParameterizedType) <span class="hljs-keyword">this</span>.getClass().getGenericSuperclass()).getActualTypeArguments()[<span class="hljs-number">0</span>];<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;T&gt; <span class="hljs-title">doSearch</span><span class="hljs-params">(SearchRequest searchRequest)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        SearchResponse search = mssRestHighLevelClient.search(searchRequest);<br>        List&lt;T&gt; list = Stream.of(search.getHits().getHits()).map(e -&gt; <span class="hljs-keyword">new</span> JSONObject(e.getSourceAsMap()).toJavaObject(clazz)).collect(Collectors.toList());<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MssRestHighLevelClient <span class="hljs-title">getRestHighLevelClient</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mssRestHighLevelClient;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mss-user-item&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;mssesuseritem&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Class&lt;T&gt; <span class="hljs-title">getClazz</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> clazz;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="3、封装Lambda调用-举例封装must、should、filter"><a href="#3、封装Lambda调用-举例封装must、should、filter" class="headerlink" title="3、封装Lambda调用(举例封装must、should、filter)"></a>3、封装Lambda调用(举例封装must、should、filter)</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ColumnFunction</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">Function</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">R</span>&gt;, <span class="hljs-title">Serializable</span></span>&#123;<br><br>&#125;<br><span class="hljs-comment">//根据传进来的get方法获取字段属性名</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ColumnUtil</span></span>&#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String GET = <span class="hljs-string">&quot;get&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getColumn</span><span class="hljs-params">(ColumnFunction&lt;?,?&gt; fn)</span></span>&#123;<br>        Method writeReplaceMethod;<br>        <span class="hljs-keyword">try</span> &#123;<br>            writeReplaceMethod = fn.getClass().getDeclaredMethod(<span class="hljs-string">&quot;writeReplace&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;es入参序列化失败,e&quot;</span>,e);<br>        &#125;<br><br>        ReflectionUtils.makeAccessible(writeReplaceMethod);<br>        SerializedLambda serializedLambda;<br>        <span class="hljs-keyword">try</span> &#123;<br>            serializedLambda = (SerializedLambda) writeReplaceMethod.invoke(fn);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;es入参序列化失败,e&quot;</span>,e);<br>        &#125;<br><br>        <span class="hljs-comment">// 从lambda信息取出methodName</span><br>        String implMethodName = serializedLambda.getImplMethodName();<br>        <span class="hljs-comment">// 确保方法是符合规范的get方法</span><br>        <span class="hljs-keyword">if</span> (!implMethodName.startsWith(GET)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;只允许传入get方法: &quot;</span> + implMethodName);<br>        &#125;<br><br>        String fieldName = implMethodName.substring(GET.length());<br>        String firstChar = fieldName.substring(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        fieldName = fieldName.replaceFirst(firstChar, firstChar.toLowerCase());<br>        <span class="hljs-keyword">return</span> fieldName;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//链式调用构造SearchRequest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseEsQueryChainWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">protected</span> SearchSourceBuilder builder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>    <span class="hljs-keyword">protected</span> MssRestHighLevelClient restHighLevelClient;<br><br>    <span class="hljs-keyword">protected</span> String index;<br>    <span class="hljs-keyword">public</span> Class&lt;T&gt; clazz;<br><br>    <span class="hljs-keyword">protected</span> String type;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClazz</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColumn</span><span class="hljs-params">(ColumnFunction&lt;T,?&gt; fn)</span></span>&#123;<br>        String column = ColumnUtil.getColumn(fn);<br>        <span class="hljs-keyword">return</span> column;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRestHighLevelClient</span><span class="hljs-params">(MssRestHighLevelClient restHighLevelClient)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restHighLevelClient = restHighLevelClient;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getIndex</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> type;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setIndex</span><span class="hljs-params">(String index)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.index = index;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setType</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.type = type;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseEsQueryChainWrapper</span><span class="hljs-params">()</span> </span>&#123;<br>        builder.query(QueryBuilders.boolQuery());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">mustEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.must(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">filterEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.filter(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">shouldEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.should(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">nestedMustEq</span><span class="hljs-params">(BoolQueryBuilder nestedQueryBuilder)</span></span>&#123;<br>        BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) builder.query();<br>        boolQueryBuilder.must(nestedQueryBuilder);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SearchRequest <span class="hljs-title">getSearchRequest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(index);<br>        request.types(type);<br>        request.source(builder);<br>        <span class="hljs-keyword">return</span> request;<br>    &#125;<br><br>&#125;<br><span class="hljs-comment">//嵌套链式调用</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseNestedEsQueryChainWrapper</span>&lt;<span class="hljs-title">T</span>&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery(); ;<br><br>    <span class="hljs-keyword">public</span> Class&lt;T&gt; clazz;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClazz</span><span class="hljs-params">(Class&lt;T&gt; clazz)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.clazz = clazz;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColumn</span><span class="hljs-params">(ColumnFunction&lt;T,?&gt; fn)</span></span>&#123;<br>        String column = ColumnUtil.getColumn(fn);<br>        <span class="hljs-keyword">return</span> column;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseNestedEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">mustEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        boolQueryBuilder.must(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseNestedEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">filterEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        boolQueryBuilder.filter(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseNestedEsQueryChainWrapper&lt;T&gt; <span class="hljs-title">shouldEq</span><span class="hljs-params">(ColumnFunction&lt;T, ?&gt; column , Object value)</span></span>&#123;<br>        boolQueryBuilder.should(QueryBuilders.termQuery(getColumn(column),value));<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BoolQueryBuilder <span class="hljs-title">getBoolQueryBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> boolQueryBuilder;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h4 id="4、日志切面"><a href="#4、日志切面" class="headerlink" title="4、日志切面"></a>4、日志切面</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Order</span><br><span class="hljs-meta">@Profile(&#123;&quot;local&quot;, &quot;dev&quot;, &quot;test&quot;, &quot;ys&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EsLogAspect</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Integer PRINT_LIMIT = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">//切EsIServiceImpl的do开头的方法</span><br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * *.EsIServiceImpl.do*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Around(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-comment">// 获取切入点的方法参数</span><br>        Object[] args = point.getArgs();<br>        <span class="hljs-keyword">for</span> (Object arg : args) &#123;<br>            <span class="hljs-keyword">if</span> (arg <span class="hljs-keyword">instanceof</span> SearchRequest) &#123;<br>                SearchRequest searchRequest = (SearchRequest) arg;<br>                log.info(<span class="hljs-string">&quot;ES查询参数：&#123;&#125;&quot;</span>, searchRequest);<br>            &#125;<br>        &#125;<br><br>        Object ret = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>            ret = point.proceed();<br>            <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>            <span class="hljs-keyword">if</span> (ret <span class="hljs-keyword">instanceof</span> SearchResponse) &#123;<br>                SearchResponse searchResponse = (SearchResponse) ret;<br>                Aggregations aggs = searchResponse.getAggregations();<br>                SearchHit[] hits = searchResponse.getHits().getHits();<br>                <span class="hljs-comment">// 防止查询出来的记录数太多打印不了，最多打印10条</span><br>                <span class="hljs-keyword">int</span> toIndex = hits.length &gt; PRINT_LIMIT? PRINT_LIMIT:  hits.length;<br>                List&lt;SearchHit&gt; hitList = Arrays.stream(hits).limit(toIndex).collect(Collectors.toList());<br>                String data = hitList.stream().map(SearchHit::getSourceAsString).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>                log.info(<span class="hljs-string">&quot;ES查询耗时：&#123;&#125;ms, ES查询结果：contents=&#123;&#125;, 聚合结果：aggregations=&#123;&#125;&quot;</span>,<br>                        end - start, data, aggs == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : JSON.toJSON(aggs.asList()));<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                log.info(<span class="hljs-string">&quot;ES查询耗时：&#123;&#125;ms, ES查询结果：contents=&#123;&#125;&quot;</span>,end - start,ret);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            log.error(<span class="hljs-string">&quot;ES请求错误：&#123;&#125;&quot;</span>, e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MssBizException(<span class="hljs-string">&quot;ES请求错误&quot;</span>);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> ret;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="5、测试类"><a href="#5、测试类" class="headerlink" title="5、测试类"></a>5、测试类</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItemEsMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EsIServiceImpl</span>&lt;<span class="hljs-title">MssEsUserItem</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(String index,String type)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//原生构造</span><br>        SearchRequest request = <span class="hljs-keyword">new</span> SearchRequest(index);<br>        request.types(type);<br>        SearchSourceBuilder builder = <span class="hljs-keyword">new</span> SearchSourceBuilder();<br>        BoolQueryBuilder query = QueryBuilders.boolQuery();<br>        query.filter(QueryBuilders.termsQuery(<span class="hljs-string">&quot;itemUserId&quot;</span>, Arrays.asList(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>)));<br>        query.must(QueryBuilders.prefixQuery(<span class="hljs-string">&quot;userName&quot;</span>, <span class="hljs-string">&quot;李&quot;</span>));<br>        query.must(QueryBuilders.rangeQuery(<span class="hljs-string">&quot;itemUserId&quot;</span>).lte(<span class="hljs-number">9</span>).gte(<span class="hljs-number">1</span>));<br>        builder.query(query);<br>        builder.from(<span class="hljs-number">0</span>).size(<span class="hljs-number">10</span>);<br>        builder.sort(<span class="hljs-string">&quot;itemUserId&quot;</span>);<br>        builder.aggregation(AggregationBuilders.count(<span class="hljs-string">&quot;userName&quot;</span>).field(<span class="hljs-string">&quot;userName&quot;</span>));<br>        request.source(builder);<br>        List&lt;MssEsUserItem&gt; search = itemEsMapper.doSearch(request);<br>        <span class="hljs-comment">//链式构造</span><br>        BoolQueryBuilder nested = itemEsMapper.lambdaNestedQuery().shouldEq(MssEsUserItem::getUserName, <span class="hljs-string">&quot;李1&quot;</span>).shouldEq(MssEsUserItem::getUserName, <span class="hljs-string">&quot;李2&quot;</span>).getBoolQueryBuilder();<br>        SearchRequest searchRequest = itemEsMapper.lambdaQuery()<br>                .mustEq(MssEsUserItem::getItemUserId, <span class="hljs-number">1L</span>).nestedMustEq(nested).getSearchRequest();<br>        List&lt;MssEsUserItem&gt; list = itemEsMapper.doSearch(searchRequest);<br><br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//测试接口</span><br><span class="hljs-meta">@PostMapping(value = &quot;/testQuery&quot;)</span><br><span class="hljs-meta">@Menu(MenuConfig.DATA_REPAIR)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;测试查询&quot;, notes = &quot; 测试查询&quot;)</span><br><span class="hljs-keyword">public</span> Response&lt;PageResult&lt;MssEsUserItem&gt;&gt; testQuery(<span class="hljs-meta">@RequestBody</span> VisitTagDTO visitTagDTO) <span class="hljs-keyword">throws</span> IOException &#123;<br>    esTestService.test(<span class="hljs-string">&quot;mss-user-item&quot;</span>,<span class="hljs-string">&quot;mssesuseritem&quot;</span>);<br>    <span class="hljs-keyword">return</span> RestResponse.buildSuccessInfo(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h1><p>1、单次查询数量 form+size不大于5k</p>
<blockquote>
<p>假如每页是 10 条数据，现在要查询第 100 页的10条数据，实际上是会把每个 shard 上存储的前 1000 条数据都查到一个协调节点上。如果有个 5 个 shard，那么就有 5000 条数据，接着协调节点对这 5000 条数据进行一些合并、处理，再获取到最终第 100 页的 10 条数据。</p>
<p>ES作为分布式程序，要查第 100 页的 10 条数据，不可能说从 5 个 shard，每个 shard 就查 2 条数据，最后到协调节点合并成 10 条数据，必须得从每个 shard 都查 1000 条数据过来，然后根据的需求进行排序、筛选等等操作，最后再次分页，拿到里面第 100 页的数据。翻页的时候，翻的越深，每个 shard 返回的数据就越多，而且协调节点处理的时间越长，所以用 es 做分页的时候，会发现越翻到后面，就越是慢。</p>
<p>解决方案：</p>
<ol>
<li><p>不允许深度分页。（目前使用的是这种方法）</p>
</li>
<li><p>scroll api</p>
<p>scroll 会一次性给你生成所有数据的一个快照，然后每次滑动向后翻页就是通过游标 scroll_id移动，获取下一页下一页这样子，性能会比上面说的那种分页性能要高很多很多，基本上都是毫秒级的。但是这一种不能随意跳到任何一页。</p>
</li>
<li><p>search_after</p>
<p>search_after 的思想是使用前一页的结果来帮助检索下一页的数据，显然，这种方式也不允许你随意翻页，你只能一页页往后翻。初始化时，需要使用一个唯一值的字段作为 sort 字段。</p>
</li>
</ol>
</blockquote>
<p>2、禁用 wildcard（keyword前后模糊必须使用）</p>
<p>3、充分利用倒排索引机制，能 keyword 类型尽量 keyword</p>
<p>4、尽可能使用filter而不是query，但是要避免filter cache过大导致jvm飙升</p>
<p>5、做好索引重建的准备（起别名）</p>
<p>6、 java使用es的客户端时，不要使用TransportClient sdk啦。直接使用high level rest client以及low level rest client就好了。（如果不看文档，很多人直接选择 TransportClient ，里面好多query dsl的java类，刚刚接触可能选择这个了，但，这个7.0时就被废弃了；8.0之后直接就删除了） </p>
]]></content>
      <categories>
        <category>Elasticsearch</category>
      </categories>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫02-webmagic</title>
    <url>/2024/09/11/Java%E7%88%AC%E8%99%AB02-webmagic/</url>
    <content><![CDATA[<h1 id="Webmagic"><a href="#Webmagic" class="headerlink" title="Webmagic"></a>Webmagic</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>​    WebMagic是一款简单灵活的爬虫框架，它的的架构设计参照了Scrapy，目标是尽量的模块化，并体现爬虫的功能特点。</p>
<h2 id="架构设计"><a href="#架构设计" class="headerlink" title="架构设计"></a>架构设计</h2><h3 id="WebMagic的四个组件"><a href="#WebMagic的四个组件" class="headerlink" title="WebMagic的四个组件"></a>WebMagic的四个组件</h3><p><img src="images/Java%E7%88%AC%E8%99%AB02-webmagic/webmagic.png" alt="image"></p>
<h4 id="1-Downloader"><a href="#1-Downloader" class="headerlink" title="1.Downloader"></a>1.Downloader</h4><p>​    Downloader负责从互联网上下载页面，以便后续处理。WebMagic默认使用了<a href="http://hc.apache.org/index.html">Apache HttpClient</a>作为下载工具。</p>
<h4 id="2-PageProcessor"><a href="#2-PageProcessor" class="headerlink" title="2.PageProcessor"></a>2.PageProcessor</h4><p>​    PageProcessor负责解析页面，抽取有用信息，以及发现新的链接。WebMagic使用<a href="http://jsoup.org/">Jsoup</a>作为HTML解析工具，并基于其开发了解析XPath的工具<a href="https://github.com/code4craft/xsoup">Xsoup</a>。</p>
<p>在这四个组件中，<code>PageProcessor</code>对于每个站点每个页面都不一样，是需要使用者定制的部分。</p>
<h4 id="3-Scheduler"><a href="#3-Scheduler" class="headerlink" title="3.Scheduler"></a>3.Scheduler</h4><p>​    Scheduler负责管理待抓取的URL，以及一些去重的工作。WebMagic默认提供了JDK的内存队列来管理URL，并用集合来进行去重。也支持使用Redis进行分布式管理。</p>
<p>除非项目有一些特殊的分布式需求，否则无需自己定制Scheduler。</p>
<h4 id="4-Pipeline"><a href="#4-Pipeline" class="headerlink" title="4.Pipeline"></a>4.Pipeline</h4><p>​    Pipeline负责抽取结果的处理，包括计算、持久化到文件、数据库等。WebMagic默认提供了“输出到控制台”和“保存到文件”两种结果处理方案。</p>
<p><code>Pipeline</code>定义了结果保存的方式，如果你要保存到指定数据库，则需要编写对应的Pipeline。对于一类需求一般只需编写一个<code>Pipeline</code>。</p>
<h3 id="用于数据流转的对象"><a href="#用于数据流转的对象" class="headerlink" title="用于数据流转的对象"></a>用于数据流转的对象</h3><h4 id="1-Request"><a href="#1-Request" class="headerlink" title="1. Request"></a>1. Request</h4><p>​    <code>Request</code>是对URL地址的一层封装，一个Request对应一个URL地址。</p>
<p>它是PageProcessor与Downloader交互的载体，也是PageProcessor控制Downloader唯一方式。</p>
<p>除了URL本身外，它还包含一个Key-Value结构的字段<code>extra</code>。你可以在extra中保存一些特殊的属性，然后在其他地方读取，以完成不同的功能。例如附加上一个页面的一些信息等。</p>
<h4 id="2-Page"><a href="#2-Page" class="headerlink" title="2. Page"></a>2. Page</h4><p>​    <code>Page</code>代表了从Downloader下载到的一个页面——可能是HTML，也可能是JSON或者其他文本格式的内容。</p>
<p>Page是WebMagic抽取过程的核心对象，它提供一些方法可供抽取、结果保存等。在第四章的例子中，我们会详细介绍它的使用。</p>
<h4 id="3-ResultItems"><a href="#3-ResultItems" class="headerlink" title="3. ResultItems"></a>3. ResultItems</h4><p><code>ResultItems</code>相当于一个Map，它保存PageProcessor处理的结果，供Pipeline使用。它的API与Map很类似，值得注意的是它有一个字段<code>skip</code>，若设置为true，则不应被Pipeline处理</p>
<h3 id="控制爬虫运转的引擎–Spider"><a href="#控制爬虫运转的引擎–Spider" class="headerlink" title="控制爬虫运转的引擎–Spider"></a>控制爬虫运转的引擎–Spider</h3><p>​    Spider是WebMagic内部流程的核心。Downloader、PageProcessor、Scheduler、Pipeline都是Spider的一个属性，这些属性是可以自由设置的，通过设置这个属性可以实现不同的功能。Spider也是WebMagic操作的入口，它封装了爬虫的创建、启动、停止、多线程等功能</p>
<h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>​    不适合爬取动态或者动态加载页面，而现如今大部门大厂网站都做了动态渲染或者反扒。如果需要爬取，可以结合selenium +浏览器驱动访问页面。</p>
<h1 id="Selenium"><a href="#Selenium" class="headerlink" title="Selenium"></a>Selenium</h1><h2 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h2><p>​    Selenium 通过使用 <em>WebDriver</em> 支持市场上所有主流浏览器的自动化。 WebDriver 是一个 API 和协议，它定义了一个语言中立的接口，用于控制 web 浏览器的行为。 每个浏览器都有一个特定的 WebDriver 实现，称为驱动程序。 驱动程序是负责委派给浏览器的组件，并处理与 Selenium 和浏览器之间的通信。总的来说，selenium是一种浏览器控制框架。</p>
<h2 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h2><h5 id="Webmagic-Selenium-Chormedriver"><a href="#Webmagic-Selenium-Chormedriver" class="headerlink" title="Webmagic+Selenium+Chormedriver"></a>Webmagic+Selenium+Chormedriver</h5><h2 id="Boss直聘网爬取"><a href="#Boss直聘网爬取" class="headerlink" title="Boss直聘网爬取"></a>Boss直聘网爬取</h2><h4 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> <span class="hljs-keyword">table</span> `job_info`<br>(<br>    `id`                 <span class="hljs-type">bigint</span>(<span class="hljs-number">20</span>)    <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> auto_increment comment <span class="hljs-string">&#x27;主键id&#x27;</span>,<br>    job_id               <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">100</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;jobid&#x27;</span>,<br>    work_location        <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">50</span>)   <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;workLocation&#x27;</span>,<br>    job_benifit          <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;jobBenifit&#x27;</span>,<br>    work_experience      <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;workExperience&#x27;</span>,<br>    degree_experience    <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">200</span>)  <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;degreeExperience&#x27;</span>,<br>    job_desc             <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">2000</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;jobDesc&#x27;</span>,<br>    `company_name`       <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)           <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;公司名称&#x27;</span>,<br>    `company_addr`       <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>)           <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;公司联系方式&#x27;</span>,<br>    `company_info`       text comment <span class="hljs-string">&#x27;公司信息&#x27;</span>,<br>    `job_name`           <span class="hljs-type">varchar</span>(<span class="hljs-number">100</span>)           <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;职位名称&#x27;</span>,<br>    `job_addr`           <span class="hljs-type">varchar</span>(<span class="hljs-number">200</span>)            <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;工作地点&#x27;</span>,<br>    `job_info`           text comment <span class="hljs-string">&#x27;职位信息&#x27;</span>,<br>    `salary_min`         <span class="hljs-type">float</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)           <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;薪资范围，最小&#x27;</span>,<br>    `salary_max`         <span class="hljs-type">float</span>(<span class="hljs-number">10</span>, <span class="hljs-number">2</span>)           <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;薪资范围，最大&#x27;</span>,<br>     salary_month        <span class="hljs-type">int</span>                    <span class="hljs-keyword">default</span> <span class="hljs-number">12</span> <span class="hljs-keyword">not</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;薪资月数&#x27;</span>,<br>    `url`                <span class="hljs-type">varchar</span>(<span class="hljs-number">1500</span>)          <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;招聘信息详情页&#x27;</span>,<br>    `<span class="hljs-type">time</span>`               <span class="hljs-type">varchar</span>(<span class="hljs-number">10</span>)            <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;职位最近发布时间&#x27;</span>,<br>    `company_creat_time` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>)            <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;公司成立时间&#x27;</span>,<br>    `company_fund`       <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>)            <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;公司注册资本&#x27;</span>,<br>    `boss_active_time`   <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>)            <span class="hljs-keyword">default</span> <span class="hljs-keyword">null</span> comment <span class="hljs-string">&#x27;职位最近发布时间&#x27;</span>,<br>    <span class="hljs-keyword">primary</span> key (`id`)<br>) engine <span class="hljs-operator">=</span> InnoDB comment <span class="hljs-operator">=</span><span class="hljs-string">&#x27;招聘信息&#x27;</span>;<br></code></pre></td></tr></table></figure>

<h4 id="application-properties"><a href="#application-properties" class="headerlink" title="application.properties"></a>application.properties</h4><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.datasource.driver-class-name</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">spring.datasource.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/selenium?characterEncoding=UTF-8&amp;useUnicode=true&amp;useSSL=false&amp;tinyInt1isBit=false&amp;allowPublicKeyRetrieval=true&amp;serverTimezone=Asia/Shanghai</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123456</span><br></code></pre></td></tr></table></figure>

<h4 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cn.hutool<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hutool-all<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.8.27<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>us.codecraft<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>webmagic-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>us.codecraft<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>webmagic-extension<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.8.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.commons<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-lang3<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.47<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>selenium-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.22.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.seleniumhq.selenium<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>selenium-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.13.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-comment">&lt;!--selenium--&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="webmagic3件套"><a href="#webmagic3件套" class="headerlink" title="webmagic3件套"></a>webmagic3件套</h3><h4 id="MyBossDownloader-注入谷歌浏览器驱动"><a href="#MyBossDownloader-注入谷歌浏览器驱动" class="headerlink" title="MyBossDownloader:注入谷歌浏览器驱动"></a><strong>MyBossDownloader</strong>:注入谷歌浏览器驱动</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBossDownloader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Downloader</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RemoteWebDriver driver;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyBossDownloader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 创建chorme的配置信息</span><br>        System.setProperty(<span class="hljs-string">&quot;webdriver.chrome.driver&quot;</span>,<span class="hljs-string">&quot;C:\\Users\\81566\\Downloads\\chromedriver-win64\\chromedriver-win64\\chromedriver.exe&quot;</span>);<br>        <span class="hljs-comment">// 创建chorme对象</span><br>        ChromeOptions chromeOptions = <span class="hljs-keyword">new</span> ChromeOptions();<br>        <span class="hljs-comment">//关闭谷歌驱动上的 Chrome 正在受软件测试控制的 提示</span><br>        chromeOptions.setExperimentalOption(<span class="hljs-string">&quot;excludeSwitches&quot;</span>, Arrays.asList(<span class="hljs-string">&quot;enable-automation&quot;</span>));<br>        <span class="hljs-comment">// 设置为无头模式</span><br>        <span class="hljs-comment">//chromeOptions.addArguments(&quot;--headless&quot;);</span><br>        <span class="hljs-comment">// 设置浏览器打开窗口大小</span><br>        <span class="hljs-comment">//chromeOptions.addArguments(&quot;--window-size=100,100&quot;);</span><br>        <span class="hljs-comment">// 1. 基于配置信息，创建RemoteWebDriver对象</span><br>        driver = <span class="hljs-keyword">new</span> ChromeDriver(chromeOptions);<br>    &#125;<br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Page <span class="hljs-title">download</span><span class="hljs-params">(Request request, Task task)</span> </span>&#123;<br>        String url = request.getUrl();<br>        System.out.println(<span class="hljs-string">&quot;url:&quot;</span>+url);<br>        <span class="hljs-keyword">if</span>(!url.contains(<span class="hljs-string">&quot;detail&quot;</span>))&#123;<br>            <span class="hljs-comment">//下一页</span><br>            <span class="hljs-keyword">if</span>(StrUtil.isNotBlank(request.getExtra(<span class="hljs-string">&quot;url&quot;</span>)))&#123;<br>                url = request.getExtra(<span class="hljs-string">&quot;url&quot;</span>);<br>                <span class="hljs-keyword">if</span>(!url.equals(driver.getCurrentUrl()))&#123;<br>                    driver.get(url);<br>                    Thread.sleep( RandomUtil.randomInt(<span class="hljs-number">8000</span>,<span class="hljs-number">12000</span>));<br>                    doScrollToEnd();<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125;<br><br>                List&lt;WebElement&gt; nextPages = driver.findElementsByCssSelector(<span class="hljs-string">&quot;#wrap &gt; div.page-job-wrapper &gt; div.page-job-inner &gt; div &gt; div.job-list-wrapper &gt; div.search-job-result &gt; div &gt; div &gt; div &gt; a&quot;</span>);<br>                WebElement nextPage = nextPages.get(nextPages.size() - <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span>(!<span class="hljs-string">&quot;disabled&quot;</span>.equals(nextPage.getAttribute(<span class="hljs-string">&quot;class&quot;</span>)))&#123;<br>                    <span class="hljs-comment">//等待元素可点击</span><br>                    ((JavascriptExecutor) driver).executeScript(<span class="hljs-string">&quot;arguments[0].click();&quot;</span>, nextPage);<br>                    Thread.sleep( RandomUtil.randomInt(<span class="hljs-number">8000</span>,<span class="hljs-number">12000</span>));<br><br>                    doScrollToEnd();<br>                    <span class="hljs-keyword">return</span> createPage(driver.getCurrentUrl(), driver.getPageSource(), <span class="hljs-string">&quot;page&quot;</span>);<br>                &#125;<br>                System.out.println(<span class="hljs-string">&quot;翻页失败&quot;</span>);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">//分页 https://www.zhipin.com/web/geek/job?query=Java&amp;city=101280100&amp;page=1</span><br>                driver.get(url);<br>                Thread.sleep( RandomUtil.randomInt(<span class="hljs-number">8000</span>,<span class="hljs-number">12000</span>));<br>                doScrollToEnd();<br>                <span class="hljs-keyword">return</span> createPage(driver.getCurrentUrl(), driver.getPageSource(), <span class="hljs-string">&quot;page&quot;</span>);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            driver.get(url);<br>            Thread.sleep(RandomUtil.randomInt(<span class="hljs-number">2000</span>,<span class="hljs-number">5000</span>));<br>            Page page = createPage(driver.getCurrentUrl(), driver.getPageSource(), <span class="hljs-string">&quot;pageDetail&quot;</span>);<br>            String jobId = request.getExtra(<span class="hljs-string">&quot;jobId&quot;</span>);<br>            page.putField(<span class="hljs-string">&quot;jobId&quot;</span>, jobId);<br>            <span class="hljs-keyword">return</span> page;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doScrollToEnd</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">long</span> height = (<span class="hljs-keyword">long</span>) driver.executeScript(<span class="hljs-string">&quot;return document.body.scrollHeight&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height - <span class="hljs-number">1000</span>; i = i + RandomUtil.randomInt(<span class="hljs-number">200</span>,<span class="hljs-number">500</span>)) &#123;<br>            driver.executeScript(StrUtil.format(<span class="hljs-string">&quot;window.scrollTo(0,&#123;&#125;)&quot;</span>,i));<br>            Thread.sleep(RandomUtil.randomInt(<span class="hljs-number">200</span>,<span class="hljs-number">1000</span>));<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Page <span class="hljs-title">createPage</span><span class="hljs-params">(String url, String html, String pageName)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Page page = <span class="hljs-keyword">new</span> Page();<br>        PlainText plainText = <span class="hljs-keyword">new</span> PlainText(url);<br>        page.setUrl(plainText);<br>        page.setRawText(html);<br><br>        <span class="hljs-keyword">int</span> retry  = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (html.contains(<span class="hljs-string">&quot;请稍候&quot;</span>) &amp;&amp; url.contains(<span class="hljs-string">&quot;detail&quot;</span>) &amp;&amp; retry &lt; <span class="hljs-number">1</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;加载无效,重新加载&quot;</span>);<br>            driver.get(url);<br>            Thread.sleep(<span class="hljs-number">5000</span>);<br>            html = driver.getPageSource();<br>            page.setRawText(html);<br>            retry++;<br>        &#125;<br><br>        Request req = <span class="hljs-keyword">new</span> Request(url);<br>        req.putExtra(<span class="hljs-string">&quot;pageName&quot;</span>,pageName);<br>        page.setRequest(req);<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setThread</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="MyBossPageInterceptor：处理列表页、详情页、下一页"><a href="#MyBossPageInterceptor：处理列表页、详情页、下一页" class="headerlink" title="MyBossPageInterceptor：处理列表页、详情页、下一页"></a><strong>MyBossPageInterceptor</strong>：处理列表页、详情页、下一页</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBossPageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PageProcessor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String domain = <span class="hljs-string">&quot;https://www.zhipin.com&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> Random random = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>        <span class="hljs-comment">//1、列表页 2、详情页</span><br>        Html html = page.getHtml();<br>        Document document = html.getDocument();<br>        String pageName = (String) page.getRequest().getExtras().get(<span class="hljs-string">&quot;pageName&quot;</span>);<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;page&quot;</span>.equals(pageName))&#123;<br>            <span class="hljs-comment">//下一页</span><br>            Request request = <span class="hljs-keyword">new</span> Request();<br>            request.setPriority(RandomUtil.randomInt(<span class="hljs-number">20</span>,<span class="hljs-number">100</span>));<br>            request.setUrl(<span class="hljs-string">&quot;nextPage&quot;</span> + UUID.randomUUID().toString().replace(<span class="hljs-string">&quot;-&quot;</span>, <span class="hljs-string">&quot;&quot;</span>));<br>            request.putExtra(<span class="hljs-string">&quot;url&quot;</span>,page.getUrl().get());<br>            page.addTargetRequest(request);<br><br>            Elements selects = document.select(<span class="hljs-string">&quot;#wrap &gt; div.page-job-wrapper &gt; div.page-job-inner &gt; div &gt; div.job-list-wrapper &gt; div.search-job-result &gt; ul &gt; li&quot;</span>);<br>            <span class="hljs-keyword">if</span>(CollUtil.isNotEmpty(selects))&#123;<br>                <span class="hljs-comment">//列表页</span><br>                List&lt;JobInfo&gt; itemList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                <span class="hljs-keyword">for</span> (Element select : selects) &#123;<br>                    String jobName = select.selectFirst(<span class="hljs-string">&quot;div.job-card-body.clearfix &gt; a &gt; div.job-title.clearfix &gt; span.job-name&quot;</span>).text();<br>                    System.out.println(<span class="hljs-string">&quot;jobName:&quot;</span> + jobName);<br>                    String companyName = select.selectFirst(<span class="hljs-string">&quot;div.job-card-body.clearfix &gt; div &gt; div.company-info &gt; h3 &gt; a&quot;</span>).text();<br>                    System.out.println(<span class="hljs-string">&quot;companyName:&quot;</span> + companyName);<br>                    String workLocation = select.selectFirst(<span class="hljs-string">&quot;div.job-card-body.clearfix &gt; a &gt; div.job-title.clearfix &gt; span.job-area-wrapper &gt; span&quot;</span>).text();<br>                    System.out.println(<span class="hljs-string">&quot;workLocation:&quot;</span> + workLocation);<br>                    String companyInfo = select.select(<span class="hljs-string">&quot;div.job-card-body.clearfix &gt; div &gt; div.company-info &gt; ul &gt; li&quot;</span>).stream().map(Element::text).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;companyInfo:&quot;</span>+companyInfo);<br>                    String jobBenifit = select.select(<span class="hljs-string">&quot;div.job-card-footer.clearfix &gt; div&quot;</span>).stream().map(Element::text).collect(Collectors.joining(<span class="hljs-string">&quot;,&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;jobBenifit:&quot;</span>+jobBenifit);<br>                    String salary = select.select(<span class="hljs-string">&quot;div.job-card-body.clearfix span.salary&quot;</span>).text();<br><br>                    String[] split = salary.split(<span class="hljs-string">&quot;-&quot;</span>);<br>                    Float min = Float.valueOf(split[<span class="hljs-number">0</span>]);<br>                    Float max;<br>                    <span class="hljs-keyword">int</span> month = <span class="hljs-number">12</span>;<br>                            String maxStr = split[<span class="hljs-number">1</span>];<br>                    String[] split1 = maxStr.split(<span class="hljs-string">&quot;\\·&quot;</span>);<br>                    <span class="hljs-keyword">if</span>(split1.length == <span class="hljs-number">1</span>)&#123;<br>                        max = Float.valueOf(maxStr.substring(<span class="hljs-number">0</span>,maxStr.length()-<span class="hljs-number">1</span>));<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        max = Float.valueOf(split1[<span class="hljs-number">0</span>].substring(<span class="hljs-number">0</span>,split1[<span class="hljs-number">0</span>].length()-<span class="hljs-number">1</span>));<br>                        month = Integer.parseInt(split1[<span class="hljs-number">1</span>].substring(<span class="hljs-number">0</span>,split1[<span class="hljs-number">1</span>].length()-<span class="hljs-number">1</span>));<br>                    &#125;<br>                    System.out.println(<span class="hljs-string">&quot;salary:&quot;</span>+min+<span class="hljs-string">&quot;-&quot;</span>+max+<span class="hljs-string">&quot;*&quot;</span>+month);<br>                    <span class="hljs-comment">//把详情链接放到Request</span><br>                    String detailUrl = select.select(<span class="hljs-string">&quot;div.job-card-body.clearfix &gt; a&quot;</span>).attr(<span class="hljs-string">&quot;href&quot;</span>);<br>                    String jobId = detailUrl.substring(detailUrl.lastIndexOf(<span class="hljs-string">&quot;/&quot;</span>) + <span class="hljs-number">1</span>,detailUrl.lastIndexOf(<span class="hljs-string">&quot;.html?&quot;</span>));<br>                    System.out.println(<span class="hljs-string">&quot;jobId:&quot;</span>+jobId);<br><br>                    JobInfo jobInfo = <span class="hljs-keyword">new</span> JobInfo();<br>                    jobInfo.setJobId(jobId);<br>                    jobInfo.setWorkLocation(workLocation);<br>                    jobInfo.setJobBenifit(jobBenifit);<br>                    jobInfo.setCompanyName(companyName);<br>                    jobInfo.setCompanyInfo(companyInfo);<br>                    jobInfo.setJobName(jobName);<br>                    jobInfo.setSalaryMonth(month);<br>                    jobInfo.setSalaryMin(min);<br>                    jobInfo.setSalaryMax(max);<br>                    jobInfo.setUrl(detailUrl);<br>                    itemList.add(jobInfo);<br>                    System.out.println();<br>                    detailUrl = domain + detailUrl;<br>                    Request detailRequest = <span class="hljs-keyword">new</span> Request();<br>                    detailRequest.setPriority(RandomUtil.randomInt(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>));<br>                    detailRequest.putExtra(<span class="hljs-string">&quot;jobId&quot;</span>, jobId);<br>                    detailRequest.setUrl(detailUrl);<br>                    page.addTargetRequest(detailRequest);<br>                &#125;<br>                page.putField(<span class="hljs-string">&quot;itemList&quot;</span>,itemList);<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;pageDetail&quot;</span>.equals(pageName))&#123;<br>            String jobId = page.getResultItems().get(<span class="hljs-string">&quot;jobId&quot;</span>);<br>            <span class="hljs-comment">//详情页-获取岗位描述、要求                            #main &gt; div.job-banner &gt; div &gt; div &gt; div.info-primary &gt; p &gt; span.text-desc.text-experiece</span><br>            String workExperience = document.select(<span class="hljs-string">&quot;#main &gt; div.job-banner &gt; div &gt; div &gt; div.info-primary &gt; p &gt; span.text-desc.text-experiece&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;workExperience:&quot;</span>+ workExperience);<br>            String degreeExperience = document.select(<span class="hljs-string">&quot;#main &gt; div.job-banner &gt; div &gt; div &gt; div.info-primary &gt; p &gt; span.text-desc.text-degree&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;degreeExperience:&quot;</span> + degreeExperience);<br>            String jobDesc = document.select(<span class="hljs-string">&quot;#main &gt; div.job-box &gt; div &gt; div.job-detail &gt; div:nth-child(1) &gt; div.job-sec-text&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;jobDesc:&quot;</span> + jobDesc);<br>            String bossActiveTime = document.select(<span class="hljs-string">&quot;#main &gt; div.job-box &gt; div &gt; div.job-detail &gt; div:nth-child(1) &gt; div.job-boss-info &gt; h2 &gt; span&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;bossActiveTime:&quot;</span> + bossActiveTime);<br>            String lastUpdateTime = document.select(<span class="hljs-string">&quot;#main &gt; div.job-box &gt; div &gt; div.job-detail &gt; p&quot;</span>).text();<br>            lastUpdateTime = lastUpdateTime.substring(lastUpdateTime.indexOf(<span class="hljs-string">&quot;：&quot;</span>) + <span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;lastUpdateTime:&quot;</span> + lastUpdateTime);<br>            String workAddr = document.select(<span class="hljs-string">&quot;#main &gt; div.job-box &gt; div &gt; div.job-detail &gt; div.job-detail-section.job-detail-company &gt; div.detail-section-item.company-address &gt; div &gt; div.location-address&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;workAddr:&quot;</span> + workAddr);<br>            String companyCreatTime = document.select(<span class="hljs-string">&quot;#main &gt; div.job-box &gt; div &gt; div.job-detail &gt; div.job-detail-section.job-detail-company &gt; div.detail-section-item.business-info-box &gt; div &gt; ul &gt; li.res-time&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;companyCreatTime:&quot;</span> + companyCreatTime);<br>            String companyFund = document.select(<span class="hljs-string">&quot;#main &gt; div.job-box &gt; div &gt; div.job-detail &gt; div.job-detail-section.job-detail-company &gt; div.detail-section-item.business-info-box &gt; div &gt; ul &gt; li.company-fund&quot;</span>).text();<br>            System.out.println(<span class="hljs-string">&quot;companyFund:&quot;</span> + companyFund);<br>            System.out.println();<br><br>            JobInfo jobInfo = <span class="hljs-keyword">new</span> JobInfo();<br>            jobInfo.setJobId(jobId);<br>            jobInfo.setWorkExperience(workExperience);<br>            jobInfo.setDegreeExperience(degreeExperience);<br>            jobInfo.setJobDesc(jobDesc);<br>            jobInfo.setJobAddr(workAddr);<br>            jobInfo.setTime(lastUpdateTime);<br>            jobInfo.setCompanyCreatTime(companyCreatTime);<br>            jobInfo.setCompanyFund(companyFund);<br>            jobInfo.setBossActiveTime(bossActiveTime);<br>            page.putField(<span class="hljs-string">&quot;item&quot;</span>,jobInfo);<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Site <span class="hljs-title">getSite</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Site.me().setSleepTime(<span class="hljs-number">1000</span>).setTimeOut(<span class="hljs-number">2000</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="MyBossPipeline"><a href="#MyBossPipeline" class="headerlink" title="MyBossPipeline"></a><strong>MyBossPipeline</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBossPipeline</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Pipeline</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> JobInfoService jobInfoService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(ResultItems resultItems, Task task)</span> </span>&#123;<br>        JobInfo item = resultItems.get(<span class="hljs-string">&quot;item&quot;</span>);<br>        <span class="hljs-keyword">if</span>(Objects.nonNull(item))&#123;<br>            JobInfo jobInfo = jobInfoService.lambdaQuery().eq(JobInfo::getJobId, item.getJobId()).one();<br>            <span class="hljs-keyword">if</span>(Objects.nonNull(jobInfo))&#123;<br>                item.setId(jobInfo.getId());<br>                jobInfoService.updateById(item);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                jobInfoService.save(item);<br>            &#125;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        List&lt;JobInfo&gt; itemList = resultItems.get(<span class="hljs-string">&quot;itemList&quot;</span>);<br>        <span class="hljs-keyword">if</span>(CollUtil.isNotEmpty(itemList))&#123;<br>            <span class="hljs-keyword">for</span> (JobInfo jobInfo : itemList) &#123;<br>                JobInfo selectJob = jobInfoService.lambdaQuery().eq(JobInfo::getJobId, jobInfo.getJobId()).one();<br>                <span class="hljs-keyword">if</span>(Objects.nonNull(selectJob))&#123;<br>                    jobInfo.setId(selectJob.getId());<br>                    jobInfoService.updateById(jobInfo);<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    jobInfoService.save(jobInfo);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BossSpiderStart</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> MyBossPageInterceptor myBossPageInterceptor;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> MyBossPipeline myBossPipeline;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> MyBossDownloader myBossDownloader;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>&#123;<br>        Spider.create(myBossPageInterceptor)<br>                .setPipelines(Arrays.asList(myBossPipeline))<br>                .setDownloader(myBossDownloader)<br>                .setScheduler(<span class="hljs-keyword">new</span> PriorityScheduler())<br>                .addUrl(<span class="hljs-string">&quot;https://www.zhipin.com/web/geek/job?query=Java&amp;city=101280100&amp;jobType=1901&quot;</span>)<br>                .thread(<span class="hljs-number">1</span>)<br>                .start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="难题"><a href="#难题" class="headerlink" title="难题"></a>难题</h2><p>1、被识别出ip存在异常访问行为需要人工验证滑动滑块。</p>
<p><img src="/images/Java%E7%88%AC%E8%99%AB02-webmagic/image-20240928221420318.png" alt="image-20240928221420318"></p>
<h3 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h3><p>守在电脑前，人力手动验证。</p>
<h3 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h3><p>在Downloader动态设置代理ip，按照特性规则每50个请求换一个ip</p>
<h3 id="方案三"><a href="#方案三" class="headerlink" title="方案三"></a>方案三</h3><p>​    滑动验证码识别技术。这种技术通常利用机器学习或深度学习算法来识别滑动验证码的图案和特征，并模拟用户进行滑动操作。然而，由于滑动验证码的复杂性和变化性，识别技术的准确性和稳定性仍然是一个挑战，目前常用的验证码平台是超级鹰：<a href="https://www.chaojiying.com/api-45.html%EF%BC%8C%E4%B8%80%E8%88%AC%E7%94%A8%E6%9D%A5%E8%AF%86%E5%88%AB%E9%AA%8C%E8%AF%81%E7%A0%81%EF%BC%8C%E8%BF%98%E4%B8%8D%E8%83%BD%E8%A7%A3%E5%86%B3%E6%BB%91%E5%9D%97%E9%97%AE%E9%A2%98%E3%80%82">https://www.chaojiying.com/api-45.html，一般用来识别验证码，还不能解决滑块问题。</a></p>
<p>​    如果要解决滑块问题，需要定位获取滑块区域，通过算法来解析凹槽的位置，计算得出滑块需要移动的距离，但是该方案难度很高，如果采用第三方解析成本极高，故尽量降低被反扒的可能</p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
        <tag>webmagic</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-plus</title>
    <url>/2021/05/25/Mybatis-plus/</url>
    <content><![CDATA[<h1 id="内容目录"><a href="#内容目录" class="headerlink" title="内容目录"></a>内容目录</h1><p>1、Mybatis-plus的介绍</p>
<p>2、Mybatis-plus自定义插件开发</p>
<h1 id="Mybatis-plus的介绍"><a href="#Mybatis-plus的介绍" class="headerlink" title="Mybatis-plus的介绍"></a>Mybatis-plus的介绍</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>MyBatis-Plus （简称 MP）是一个 MyBatis 的增强工具，在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。</p>
<h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul>
<li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li>
<li><strong>强大的crud</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li>
<li><strong>支持lambda链式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错，方便数据库字段修改</li>
<li><strong>内置代码生成器</strong></li>
<li><strong>内置分页插件</strong></li>
<li><strong>内置性能分析插件</strong>：下文中提及</li>
<li><strong>内置全局拦截插件</strong>：下文中提及</li>
</ul>
<h2 id="SpringBoot整合引入"><a href="#SpringBoot整合引入" class="headerlink" title="SpringBoot整合引入"></a>SpringBoot整合引入</h2><p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-springboot<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>mybatis-plus-springboot<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-generator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.16.20<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.31<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#mysql数据源配置</span><br><span class="hljs-meta">spring.datasource.driverClassName</span>=<span class="hljs-string">com.mysql.jdbc.Driver</span><br><span class="hljs-meta">spring.datasource.url</span>= <span class="hljs-string">jdbc:mysql:///mybatis-study</span><br><span class="hljs-meta">spring.datasource.username</span>=<span class="hljs-string">root</span><br><span class="hljs-meta">spring.datasource.password</span>=<span class="hljs-string">123456</span><br><span class="hljs-meta">mybatis-plus.mapper-locations</span>=<span class="hljs-string">classpath:mapper/system/repository/dao/**/*.xml</span><br><span class="hljs-meta">mybatis-plus.configuration.log-impl</span>=<span class="hljs-string">org.apache.ibatis.logging.stdout.StdOutImpl</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(basePackages = &#123;&quot;com.study.domain.*.dao&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringbootClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(SpringbootClass.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="内置代码生成器"><a href="#内置代码生成器" class="headerlink" title="内置代码生成器"></a>内置代码生成器</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisGenerator</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 读取控制台内容</span><br><span class="hljs-comment">     * &lt;/p&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();<br>        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);<br>        System.out.println(help.toString());<br>        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;<br>            String ipt = scanner.next();<br>            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;<br>                <span class="hljs-keyword">return</span> ipt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// 代码生成器</span><br>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<br><br>        <span class="hljs-comment">// 全局配置</span><br>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();<br>        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>);<br>        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/mybatis-plus-springboot/src/main/java&quot;</span>);<br>        gc.setAuthor(<span class="hljs-string">&quot;24khandsome&quot;</span>);<br>        gc.setOpen(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// XML 二级缓存</span><br>        gc.setEnableCache(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 自定义文件命名，注意 %s 会自动填充表实体属性！</span><br>        gc.setEntityName(<span class="hljs-string">&quot;%sPO&quot;</span>);<br>        gc.setMapperName(<span class="hljs-string">&quot;%sDao&quot;</span>);<br>        gc.setXmlName(<span class="hljs-string">&quot;%sDao&quot;</span>);<br>        gc.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>);<br>        gc.setServiceImplName(<span class="hljs-string">&quot;%sServiceImpl&quot;</span>);<br>        gc.setControllerName(<span class="hljs-string">&quot;%sController&quot;</span>);<br>        gc.setXmlName(<span class="hljs-string">&quot;%sDao&quot;</span>);<br>        mpg.setGlobalConfig(gc);<br><br>        <span class="hljs-comment">// 数据源配置</span><br>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();<br>        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql:///mybatis-study?useUnicode=true&amp;useSSL=false&amp;characterEncoding=utf8&quot;</span>);<br>        <span class="hljs-comment">// dsc.setSchemaName(&quot;public&quot;);</span><br>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsc.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        mpg.setDataSource(dsc);<br><br>        <span class="hljs-comment">// 包配置</span><br>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();<br>        pc.setModuleName(scanner(<span class="hljs-string">&quot;模块名&quot;</span>));<br>        pc.setEntity(<span class="hljs-string">&quot;entity.po&quot;</span>);<br>        pc.setMapper(<span class="hljs-string">&quot;dao&quot;</span>);<br>        pc.setController(<span class="hljs-string">&quot;api&quot;</span>);<br>        pc.setParent(<span class="hljs-string">&quot;com.study.domain&quot;</span>);<br>        mpg.setPackageInfo(pc);<br><br>        <span class="hljs-comment">// 自定义配置</span><br>        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// to do nothing</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 如果模板引擎是 freemarker</span><br>        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.ftl&quot;</span>;<br>        <span class="hljs-comment">// 如果模板引擎是 velocity</span><br>        <span class="hljs-comment">// String templatePath = &quot;/templates/mapper.xml.vm&quot;;</span><br><br>        <span class="hljs-comment">// 自定义输出配置</span><br>        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 自定义配置会被优先输出</span><br>        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;<br>                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br>                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/mybatis-plus-springboot/src/main/resources/mapper/&quot;</span> + pc.getModuleName()<br>                        + <span class="hljs-string">&quot;/repository/dao/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;<br>            &#125;<br>        &#125;);<br><br>        cfg.setFileOutConfigList(focList);<br>        mpg.setCfg(cfg);<br><br>        <span class="hljs-comment">// 配置模板</span><br>        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();<br><br>        <span class="hljs-comment">// 配置自定义输出模板</span><br>        <span class="hljs-comment">//指定自定义模板路径，注意不要带上.ftl/.vm, 会根据使用的模板引擎自动识别</span><br>        <span class="hljs-comment">// templateConfig.setEntity(&quot;templates/entity2.java&quot;);</span><br>        <span class="hljs-comment">// templateConfig.setService();</span><br>        <span class="hljs-comment">// templateConfig.setController();</span><br><br>        templateConfig.setXml(<span class="hljs-keyword">null</span>);<br>        mpg.setTemplate(templateConfig);<br>        <span class="hljs-comment">// 选择 freemarker 引擎，默认 Veloctiy</span><br>        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());<br>        <span class="hljs-comment">// 策略配置</span><br>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();<br>        strategy.setNaming(NamingStrategy.underline_to_camel);<br>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<br><br>        strategy.setSuperEntityClass(BasePO.class);<br>        strategy.setSuperEntityColumns(<span class="hljs-string">&quot;create_time&quot;</span>, <span class="hljs-string">&quot;create_user&quot;</span>, <span class="hljs-string">&quot;update_time&quot;</span>,<br>                <span class="hljs-string">&quot;update_user&quot;</span>, <span class="hljs-string">&quot;version&quot;</span>, <span class="hljs-string">&quot;is_delete&quot;</span>, <span class="hljs-string">&quot;last_update_time&quot;</span>);<br>        strategy.setEntityLombokModel(<span class="hljs-keyword">true</span>);<br>        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 公共父类</span><br>        <span class="hljs-comment">//strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span><br>        strategy.setInclude(scanner(<span class="hljs-string">&quot;表名，多个英文逗号分割&quot;</span>).split(<span class="hljs-string">&quot;,&quot;</span>));<br>        strategy.setTablePrefix(pc.getModuleName() + <span class="hljs-string">&quot;_&quot;</span>);<br>        mpg.setStrategy(strategy);<br>        mpg.setTemplateEngine(<span class="hljs-keyword">new</span> FreemarkerTemplateEngine());<br>        mpg.execute();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasePO</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(value = &quot;create_user&quot;, fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Long createUser;<br>    <span class="hljs-meta">@TableField(value = &quot;create_time&quot;, fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 更新人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(value = &quot;update_user&quot;, fill = FieldFill.UPDATE)</span><br>    <span class="hljs-keyword">private</span> Long updateUser;<br>    <span class="hljs-meta">@TableField(value = &quot;update_time&quot;, fill = FieldFill.UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 版本</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Version</span><br>    <span class="hljs-keyword">private</span> Integer version;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否删除</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableField(&quot;is_delete&quot;)</span><br>    <span class="hljs-meta">@TableLogic</span><br>    <span class="hljs-keyword">private</span> Integer isDelete;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 删除字段枚举</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Delete</span> </span>&#123;<br>        <span class="hljs-comment">//删除枚举</span><br>        NORMAL(<span class="hljs-number">0</span>, <span class="hljs-string">&quot;正常&quot;</span>), DELETED(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;删除&quot;</span>);<br>        <span class="hljs-meta">@Getter</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Integer code;<br>        <span class="hljs-meta">@Getter</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String name;<br><br>        Delete(Integer code, String name) &#123;<br>            <span class="hljs-keyword">this</span>.code = code;<br>            <span class="hljs-keyword">this</span>.name = name;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Delete <span class="hljs-title">getDelete</span><span class="hljs-params">(Integer state)</span> </span>&#123;<br>            <span class="hljs-keyword">for</span> (Delete delete : values()) &#123;<br>                <span class="hljs-keyword">if</span> (delete.getCode().equals(state)) &#123;<br>                    <span class="hljs-keyword">return</span> delete;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果</p>
<p><img src="/images/Mybatis-plus/image-20210529174638703.png" alt="image-20210529174638703"></p>
<h2 id="自定义SQL语句模板（Sql-注入器）"><a href="#自定义SQL语句模板（Sql-注入器）" class="headerlink" title="自定义SQL语句模板（Sql 注入器）"></a>自定义SQL语句模板（Sql 注入器）</h2><p>参考：<a href="https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-deluxe">https://gitee.com/baomidou/mybatis-plus-samples/tree/master/mybatis-plus-sample-deluxe</a></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><br><span class="hljs-number">1.</span>自定义方法<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyDeleteAllMethod</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMethod</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MappedStatement <span class="hljs-title">injectMappedStatement</span><span class="hljs-params">(Class&lt;?&gt; mapperClass, Class&lt;?&gt; modelClass, TableInfo tableInfo)</span> </span>&#123;<br>        String sql;<br>        String sqlMethod = <span class="hljs-string">&quot;&lt;script&gt;\nDELETE FROM %s \n&lt;/script&gt;&quot;</span>;<br>        sql = String.format(sqlMethod, tableInfo.getTableName(), sqlLogicSet(tableInfo),<br>                sqlWhereEntityWrapper(<span class="hljs-keyword">true</span>, tableInfo),<br>                sqlComment());<br>        SqlSource sqlSource = languageDriver.createSqlSource(configuration, sql, modelClass);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.addDeleteMappedStatement(mapperClass, <span class="hljs-string">&quot;deleteAll&quot;</span>, sqlSource);<br>    &#125;<br>&#125;<br><br><span class="hljs-number">2.</span>自定义SqlInjector，注册自定义方法<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyLogicSqlInjector</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultSqlInjector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;AbstractMethod&gt; <span class="hljs-title">getMethodList</span><span class="hljs-params">(Class&lt;?&gt; mapperClass)</span> </span>&#123;<br>        List&lt;AbstractMethod&gt; list = <span class="hljs-keyword">super</span>.getMethodList(mapperClass);<br>        list.add(<span class="hljs-keyword">new</span> MyTruncateMethod());<br>        <span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br><br><span class="hljs-number">3.</span>把方法定义到BaseMapper<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyBaseMapper</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-number">4</span>、mapper继承自己的basemapper<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MyBaseMapper</span>&lt;<span class="hljs-title">UserPO</span>&gt; </span>&#123;<br><br>    <span class="hljs-function">UserPO <span class="hljs-title">selectOneUserByName</span><span class="hljs-params">(String userName)</span></span>;<br><br>    <span class="hljs-function">List&lt;UserPO&gt; <span class="hljs-title">findPageUser</span><span class="hljs-params">(Page&lt;UserPO&gt; page)</span></span>;<br>&#125;<br><br><span class="hljs-number">5</span>、覆盖全局SQL注入器配置<br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisPlusConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ISqlInjector <span class="hljs-title">myLogicSqlInjector</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyLogicSqlInjector();<br>    &#125;<br>&#125;<br><span class="hljs-number">6</span>、使用<br><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserDao</span>, <span class="hljs-title">UserPO</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteAll</span><span class="hljs-params">()</span> </span>&#123;<br>        userDao.deleteAll();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="内置性能分析插件"><a href="#内置性能分析插件" class="headerlink" title="内置性能分析插件"></a>内置性能分析插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HIKARIPROXY_PREPARED_STATEMENT = <span class="hljs-string">&quot;com.zaxxer.hikari.pool.HikariProxyPreparedStatement&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> SqlFormatter SQL_FORMATTER = <span class="hljs-keyword">new</span> SqlFormatter();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 格式sql</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> boundSql</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> format</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">sqlFormat</span><span class="hljs-params">(String boundSql, <span class="hljs-keyword">boolean</span> format)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (format) &#123;<br>            <span class="hljs-keyword">return</span> SQL_FORMATTER.format(boundSql);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> boundSql.replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 执行最大时长，超过自动停止运行，有助于发现问题。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 是否格式化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> format = <span class="hljs-keyword">false</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Statement statement;<br>        Object firstArg = invocation.getArgs()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(firstArg.getClass())) &#123;<br>            statement = (Statement) SystemMetaObject.forObject(firstArg).getValue(<span class="hljs-string">&quot;h.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            statement = (Statement) firstArg;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            statement = (Statement) SystemMetaObject.forObject(statement).getValue(<span class="hljs-string">&quot;stmt.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br><br>        String originalSql = <span class="hljs-keyword">null</span>;<br>        String stmtClassName = statement.getClass().getName();<br>        <span class="hljs-keyword">if</span> (HIKARIPROXY_PREPARED_STATEMENT.equals(stmtClassName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; clazz = Class.forName(HIKARIPROXY_PREPARED_STATEMENT);<br>                Method druidGetSqlMethod = clazz.getMethod(<span class="hljs-string">&quot;getSql&quot;</span>);<br>                Object stmtSql = druidGetSqlMethod.invoke(statement);<br>                <span class="hljs-keyword">if</span> (stmtSql != <span class="hljs-keyword">null</span> &amp;&amp; stmtSql <span class="hljs-keyword">instanceof</span> String) &#123;<br>                    originalSql = (String) stmtSql;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (originalSql == <span class="hljs-keyword">null</span>) &#123;<br>            originalSql = statement.toString();<br>        &#125;<br>        originalSql = originalSql.replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">int</span> index = originalSql.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            originalSql = originalSql.substring(index + <span class="hljs-number">1</span>, originalSql.length());<br>        &#125;<br>        String sqlFormat = sqlFormat(originalSql, format);<br>        Object target = realTarget(invocation.getTarget());<br>        MetaObject metaObject = SystemMetaObject.forObject(target);<br>        MappedStatement ms = (MappedStatement) metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br>        Logger mybatisLogger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br>        <span class="hljs-comment">// 计算执行 SQL 耗时</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = invocation.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">long</span> timing =  System.currentTimeMillis() - start;<br>            StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder()<br>                    .append(<span class="hljs-string">&quot;execute sql error, use time：&quot;</span>).append(timing).append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                    .append(sqlFormat);<br>            mybatisLogger.error(formatSql.toString());<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <span class="hljs-keyword">long</span> timing = System.currentTimeMillis() - start;<br><br>        <span class="hljs-comment">// 格式化 SQL 打印执行结果</span><br>        StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;Execute sql use time：&quot;</span>).append(timing)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; Execute SQL：&quot;</span>).append(sqlFormat)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; result: &quot;</span>).append(result);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMaxTime() &gt;= <span class="hljs-number">1</span> &amp;&amp; timing &gt; <span class="hljs-keyword">this</span>.getMaxTime()) &#123;<br>            mybatisLogger.error(formatSql.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mybatisLogger.debug(formatSql.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> StatementHandler) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties prop)</span> </span>&#123;<br>        String maxTime = prop.getProperty(<span class="hljs-string">&quot;maxTime&quot;</span>);<br>        String format = prop.getProperty(<span class="hljs-string">&quot;format&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(maxTime)) &#123;<br>            <span class="hljs-keyword">this</span>.maxTime = Long.parseLong(maxTime);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(format)) &#123;<br>            <span class="hljs-keyword">this</span>.format = Boolean.valueOf(format);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">realTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(target.getClass())) &#123;<br>            MetaObject metaObject = SystemMetaObject.forObject(target);<br>            <span class="hljs-keyword">return</span> realTarget(metaObject.getValue(<span class="hljs-string">&quot;h.target&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) target;<br>    &#125;<br><br>&#125;<br><br>	<span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PerformanceInterceptor <span class="hljs-title">performanceInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> PerformanceInterceptor();<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="事务检查插件"><a href="#事务检查插件" class="headerlink" title="事务检查插件"></a>事务检查插件</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisUpdateCheckInterceptor <span class="hljs-title">mybatisUpdateCheckInterceptor</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MybatisUpdateCheckInterceptor(dataSource);<br>&#125;<br><span class="hljs-meta">@Intercepts(&#123;@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisUpdateCheckInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MybatisUpdateCheckInterceptor</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.dataSource = dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>        <span class="hljs-comment">// 检查事务是否开启</span><br>        assertTransactional();<br><br>        Object[] args = invocation.getArgs();<br>        MappedStatement ms = (MappedStatement) args[<span class="hljs-number">0</span>];<br>        SqlCommandType sqlCommandType = ms.getSqlCommandType();<br><br>        Object param = args[<span class="hljs-number">1</span>];<br><br>        <span class="hljs-comment">// 插入只判断是否插入成功即可</span><br>        <span class="hljs-keyword">if</span> (SqlCommandType.INSERT == sqlCommandType) &#123;<br>            checkParam(param);<br>            Object proceed = invocation.proceed();<br>            validateReturnGtZero(proceed);<br>            <span class="hljs-keyword">return</span> proceed;<br>        &#125;<br>        Object proceed = invocation.proceed();<br>        <span class="hljs-keyword">return</span> proceed;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验是否已经开启事务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assertTransactional</span><span class="hljs-params">()</span> </span>&#123;<br>        Connection connection = DataSourceUtils.getConnection(dataSource);<br>        <span class="hljs-keyword">if</span> (!DataSourceUtils.isConnectionTransactional(connection, dataSource)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;mybatis can not update without transactional&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 检查参数是否非空</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> param</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">checkParam</span><span class="hljs-params">(Object param)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == param) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;mybatis update can not insert null object&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 校验更新数量是否大于0</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proceed</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">validateReturnGtZero</span><span class="hljs-params">(Object proceed)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!(proceed <span class="hljs-keyword">instanceof</span> Number)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;mybatis update return is not a number&quot;</span>);<br>        &#125;<br><br>        Number result = (Number) proceed;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-number">0L</span> == result.longValue()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;数据已被他人修改，请刷新重试&quot;</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="动态表名插件-since-3-4-0"><a href="#动态表名插件-since-3-4-0" class="headerlink" title="动态表名插件(since 3.4.0)"></a>动态表名插件(since 3.4.0)</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span></span>&#123;<br>    MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>    DynamicTableNameInnerInterceptor interceptor = <span class="hljs-keyword">new</span> DynamicTableNameInnerInterceptor();<br>    <span class="hljs-keyword">int</span> b=(<span class="hljs-keyword">int</span>)(Math.random()*<span class="hljs-number">3</span>);<br>    String[] table = &#123;<span class="hljs-string">&quot;system_user&quot;</span>,<span class="hljs-string">&quot;system_user_copy1&quot;</span>,<span class="hljs-string">&quot;system_user_copy2&quot;</span>&#125;;<br>    Map&lt;String, TableNameHandler&gt; tableNameHandlerMap = <span class="hljs-keyword">new</span> HashMap&lt;String,TableNameHandler&gt;(<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//自定义逻辑，用新的表明替换旧的表名</span><br>    tableNameHandlerMap.put(<span class="hljs-string">&quot;system_user&quot;</span>,((sql,tablename) -&gt; table[b]));<br>    interceptor.setTableNameHandlerMap(tableNameHandlerMap);<br>    <span class="hljs-comment">//tableNameHandlerMap.put(&quot;system_user&quot;,((sql,tablename) -&gt; tablename +table[b]));</span><br>    mybatisPlusInterceptor.addInnerInterceptor(interceptor);<br>    <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="多租户（约等于数据隔离、也可作为权限过滤）"><a href="#多租户（约等于数据隔离、也可作为权限过滤）" class="headerlink" title="多租户（约等于数据隔离、也可作为权限过滤）"></a>多租户（约等于数据隔离、也可作为权限过滤）</h2><blockquote>
<p>多租户 != 权限过滤,不要乱用,租户之间是完全隔离的!!!<br>启用多租户后所有执行的method的sql都会进行处理.<br>自写的sql请按规范书写(sql涉及到多个表的每个表都要给别名,特别是 inner join 的要写标准的 inner join)</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 租户处理器（ TenantId 行级 ）</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> hubin</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@since</span> 2017-08-31</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TenantHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取租户 ID 值表达式，支持多个 ID 条件查询</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 支持自定义表达式，比如：tenant_id in (1,2) <span class="hljs-doctag">@since</span> 2019-8-2</span><br><span class="hljs-comment">     * 多参请使用 &#123;<span class="hljs-doctag">@link</span> ValueListExpression&#125;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> select 参数 true 表示为 select 下的 where 条件,false 表示 insert/update/delete 下的条件</span><br><span class="hljs-comment">     *               只有 select 下才允许多参,否则只支持单参</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 租户 ID 值表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">Expression <span class="hljs-title">getTenantId</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> select)</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取租户字段名</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 租户字段名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getTenantIdColumn</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 根据表名判断是否进行过滤</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tableName 表名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 是否进行过滤, true:表示忽略，false:需要解析多租户字段</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">doTableFilter</span><span class="hljs-params">(String tableName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>假设有如下场景：</p>
<p>查询某些表的数据需要根据这些表的某个字段进行数据隔离</p>
<p>于是</p>
<blockquote>
<ol>
<li>自定义TenantHandler</li>
<li>自定义MyTenantSqlParser</li>
<li>注册多租户组件</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">DataAccessTable</span> </span>&#123;<br>    <span class="hljs-comment">//数据权限过滤表名</span><br>    SYSTEM_USER(<span class="hljs-string">&quot;system_user&quot;</span>, <span class="hljs-string">&quot;用户表&quot;</span>, <span class="hljs-string">&quot;user_id&quot;</span>),<br>    ;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String, DataAccessTable&gt; TABLE_MAP = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">for</span> (DataAccessTable value : DataAccessTable.values()) &#123;<br>            TABLE_MAP.put(value.getTableName(), value);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String tableName;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String publisherColumn;<br><br>    DataAccessTable(String tableName, String desc, String publisherColumn) &#123;<br>        <span class="hljs-keyword">this</span>.tableName = tableName;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>        <span class="hljs-keyword">this</span>.publisherColumn = publisherColumn;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Set&lt;String&gt; <span class="hljs-title">getDataAccessTables</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> TABLE_MAP.keySet();<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getDataPublisherColumn</span><span class="hljs-params">(String tableName)</span></span>&#123;<br>        DataAccessTable dataAccessTable = TABLE_MAP.get(tableName);<br>        <span class="hljs-keyword">return</span> dataAccessTable == <span class="hljs-keyword">null</span> ? <span class="hljs-string">&quot;&quot;</span> : dataAccessTable.getPublisherColumn();<br><br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyTenantHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TenantHandler</span> </span>&#123;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义方法</span><br><span class="hljs-comment">     * 获取发布人用户ID</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tableName 表名</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 发布人字段名</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">getPublishUserIdColumn</span><span class="hljs-params">(String  tableName)</span></span>;<br>&#125;<br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTenantSqlParser</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TenantSqlParser</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> MyTenantHandler greatTenantHandler;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TenantSqlParser <span class="hljs-title">setTenantHandler</span><span class="hljs-params">(TenantHandler tenantHandler)</span> </span>&#123;<br>        greatTenantHandler = (MyTenantHandler) tenantHandler;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.setTenantHandler(tenantHandler);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 目前: 针对自定义的tenantId的条件表达式[tenant_id in (1,2,3)]，无法处理多租户的字段加上表别名</span><br><span class="hljs-comment">     * select a.id, b.name</span><br><span class="hljs-comment">     * from a</span><br><span class="hljs-comment">     * join b on b.aid = a.id and [b.]tenant_id in (1,2) --别名[b.]无法加上 TODO</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expression</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> table</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 加上别名的多租户字段表达式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Expression <span class="hljs-title">processTableAlias4CustomizedTenantIdExpression</span><span class="hljs-params">(Expression expression, Table table)</span> </span>&#123;<br>        Expression target;<br>        <span class="hljs-comment">//判断多租户字段</span><br>        <span class="hljs-keyword">if</span> (expression <span class="hljs-keyword">instanceof</span> ValueListExpression) &#123;<br>            InExpression inExpression = <span class="hljs-keyword">new</span> InExpression();<br>            inExpression.setLeftExpression(<span class="hljs-keyword">this</span>.getTableAliasColumn(table, greatTenantHandler.getTenantIdColumn()));<br>            inExpression.setRightItemsList(((ValueListExpression) expression).getExpressionList());<br>            target = inExpression;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            EqualsTo equalsTo = <span class="hljs-keyword">new</span> EqualsTo();<br>            equalsTo.setLeftExpression(<span class="hljs-keyword">this</span>.getTableAliasColumn(table, greatTenantHandler.getTenantIdColumn()));<br>            equalsTo.setRightExpression(expression);<br>            target = equalsTo;<br>        &#125;<br>        String publishUserIdColumn = greatTenantHandler.getPublishUserIdColumn(table.getName());<br>        <span class="hljs-keyword">if</span>(StringUtils.isBlank(publishUserIdColumn))&#123;<br>           <span class="hljs-keyword">return</span> target;<br>        &#125;<br>        <span class="hljs-comment">//自定义多租户逻辑</span><br>        EqualsTo equalsTo = <span class="hljs-keyword">new</span> EqualsTo();<br>        equalsTo.setLeftExpression(<span class="hljs-keyword">this</span>.getTableAliasColumn(table, publishUserIdColumn));<br>        <span class="hljs-comment">//自定义多租户字段写死 -1</span><br>        equalsTo.setRightExpression(<span class="hljs-keyword">new</span> LongValue(<span class="hljs-string">&quot;8&quot;</span>));<br>        <span class="hljs-comment">// equalsTo.setRightExpression(new LongValue(SessionContext.getCurrentUserId()));</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Parenthesis(<span class="hljs-keyword">new</span> OrExpression(target, equalsTo));<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 租户字段别名设置</span><br><span class="hljs-comment">     * &lt;p&gt;tenantId 或 tableAlias.tenantId&lt;/p&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> table 表对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 字段</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Column <span class="hljs-title">getTableAliasColumn</span><span class="hljs-params">(Table table, String columnName)</span> </span>&#123;<br>        StringBuilder column = <span class="hljs-keyword">new</span> StringBuilder();<br>        <span class="hljs-keyword">if</span> (table.getAlias() != <span class="hljs-keyword">null</span>) &#123;<br>            column.append(table.getAlias().getName()).append(StringPool.DOT);<br>        &#125;<br>        column.append(columnName);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Column(column.toString());<br>    &#125;<br>&#125;<br><br><br>	<span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PaginationInterceptor <span class="hljs-title">paginationInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        PaginationInterceptor page = <span class="hljs-keyword">new</span> PaginationInterceptor();<br>        List&lt;ISqlParser&gt; sqlParserList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        MyTenantSqlParser tenantSqlParser = <span class="hljs-keyword">new</span> MyTenantSqlParser();<br>        tenantSqlParser.setTenantHandler(<span class="hljs-keyword">new</span> MyTenantHandler() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPublishUserIdColumn</span><span class="hljs-params">(String tableName)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> DataAccessTable.getDataPublisherColumn(tableName);<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Expression <span class="hljs-title">getTenantId</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> select)</span> </span>&#123;<br>                <span class="hljs-comment">//没有设置数据权限，设置为本中心数据权限</span><br>                ValueListExpression expression = <span class="hljs-keyword">new</span> ValueListExpression();<br>                List&lt;Expression&gt; expressions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                expressions.add(<span class="hljs-keyword">new</span> StringValue(<span class="hljs-string">&quot;木子李&quot;</span>));<br><br><br>                expression.setExpressionList(<span class="hljs-keyword">new</span> ExpressionList(expressions));<br>                <span class="hljs-keyword">return</span> expression;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTenantIdColumn</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;username&quot;</span>;<br>            &#125;<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 返回true忽略，false需要解析多租户字段</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@param</span> tableName</span><br><span class="hljs-comment">             * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">doTableFilter</span><span class="hljs-params">(String tableName)</span> </span>&#123;<br>                <span class="hljs-comment">//查询所有进行数据权限过滤的表名</span><br>                Set&lt;String&gt; tableNameSet = DataAccessTable.getDataAccessTables();<br>                <span class="hljs-comment">// 强制检查表单内，返回false</span><br>                <span class="hljs-keyword">if</span> (tableNameSet.contains(tableName)) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;);<br>        sqlParserList.add(tenantSqlParser);<br>        page.setSqlParserList(sqlParserList);<br>        page.setSqlParserFilter(metaObject -&gt;&#123;<br>            <span class="hljs-comment">// 不处理非select之外的语句</span><br>            MappedStatement mappedStatement = (MappedStatement)metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br>            <span class="hljs-keyword">if</span>(!SqlCommandType.SELECT.equals(mappedStatement.getSqlCommandType()))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br><br><br><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> page;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>效果</p>
<p><img src="/images/Mybatis-plus/image-20210531170508023.png" alt="image-20210531170508023"></p>
]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>Mybatis</tag>
        <tag>Mybatis-plus</tag>
      </tags>
  </entry>
  <entry>
    <title>myBatis基础</title>
    <url>/2021/05/05/Mybatis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="一、myBatis-核心概念"><a href="#一、myBatis-核心概念" class="headerlink" title="一、myBatis 核心概念"></a>一、myBatis 核心概念</h1><h2 id="1、基本概念"><a href="#1、基本概念" class="headerlink" title="1、基本概念"></a>1、基本概念</h2><p>​    MyBatis 是一款优秀的<strong>持久层</strong>框架，它支持<strong>定制化 SQL</strong>、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生类型、接口和 Java 的 POJO（Plain Old Java Objects，普通老式 Java 对象）为数据库中的记录</p>
<p>其它持久层解决方案对比：</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/image-20210505210233881.png"></p>
<p>如图所示：普通的操作SQL的流程包括：</p>
<p>​    获取连接、声明预处理器、设置参数、拼装SQL、执行获取结果集、封装成Java对象</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>​    Java DataBase Connectivity ，java数据库连接技术） 用来访问各种数据库 。JDBC 规范定义接口 ， 具体的实现由各大数据库厂商来实现。每个数据库厂商根据自家数据库的通信格式编写好自己数据库的驱动，数据库驱动由数据库厂商提供。</p>
<h3 id="JdbcTemplate"><a href="#JdbcTemplate" class="headerlink" title="JdbcTemplate"></a>JdbcTemplate</h3><p>​    就是Spring对JDBC的封装，目的是使JDBC更加易于使用。</p>
<h3 id="Hibernate-全自动"><a href="#Hibernate-全自动" class="headerlink" title="Hibernate( 全自动)"></a>Hibernate( 全自动)</h3><p>​    基于ORM,对象关系映射(Object Relational Mapping),简单的说ORM框架就是数据库的表和简单Java对象的映射关系模型，我们通过这层映射关系就可以简单迅速地把数据库表的数据转化为POJO</p>
<p>​    缺点：定制化或者优化SQL学习成本较高，需要学习HQL</p>
<p>​    <strong>智能机器人，但研发它（学习、熟练度）的成本很高，工作都可以摆脱他了，但仅限于它能做的事。（强大、方便、高效、复杂、绕弯子、全自动）</strong></p>
<h3 id="Mybatis-半自动化"><a href="#Mybatis-半自动化" class="headerlink" title="Mybatis(半自动化)"></a>Mybatis(半自动化)</h3><p>​    <strong>机械工具，使用方便，拿来就用，但工作还是要自己来作，不过工具是活的，怎么使由我决定。（小巧、方便、高效、简单、直接、半自动）</strong></p>
<p>​    方便，学习成本低、便于优化SQL</p>
<h2 id="2、核心对象的作用域与生命周期"><a href="#2、核心对象的作用域与生命周期" class="headerlink" title="2、核心对象的作用域与生命周期"></a>2、核心对象的作用域与生命周期</h2><h3 id="1、mybatis-config-xml"><a href="#1、mybatis-config-xml" class="headerlink" title="1、mybatis-config.xml"></a>1、mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://192.168.0.147/luban&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;com/tuling/mybatis/dao/xml/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.UserMapper&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="2、UserMapper-xml"><a href="#2、UserMapper-xml" class="headerlink" title="2、UserMapper.xml"></a>2、UserMapper.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>    select * from User where id = #&#123;id&#125;<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="3、测试代码"><a href="#3、测试代码" class="headerlink" title="3、测试代码"></a>3、测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br><span class="hljs-comment">//读取配置文件</span><br>InputStream inputStream = Resources.getResourceAsStream(resource);<br><span class="hljs-comment">//文件流转成configuration对象构建出 SqlSessionFactory</span><br>SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br><span class="hljs-comment">//SqlSessionFactory获取session对象</span><br>SqlSession session = sqlSessionFactory.openSession();<br>User result = session.selectOne(<span class="hljs-string">&quot;com.tuling.mybatis.dao.UserMapper.selectUser&quot;</span>, <span class="hljs-number">1</span>);<br>System.out.println(result.toString());<br></code></pre></td></tr></table></figure>

<h3 id="4、SqlSessionFactoryBuilder："><a href="#4、SqlSessionFactoryBuilder：" class="headerlink" title="4、SqlSessionFactoryBuilder："></a>4、SqlSessionFactoryBuilder：</h3><p> 用于构建会话工厂，基于 config.xml environment 、props 构建会话工厂,构建完成后即可丢弃。</p>
<h3 id="5、SqlSessionFactory："><a href="#5、SqlSessionFactory：" class="headerlink" title="5、SqlSessionFactory："></a>5、SqlSessionFactory：</h3><p>用于生成会话的工厂，<strong>作用于整个应用运行期间</strong>，一般不需要构造多个工厂对像</p>
<h3 id="6、SqlSession："><a href="#6、SqlSession：" class="headerlink" title="6、SqlSession："></a>6、SqlSession：</h3><p><strong>作用于单次会话</strong>，如WEB一次请求期间，不能用作于某个对像属性，也不能在多个线程间共享，因为它是==<strong>线程不安全的</strong>==</p>
<h3 id="7、接口式编程"><a href="#7、接口式编程" class="headerlink" title="7、接口式编程"></a>7、接口式编程</h3><p>由于每次调用时都去找对应用 statement 以及拼装参数，使用上不是特别友好，myBatis 引入了接口的机制，将接口与mapper.xml  的namespace 名称绑定，MyBatis就可以根据ASM工具动态构建该接口的实例。</p>
<p>mapper 映射器接口实例</p>
<p>通过 session.getMapper(Class<T> type) 就可以获取mapper 实例，该实例一般作用于方法域。</T></p>
<h1 id="二、全局的-configuration-配置"><a href="#二、全局的-configuration-配置" class="headerlink" title="二、全局的 configuration 配置"></a>二、全局的 configuration 配置</h1><h2 id="1、属性"><a href="#1、属性" class="headerlink" title="1、属性"></a>1、属性</h2><p>properties 元素可以通过 resource 或url 加载外部 properties文件中的属性，也可以直接设置property 属性。然后在xml 中就可以通过${属性名}进行引用替换。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;app.properties&quot;</span> <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbc.driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.oracle.jdbc.Driver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>resource= app.properties  从class path中加载</p>
<p>url=<a href="file:///G:/git/tuling-mybatis/src/main/resources/app.properties">file:///G:/git/tuling-mybatis/src/main/resources/app.properties</a> 基于url加载</p>
<p>引用属性方式：</p>
<p>${jdbc.user}</p>
<p>从 MyBatis 3.4.2 开始，位符指定一个默认值。例如：${jdbc.user:root}</p>
<h2 id="2、环境配置"><a href="#2、环境配置" class="headerlink" title="2、环境配置"></a>2、环境配置</h2><p>一个项目经常需要在例如开发坏境、测试环境、预演环境、生产环境中等不同环境中进行部署，每个环境所对应的参数是不一样的，myBatis 中可以通过 environment 来设置不同环境的属性。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!--type=JDBC|MANAGED--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">transactionManager</span>&gt;</span><br><br>  <span class="hljs-comment">&lt;!-- type=UNPOOLED|POOLED|JNDI--&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;UNPOOLED&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driver&#125;&quot;</span>/&gt;</span><br><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可通过 SqlSessionFactoryBuilder.build( environment) 来指定初始化哪套环境。</p>
<h2 id="3、设置"><a href="#3、设置" class="headerlink" title="3、设置"></a>3、设置</h2><p>设置MyBatis 全局参数，约定myBatis 的全局行为</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 开启二级缓存--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br> <span class="hljs-comment">&lt;!-- 开启驼峰命名适配--&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>示例驼峰命名开启与关闭：</p>
<p>l 尝试开关 mapUnderscoreToCamelCase 属性 来观察Account 数据查询情况。</p>
<h2 id="4、别名"><a href="#4、别名" class="headerlink" title="4、别名"></a>4、别名</h2><p>在myBatis 中经常会用到 java 中类型，如sql 块中中 parameterType  参数引用中 javaType 结果集映射的javaType ,都要使用java 全路径名，可以通过 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeAlias</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;account&quot;</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>提示：建议不要设置。因为常用的类 mybatis 已经内置别名，而自定义的类设置别反而不好去找，影响阅读。</p>
<h2 id="5、类型处理器"><a href="#5、类型处理器" class="headerlink" title="5、类型处理器"></a>5、类型处理器</h2><p>持久层框架其中比较重要的工作就是处理数据的映射转换，把java 类型转换成jdbc 类型的参数，又需要把jdbc 类型的结果集转换成java 类型。在mybatis 中是通过 TypeHandler 接口来实现的。</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/wps4.jpg" alt="img"> </p>
<p> 可以看到 typeHandler 就是两个作用 设置参数 与获取结果。</p>
<p>你可以设置自定义处理器</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">typeHandler</span> <span class="hljs-attr">handler</span>=<span class="hljs-string">&quot;org.mybatis.example.ExampleTypeHandler&quot;</span>  /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">typeHandlers</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>可以通过以下两种方式指定处理的范围</p>
<p>1、javaType=”long”, jdbcType=”Date”</p>
<p>2、@MappedJdbcTypes( jdbc类型) @MappedTypes    java类型</p>
<h3 id="1、示例：long-类型时间戳转换成-日期类型"><a href="#1、示例：long-类型时间戳转换成-日期类型" class="headerlink" title="1、示例：long 类型时间戳转换成 日期类型"></a>1、示例：long 类型时间戳转换成 日期类型</h3><h3 id="2、添加算定义处理类："><a href="#2、添加算定义处理类：" class="headerlink" title="2、添加算定义处理类："></a>2、添加算定义处理类：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MappedJdbcTypes(JdbcType.TIMESTAMP)</span><br><span class="hljs-meta">@MappedTypes(Long.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongTimeHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseTypeHandler</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNonNullParameter</span><span class="hljs-params">(PreparedStatement ps, <span class="hljs-keyword">int</span> i, Long parameter, JdbcType jdbcType)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	ps.setDate(i, <span class="hljs-keyword">new</span> Date(parameter));<br>  &#125;<br>    <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(ResultSet rs, String columnName)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	<span class="hljs-keyword">return</span> rs.getDate(columnName).getTime();<br>  &#125;<br>    <br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(ResultSet rs, <span class="hljs-keyword">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	<span class="hljs-keyword">return</span> rs.getDate(columnIndex).getTime();<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getNullableResult</span><span class="hljs-params">(CallableStatement cs, <span class="hljs-keyword">int</span> columnIndex)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>	<span class="hljs-keyword">return</span> cs.getDate(columnIndex).getTime();<br>  &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>在resultMap中指定 typeHandler：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.LongTimeHandler&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById2&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;account2&quot;</span>&gt;</span><br>	 select a.*,a.createTime as createTimestamp from account a where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="6、mappers映谢器"><a href="#6、mappers映谢器" class="headerlink" title="6、mappers映谢器"></a>6、mappers映谢器</h2><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;org/mybatis/builder/AuthorMapper.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span>  <span class="hljs-attr">url</span>=<span class="hljs-string">&quot;http://www.xxx.com/xml/BlogMapper.xml&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.builder.BlogMapper&quot;</span>/&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;org.mybatis.builder&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>加载方式：</p>
<p>1、 resource 基于classPath 加载xml文件</p>
<p>2、url:基于资源定位加载xml 文件</p>
<p>3、class:基于接口加载</p>
<p>4、package ：扫描包下所有class 然后进行加载</p>
<p>约定规则：</p>
<p><strong>1、mapper 中的 namespace必须与对应的接口名称对应。</strong></p>
<p><strong>2、通过 class 或package 中加载时 .xml 文件必须与接口在同一级目录。</strong></p>
<h1 id="三、mapper-文件"><a href="#三、mapper-文件" class="headerlink" title="三、mapper 文件"></a>三、mapper 文件</h1><h2 id="1、sql语句块statement"><a href="#1、sql语句块statement" class="headerlink" title="1、sql语句块statement"></a>1、sql语句块statement</h2><p>通过原生JDBC写DAO的年代 ，程序员最怕莫过于 拼接SQL语句，拼接参数与设置返回结果集，Hibernate 将拼接SQL时代成为过去，通过ORM映谢，完全不需要处理任何SQL，但这又带来了新的问题就是。无法编写自定义SQL从而丧失了灵活活及更好的性能。MyBatis 通过 mapper 映射SQL很好解决了这一点。它无需在JAVA代码中拼接SQL，而是将其移至mapper 文件集中处理SQL节约了大量的开发时间。</p>
<h3 id="2、Mapper中的元素"><a href="#2、Mapper中的元素" class="headerlink" title="2、Mapper中的元素"></a>2、Mapper中的元素</h3><blockquote>
<p>cache – 对给定命名空间的缓存配置。</p>
<p>resultMap – 结果集映射。</p>
<p>sql – 可被其他语句引用的可重用语句块。</p>
<p>insert – 插入语句</p>
<p>update – 更新语句</p>
<p>delete –删除语句</p>
<p>select – 查询语句</p>
</blockquote>
<h3 id="3、select-用法及属性"><a href="#3、select-用法及属性" class="headerlink" title="3、select 用法及属性"></a><strong>3、select 用法及属性</strong></h3><p>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectById&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br> select * from account where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-comment">&lt;!--属性：--&gt;</span><br>&lt;select<br> id=&quot;selectById&quot;     <span class="hljs-comment">&lt;!-- 语句块的唯一标识 与接口中方法名称对应 --&gt;</span><br> parameterType=&quot;User&quot;  <span class="hljs-comment">&lt;!--参数java类型--&gt;</span><br> resultType=&quot;hashmap&quot;  <span class="hljs-comment">&lt;!--返回结果java类型--&gt;</span><br> resultMap=&quot;userResultMap&quot; <span class="hljs-comment">&lt;!--返回结果映射--&gt;</span><br> flushCache=&quot;false&quot;    <span class="hljs-comment">&lt;!--true 每次调用都会刷新 一二级缓存--&gt;</span><br> useCache=&quot;true&quot;     <span class="hljs-comment">&lt;!--true 是否保存至二级缓存当中去--&gt;</span><br> timeout=&quot;10&quot;<br> statementType= PREPARED&quot;&gt;<br></code></pre></td></tr></table></figure>

<h3 id="4、insert-amp-update-amp-delete-用法"><a href="#4、insert-amp-update-amp-delete-用法" class="headerlink" title="4、insert&amp;update&amp;delete 用法"></a><strong>4、insert&amp;update&amp;delete 用法</strong></h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">&lt;insert<br> id=&quot;addUser&quot;  <span class="hljs-comment">&lt;!-- 语句块的唯一标识 与接口中方法名称对应 --&gt;</span><br> parameterType=&quot;User&quot;  <span class="hljs-comment">&lt;!--参数java类型--&gt;</span><br> flushCache=&quot;true&quot;  <span class="hljs-comment">&lt;!--true 每次调用都会刷新 一二级缓存--&gt;</span><br> statementType=&quot;PREPARED&quot; &lt;执行类型&gt;<br> keyProperty=&quot;&quot;    <span class="hljs-comment">&lt;!--主键对应的java 属性，多个用 逗号分割--&gt;</span><br> keyColumn=&quot;&quot;     <span class="hljs-comment">&lt;!--主键列，多个用 逗号分割--&gt;</span><br> useGeneratedKeys=&quot;&quot;  <span class="hljs-comment">&lt;!--插入成功后将 将值回设至 原参数-&gt;</span><br><span class="hljs-comment"> timeout=&quot;20&quot;&gt;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">&lt;!--示例：--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;addUser&quot;</span> <span class="hljs-attr">keyColumn</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">   <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>  insert into  user (name,updateTime,createTime) values (#&#123;name&#125;,#&#123;updateTime&#125;,#&#123;createTime&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="5、参数映射"><a href="#5、参数映射" class="headerlink" title="5、参数映射"></a>5、参数映射</h3><p>参数映射是最强大功能之一，基可以通过以下方式进行引用</p>
<blockquote>
<p>1、单个简单参数引用 :如果方法中只有一个参数可通过任意名称 进行引用<br>2、多个简单参数引用：通过参数下标引用 #{arg0} #{arg1}  或 #{param1} ,#{param2}<br>3、对像属性引用: 直接通过对象属性名称引用，嵌套对像通过. 号进行引用<br>4、map key值引用：变量名称引用(需要jdk1.8支持) ：通过方法中参数名称引用，需要jdk1.8支持，且在编译时必须加上 -parameters 编译命令</p>
</blockquote>
<p>在idea 中添加 编译参数</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/wps5.jpg" alt="img"> </p>
<p>在maven中添加 编译参数</p>
<p><img src="/images/Mybatis%E5%9F%BA%E7%A1%80/wps6.jpg" alt="img"> </p>
<p>注：一但可通过变量名称引入不在支持arg0获取！</p>
<p>参数引用 相关属性</p>
<p>javaType=int, #参数java类型</p>
<p>jdbcType=NUMERIC,# jdbc类型</p>
<p>typeHandler=MyTypeHandler#  指定类型处理器</p>
<h3 id="6、参数拼接"><a href="#6、参数拼接" class="headerlink" title="6、参数拼接${}"></a><strong>6、参数拼接${}</strong></h3><p>​    基于#的参数引用,其原理是通过 ?占位其通过预处理能获得<strong>更好的性能 和安全性（防止SQL注入攻击）</strong></p>
<p>但有些需求是通过?占位无法实现的，比如在一些分库分表的场景中我们需要 动态的拼接表结构。</p>
<p>比如某系统日志表是按年进行切割的 2018_systemlog,2019_systemlog这时就可以通过</p>
<p> 示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Select(&quot;SELECT * FROM $&#123;table&#125; WHERE id = #&#123;id&#125;&quot;)</span><br><span class="hljs-function">User <span class="hljs-title">selectByTable</span><span class="hljs-params">(String table, <span class="hljs-keyword">int</span> id)</span></span>;<br></code></pre></td></tr></table></figure>

<p>**#{}**：是 MyBatis 推荐的参数拼接方式。<code>#&#123;&#125;</code>会将参数值作为预编译参数传递给 JDBC，从而避免SQL注入攻击，此外#{}也支持自动处理参数类型转化比如日期格式、字符串转数字等。</p>
<p>**${}**：纯字符串替换，它会直接将<code>$&#123;&#125;</code>内的内容替换为参数的值，并将结果拼接到 SQL 语句中。这种方式存在 SQL 注入的风险，因为参数值直接嵌入到 SQL 语句中，可能会导致安全问题。优点：可用于动态拼接表名、列名等</p>
<h4 id="举例："><a href="#举例：" class="headerlink" title="举例："></a>举例：</h4><p>假设我们有一个用户输入的参数<code>username</code>，我们希望通过MyBatis执行一个查询操作，根据用户输入的用户名来查询对应的用户信息。</p>
<p>使用<code>#&#123;&#125;</code>的示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    SELECT * FROM users WHERE username = #&#123;username&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>#&#123;username&#125;</code>会将参数值作为预编译参数传递给JDBC，这意味着不会直接将用户输入的值直接拼接到SQL语句中，而是将其作为一个参数传递给数据库。这样，即使用户输入的<code>username</code>中包含SQL注入攻击的特殊字符，比如单引号或者SQL关键字，数据库也会将其作为普通字符串进行处理，而不会将其作为SQL语句的一部分执行。</p>
<p>而如果我们使用<code>$&#123;&#125;</code>的话：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;getUserByUsername&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;String&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    SELECT * FROM users WHERE username = &#x27;$&#123;username&#125;&#x27;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在这个示例中，<code>$&#123;username&#125;</code>会直接将参数值作为字符串替换到SQL语句中，这样就存在SQL注入的风险。如果用户输入的<code>username</code>包含恶意构造的SQL语句片段，比如<code>&#39; OR &#39;1&#39;=&#39;1&#39;</code>，那么最终拼接到SQL语句中的结果就可能变成<code>SELECT * FROM users WHERE username = &#39;&#39; OR &#39;1&#39;=&#39;1&#39;</code>，导致SQL注入攻击成功。</p>
<p>因此，使用<code>#&#123;&#125;</code>参数拼接可以有效地防止SQL注入攻击。</p>
<h3 id="7、结果集映射"><a href="#7、结果集映射" class="headerlink" title="7、结果集映射"></a>7、结果集映射</h3><h4 id="1、结果集映射"><a href="#1、结果集映射" class="headerlink" title="1、结果集映射"></a>1、结果集映射</h4><p>结果集映射是指 将resultSet 中内容封装转换成java对像，在纯jdbc时代全部都是用调用resultSet的getXXX(columnName) 来获取属性并封装。代码量大，编程效率低尤其当数据模型是1对多，或多对多这种复杂关系，这种封装代码将会变得非常复杂。结果集映射就是为解决这个问题 通过resultMap 集中处理 结果集与JAVA对像的关系。</p>
<h5 id="1、结果集自动映射"><a href="#1、结果集自动映射" class="headerlink" title="1、结果集自动映射"></a>1、结果集自动映射</h5><p>在select 中指定 resultType=XXX后，无需要任何配置 myBatis会基于resultType中的java类型及属性自动推断生成 一个隐示的resultMap  从而完成结果映射resultMap，但有时jdbc 并不是与java Bean 完全贴合这时就需要手动设置resultMap</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;account2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;createTimestamp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">typeHandler</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.LongTimeHandler&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这时在select元素中用 resultMap =”account2” 即可引用该map映射。</p>
<p>基本元素与属性</p>
<blockquote>
<p>ID：用于结果集中的唯一标识<br>result：设置一个某通过字段<br>property:<br>jdbcType:<br>javaType:<br>column:<br>typeHandler:</p>
</blockquote>
<h5 id="2、嵌套结果映射"><a href="#2、嵌套结果映射" class="headerlink" title="2、嵌套结果映射"></a>2、嵌套结果映射</h5><p>关联 association<br>示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountAndUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;userName&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAccountAndUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;accountAndUser&quot;</span>&gt;</span><br>    SELECT a.*, b.name userName from account a,user b where a.user_id=b.id<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="3、引入外部Select"><a href="#3、引入外部Select" class="headerlink" title="3、引入外部Select"></a>3、引入外部Select</h5><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--基于多次查询拼装引入 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;accountAndUser2&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.Account&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">javaType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span> 		                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span>&gt;</span><br>    select * from user  where id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>myBatis缓存与动态SQL</title>
    <url>/2021/05/11/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/</url>
    <content><![CDATA[<h1 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h1><ol>
<li>1,2级缓存处理</li>
<li>动态化SQL</li>
</ol>
<h1 id="一、1-2级缓存处理"><a href="#一、1-2级缓存处理" class="headerlink" title="一、1,2级缓存处理"></a>一、1,2级缓存处理</h1><hr>
<p>知识点：</p>
<p>1级缓存使用场景</p>
<p>2级缓存使用场景</p>
<h2 id="1、1级缓存使用场景"><a href="#1、1级缓存使用场景" class="headerlink" title="1、1级缓存使用场景"></a>1、1级缓存使用场景</h2><p>订单表与会员表是存在一对多的关系，为了尽可能减少join 查询，进行了分阶段查询，即先查询出订单表，在根据member_id 字段查询出会员表，最后进行数据整合 。如果订单表中存在重复的member_id，就会出现很多没必要的重复查询。</p>
<p>​    针对这种情况myBatis 通过1级缓存来实现，在同一次查询会话中如果出现相同的语句及参数，就会从缓存中取出不在走数据库查询。</p>
<p>​    1级缓存只能作用于<strong>查询会话</strong>中 所以也叫做==会话缓存==。</p>
<p>示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br><br>  <span class="hljs-function">User <span class="hljs-title">getUser</span><span class="hljs-params">(Integer id)</span></span>;<br><br>  <span class="hljs-function">User <span class="hljs-title">selectById</span><span class="hljs-params">(Integer id)</span></span>;<br><br>  <span class="hljs-meta">@Update(&quot;select * from user where id = #&#123;id&#125;&quot;)</span><br>  <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">updateById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainTest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> SqlSession sqlSession = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">private</span> SqlSession sqlSession2 = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        String resource = <span class="hljs-string">&quot;mybatis-config.xml&quot;</span>;<br>        InputStream inputStream = MainTest.class.getClassLoader().getResourceAsStream(resource);<br>        SqlSessionFactory sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>        sqlSession = sqlSessionFactory.openSession();<br>        sqlSession2 = sqlSessionFactory.openSession();<br><br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test00</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//原始用法</span><br>        User user = (User)sqlSession.selectOne(<span class="hljs-string">&quot;com.study.mapper.UserMapper.selectById&quot;</span>, <span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        User user2 = mapper.getUser(<span class="hljs-number">1</span>);<br>        User user3 = mapper.selectById(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user3);<br>        System.out.println(user2==user1);<br>        System.out.println(user3==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        UserMapper mapper2 = sqlSession2.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        User user2 = mapper2.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        UserMapper2 mapper2 = sqlSession.getMapper(UserMapper2.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询结束======================&quot;</span>);<br>        User user2 = mapper2.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        sqlSession.clearCache();<br>        User user2 = mapper.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test05</span><span class="hljs-params">()</span></span>&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user1 = mapper.getUser(<span class="hljs-number">1</span>);<br>        log.info(<span class="hljs-string">&quot;首次查询======================&quot;</span>);<br>        mapper.updateById(<span class="hljs-number">1</span>);<br>        User user2 = mapper.getUser(<span class="hljs-number">1</span>);<br>        System.out.println(user1);<br>        System.out.println(user2);<br>        System.out.println(user2==user1);<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>一级缓存的使用条件：</p>
<h3 id="1-必须是相同的SQL和参数"><a href="#1-必须是相同的SQL和参数" class="headerlink" title="1.必须是相同的SQL和参数"></a>1.必须是相同的SQL和参数</h3><h3 id="2-必须是相同的statement-即同一个mapper实例接口中的同一个方法"><a href="#2-必须是相同的statement-即同一个mapper实例接口中的同一个方法" class="headerlink" title="2.必须是相同的statement 即同一个mapper实例接口中的同一个方法"></a>2.必须是相同的statement 即同一个mapper实例接口中的同一个方法</h3><h3 id="3-必须是相同的会话"><a href="#3-必须是相同的会话" class="headerlink" title="3.必须是相同的会话"></a>3.必须是相同的会话</h3><h3 id="4-查询语句中间没有执行session-clearCache-方法"><a href="#4-查询语句中间没有执行session-clearCache-方法" class="headerlink" title="4.查询语句中间没有执行session.clearCache() 方法"></a>4.查询语句中间没有执行session.clearCache() 方法</h3><h3 id="5-查询语句中间没有执行-insert-update-delete-方法"><a href="#5-查询语句中间没有执行-insert-update-delete-方法" class="headerlink" title="5.查询语句中间没有执行 insert update delete 方法"></a>5.查询语句中间没有执行 insert update delete 方法</h3><p>（无论变动记录是否与 缓存数据有无关系）</p>
<h3 id="6-必须是相同的namespace-即同一个mapper"><a href="#6-必须是相同的namespace-即同一个mapper" class="headerlink" title="6.必须是相同的namespace 即同一个mapper"></a>6.必须是相同的namespace 即同一个mapper</h3><h3 id="7、同一个Mapper实例（Mapper类型相同的不同实例也不行"><a href="#7、同一个Mapper实例（Mapper类型相同的不同实例也不行" class="headerlink" title="7、同一个Mapper实例（Mapper类型相同的不同实例也不行)"></a>7、同一个Mapper实例（Mapper类型相同的不同实例也不行)</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//无法共用一级缓存</span><br>UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>UserMapper2 mapper2 = sqlSession.getMapper(UserMapper2.class);<br></code></pre></td></tr></table></figure>

<p>一级缓存源码解析：</p>
<p>缓存获取 ：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">mapper.mapper.selectById(<span class="hljs-number">23</span>)<br>	&gt;org.apache.ibatis.binding.MapperProxy#invoke<br>    &gt;org.apache.ibatis.binding.MapperMethod#execute<br>    	&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectOne()<br>		&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()<br>			&gt;org.apache.ibatis.executor.CachingExecutor#query()//尝试获取二级缓存<br>                &gt;org.apache.ibatis.executor.BaseExecutor#query() 142L<br>                	&gt;org.apache.ibatis.cache.impl.PerpetualCache#getObject 55L//尝试获取一级缓存<br></code></pre></td></tr></table></figure>



<p>缓存的存储：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">mapper.mapper.selectById(<span class="hljs-number">23</span>)<br>org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()<br>org.apache.ibatis.executor.CachingExecutor#query()<br>org.apache.ibatis.executor.BaseExecutor#query() 142L<br>org.apache.ibatis.executor.BaseExecutor#queryFromDatabase<br>org.apache.ibatis.cache.impl.PerpetualCache#putObject<br></code></pre></td></tr></table></figure>

<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210509213336367.png" alt="image-20210509213336367"></p>
<p>通过对clearCache 作为入口我们可能追踪到 一级缓存的实现PerpetualCache</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">org.apache.ibatis.session.defaults.DefaultSqlSession#clearCache<br>org.apache.ibatis.executor.CachingExecutor#clearLocalCache<br>org.apache.ibatis.executor.BaseExecutor#clearLocalCache<br>org.apache.ibatis.cache.impl.PerpetualCache#clear<br></code></pre></td></tr></table></figure>

<h3 id="8-一级缓存是线程不安全的"><a href="#8-一级缓存是线程不安全的" class="headerlink" title="8.一级缓存是线程不安全的"></a>8.一级缓存是线程不安全的</h3><p>提问：</p>
<p>在查询时另一个会话并发去修改查询的数据，一级缓存是否会生效？如果生效是否就会导致数据不正确？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testThread</span><span class="hljs-params">()</span></span>&#123;<br>    UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            User user1 = userMapper.getUser(<span class="hljs-number">1</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程一：&quot;</span>);<br>            System.out.println(user1);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">2000</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;线程一：&quot;</span>);<br>            System.out.println(user1);<br>        &#125;<br>    &#125;).start();<br>    <span class="hljs-keyword">try</span> &#123;<br>        Thread.sleep(<span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>    <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            User user2 = userMapper.getUser(<span class="hljs-number">1</span>);<br>            user2.setUsername(<span class="hljs-string">&quot;周树人&quot;</span>);<br>            System.out.println(<span class="hljs-string">&quot;线程二：&quot;</span>);<br>            System.out.println(user2);<br>            sqlSession.close();<br>        &#125;<br>    &#125;).start();<br></code></pre></td></tr></table></figure>



<p>答：多次查询相同id一级缓存获取到的对象都是同一个应用，并没有做深克隆。所以当线程2查询某个缓存对象后并且人为修改了这个对象，那么也会同步影响线程一原本的对象，存在<strong>脏读</strong>问题</p>
<h2 id="2、2级缓存使用场景："><a href="#2、2级缓存使用场景：" class="headerlink" title="2、2级缓存使用场景："></a>2、2级缓存使用场景：</h2><p>业务系统中存在很多的静态数据如，字典表、菜单表、权限表等，这些数据的特性是不会轻易修改但又是查询的热点数据。一级缓存针对的是同一个会话当中相同SQL，并不适合这情热点数据的缓存场景。为了解决这个问题引入了二级缓存，它脱离于会话之外。</p>
<p>2级缓存示例：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@CacheNamespace()</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LabelMapper</span> </span>&#123;<br><span class="hljs-meta">@Select(&quot;select * from t_label where id =#&#123;id&#125;&quot;)</span><br><span class="hljs-function">Label <span class="hljs-title">getById</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br>属性说明：<br><span class="hljs-meta">@CacheNamespace(</span><br><span class="hljs-meta">implementation = PerpetualCache.class,//  缓存实现 Cache接口 实现类</span><br><span class="hljs-meta">eviction = LruCache.class,// 缓存算法</span><br><span class="hljs-meta">flushInterval =60000,// 刷新间隔时间 毫秒</span><br><span class="hljs-meta">size =1024,// 最大缓存引用对象</span><br><span class="hljs-meta">readWrite =true,// 是否可写</span><br><span class="hljs-meta">blocking = false// 是否阻塞，用来防止缓存击穿</span><br><span class="hljs-meta">)</span><br>    或者<br>&lt;cache  readOnly=<span class="hljs-string">&quot;false&quot;</span> blocking=<span class="hljs-string">&quot;true&quot;</span> flushInterval=<span class="hljs-string">&quot;60000&quot;</span> size=<span class="hljs-string">&quot;1024&quot;</span> eviction=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210510232548387.png" alt="image-20210510232548387"></p>
<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210510232254209.png" alt="image-20210510232254209">bolocking 示意图</p>
<h3 id="1、2级缓存使用条件"><a href="#1、2级缓存使用条件" class="headerlink" title="1、2级缓存使用条件:"></a>1、2级缓存使用条件:</h3><h4 id="1、当会话提交或关闭之后才会填充二级缓存"><a href="#1、当会话提交或关闭之后才会填充二级缓存" class="headerlink" title="1、当会话提交或关闭之后才会填充二级缓存"></a>1、当会话提交或关闭之后才会填充二级缓存</h4><h4 id="2、必须是在同一个命名空间之下"><a href="#2、必须是在同一个命名空间之下" class="headerlink" title="2、必须是在同一个命名空间之下"></a>2、必须是在同一个命名空间之下</h4><h4 id="3、必须是相同的statement-即同一个mapper-接口中的同一个方法"><a href="#3、必须是相同的statement-即同一个mapper-接口中的同一个方法" class="headerlink" title="3、必须是相同的statement 即同一个mapper 接口中的同一个方法"></a>3、必须是相同的statement 即同一个mapper 接口中的同一个方法</h4><h4 id="4、必须是相同的SQL语句和参数"><a href="#4、必须是相同的SQL语句和参数" class="headerlink" title="4、必须是相同的SQL语句和参数"></a>4、必须是相同的SQL语句和参数</h4><h4 id="5、如果readWrite-true（readOnly-”false”）-，实体对像必须实现Serializable-接口"><a href="#5、如果readWrite-true（readOnly-”false”）-，实体对像必须实现Serializable-接口" class="headerlink" title="5、如果readWrite=true（readOnly=”false”） ，实体对像必须实现Serializable 接口"></a>5、如果readWrite=true（readOnly=”false”） ，实体对像必须实现Serializable 接口</h4><p>​    true:表示深克隆，实体需实现序列化，2次查询出来对象不是同一个，readWrite=false时，两次查询获取对象是同一个</p>
<h4 id="6、mapper-xml-的-lt-cache-gt-和-Mapper-java-的-CacheNamespace-是两个缓存空间，且不能共存"><a href="#6、mapper-xml-的-lt-cache-gt-和-Mapper-java-的-CacheNamespace-是两个缓存空间，且不能共存" class="headerlink" title="6、mapper.xml 的&lt;cache/&gt;和 Mapper.java 的@CacheNamespace 是两个缓存空间，且不能共存"></a>6、mapper.xml 的<code>&lt;cache/&gt;</code>和 Mapper.java 的@CacheNamespace 是两个缓存空间，且不能共存</h4><h3 id="2、2级缓存清除条件："><a href="#2、2级缓存清除条件：" class="headerlink" title="2、2级缓存清除条件："></a>2、2级缓存清除条件：</h3><h4 id="1、xml中配置的update-不能清空-CacheNamespace-中的缓存数据"><a href="#1、xml中配置的update-不能清空-CacheNamespace-中的缓存数据" class="headerlink" title="1、xml中配置的update 不能清空 @CacheNamespace 中的缓存数据"></a>1、xml中配置的update 不能清空 @CacheNamespace 中的缓存数据</h4><h4 id="2、只有修改会话提交之后-才会执行清空操作"><a href="#2、只有修改会话提交之后-才会执行清空操作" class="headerlink" title="2、只有修改会话提交之后 才会执行清空操作"></a>2、只有修改会话提交之后 才会执行清空操作</h4><h4 id="3、任何一种增删改操作-都会清空整个namespace-中的缓存"><a href="#3、任何一种增删改操作-都会清空整个namespace-中的缓存" class="headerlink" title="3、任何一种增删改操作 都会清空整个namespace 中的缓存"></a>3、任何一种增删改操作 都会清空整个namespace 中的缓存</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&lt;cache  readOnly=<span class="hljs-string">&quot;true&quot;</span> blocking=<span class="hljs-string">&quot;true&quot;</span> flushInterval=<span class="hljs-string">&quot;60000&quot;</span> size=<span class="hljs-string">&quot;1024&quot;</span> eviction=<span class="hljs-string">&quot;LRU&quot;</span>/&gt;<br><br><span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test00</span><span class="hljs-params">()</span></span>&#123;<br><br>       UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>       User user = userMapper.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(<span class="hljs-string">&quot;第一次会话结束&quot;</span>);<br>       sqlSession.close();<br><br>       UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);<br>       User user2 = userMapper2.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(user==user2); <span class="hljs-comment">//二级缓存生效，浅克隆，返回true</span><br>   &#125;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span></span>&#123;<br><br>       UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>       User user = userMapper.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(<span class="hljs-string">&quot;第一次会话结束&quot;</span>);<br>     <br><br>       UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);<br>       User user2 = userMapper2.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(user==user2);<span class="hljs-comment">//二级缓存不生效，返回false</span><br>   &#125;<br><br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span></span>&#123;<br><br>       UserMapper userMapper = sqlSession.getMapper(UserMapper.class);<br>       User user = userMapper.getUser(<span class="hljs-number">1</span>);<br>       System.out.println(<span class="hljs-string">&quot;第一次会话结束&quot;</span>);<br>       sqlSession.close();<br><br>       UserMapper userMapper2 = sqlSession2.getMapper(UserMapper.class);<br>       User user1 = <span class="hljs-keyword">new</span> User();<br>       user1.setUsername(<span class="hljs-string">&quot;lao li&quot;</span>);<br>       user1.setId(<span class="hljs-number">1</span>);<br>       userMapper2.updateUserById(user1);<br>       <span class="hljs-comment">//必须关闭，才能触发清空二级缓存</span><br>       sqlSession2.close();<br>       User user2 = sqlSessionFactory.openSession().getMapper(UserMapper.class).getUser(<span class="hljs-number">1</span>);<br>       System.out.println(user==user2);<span class="hljs-comment">//二级缓存清空，false</span><br>   &#125;<br></code></pre></td></tr></table></figure>



<p>2级缓存源码解析：</p>
<p>清除缓存！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">org.apache.ibatis.session.defaults.DefaultSqlSession#selectList() 147L<br>org.apache.ibatis.executor.CachingExecutor#query()81L<br>org.apache.ibatis.executor.CachingExecutor#query()95L<br>org.apache.ibatis.executor.CachingExecutor#flushCacheIfRequired() 164L //清除缓存<br></code></pre></td></tr></table></figure>

<p>获取缓存关键源码！</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">org.apache.ibatis.cache.TransactionalCacheManager#getObject<br>org.apache.ibatis.cache.decorators.TransactionalCache#getObject<br>org.apache.ibatis.cache.decorators.SynchronizedCache#getObject<br>org.apache.ibatis.cache.decorators.LoggingCache#getObject<br>org.apache.ibatis.cache.decorators.SerializedCache#getObject<br>org.apache.ibatis.cache.decorators.ScheduledCache#getObject<br>org.apache.ibatis.cache.decorators.LruCache#getObject<br>org.apache.ibatis.cache.impl.PerpetualCache#getObject<br></code></pre></td></tr></table></figure>

<p>保存2级缓存 ！</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.apache.ibatis.executor.CachingExecutor#close<br>org.apache.ibatis.cache.TransactionalCacheManager#commit<br>org.apache.ibatis.cache.decorators.TransactionalCache#flushPendingEntries<br>org.apache.ibatis.cache.decorators.SynchronizedCache#putObject<br>org.apache.ibatis.cache.decorators.LoggingCache#putObject<br>org.apache.ibatis.cache.decorators.SerializedCache#putObject<br>org.apache.ibatis.cache.decorators.ScheduledCache#putObject<br>org.apache.ibatis.cache.decorators.LruCache#putObject<br>org.apache.ibatis.cache.impl.PerpetualCache#putObject<br>    <br>    <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionalCache</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cache</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> Cache delegate;<br>  <span class="hljs-keyword">private</span> Map&lt;Object, Object&gt; entriesToAddOnCommit;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>    <span class="hljs-comment">// issue #116</span><br>    Object object = delegate.getObject(key);<br>    <span class="hljs-keyword">if</span> (object == <span class="hljs-keyword">null</span>) &#123;<br>      entriesMissedInCache.add(key);<br>    &#125;<br>    <span class="hljs-comment">// issue #146</span><br>    <span class="hljs-keyword">if</span> (clearOnCommit) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">return</span> object;<br>    &#125;<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">putObject</span><span class="hljs-params">(Object key, Object object)</span> </span>&#123;<br>    entriesToAddOnCommit.put(key, object);<br>  &#125;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clear</span><span class="hljs-params">()</span> </span>&#123;<br>    clearOnCommit = <span class="hljs-keyword">true</span>;<br>    entriesToAddOnCommit.clear();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (clearOnCommit) &#123;<br>      delegate.clear();<br>    &#125;<br>    flushPendingEntries();<br>    reset();<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">()</span> </span>&#123;<br>    unlockMissedEntries();<br>    reset();<br>  &#125;<br> <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、如何理解-TransacionCache"><a href="#3、如何理解-TransacionCache" class="headerlink" title="3、如何理解 TransacionCache"></a>3、如何理解 TransacionCache</h3><p>TransacionCache的生命周期是<strong>会话（事务）级别</strong></p>
<p>TransacionCache：事务级别，sqlSession提交时会触发TransacionCache的commit</p>
<p>二级缓存：Mapper级别（应用级别）</p>
<p>一级缓存：SqlSession级别（会话级别）</p>
<p>问题：</p>
<p>为什么存在 TransactionalCache，且二级缓存必须是<strong>会话提交后</strong>才生效</p>
<ol>
<li>为了防止事务回滚的场景，别的会话脏读了二级缓存的的内容</li>
<li>所以当本次会话未关闭前，二级缓存新增对象都暂存在<strong>entriesToAddOnCommit</strong>本地中</li>
<li>当事务提交时，才触发<strong>entriesToAddOnCommit</strong> 持久化到应用生命周期的<strong>delegate</strong>这个实际cache中</li>
<li>而且每个会话期间，获取二级缓存都是从<strong>delegate</strong>这个实际cache中获取，这样就避免了脏读（读未提交）问题.</li>
</ol>
<p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210512231601527.png" alt="image-20210512231601527"></p>
<h3 id="4、二级缓存生命周期示意图"><a href="#4、二级缓存生命周期示意图" class="headerlink" title="4、二级缓存生命周期示意图"></a>4、二级缓存生命周期示意图</h3><p><img src="/images/Mybatis%E7%BC%93%E5%AD%98%E4%B8%8E%E5%8A%A8%E6%80%81SQL/image-20210512231634979.png" alt="image-20210512231634979"></p>
<h1 id="二、动态化SQL"><a href="#二、动态化SQL" class="headerlink" title="二、动态化SQL"></a>二、动态化SQL</h1><hr>
<p>基本命令使用</p>
<ul>
<li>if</li>
<li>choose (when, otherwise)</li>
<li>trim (where, set)</li>
<li>foreach</li>
</ul>
<p><strong><trim>示例说明：</trim></strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br>	<span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;id != null&quot;</span>&gt;</span><br>		and id = #&#123;id&#125;<br>	<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;name != null&quot;</span>&gt;</span><br>    	and name = #&#123;name&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br>trim属性说明：<br>* prefix=&quot;where&quot;// 前缀<br>* prefixOverrides=&quot;and|or&quot;// 前缀要替换的词<br>* suffix=&quot;&quot;// 添加后缀<br>* suffixOverrides=&quot;&quot;// 后缀要替换的词<br><br><span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span>元素说明：<br>在where 包裹的SQL前会自动添加 where 字符 并去掉首尾多佘的 and|or 字符 相当于下配置:<br><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;where&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;and|or&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span>元素说明：<br>在set包裹的SQL前会自动添加 set 字符并去掉首尾多佘的 , 字符。<br><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">parameterType</span>=<span class="hljs-string">&quot;User&quot;</span>&gt;</span><br>    UPDATE users<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;username != null&quot;</span>&gt;</span>username=#&#123;username&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;password != null&quot;</span>&gt;</span>password=#&#123;password&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;email != null&quot;</span>&gt;</span>email=#&#123;email&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    WHERE id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span>    <br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span>&gt;</span> 元素说明:在同一个mapper多个statement 存在多个相同的sql  片段时，可以通过<span class="hljs-tag">&lt;<span class="hljs-name">sql</span>&gt;</span>元素声明，在通过   <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>  元素进行引用<br>声明sql 段<br><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;files&quot;</span>&gt;</span><br>	id ,name ,createTime<br><span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br>    <br>引用<br><span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;files&quot;</span> /&gt;</span><br>    <br>    <br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span>&gt;</span> 变量使用<br>有时需要进行一些额外 逻辑运行，通过 声明<span class="hljs-tag">&lt;<span class="hljs-name">bind</span>&gt;</span>元素，并在其value 属性中添加运算脚本，如下示例 自动给likeName 加上了% 分号，然后就可以用#&#123;likeName&#125; 来使用带%分号的like 运算。<br><br><span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;likeName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27;+ _parameter.getName() +&#x27;%&#x27;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bind</span>&gt;</span><br>    <br>    <br>    <br>内置变量<br>_databaseid  数据库标识ID<br>_parameter 当前参数变理<br></code></pre></td></tr></table></figure>

<h2 id="使用别的解析模板"><a href="#使用别的解析模板" class="headerlink" title="使用别的解析模板"></a>使用别的解析模板</h2><p>以上的if trim where 等逻辑符都是 myBatis 自带的XMLLanguageDriver 所提供的解释语言，除非此之外 我们还可以使用 MyBatis-Velocity 或 mybatis-freemarker 等外部 解释器来编写动态脚本。</p>
<h3 id="mybatis-freemarker-使用"><a href="#mybatis-freemarker-使用" class="headerlink" title="mybatis-freemarker 使用"></a>mybatis-freemarker 使用</h3><p>引入mybatis 包：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.scripting<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-freemarker<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">添加sql 语句<br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectByIds&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.tuling.mybatis.dao.User&quot;</span></span><br><span class="hljs-tag">	<span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;org.mybatis.scripting.freemarker.FreeMarkerLanguageDriver&quot;</span>&gt;</span><br>    select  * from user<br>    	where  id in($&#123;ids?join(&#x27;,&#x27;)&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><br>lang=&quot;org.mybatis.scripting.freemarker.FreeMarkerLanguageDriver&quot;<br>指定解析器<br></code></pre></td></tr></table></figure>



<p>添加接口方法<br>List<User> selectByIds(@Param(“ids”) List<Integer> ids);</Integer></User></p>
]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>缓存</tag>
        <tag>动态SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybati执行对象创建过程与执行</title>
    <url>/2021/05/15/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<p>概要：</p>
<ol>
<li>执行流程解析</li>
<li>myBatis插件开发</li>
</ol>
<h1 id="执行流程分析"><a href="#执行流程分析" class="headerlink" title="执行流程分析"></a>执行流程分析</h1><h2 id="Configuration全局配置对象创建"><a href="#Configuration全局配置对象创建" class="headerlink" title="Configuration全局配置对象创建"></a>Configuration全局配置对象创建</h2><p>讲解解析流程之前先回顾一下myBatis 中配置文件的结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">mybatis-config.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">settting</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">typeHandlers</span>/&gt;</span><br>  &lt;..../&gt;<br>  <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>mybatis-mapper.xml<br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> &gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span>/&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">select</span>/&gt;</span>  <br>  <span class="hljs-tag">&lt;<span class="hljs-name">update</span>/&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">delete</span>/&gt;</span> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">insert</span>/&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>配置文件的解析流程即是将上述XML描述元素转换成对应的JAVA对像过程，其最终转换对像及其关系如下图：</p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image1.png"></p>
<p>配置元素解析构建器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.apache.ibatis.builder.xml.XMLConfigBuilder<br>    <span class="hljs-comment">//生成org.apache.ibatis.session.Configuration对象 生命周期：整个应用周期</span><br> &gt;org.apache.ibatis.builder.xml.XMLMapperBuilder<br>    <span class="hljs-comment">//生成生成configuration对象的MappedStatement key为namcspace + 语语句块的id	 </span><br>    <span class="hljs-comment">//生命周期：整个应用周期</span><br>  &gt;org.apache.ibatis.builder.xml.XMLStatementBuilder<br>    <span class="hljs-comment">//Statement 生命周期：整个应用周期</span><br>   &gt;org.apache.ibatis.builder.SqlSourceBuilder<br>    <span class="hljs-comment">//增删改查语句内容构建</span><br>    &gt;org.apache.ibatis.scripting.xmltags.XMLScriptBuilder<br>    <span class="hljs-comment">//动态SQL构建</span><br> &gt;org.apache.ibatis.builder.annotation.MapperAnnotationBuilder<br>    <span class="hljs-comment">//用注解方式构建起如@Select（...）</span><br></code></pre></td></tr></table></figure>

<h2 id="SqlSession-会话对象创建"><a href="#SqlSession-会话对象创建" class="headerlink" title="SqlSession 会话对象创建"></a>SqlSession 会话对象创建</h2><p>首先我们还是先来了解一下会话对像的组成结构如下图：</p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516131743828.png" alt="image-20210516131743828"></p>
<p>会话构建源码解析:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSession(boolean)<br>&gt;org.apache.ibatis.session.defaults.DefaultSqlSessionFactory#openSessionFromDataSource<br>&gt;org.apache.ibatis.transaction.jdbc.JdbcTransactionFactory#newTransaction()<br>&gt;org.apache.ibatis.session.Configuration#newExecutor() &gt;org.apache.ibatis.executor.SimpleExecutor#SimpleExecutor &gt;org.apache.ibatis.executor.CachingExecutor#CachingExecutor <br><span class="hljs-comment">//执行器插件包装 </span><br>&gt;org.apache.ibatis.plugin.InterceptorChain#pluginAll(executor) &gt;org.apache.ibatis.session.defaults.DefaultSqlSession#DefaultSqlSession()<br></code></pre></td></tr></table></figure>

<h2 id="方法执行流程"><a href="#方法执行流程" class="headerlink" title="方法执行流程"></a>方法执行流程</h2><p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/%E6%9F%A5%E8%AF%A2%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B.png" alt="image-20210516135633903 "></p>
<p>StatementHandler 源码解析</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.apache.ibatis.session.defaults.DefaultSqlSession#selectList()<br> &gt;org.apache.ibatis.executor.CachingExecutor#query()<br>  &gt;org.apache.ibatis.executor.BaseExecutor#query()<br>   &gt;org.apache.ibatis.executor.BaseExecutor#queryFromDatabase<br>&gt;org.apache.ibatis.session.Configuration#newStatementHandler<br>org.apache.ibatis.executor.statement.BaseStatementHandler#BaseStatementHandler<br>org.apache.ibatis.session.Configuration#newParameterHandler<br>org.apache.ibatis.plugin.InterceptorChain#pluginAll(parameterHandler)<br>org.apache.ibatis.session.Configuration#newResultSetHandler<br>org.apache.ibatis.plugin.InterceptorChain#pluginAll(resultSetHandler)<br>&gt;org.apache.ibatis.plugin.InterceptorChain#pluginAll(statementHandler)<br>&gt;org.apache.ibatis.executor.BaseExecutor#getConnection<br>&gt;org.apache.ibatis.executor.statement.PreparedStatementHandler#instantiateStatement<br>&gt;org.apache.ibatis.executor.statement.PreparedStatementHandler#parameterize<br>&gt;org.apache.ibatis.scripting.defaults.DefaultParameterHandler#setParameters<br>org.apache.ibatis.type.BaseTypeHandler#setParameter<br>org.apache.ibatis.type.UnknownTypeHandler#setNonNullParameter<br>org.apache.ibatis.type.IntegerTypeHandler#setNonNullParameter<br></code></pre></td></tr></table></figure>



<h2 id="Mapper接口对象创建"><a href="#Mapper接口对象创建" class="headerlink" title="Mapper接口对象创建"></a>Mapper接口对象创建</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.apache.ibatis.binding.MapperProxyFactory.newInstance(MapperProxyFactory.java:<span class="hljs-number">48</span>)<br>org.apache.ibatis.binding.MapperProxyFactory.newInstance(MapperProxyFactory.java:<span class="hljs-number">53</span>)<br>org.apache.ibatis.binding.MapperRegistry.getMapper(MapperRegistry.java:<span class="hljs-number">50</span>)<br>org.apache.ibatis.session.Configuration.getMapper(Configuration.java:<span class="hljs-number">779</span>)<br>org.apache.ibatis.session.defaults.DefaultSqlSession.getMapper(DefaultSqlSession.java:<span class="hljs-number">291</span>)<br>com.study.SecondLevelCacheTest.test01(SecondLevelCacheTest.java:<span class="hljs-number">46</span>)<br></code></pre></td></tr></table></figure>



<h1 id="MyBatis插件开发"><a href="#MyBatis插件开发" class="headerlink" title="MyBatis插件开发"></a>MyBatis插件开发</h1><h3 id="插件的四大扩展点"><a href="#插件的四大扩展点" class="headerlink" title="插件的四大扩展点"></a>插件的四大扩展点</h3><p>1、Executor</p>
<p>2、StatementHandler</p>
<p>3、ParameterHandler</p>
<p>4、ResultSetHandler</p>
<p><strong>Executor提供了增删改查的接口.</strong></p>
<p><strong>StatementHandler负责处理Mybatis与JDBC之间Statement的交互.</strong></p>
<p><strong>ResultSetHandler负责处理Statement执行后产生的结果集，生成结果列表.</strong></p>
<p><strong>ParameterHandler是Mybatis实现Sql入参设置的对象。</strong></p>
<h3 id="分页插件实现"><a href="#分页插件实现" class="headerlink" title="分页插件实现"></a>分页插件实现</h3><p>用户在接口中声明Page  对像实现后，由插件实现自动分页。</p>
<p>使用示例如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Page</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;   <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> szie; <span class="hljs-comment">// 每页大    </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> number; <span class="hljs-comment">// 当前页码</span><br>&#125;<br> <span class="hljs-function">List&lt;User&gt;  <span class="hljs-title">selectUserList</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;user&quot;)</span> User user, <span class="hljs-meta">@Param(&quot;page&quot;)</span> PageDTO page)</span></span>;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserList&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.study.pojo.User&quot;</span>&gt;</span><br>    select * from user where id = #&#123;user.id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>实现目标分解：</p>
<p>1、判断方法参数是否包含Page对象</p>
<p>2、取出page对象生成 limit 语句</p>
<p>3、修改SQL语句添加 limit 语句</p>
<p>4、上述操作必须在Statement（PrepareStatement）对象生成之前完成</p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516160916272.png" alt="image-20210516160916272"></p>
<p><img src="/images/Mybati%E6%89%A7%E8%A1%8C%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B%E4%B8%8E%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/image-20210516161122668.png" alt="image-20210516161122668"></p>
<p>根据第四点和上面俩图得知插件拦截的时，拦截的目标类和目标方法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StatementHandler</span> </span>&#123;<br>    <span class="hljs-function">Statement <span class="hljs-title">prepare</span><span class="hljs-params">(Connection connection, Integer transactionTimeout)</span></span><br><span class="hljs-function">      <span class="hljs-keyword">throws</span> SQLException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>所以最终的拦截器代码如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PagePlugin</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>       <span class="hljs-keyword">return</span> invocation.getTarget();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(target <span class="hljs-keyword">instanceof</span> StatementHandler)&#123;<br>            <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.getClass().getClassLoader(),<br>                    <span class="hljs-keyword">new</span> Class[]&#123;StatementHandler.class&#125;,<br>                    <span class="hljs-keyword">new</span> PageHandler((StatementHandler) target));<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageHandler</span> <span class="hljs-keyword">implements</span>  <span class="hljs-title">InvocationHandler</span></span>&#123;<br><br>        <span class="hljs-keyword">private</span> StatementHandler statementHandler;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PageHandler</span><span class="hljs-params">(StatementHandler statementHandler)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.statementHandler = statementHandler;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>            <span class="hljs-keyword">if</span>(method.getName().equals(<span class="hljs-string">&quot;prepare&quot;</span>))&#123;<br>                ((Map)statementHandler.getBoundSql().getParameterObject()).values().stream()<br>                        .filter(e -&gt; e <span class="hljs-keyword">instanceof</span> PageDTO)<br>                        .findFirst()<br>                        .ifPresent(<br>                                page -&gt; &#123;<br><br>                                    appendPageSql((PageDTO) page);<br>                                &#125;<br>                        );<br>            &#125;<br>            <span class="hljs-keyword">return</span> method.invoke(statementHandler,args);<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">appendPageSql</span><span class="hljs-params">(PageDTO page)</span> </span>&#123;<br>            BoundSql boundSql = statementHandler.getBoundSql();<br>            String sql = boundSql.getSql();<br>            String appendString = String.format(<span class="hljs-string">&quot; limit %s,%s&quot;</span>,(page.getNumber()-<span class="hljs-number">1</span>) * page.getSzie(),page.getSzie());<br>            String result = sql + appendString;<br>            <span class="hljs-keyword">try</span> &#123;<br>                setField(boundSql,<span class="hljs-string">&quot;sql&quot;</span>,result);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setField</span><span class="hljs-params">(BoundSql boundSql, String field, String result)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, NoSuchFieldException </span>&#123;<br>            Field declaredField = BoundSql.class.getDeclaredField(field);<br>            declaredField.setAccessible(<span class="hljs-keyword">true</span>);<br>            declaredField.set(boundSql,result);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="SQL性能插件"><a href="#SQL性能插件" class="headerlink" title="SQL性能插件"></a>SQL性能插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(&#123;@Signature(type = StatementHandler.class, method = &quot;query&quot;, args = &#123;Statement.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;update&quot;, args = &#123;Statement.class&#125;),</span><br><span class="hljs-meta">        @Signature(type = StatementHandler.class, method = &quot;batch&quot;, args = &#123;Statement.class&#125;)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PerformanceInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String JDBC4_PREPARED_STATEMENT = <span class="hljs-string">&quot;com.mysql.jdbc.JDBC4PreparedStatement&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 执行最大时长，超过自动停止运行，有助于发现问题。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> maxTime = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * SQL 是否格式化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-meta">@Setter</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> format = <span class="hljs-keyword">false</span>;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        Statement statement;<br>        Object firstArg = invocation.getArgs()[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(firstArg.getClass())) &#123;<br>            statement = (Statement) SystemMetaObject.forObject(firstArg).getValue(<span class="hljs-string">&quot;h.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            statement = (Statement) firstArg;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            statement = (Statement) SystemMetaObject.forObject(statement).getValue(<span class="hljs-string">&quot;stmt.statement&quot;</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// do nothing</span><br>        &#125;<br><br>        String originalSql = <span class="hljs-keyword">null</span>;<br>        String stmtClassName = statement.getClass().getName();<br>        <span class="hljs-keyword">if</span> (JDBC4_PREPARED_STATEMENT.equals(stmtClassName)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Class&lt;?&gt; clazz = Class.forName(JDBC4_PREPARED_STATEMENT);<br>                Method druidGetSqlMethod = clazz.getMethod(<span class="hljs-string">&quot;getSql&quot;</span>);<br>                Object stmtSql = druidGetSqlMethod.invoke(statement);<br>                <span class="hljs-keyword">if</span> (stmtSql != <span class="hljs-keyword">null</span> &amp;&amp; stmtSql <span class="hljs-keyword">instanceof</span> String) &#123;<br>                    originalSql = (String) stmtSql;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (originalSql == <span class="hljs-keyword">null</span>) &#123;<br>            originalSql = statement.toString();<br>        &#125;<br>        originalSql = originalSql.replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        <span class="hljs-keyword">int</span> index = originalSql.indexOf(<span class="hljs-string">&#x27;:&#x27;</span>);<br>        <span class="hljs-keyword">if</span> (index &gt; <span class="hljs-number">0</span>) &#123;<br>            originalSql = originalSql.substring(index + <span class="hljs-number">1</span>, originalSql.length());<br>        &#125;<br>        String sqlFormat = SqlUtil.sqlFormat(originalSql, format);<br>        Object target = realTarget(invocation.getTarget());<br>        MetaObject metaObject = SystemMetaObject.forObject(target);<br>        MappedStatement ms = (MappedStatement) metaObject.getValue(<span class="hljs-string">&quot;delegate.mappedStatement&quot;</span>);<br>        Logger mybatisLogger = LoggerFactory.getLogger(<span class="hljs-keyword">this</span>.getClass());<br>        <span class="hljs-comment">// 计算执行 SQL 耗时</span><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br>        Object result = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            result = invocation.proceed();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException | IllegalAccessException e) &#123;<br>            <span class="hljs-keyword">long</span> timing =  System.currentTimeMillis() - start;<br>            StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder()<br>                    .append(<span class="hljs-string">&quot;execute sql error, use time：&quot;</span>).append(timing).append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                    .append(sqlFormat);<br>            mybatisLogger.error(formatSql.toString());<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>        <span class="hljs-keyword">long</span> timing = System.currentTimeMillis() - start;<br><br>        <span class="hljs-comment">// 格式化 SQL 打印执行结果</span><br>        StringBuilder formatSql = <span class="hljs-keyword">new</span> StringBuilder().append(<span class="hljs-string">&quot;Execute sql use time：&quot;</span>).append(timing)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; Execute SQL：&quot;</span>).append(sqlFormat)<br>                .append(<span class="hljs-string">&quot;\n&quot;</span>)<br>                .append(<span class="hljs-string">&quot; result: &quot;</span>).append(result);<br><br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.getMaxTime() &gt;= <span class="hljs-number">1</span> &amp;&amp; timing &gt; <span class="hljs-keyword">this</span>.getMaxTime()) &#123;<br>            mybatisLogger.error(formatSql.toString());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            mybatisLogger.debug(formatSql.toString());<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> StatementHandler) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties prop)</span> </span>&#123;<br>        String maxTime = prop.getProperty(<span class="hljs-string">&quot;maxTime&quot;</span>);<br>        String format = prop.getProperty(<span class="hljs-string">&quot;format&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(maxTime)) &#123;<br>            <span class="hljs-keyword">this</span>.maxTime = Long.parseLong(maxTime);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!StringUtils.isEmptyOrWhitespaceOnly(format)) &#123;<br>            <span class="hljs-keyword">this</span>.format = Boolean.valueOf(format);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">realTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (Proxy.isProxyClass(target.getClass())) &#123;<br>            MetaObject metaObject = SystemMetaObject.forObject(target);<br>            <span class="hljs-keyword">return</span> realTarget(metaObject.getValue(<span class="hljs-string">&quot;h.target&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> (T) target;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="带参数SQL打印插件"><a href="#带参数SQL打印插件" class="headerlink" title="带参数SQL打印插件"></a>带参数SQL打印插件</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts</span><br>        (&#123;<br>                <span class="hljs-meta">@Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;)</span>,<br>                <span class="hljs-meta">@Signature(type = Executor.class, method = &quot;update&quot;, args = &#123;MappedStatement.class, Object.class&#125;)</span><br>        &#125;)<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlPrintInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span></span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger log = LoggerFactory.getLogger(SqlPrintInterceptor.class);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> DateFormat DATE_FORMAT = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Invocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        MappedStatement mappedStatement = (MappedStatement) invocation.getArgs()[<span class="hljs-number">0</span>];<br>        Object parameterObject = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span> (invocation.getArgs().length &gt; <span class="hljs-number">1</span>) &#123;<br>            parameterObject = invocation.getArgs()[<span class="hljs-number">1</span>];<br>        &#125;<br><br>        <span class="hljs-keyword">long</span> start = System.currentTimeMillis();<br><br>        Object result = invocation.proceed();<br><br>        String statementId = mappedStatement.getId();<br>        BoundSql boundSql = mappedStatement.getBoundSql(parameterObject);<br>        Configuration configuration = mappedStatement.getConfiguration();<br>        String sql = getSql(boundSql, parameterObject, configuration);<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> timing = end - start;<br>        <span class="hljs-keyword">if</span>(log.isInfoEnabled())&#123;<br>            log.info(<span class="hljs-string">&quot;执行sql耗时:&quot;</span> + timing + <span class="hljs-string">&quot; ms&quot;</span> + <span class="hljs-string">&quot; - id:&quot;</span> + statementId + <span class="hljs-string">&quot; - Sql:&quot;</span> );<br>            log.info(<span class="hljs-string">&quot;   &quot;</span>+sql);<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">plugin</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (target <span class="hljs-keyword">instanceof</span> Executor) &#123;<br>            <span class="hljs-keyword">return</span> Plugin.wrap(target, <span class="hljs-keyword">this</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> target;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setProperties</span><span class="hljs-params">(Properties properties)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getSql</span><span class="hljs-params">(BoundSql boundSql, Object parameterObject, Configuration configuration)</span> </span>&#123;<br>        String sql = boundSql.getSql().replaceAll(<span class="hljs-string">&quot;[\\s]+&quot;</span>, <span class="hljs-string">&quot; &quot;</span>);<br>        List&lt;ParameterMapping&gt; parameterMappings = boundSql.getParameterMappings();<br>        TypeHandlerRegistry typeHandlerRegistry = configuration.getTypeHandlerRegistry();<br>        <span class="hljs-keyword">if</span> (parameterMappings != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; parameterMappings.size(); i++) &#123;<br>                ParameterMapping parameterMapping = parameterMappings.get(i);<br>                <span class="hljs-keyword">if</span> (parameterMapping.getMode() != ParameterMode.OUT) &#123;<br>                    Object value;<br>                    String propertyName = parameterMapping.getProperty();<br>                    <span class="hljs-keyword">if</span> (boundSql.hasAdditionalParameter(propertyName)) &#123;<br>                        value = boundSql.getAdditionalParameter(propertyName);<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (parameterObject == <span class="hljs-keyword">null</span>) &#123;<br>                        value = <span class="hljs-keyword">null</span>;<br>                    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (typeHandlerRegistry.hasTypeHandler(parameterObject.getClass())) &#123;<br>                        value = parameterObject;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        MetaObject metaObject = configuration.newMetaObject(parameterObject);<br>                        value = metaObject.getValue(propertyName);<br>                    &#125;<br>                    sql = replacePlaceholder(sql, value);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sql;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">replacePlaceholder</span><span class="hljs-params">(String sql, Object propertyValue)</span> </span>&#123;<br>        String result;<br>        <span class="hljs-keyword">if</span> (propertyValue != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (propertyValue <span class="hljs-keyword">instanceof</span> String) &#123;<br>                result = <span class="hljs-string">&quot;&#x27;&quot;</span> + propertyValue + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (propertyValue <span class="hljs-keyword">instanceof</span> Date) &#123;<br>                result = <span class="hljs-string">&quot;&#x27;&quot;</span> + DATE_FORMAT.format(propertyValue) + <span class="hljs-string">&quot;&#x27;&quot;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                result = propertyValue.toString();<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            result = <span class="hljs-string">&quot;null&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> sql.replaceFirst(<span class="hljs-string">&quot;\\?&quot;</span>, Matcher.quoteReplacement(result));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>myBatis</category>
      </categories>
      <tags>
        <tag>myBatis</tag>
        <tag>执行流程</tag>
        <tag>mybatis插件开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring04-如何解决循环依赖</title>
    <url>/2021/06/25/Spring04-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%C2%B7/</url>
    <content><![CDATA[<p>读前猜想：</p>
<ol>
<li>什么是Spring的循环依赖</li>
<li>如何检测是否存在循环依赖</li>
<li><strong>如何解决循环依赖</strong></li>
<li>循环依赖解决要满足哪些条件</li>
<li>什么是早期bean</li>
<li>为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？</li>
</ol>
<h1 id="什么是Spring的循环依赖"><a href="#什么是Spring的循环依赖" class="headerlink" title="什么是Spring的循环依赖"></a>什么是Spring的循环依赖</h1><p>多个bean之间相互依赖，形成了一个闭环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> B b;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="如何检测是否存在循环依赖"><a href="#如何检测是否存在循环依赖" class="headerlink" title="如何检测是否存在循环依赖"></a>如何检测是否存在循环依赖</h1><p>​    检测循环依赖比较简单，使用一个列表来记录当前正在创建的bean，在每个bean创建之前，先去记录中看一下自己是否在列表中，如果存在，则说明存在循环依赖（A-&gt;B-&gt;A）,如果不在，则将其加入到列表中，待到bean创建完成，再从该列表中移除</p>
<h2 id="单例："><a href="#单例：" class="headerlink" title="单例："></a>单例：</h2><p>spring创建单例bean时候，会调用下面方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeSingletonCreation</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.inCreationCheckExclusions.contains(beanName) &amp;&amp; !<span class="hljs-keyword">this</span>.singletonsCurrentlyInCreation.add(beanName)) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    singletonsCurrentlyInCreation就是用来记录目前正在创建中的bean名称列表，<code>this.singletonsCurrentlyInCreation.add(beanName)</code>返回false，说明beanName已经在当前列表中了，此时会抛循环依赖的异常BeanCurrentlyInCreationException</p>
<h2 id="多例"><a href="#多例" class="headerlink" title="多例"></a>多例</h2><p>​    以prototype情况为例，源码位于<code>org.springframework.beans.factory.support.AbstractBeanFactory#doGetBean</code>方法中，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//检查正在创建的bean列表中是否存在beanName，如果存在，说明存在循环依赖，抛出循环依赖的异常</span><br><span class="hljs-keyword">if</span> (isPrototypeCurrentlyInCreation(beanName)) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName);<br>&#125;<br><br><span class="hljs-comment">//判断scope是否是prototype</span><br><span class="hljs-keyword">if</span> (mbd.isPrototype()) &#123;<br>    Object prototypeInstance = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-comment">//将beanName放入正在创建的列表中</span><br>        beforePrototypeCreation(beanName);<br>        prototypeInstance = createBean(beanName, mbd, args);<br>    &#125;<br>    <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//将beanName从正在创建的列表中移除</span><br>        afterPrototypeCreation(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Spring如何解决循环依赖的问题"><a href="#Spring如何解决循环依赖的问题" class="headerlink" title="Spring如何解决循环依赖的问题"></a>Spring如何解决循环依赖的问题</h1><p>有了前面创建bean的基础后我们知道</p>
<p>Spring创建bean的主要步骤</p>
<p>1、实例化Bean，及调用构造器或者工厂方法创建bean</p>
<p>2、populateBean 填充属性，注入依赖的bean，比如通过set方式、@Autowired注解的方式注入依赖的bean</p>
<p>3、初始化bean，调用初始化方法</p>
<p>从Spring Bean创建的过程来看，注入依赖的方式有两种</p>
<ol>
<li><strong>实例化bean时通过构造方法注入</strong></li>
<li><strong>填充属性时</strong></li>
</ol>
<h2 id="构造注入方式导致的循环依赖无法解决"><a href="#构造注入方式导致的循环依赖无法解决" class="headerlink" title="构造注入方式导致的循环依赖无法解决"></a>构造注入方式导致的循环依赖无法解决</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceA</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceB serviceB;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceA</span><span class="hljs-params">(ServiceB serviceB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceB = serviceB;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceB</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceA serviceA;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServiceB</span><span class="hljs-params">(ServiceA serviceA)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceA = serviceA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="属性注入方式导致的循环依赖可以解决"><a href="#属性注入方式导致的循环依赖可以解决" class="headerlink" title="属性注入方式导致的循环依赖可以解决"></a>属性注入方式导致的循环依赖可以解决</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceA</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceB serviceB;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServiceB</span><span class="hljs-params">(ServiceB serviceB)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceB = serviceB;<br>    &#125;<br>&#125;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServiceB</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ServiceA serviceA;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setServiceA</span><span class="hljs-params">(ServiceA serviceA)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.serviceA = serviceA;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><img src="/images/Spring04-%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%C2%B7/spring%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B%E5%9B%BE.svg" alt="spring循环依赖数据流程图"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">1.spring轮询准备创建2个bean：serviceA和serviceB<br>2.spring容器发现singletonObjects中没有serviceA<br>3.调用serviceA的构造器创建serviceA实例<br>4.serviceA准备注入依赖的对象，发现需要通过setServiceB注入serviceB<br>5.serviceA向spring容器查找serviceB<br>6.spring容器发现singletonObjects中没有serviceB<br>7.调用serviceB的构造器创建serviceB实例<br>8.serviceB准备注入依赖的对象，发现需要通过setServiceA注入serviceA<br>9.serviceB向spring容器查找serviceA<br>10.此时又进入步骤2了<br></code></pre></td></tr></table></figure>

<p>完整解决循环依赖的过程：</p>
<ul>
<li>1.从容器中获取serviceA</li>
<li>2.容器尝试从单例缓存中找serviceA，找不到</li>
<li>3.准备创建serviceA</li>
<li>4.调用serviceA的构造器创建serviceA，得到serviceA实例，此时serviceA还未填充属性，未进行其他任何初始化的操作</li>
<li>5.将早期的serviceA暴露出去：即将其丢到第3级缓存**<span style="background:yellow">singletonFactories</span>**中</li>
<li>6.serviceA准备填充属性，发现需要注入serviceB，然后向容器获取serviceB</li>
<li>7.容器尝试从单例缓存中找serviceB，找不到</li>
<li>8.准备创建serviceB</li>
<li>9.调用serviceB的构造器创建serviceB，得到serviceB实例，此时serviceB还未填充属性，未进行其他任何初始化的操作</li>
<li>10.<strong>将早期的serviceB暴露出去：即将其丢到第3级缓存singletonFactories中</strong></li>
<li>11.serviceB准备填充属性，发现需要注入serviceA，然后向容器获取serviceA</li>
<li>12.<strong>容器尝试从单例缓存中找serviceA，发现此时serviceA位于第3级缓存中，经过处理之后，serviceA会从第3级缓存中移除，然后会存到第2级缓存中，然后将其返回给serviceB，此时serviceA通过serviceB中的setServiceA方法被注入到serviceB中</strong></li>
<li>13.<strong>serviceB继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除</strong></li>
<li>14.serviceB将自己返回给serviceA</li>
<li>15.serviceA通过setServiceB方法将serviceB注入进去</li>
<li>16.serviceB继续执行后续的一些操作，最后完成创建工作,然后会调用addSingleton方法，将自己丢到第1级缓存中，并将自己从第2和第3级缓存中移除</li>
</ul>
<h1 id="循环依赖解决要哪些情况下无法解决"><a href="#循环依赖解决要哪些情况下无法解决" class="headerlink" title="循环依赖解决要哪些情况下无法解决"></a>循环依赖解决要哪些情况下无法解决</h1><p><strong>1、构造器注入（因为暴露早期对象是对象实例化后进行的）</strong></p>
<p><strong>2、A\B都是多例</strong></p>
<p><strong>3、A多例 B单例懒加载 且容器先获取A时(如果先获取B时可以解决循环依赖的)</strong></p>
<p>4、某些情况下使用了在类方法上使用了@async注解的类（后续再讨论）</p>
<h1 id="什么是早期bean"><a href="#什么是早期bean" class="headerlink" title="什么是早期bean"></a>什么是早期bean</h1><p>​    <strong>刚刚实例化好的bean就是早期的bean，此时bean还未进行属性填充，初始化等操作</strong></p>
<h1 id="为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？"><a href="#为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？" class="headerlink" title="为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？"></a>为什么采用三级缓存解决循环依赖？如果直接将早期bean丢到二级缓存可以么？</h1><h2 id="为什么使用三级缓存"><a href="#为什么使用三级缓存" class="headerlink" title="为什么使用三级缓存"></a>为什么使用三级缓存</h2><p>没看源码之前，有我们自己猜想，可能有一个 HashMap，缓存这我们创建的单例bean，每个创建完成后就往这个bean里放。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure>

<p>但是单单如此还解决不了问题,如以下场景</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>spring轮询准备创建<span class="hljs-number">2</span>个bean：serviceA和serviceB<br><span class="hljs-number">2.</span>spring容器发现singletonObjects中没有serviceA<br><span class="hljs-number">3.</span>调用serviceA的构造器创建serviceA实例<br><span class="hljs-number">4.</span>serviceA准备注入依赖的对象，发现需要通过setServiceB注入serviceB<br><span class="hljs-number">5.</span>serviceA向spring容器查找serviceB<br><span class="hljs-number">6.</span>spring容器发现singletonObjects中没有serviceB<br><span class="hljs-number">7.</span>调用serviceB的构造器创建serviceB实例<br><span class="hljs-number">8.</span>serviceB准备注入依赖的对象，发现需要通过setServiceA注入serviceA<br><span class="hljs-number">9.</span>serviceB向spring容器查找serviceA<br><span class="hljs-number">10.</span>此时又进入步骤<span class="hljs-number">2</span>了<br></code></pre></td></tr></table></figure>

<h2 id="猜想"><a href="#猜想" class="headerlink" title="猜想"></a>猜想</h2><p>​    既然要解决循环依赖，那么势必有一个Map可以缓存当前创建实例后的bean，以便别的bean在实例化时可以从这个map中获取对象。因此我们需要第二个Map:secondMap来帮我们保存正在创建的bean。</p>
<p>这样的话，我们猜想Spring创建Bean过程如下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>spring轮询准备创建<span class="hljs-number">2</span>个bean：serviceA和serviceB<br><span class="hljs-number">2.</span>spring容器发现<span class="hljs-number">2</span>个map中没有serviceA<br><span class="hljs-number">3.</span>调用serviceA的构造器创建serviceA实例，并且把serviceA实例添加到secondMap中<br><span class="hljs-number">4.</span>serviceA准备注入依赖的对象，发现需要通过setServiceB注入serviceB<br><span class="hljs-number">5.</span>serviceA向spring容器查找serviceB<br><span class="hljs-number">6.</span>spring容器发现<span class="hljs-number">2</span>个map中没有serviceB<br><span class="hljs-number">7.</span>调用serviceB的构造器创建serviceB实例，并且把serviceB实例添加到secondMap中<br><span class="hljs-number">8.</span>serviceB准备注入依赖的对象，发现需要通过setServiceA注入serviceA<br><span class="hljs-number">9.</span>serviceB向spring容器查找serviceA，secondMap获取到serviceA<br><span class="hljs-number">10.</span>serviceB创建成功，添加到singletonObjects中，移除secondMap对应实例<br><span class="hljs-number">10.</span>serviceA创建成功，添加到singletonObjects中，移除secondMap对应实例<br></code></pre></td></tr></table></figure>

<p>​    咋一看，这样设计也不是不行，实际上，spring中也采用类似的方式，稍微有点区别，上面使用了一个缓存，而spring内部采用了3级缓存来解决这个问题，我们一起来细看一下。</p>
<p>3级缓存对应的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** 第一级缓存：单例bean的缓存 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br><span class="hljs-comment">/** 第二级缓存：早期暴露的bean的缓存 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, Object&gt; earlySingletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);<br><span class="hljs-comment">/** 第三级缓存：单例bean工厂的缓存 */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, ObjectFactory&lt;?&gt;&gt; singletonFactories = <span class="hljs-keyword">new</span> HashMap&lt;&gt;(<span class="hljs-number">16</span>);<br></code></pre></td></tr></table></figure>

<p>因此bean从缓存角度实际的创建过程如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span>从容器中获取serviceA<br><span class="hljs-number">2.</span>容器尝试从<span class="hljs-number">3</span>个缓存中找serviceA，找不到<br><span class="hljs-number">3.</span>准备创建serviceA<br><span class="hljs-number">4.</span>调用serviceA的构造器创建serviceA，得到serviceA实例，此时serviceA还未填充属性，未进行其他任何初始化的操作<br><span class="hljs-number">5.</span>将早期的serviceA暴露出去：即将其丢到第<span class="hljs-number">3</span>级缓存singletonFactories中<br><span class="hljs-number">6.</span>serviceA准备填充属性，发现需要注入serviceB，然后向容器获取serviceB<br><span class="hljs-number">7.</span>容器尝试从<span class="hljs-number">3</span>个缓存中找serviceB，找不到<br><span class="hljs-number">8.</span>准备创建serviceB<br><span class="hljs-number">9.</span>调用serviceB的构造器创建serviceB，得到serviceB实例，此时serviceB还未填充属性，未进行其他任何初始化的操作<br><span class="hljs-number">10.</span>将早期的serviceB暴露出去：即将其丢到第<span class="hljs-number">3</span>级缓存singletonFactories中<br><span class="hljs-number">11.</span>serviceB准备填充属性，发现需要注入serviceA，然后向容器获取serviceA<br><span class="hljs-number">12.</span>容器尝试从<span class="hljs-number">3</span>个缓存中找serviceA，发现此时serviceA位于第<span class="hljs-number">3</span>级缓存中，经过处理之后，serviceA会从第<span class="hljs-number">3</span>级缓存中移除，然后会存到第<span class="hljs-number">2</span>级缓存中，然后将其返回给serviceB，此时serviceA通过serviceB中的setServiceA方法被注入到serviceB中<br><span class="hljs-number">13.</span>serviceB继续执行后续的一些操作，最后完成创建工作，然后会调用addSingleton方法，将自己丢到第<span class="hljs-number">1</span>级缓存中，并将自己从第<span class="hljs-number">2</span>和第<span class="hljs-number">3</span>级缓存中移除<br><span class="hljs-number">14.</span>serviceB将自己返回给serviceA<br><span class="hljs-number">15.</span>serviceA通过setServiceB方法将serviceB注入进去<br><span class="hljs-number">16.</span>serviceB继续执行后续的一些操作，最后完成创建工作,然后会调用addSingleton方法，将自己丢到第<span class="hljs-number">1</span>级缓存中，并将自己从第<span class="hljs-number">2</span>和第<span class="hljs-number">3</span>级缓存中移除<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取缓存</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getSingleton</span><span class="hljs-params">(String beanName, <span class="hljs-keyword">boolean</span> allowEarlyReference)</span> </span>&#123;<br>    <span class="hljs-comment">//1.先从一级缓存中找</span><br>    Object singletonObject = <span class="hljs-keyword">this</span>.singletonObjects.get(beanName);<br>    <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;<br>        <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>            <span class="hljs-comment">//2.从二级缓存中找</span><br>            singletonObject = <span class="hljs-keyword">this</span>.earlySingletonObjects.get(beanName);<br>            <span class="hljs-keyword">if</span> (singletonObject == <span class="hljs-keyword">null</span> &amp;&amp; allowEarlyReference) &#123;<br>                <span class="hljs-comment">//3.二级缓存中没找到 &amp;&amp; allowEarlyReference为true的情况下,从三级缓存中找</span><br>                ObjectFactory&lt;?&gt; singletonFactory = <span class="hljs-keyword">this</span>.singletonFactories.get(beanName);<br>                <span class="hljs-keyword">if</span> (singletonFactory != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">//三级缓存返回的是一个工厂，通过工厂来获取创建bean</span><br>                    singletonObject = singletonFactory.getObject();<br>                    <span class="hljs-comment">//将创建好的bean丢到二级缓存中</span><br>                    <span class="hljs-keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);<br>                    <span class="hljs-comment">//从三级缓存移除</span><br>                    <span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> singletonObject;<br>&#125;<br><span class="hljs-comment">//创建完成后，添加到缓存中</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addSingleton</span><span class="hljs-params">(String beanName, Object singletonObject)</span> </span>&#123;<br>    <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.singletonObjects) &#123;<br>        <span class="hljs-comment">//将bean放入第1级缓存中</span><br>        <span class="hljs-keyword">this</span>.singletonObjects.put(beanName, singletonObject);<br>        <span class="hljs-comment">//将其从第3级缓存中移除</span><br>        <span class="hljs-keyword">this</span>.singletonFactories.remove(beanName);<br>        <span class="hljs-comment">//将其从第2级缓存中移除</span><br>        <span class="hljs-keyword">this</span>.earlySingletonObjects.remove(beanName);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="解答"><a href="#解答" class="headerlink" title="解答"></a>解答</h2><p>那回归正题，如上所述，为什么Spring要用3级缓存来解决循环依赖呢？<strong>如果只使用2级缓存，直接将刚实例化好的bean暴露给二级缓存出是否可以？</strong></p>
<p>结论：不能</p>
<p>原因：<strong>这样做是可以解决：早期暴露给其他依赖者的bean和最终暴露的bean不一致的问题。</strong></p>
<p>​    若将刚刚实例化好的bean直接丢到二级缓存中暴露出去，如果后期这个bean对象被更改了，比如可能在上面加了一些拦截器，将其包装为一个代理了，那么暴露出去的bean和最终的这个bean就不一样的，将自己暴露出去的时候是一个原始对象，而自己最终却是一个代理对象，最终会导致被暴露出去的和最终的bean不是同一个bean的，将产生意向不到的效果，而三级缓存就可以发现这个问题，会报错。</p>
<p>举例说明</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Service1 m1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Service2 service2;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setService2</span><span class="hljs-params">(Service2 service2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.service2 = service2;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Service2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">m1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Service2 m1&quot;</span>);<br>        <span class="hljs-keyword">this</span>.service1.m1();<span class="hljs-comment">//@1</span><br>    &#125;<br><br>    <span class="hljs-keyword">private</span> Service1 service1;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setService1</span><span class="hljs-params">(Service1 service1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.service1 = service1;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Service1 <span class="hljs-title">getService1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> service1;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意上面的<code>@1</code>，service2的m1方法中会调用service1的m1方法。</p>
<h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>​    在service1上面加个拦截器，要求在调用service1的任何方法之前需要先输出一行日志：”你好,service1”</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>新增一个Bean后置处理器来对service1对应的bean进行处理，将其封装为一个代理暴露出去。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.springframework.aop.MethodBeforeAdvice;<br><span class="hljs-keyword">import</span> org.springframework.aop.framework.ProxyFactory;<br><span class="hljs-keyword">import</span> org.springframework.beans.BeansException;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.config.BeanPostProcessor;<br><span class="hljs-keyword">import</span> org.springframework.lang.Nullable;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Nullable</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;service1&quot;</span>.equals(beanName)) &#123;<br>            <span class="hljs-comment">//代理创建工厂，需传入被代理的目标对象</span><br>            ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory(bean);<br>            <span class="hljs-comment">//添加一个方法前置通知，会在方法执行之前调用通知中的before方法</span><br>            proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodBeforeAdvice() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, <span class="hljs-meta">@Nullable</span> Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;你好,service1&quot;</span>);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//返回代理对象</span><br>            <span class="hljs-keyword">return</span> proxyFactory.getProxy();<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的<code>postProcessAfterInitialization</code>方法内部会在service1初始化之后调用，内部会对service1这个bean进行处理，返回一个代理对象，通过代理来访问service1的方法，访问service1中的任何方法之前，会先输出：<code>你好，service1</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value = &#123;&quot;com.study.cycledepend.thirdlevelcache&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopConfig</span> </span>&#123;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>        context.register(AopConfig.class);<br>        context.refresh();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="运行：报错了"><a href="#运行：报错了" class="headerlink" title="运行：报错了"></a>运行：报错了</h4><p>可以看出是<code>AbstractAutowireCapableBeanFactory.java:624</code>这个地方整出来的异常，将这块代码贴出来给大家看一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (earlySingletonExposure) &#123;<br>    <span class="hljs-comment">//@1</span><br>    Object earlySingletonReference = getSingleton(beanName, <span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">if</span> (earlySingletonReference != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">//@2</span><br>        <span class="hljs-keyword">if</span> (exposedObject == bean) &#123;<br>            exposedObject = earlySingletonReference;<br>        &#125;<br>        <span class="hljs-comment">//@3</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.allowRawInjectionDespiteWrapping &amp;&amp; hasDependentBean(beanName)) &#123;<br>            String[] dependentBeans = getDependentBeans(beanName);<br>            Set&lt;String&gt; actualDependentBeans = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(dependentBeans.length);<br>            <span class="hljs-keyword">for</span> (String dependentBean : dependentBeans) &#123;<br>                <span class="hljs-keyword">if</span> (!removeSingletonIfCreatedForTypeCheckOnly(dependentBean)) &#123;<br>                    actualDependentBeans.add(dependentBean);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (!actualDependentBeans.isEmpty()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanCurrentlyInCreationException(beanName,<br>                                                           <span class="hljs-string">&quot;Bean with name &#x27;&quot;</span> + beanName + <span class="hljs-string">&quot;&#x27; has been injected into other beans [&quot;</span> +<br>                                                           StringUtils.collectionToCommaDelimitedString(actualDependentBeans) +<br>                                                           <span class="hljs-string">&quot;] in its raw version as part of a circular reference, but has eventually been &quot;</span> +<br>                                                           <span class="hljs-string">&quot;wrapped. This means that said other beans do not use the final version of the &quot;</span> +<br>                                                           <span class="hljs-string">&quot;bean. This is often the result of over-eager type matching - consider using &quot;</span> +<br>                                                           <span class="hljs-string">&quot;&#x27;getBeanNamesOfType&#x27; with the &#x27;allowEagerInit&#x27; flag turned off, for example.&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们再来通过代码级别的来解释上面代码：</p>
<p>​    这段代码主要用来判断当有循环依赖的情况下，早期暴露给别人使用的bean是否和最终的bean不一样的情况下，会抛出一个异常。</p>
<p>@1：调用getSingleton(beanName, false)方法，这个方法用来从3个级别的缓存中获取bean，但是注意了，这个地方第二个参数是false，此时只会尝试从第1级和第2级缓存中获取bean，如果能够获取到，说明了什么？说明了第2级缓存中已经有这个bean了，而什么情况下第2级缓存中会有bean？说明这个bean从第3级缓存中已经被别人获取过，然后从第3级缓存移到了第2级缓存中，说明这个早期的bean被别人通过getSingleton(beanName, true)获取过</p>
<p>@2：这个地方用来判断早期暴露的bean和最终spring容器对这个bean走完创建过程之后是否还是同一个bean，上面我们的service1被代理了，所以这个地方会返回false，此时会走到<code>@3</code></p>
<p>@3：<code>allowRawInjectionDespiteWrapping</code>这个参数用来控制是否允许循环依赖的情况下，早期暴露给被人使用的bean在后期是否可以被包装，通俗点理解就是：是否允许早期给别人使用的bean和最终bean不一致的情况，这个值默认是false，表示不允许，也就是说你暴露给别人的bean和你最终的bean需要是一直的，你给别人的是1，你后面不能将其修改成2了啊，不一样了，你给我用个鸟。</p>
<p>而上面代码注入到service2中的service1是早期的service1，而最终spring容器中的service1变成一个代理对象了，早期的和最终的不一致了，而<code>allowRawInjectionDespiteWrapping</code>又是false，所以报异常了。</p>
<h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>很简单，将<code>allowRawInjectionDespiteWrapping</code>设置为true就可以了，下面改一下代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    <span class="hljs-comment">//创建一个BeanFactoryPostProcessor：BeanFactory后置处理器</span><br>    context.addBeanFactoryPostProcessor(beanFactory -&gt; &#123;<br>        <span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory) &#123;<br>            <span class="hljs-comment">//将allowRawInjectionDespiteWrapping设置为true</span><br>            ((DefaultListableBeanFactory) beanFactory).setAllowRawInjectionDespiteWrapping(<span class="hljs-keyword">true</span>);<br>        &#125;<br>    &#125;);<br>    context.register(IocConfig.class);<br>    context.refresh();<br><br>    System.out.println(<span class="hljs-string">&quot;容器初始化完毕&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上面代码中将<code>allowRawInjectionDespiteWrapping</code>设置为true了，是通过一个<code>BeanFactoryPostProcessor</code>来实现的，后面会有一篇文章来详解<code>BeanFactoryPostProcessor</code>，目前你只需要知道<code>BeanFactoryPostProcessor</code>可以在bean创建之前用来干预<code>BeanFactory</code>的创建过程，可以用来修改<code>BeanFactory</code>中的一些配置。</p>
<p>​    这样配置虽然不报错了，但是spring容器中的Service1和Service2实例中的service1仍旧不是同一个对象,那么这种情况是不是很诧异，如何解决这个问题？</p>
<p>​    既然最终service1是一个代理对象，那么你提前暴露出去的时候，注入到service2的时候，你也必须得是个代理对象啊，需要确保给别人和最终是同一个对象。</p>
<p>这个怎么整？继续看暴露早期bean的源码，注意了下面是重点：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;<br>    Object exposedObject = bean;<br>    <span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br>        <span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br>            <span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>                SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>                exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    我们可以自定义一个<code>SmartInstantiationAwareBeanPostProcessor</code>，然后在其<code>getEarlyBeanReference</code>中来创建代理不就可以了，聪明，我们来试试，将<code>MethodBeforeInterceptor</code>代码改成下面这样：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//MethodBeforeInterceptor改为实现SmartInstantiationAwareBeanPostProcessor</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MethodBeforeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartInstantiationAwareBeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;service1&quot;</span>.equals(beanName)) &#123;<br>            <span class="hljs-comment">//代理创建工厂，需传入被代理的目标对象</span><br>            ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory(bean);<br>            <span class="hljs-comment">//添加一个方法前置通知，会在方法执行之前调用通知中的before方法</span><br>            proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodBeforeAdvice() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;你好,service1&quot;</span>);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-comment">//返回代理对象</span><br>            <span class="hljs-keyword">return</span> proxyFactory.getProxy();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainClass1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);<br>        Service1 service1 = context.getBean(Service1.class);<br>        Service2 service2 = context.getBean(Service2.class);<br><br>        service1.m1();<br>        service2.m1();<br>        System.out.println(service1.equals(service2.getService1()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">你好,service1<br>Service1 m1<br>Service2 m1<br>你好,service1<br>Service1 m1<br><span class="hljs-keyword">true</span><br></code></pre></td></tr></table></figure>

<p>这样就解决问题了。</p>
<h1 id="猜想-1"><a href="#猜想-1" class="headerlink" title="猜想"></a>猜想</h1><p>1、@Async循环依赖如何解决？<br>2、SpringAOP、事务是否会导致早期暴露bean不一致？<br>3、开放性问题：为什么@EnableAsync不像AOP和事务一样实现AbstractAdvisorAutoProxyCreator（实现了SmartInstantiationAwareBeanPostProcessor）这个接口呢？异步事务按照AOP那样生效是不是就可以避免循环依赖呢？</p>
<p>1、标注了@Async注解方法的类A，在注入其他组件时B，@lazy，懒加载该类A，因此创建B时不会实时创建A，避免破坏早期bean，避免循环依赖</p>
<p>2、@EnableAspectJAutoProxy<br>-&gt; AspectJAutoProxyRegistrar<br>-&gt;AnnotationAwareAspectJAutoProxyCreator<br>-&gt;AbstractAutoProxyCreator(实现了SmartInstantiationAwareBeanPostProcessor)(可在获取早期对象时就生成代理对象)</p>
<p>@EnableAsyncProxyAsyncConfiguration<br>-&gt;AsyncAnnotationBeanPostProcessor(没有实现SmartInstantiationAwareBeanPostProcessor)<br>(在postProcessAfterInitialization这个阶段才能触发生成代理对象)</p>
<p>3、不可估量</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>循环依赖</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring06-事务源码</title>
    <url>/2021/07/10/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/</url>
    <content><![CDATA[<h1 id="事物概念解析"><a href="#事物概念解析" class="headerlink" title="事物概念解析"></a>事物概念解析</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h2><p>​    事务是逻辑上的一组执行单元，要么都执行，要么都不执行.</p>
<h2 id="事务的特性（ACID）"><a href="#事务的特性（ACID）" class="headerlink" title="事务的特性（ACID）"></a>事务的特性（ACID）</h2><p>​    <img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210711230028299.png" alt="image-20210711230028299"></p>
<p> <strong>什么是ACID</strong>  </p>
<p>   ACID是指数据库管理系统DBMS中事物所具有四个特性</p>
<ol>
<li><p>​    原子性：Automicity</p>
<p>操作不能背分割，要么都成功，要么都失败，若事务出错了，那么事务就会回滚。</p>
</li>
<li><p>​    一致性：Consistency</p>
<p>数据库一直处于一致的状态，事务开始前是一个一致状态，结束后是另一个一致状态</p>
</li>
<li><p>​    隔离性：Isolation</p>
<p>一个事务的影响在该事务提交前对其它事务是不可见的</p>
</li>
<li><p>​    持久性：Durablility</p>
<p>若事务已经提交了，那么就回在数据库中永久的保存下来</p>
</li>
</ol>
<h2 id="Spring事务三大接口介绍"><a href="#Spring事务三大接口介绍" class="headerlink" title="Spring事务三大接口介绍"></a>Spring事务三大接口介绍</h2><h3 id="PlatformTransactionManager：事务管理器"><a href="#PlatformTransactionManager：事务管理器" class="headerlink" title="PlatformTransactionManager：事务管理器"></a>PlatformTransactionManager：事务管理器</h3><p>​    Spring并不直接管理事务，而是提供了多种事务管理器 ，他们将事务管理的职责委托给Hibernate或者JTA等持久化机制所提供的相关平台框架的事务来实现。Spring事务管理器的接口是：<br>​    org.springframework.transaction.PlatformTransactionManager ，<br>​    通过这个接口，Spring为各个平台如JDBC、Hibernate等都提供了对应的事务管理器，但是具体的实现就是各个平台自己的事情了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PlatformTransactionManager</span> </span>&#123;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物状态</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function">TransactionStatus <span class="hljs-title">getTransaction</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> TransactionDefinition definition)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *事物提交</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">commit</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;<br>     <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *事物回滚</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rollback</span><span class="hljs-params">(TransactionStatus status)</span> <span class="hljs-keyword">throws</span> TransactionException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="TransactionDefinition：事物属性的定义"><a href="#TransactionDefinition：事物属性的定义" class="headerlink" title="TransactionDefinition：事物属性的定义"></a>TransactionDefinition：事物属性的定义</h3><p>​    事务定义信息（事务隔离级别、传播行为、超时、只读、回滚）</p>
<p>​    org.springframework.transaction.TransactionDefinition</p>
<p>​    TransactionDefinition接口中定义了5个方法以及一些表示事务属性的常量比如隔离级别、传播行为等等的常量。下面只是列出了TransactionDefinition接口中的方法而没有给出接口中定义的常量，该接口中的常量信息会在后面依次介绍到</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionDefinition</span> </span>&#123;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 支持当前事物，若当前没有事物就创建一个事物</span><br><span class="hljs-comment">	 * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_REQUIRED = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_SUPPORTS = <span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_MANDATORY = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *创建一个新的事务，如果当前存在事务，则把当前事务挂起</span><br><span class="hljs-comment">     **/</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  以非事务方式运行，如果当前存在事务，则把当前事务挂起</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="hljs-number">4</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 以非事务方式运行，如果当前存在事务，则抛出异常。</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_NEVER = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  表示如果当前正有一个事务在运行中，则该方法应该运行在 一个嵌套的事务中，</span><br><span class="hljs-comment">        被嵌套的事务可以独立于封装事务进行提交或者回滚(保存点)，</span><br><span class="hljs-comment">        如果封装事务不存在,行为就像 PROPAGATION_REQUIRES NEW</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-keyword">int</span> PROPAGATION_NESTED = <span class="hljs-number">6</span>;<br><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *使用后端数据库默认的隔离级别，Mysql 默认采用的 REPEATABLE_READ隔离级别 Oracle 默认采用的 READ_COMMITTED隔离级别</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_DEFAULT = -<span class="hljs-number">1</span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_READ_UNCOMMITTED = Connection.TRANSACTION_READ_UNCOMMITTED;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_READ_COMMITTED = Connection.TRANSACTION_READ_COMMITTED;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_REPEATABLE_READ = Connection.TRANSACTION_REPEATABLE_READ;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 *最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，</span><br><span class="hljs-comment">	 * 也就是说，该级别可以防止脏读、不可重复读以及幻读。但是这将严重影响程序的性能通常情况下也不会用到该级别</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> ISOLATION_SERIALIZABLE = Connection.TRANSACTION_SERIALIZABLE;<br><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *使用默认的超时时间</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-keyword">int</span> TIMEOUT_DEFAULT = -<span class="hljs-number">1</span>;<br><br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物的传播行为</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getPropagationBehavior</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物的隔离级别</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getIsolationLevel</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回事物的超时时间</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getTimeout</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *返回当前是否为只读事物</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isReadOnly</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获取事物的名称</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function">String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712001245156.png" alt="image-20210712001245156"></p>
<h3 id="TransactionStatus：事务运行状态"><a href="#TransactionStatus：事务运行状态" class="headerlink" title="TransactionStatus：事务运行状态"></a>TransactionStatus：事务运行状态</h3><p>​    TransactionStatus接口用来记录事务的状态，该接口定义了一组方法,用来获取或判断事务的相应状态信息.</p>
<p>​    PlatformTransactionManager.getTransaction(…) 方法返回一个 TransactionStatus 对象。返回的TransactionStatus 对象可能代表一个新的或已经存在的事务（如果在当前调用堆栈有一个符合条件的事物</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TransactionStatus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SavepointManager</span>, <span class="hljs-title">Flushable</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否为新事物</span><br><span class="hljs-comment">     * */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isNewTransaction</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *是否有保存点</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasSavepoint</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *设置为只回滚</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setRollbackOnly</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *是否为只回滚</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isRollbackOnly</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 *属性</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     *判断当前事物是否已经完成</span><br><span class="hljs-comment">	 */</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isCompleted</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="EnableTransactionManagement"><a href="#EnableTransactionManagement" class="headerlink" title="@EnableTransactionManagement"></a>@EnableTransactionManagement</h1><h2 id="注入了哪些组件"><a href="#注入了哪些组件" class="headerlink" title="注入了哪些组件"></a>注入了哪些组件</h2><p>​    1、注解导入了TransactionManagementConfigurationSelector</p>
<p>​    2、TransactionManagementConfigurationSelector导入了</p>
<p>​        1)AutoProxyRegistrar：导入了 InfrastructureAdvisorAutoProxyCreator</p>
<p>​        2)ProxyTransactionManagementConfiguration</p>
<p>​                BeanFactoryTransactionAttributeSourceAdvisor</p>
<p>​                TransactionAttributeSource</p>
<p>​                TransactionInterceptor</p>
<p>​                <img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712105211686.png" alt="image-20210712105211686"></p>
<p>因此,EnableTransactionManagement，主要帮我们导入了（默认）4个组件</p>
<ol>
<li>InfrastructureAdvisorAutoProxyCreator <ol>
<li>注意，如果开启了@EnableAspectJAutoProxy，则实际上使用的还是AnnotationAwareAspectJAutoProxyCreator（优先级高）</li>
<li><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712152123224.png" alt="image-20210712152123224"></li>
</ol>
</li>
<li>TransactionAttributeSource 事务属性源</li>
<li>TransactionInterceptor 事务拦截器</li>
<li>BeanFactoryTransactionAttributeSourceAdvisor 事务属性源工厂**==增强器==** </li>
</ol>
<h3 id="InfrastructureAdvisorAutoProxyCreator"><a href="#InfrastructureAdvisorAutoProxyCreator" class="headerlink" title="InfrastructureAdvisorAutoProxyCreator"></a>InfrastructureAdvisorAutoProxyCreator</h3><p>类结构图如下，发现与@EnableAspectJAutoProxy导入的：AnnotationAwareAspectJAutoProxyCreator类似</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712105627407.png" alt="image-20210712105627407"></p>
<p>结合具体源码得到流程图如下：发现结构和也和AnnotationAwareAspectJAutoProxyCreator类似</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/image-20210712110900830.png" alt="image-20210712110900830"></p>
<p>因此Spring事务注解的启动原理与AOP类似</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.svg" alt="事务源码解析"></p>
<p>Spring事务方法调用了流程</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">new</span> AnnotationConfigApplicationContext<br>refresh()<br><span class="hljs-comment">// 创建剩余的组件</span><br>finishBeanFactoryInitialization(beanFactory);<br><span class="hljs-comment">// 第一次运行时缓存所有@Aspect的增强器且 每次都寻找容器中的Advisor</span><br>AbstractAutoProxyCreator.postProcessBeforeInstantiation() <br>    shouskip()<br>    	<span class="hljs-comment">//找到符合条件的增强器</span><br>    	findEligibleAdvisors<br>    		<span class="hljs-comment">//找到候选的增强器</span><br>    		findCandidateAdvisors()<br>			<span class="hljs-comment">//从第一步中获取能用的增强器</span><br>			findAdvisorsThatCanApply()<br>				getTransactionAttributeSource()<br>                    computeTransactionAttribute()<br>    					<span class="hljs-comment">//查找@Transational注解</span><br>    					findTransactionAttribute<br>    					<span class="hljs-number">1</span>、实现类的目标方法上找<br>    					<span class="hljs-number">2</span>、实现类上找<br>    					<span class="hljs-number">3</span>、原方法上找<br>    					<span class="hljs-number">4</span>、原类上找 	<br><span class="hljs-comment">// 初始化后，判断是否存在增强器，存在则创建动态代理对象</span><br>AbstractAutoProxyCreator.postProcessAfterInitialization()<br></code></pre></td></tr></table></figure>

<h1 id="事务代码运行调用流程"><a href="#事务代码运行调用流程" class="headerlink" title="事务代码运行调用流程"></a>事务代码运行调用流程</h1><p>以下是某个事务方法执行大致过程：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//动态代理+责任链+递归 </span><br>JdkDynamicAopProxy.invoke-&gt;MethodInterceptor.invoke()<br>    -&gt;ReflectiveMethodInvocation.proceed()<br>    	-&gt;TransactionInterceptor.invoke() <br>    		-&gt;invokeWithinTransaction<br>    			<span class="hljs-comment">//获取事务属性源</span><br>    			getTransactionAttributeSource();<br>				<span class="hljs-keyword">try</span>&#123;<br>                    <span class="hljs-comment">//在事务执行</span><br>                    invocation.proceedWithInvocation();<br>                &#125;<span class="hljs-keyword">catch</span>&#123;<br>                    <span class="hljs-comment">//可回滚事务</span><br>                    completeTransactionAfterThrowing(txInfo, ex);<br>                &#125;<br>				<span class="hljs-comment">//提交事务</span><br>				commitTransactionAfterReturning(txInfo);<br>				<br><br></code></pre></td></tr></table></figure>

<p>实例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">PayService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId,<span class="hljs-keyword">double</span> money)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">updateProductStore</span><span class="hljs-params">(Integer productId)</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PayServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PayService</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> AccountInfoDao accountInfoDao;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductInfoDao productInfoDao;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-comment">//查询余额</span><br>        <span class="hljs-keyword">double</span> blance = accountInfoDao.qryBlanceByUserId(accountId);<br>        <span class="hljs-comment">//余额不足正常逻辑</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> BigDecimal(blance).compareTo(<span class="hljs-keyword">new</span> BigDecimal(money))&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>        &#125;<br>        ((PayService) AopContext.currentProxy()).updateProductStore(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//更新余额</span><br>        <span class="hljs-keyword">int</span> retVal = accountInfoDao.updateAccountBlance(accountId,money);<br>        System.out.println(<span class="hljs-number">1</span>/<span class="hljs-number">0</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional(propagation =Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateProductStore</span><span class="hljs-params">(Integer productId)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            productInfoDao.updateProductInfo(productId);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;内部异常&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.study.tx&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring-study&quot;</span>);<br>        dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext ioc = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(TxConfig.class);<br>        String[] names = ioc.getBeanDefinitionNames();<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            System.out.println(name);<br>        &#125;<br>        PayService payService = ioc.getBean(PayService.class);<br>        payService.pay(<span class="hljs-string">&quot;123456789&quot;</span>,<span class="hljs-number">10</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.study.tx&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TxConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dataSource.setPassword(<span class="hljs-string">&quot;123456&quot;</span>);<br>        dataSource.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/spring-study&quot;</span>);<br>        dataSource.setDriverClassName(<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">transactionManager</span><span class="hljs-params">(DataSource dataSource)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>如代码所示</p>
<p>​    payservice.pay()  隔离级别是 Propagation.REQUIRED,加入事务：如果不存在事务，新建事务，存在事务则加入该事务</p>
<p>​    payService.updateProductStore()  隔离级别是 Propagation.REQUIRES_NEW 新建事务：不管是否存在事务，新建一个事务</p>
<p>具体执行过程如下</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/%E4%BA%8B%E7%89%A9%E6%B5%81%E7%A8%8B%E7%AE%80%E5%9B%BE-1626104047827.svg" alt="事物流程简图"></p>
<p>穷举所有情况：</p>
<p><img src="/images/Spring06-%E4%BA%8B%E5%8A%A1%E5%8E%9F%E7%A0%81/%E4%BA%8B%E7%89%A9%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B%E5%9B%BE.svg" alt="事物代理对象调用流程图"></p>
<h1 id="事务提交后执行的原理"><a href="#事务提交后执行的原理" class="headerlink" title="事务提交后执行的原理"></a>事务提交后执行的原理</h1><p>案例代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VoidSupplier</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池execute</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(String threadPoolName, VoidSupplier supplier)</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = SpringUtil.getBean(threadPoolName, ThreadPoolTaskExecutor.class);<br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                supplier.get();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                log.error(<span class="hljs-string">&quot;Unexpected error occurred invoking thread pool execute&quot;</span>, e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionalUtil</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource MY_DATA_SOURCE;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        MY_DATA_SOURCE = dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier 执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">(VoidSupplier supplier)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            supplier.get();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//本线程跑supplier</span><br>                supplier.get();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事务提交后异步操作</span><br><span class="hljs-comment">     * 可指定线程池</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName 线程池名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier       执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncAfterCommit</span><span class="hljs-params">(String threadPoolName,VoidSupplier supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            ThreadPoolUtil.execute(threadPoolName, supplier);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">//另起一个线程跑supplier</span><br>                ThreadPoolUtil.execute(threadPoolName, supplier);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>其中关键代码TransactionalUtil.afterCommit的原理是什么，我们来一步一步分析</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 1. 如果当前线程没有开启事务，将立即进行操作</span><br><span class="hljs-comment">    * 2. 事务提交后，在当前线程执行任务操作</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> supplier 执行任务</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">(VoidSupplier supplier)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       <span class="hljs-comment">//1、判断当前线程是否开启了事务</span><br>       <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>           supplier.get();<br>           <span class="hljs-keyword">return</span>;<br>       &#125;<br><br>       TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>           <span class="hljs-comment">//2. 事务提交后，在当前线程执行任务操作</span><br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>               supplier.get();<br>           &#125;<br>       &#125;);<br>   &#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSynchronizationActive</span><span class="hljs-params">()</span> </span>&#123;<br>	<span class="hljs-keyword">return</span> (synchronizations.get() != <span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第1处标注的原理是，以payservice.pay 举例，方法开启了事务，则在执行代理对象执行时</p>
<ul>
<li>invokeWithinTransaction<ul>
<li>createTransactionIfNecessary<ul>
<li>status = tm.getTransaction(txAttr);<ul>
<li>doGetTransaction<ul>
<li>isExistingTransaction(transaction)</li>
<li>suspend(null)(挂机事务)由于不存在事务，不需要挂起当前的</li>
<li>newTransactionStatus创建一个事务状态<ul>
<li>doBegin</li>
<li>prepareSynchronization</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">prepareSynchronization</span><span class="hljs-params">(DefaultTransactionStatus status, TransactionDefinition definition)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (status.isNewSynchronization()) &#123;<br>		<span class="hljs-comment">//激活事务</span><br>		TransactionSynchronizationManager.setActualTransactionActive(status.hasTransaction());          <br>		<span class="hljs-comment">//事务隔离级别</span><br>		TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(<br>				definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT ?<br>						definition.getIsolationLevel() : <span class="hljs-keyword">null</span>);<br>		<span class="hljs-comment">//判断是否为只读</span><br>		TransactionSynchronizationManager.setCurrentTransactionReadOnly(definition.isReadOnly())	<br>		<span class="hljs-comment">//事务名称</span><br>           TransactionSynchronizationManager.setCurrentTransactionName(definition.getName());<br>		<span class="hljs-comment">//初始化同步：就是在这里初始化事务同步回调接口</span><br>		TransactionSynchronizationManager.initSynchronization();<br>	&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initSynchronization</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br>	<span class="hljs-keyword">if</span> (isSynchronizationActive()) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Cannot activate transaction synchronization - already active&quot;</span>);<br>	&#125;<br>	logger.trace(<span class="hljs-string">&quot;Initializing transaction synchronization&quot;</span>);<br>	synchronizations.set(<span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>第2处标注的原理是</p>
<p>invokeWithinTransaction</p>
<ul>
<li>createTransactionIfNecessary</li>
<li>retVal = invocation.proceedWithInvocation();</li>
<li>commitTransactionAfterReturning(txInfo); 目标方法执行成功，触发事务提交<ul>
<li>txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());<ul>
<li>processCommit(defStatus);<ul>
<li>triggerAfterCommit(status);<ul>
<li>TransactionSynchronizationUtils.triggerAfterCommit();<ul>
<li>invokeAfterCommit(TransactionSynchronizationManager.getSynchronizations());</li>
</ul>
</li>
</ul>
</li>
<li>cleanupAfterCompletion(status);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeAfterCommit</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> List&lt;TransactionSynchronization&gt; synchronizations)</span> </span>&#123;<br>	<span class="hljs-keyword">if</span> (synchronizations != <span class="hljs-keyword">null</span>) &#123;<br>		<span class="hljs-keyword">for</span> (TransactionSynchronization synchronization : synchronizations) &#123;<br>               <span class="hljs-comment">//触发执行我们手动新增的TransactionSynchronizationAdaptor的afterCommit</span><br>			synchronization.afterCommit();<br>		&#125;<br>	&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><span style="background:yellow;font-weight:bold">小坑</span>：最好不要在TransactionSynchronization.afterCommit方法里执行DML操作，如果在事务提交后抛出异常，这个时候对于</p>
<p>DataSourceTransactionManager<br>    cleanupAfterCompletion(status)  会把连接设置为自动提交，导致DML操作回滚不了（原事务已提交，afterCommit 方法报错，afterCommit 的数据操作回滚不了）</p>
<p>JPASourceTransactionManager</p>
<p>​    正常回滚</p>
<p>最佳时间：</p>
<p>​    1、尽量不在aftercommit里做事务操作</p>
<p>​    2、如果有，也是现实声明为 @Transactional(propagation =Propagation.REQUIRES_NEW)，详细看PayServiceImpl中updateProductStoreInNewTx，updateProductStore这两个方法，前者事务正常回滚，后者不行</p>
<p>​    3、在aftercommit异步执行业务</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>事务</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring07-切面的应用</title>
    <url>/2021/07/11/Spring07-%E5%88%87%E9%9D%A2%E7%9A%84%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="Spring切面应用"><a href="#Spring切面应用" class="headerlink" title="Spring切面应用"></a>Spring切面应用</h1><h2 id="切面的顺序"><a href="#切面的顺序" class="headerlink" title="切面的顺序"></a>切面的顺序</h2><p>1、事务的优先级默认是最小的，Ordered.LOWEST_PRECEDENCE = Integer.MAX_VALUE，值越小，执行目标方法时越先开始，越后结束。所以事务理论上来说是最靠近目标方法的一层切面</p>
<p>2、如果Order相同,则是按照切面字母的顺序来执行切面，@Transactional和@Cacheable，则先执行@Cacheable</p>
<h2 id="多数据源插件-后续补充"><a href="#多数据源插件-后续补充" class="headerlink" title="多数据源插件(后续补充)"></a>多数据源插件(后续补充)</h2><h2 id="分布式锁插件"><a href="#分布式锁插件" class="headerlink" title="分布式锁插件"></a>分布式锁插件</h2><p>思路：</p>
<p>1、声明一个注解</p>
<p>2、切面环绕通知切这个注解</p>
<p>3、使用redis做分布式锁</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> DistributedLock &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁过期时间 1小时</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">expireMillis</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 3600000L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁尝试时间 1分钟</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">timeoutMillis</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> 60000L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁的主key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">mainKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 锁的spEL格式Key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">String <span class="hljs-title">spelKey</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 无法获得锁时，是否跳过</span><br><span class="hljs-comment">     * true: 跳过</span><br><span class="hljs-comment">     * false: 默认报错</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">skipWhenCanNotGetLock</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-keyword">false</span></span>;<br>&#125;<br><br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistributedLockAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisDistributedLock redisDistributedLock;<br><br><br>    String COM_LOCK = <span class="hljs-string">&quot;com:lock:&quot;</span>;<br><br><br>    String COM_LOCK_FEIGN_OAUTH_TOKEN = COM_LOCK + <span class="hljs-string">&quot;token:feign_oauth:&quot;</span>;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有被<span class="hljs-doctag">@DistributedLock</span>注解的方法，使用分布式锁，限制一个时间内只有一个任务在执行</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> distributedLock</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(distributedLock)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point, DistributedLock distributedLock)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String key = generateLockKey(point, distributedLock.mainKey(), distributedLock.spelKey());<br><br>        <span class="hljs-comment">// 判断无法获得锁的时候，是否可以跳过程序</span><br>        <span class="hljs-keyword">if</span> (distributedLock.skipWhenCanNotGetLock() &amp;&amp; redisDistributedLock.isExist(key)) &#123;<br>            log.warn(<span class="hljs-string">&quot;DistributedLock 无法获得锁: &#123;&#125;, 锁已存在, 程序将跳过执行&quot;</span>, key);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> tryLock = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            tryLock = redisDistributedLock.tryLock(key, distributedLock.expireMillis(),<br>                    distributedLock.timeoutMillis());<br>            <span class="hljs-keyword">if</span> (!tryLock) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> DistributedLockConcurrentException(<span class="hljs-string">&quot;@DistributedLock获取锁失败，已有相同任务在运行&quot;</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> point.proceed();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (tryLock) &#123;<br>                redisDistributedLock.unLock(key);<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成分布式锁的key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateLockKey</span><span class="hljs-params">(ProceedingJoinPoint point, String mainKey, String spelKey)</span> </span>&#123;<br>        MethodSignature signature = AopUtil.getMethodSignature(point);<br><br>        String targrtMainKey;<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(mainKey)) &#123;<br>            String className = AopUtil.getClassName(point);<br>            String methodName = signature.getName();<br>            targrtMainKey = className + <span class="hljs-string">&quot;_&quot;</span> + methodName;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            targrtMainKey = mainKey;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(spelKey)) &#123;<br>            <span class="hljs-keyword">return</span> COM_LOCK + targrtMainKey;<br>        &#125;<br><br>        Method method = signature.getMethod();<br>        Object[] args = point.getArgs();<br>        String targetSpelKey = AopUtil.parseSpelKey(spelKey, method, args, String.class);<br><br>        <span class="hljs-keyword">return</span> COM_LOCK + targrtMainKey + <span class="hljs-string">&quot;_&quot;</span> + targetSpelKey;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RedisDistributedLock</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key           key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis  锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutMillis 获取锁最大等待时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> expireMillis, <span class="hljs-keyword">long</span> timeoutMillis)</span> </span>&#123;<br>        String macThreadId = getThreadSignature();<br>        <span class="hljs-keyword">return</span> tryLock(key, macThreadId, expireMillis, timeoutMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryLockCnt   获取锁尝试次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLockCnt</span><span class="hljs-params">(String key, <span class="hljs-meta">@Min(1)</span> <span class="hljs-keyword">int</span> tryLockCnt, <span class="hljs-keyword">long</span> expireMillis)</span> </span>&#123;<br>        String macThreadId = getThreadSignature();<br>        <span class="hljs-keyword">return</span> tryLockCnt(key, macThreadId, tryLockCnt, expireMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        String macThreadId = getThreadSignature();<br>        <span class="hljs-keyword">return</span> unLock(key, macThreadId);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 延迟释放锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireSecond expireSecond</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLockLater</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> expireSecond)</span> </span>&#123;<br>        String signature = getThreadSignature();<br>        <span class="hljs-keyword">return</span> unLockLater(key, signature, expireSecond);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 机器锁</span><br><span class="hljs-comment">     * 锁住机器的MAC地址</span><br><span class="hljs-comment">     * 只允许同一台机器执行</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁的时间，单位秒，null表示锁1天</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryMacLock</span><span class="hljs-params">(String key, <span class="hljs-keyword">long</span> expireMillis, <span class="hljs-keyword">long</span> timeoutMillis)</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> tryLock(key, mac, expireMillis, timeoutMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得机器锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryLockCnt   获取锁尝试次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryMacLockCnt</span><span class="hljs-params">(String key, <span class="hljs-meta">@Min(1)</span> <span class="hljs-keyword">int</span> tryLockCnt, <span class="hljs-keyword">long</span> expireMillis)</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> tryLockCnt(key, mac, tryLockCnt, expireMillis);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 释放机器锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key 锁的key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unMacLock</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">return</span> unLock(key, mac);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 判断锁是否存在</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isExist</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        <span class="hljs-keyword">return</span> redisTemplate.hasKey(lockKey);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁加锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(String key, String requesterId, <span class="hljs-keyword">long</span> expireMillis, <span class="hljs-keyword">long</span> timeoutMillis)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        <span class="hljs-comment">//return eadisSyncCommands.lock(lockKey, requesterId, expireMillis, timeoutMillis);</span><br>        <span class="hljs-comment">// 利用lambda表达式</span><br>        <span class="hljs-keyword">return</span> (Boolean) redisTemplate.execute(<span class="hljs-keyword">new</span> RedisCallback&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doInRedis</span><span class="hljs-params">(RedisConnection redisConnection)</span> <span class="hljs-keyword">throws</span> DataAccessException </span>&#123;<br>                <span class="hljs-keyword">long</span> expireAt = System.currentTimeMillis() + expireMillis + <span class="hljs-number">1</span>;<br>                Boolean acquire = redisConnection.setNX(lockKey.getBytes(), String.valueOf(expireAt).getBytes());<br>                <span class="hljs-keyword">if</span> (acquire) &#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-keyword">byte</span>[] value = redisConnection.get(lockKey.getBytes());<br>                    <span class="hljs-keyword">if</span> (Objects.nonNull(value) &amp;&amp; value.length &gt; <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-keyword">long</span> expireTime = Long.parseLong(<span class="hljs-keyword">new</span> String(value));<br>                        <span class="hljs-keyword">if</span> (expireTime &lt; System.currentTimeMillis()) &#123;<br>                            <span class="hljs-comment">// 如果锁已经过期</span><br>                            <span class="hljs-keyword">byte</span>[] oldValue = redisConnection.getSet(lockKey.getBytes(), String.valueOf(System.currentTimeMillis() + expireMillis + <span class="hljs-number">1</span>).getBytes());<br>                            <span class="hljs-comment">// 防止死锁</span><br>                            <span class="hljs-keyword">return</span> Long.parseLong(<span class="hljs-keyword">new</span> String(oldValue)) &lt; System.currentTimeMillis();<br>                        &#125;<br>                    &#125;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 尝试获得获得锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key          key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId  锁标识</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> tryLockCnt   尝试获取锁的次数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireMillis 锁超时时间</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLockCnt</span><span class="hljs-params">(String key, String requesterId, <span class="hljs-meta">@Min(1)</span> <span class="hljs-keyword">int</span> tryLockCnt, <span class="hljs-keyword">long</span> expireMillis)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (i &lt; tryLockCnt) &#123;<br>            <span class="hljs-keyword">boolean</span> tryLock = tryLock(key, requesterId, expireMillis, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (tryLock) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            i++;<br>            <span class="hljs-keyword">if</span> (i == tryLockCnt) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(<span class="hljs-number">100L</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                log.warn(<span class="hljs-string">&quot;获得分布式锁时，尝试睡眠失败&quot;</span>, e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁释放</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLock</span><span class="hljs-params">(String key, String requesterId)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        <span class="hljs-keyword">return</span> redisTemplate.delete(lockKey);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 分布式锁延迟释放</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> requesterId</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> expireSecond</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">unLockLater</span><span class="hljs-params">(String key, String requesterId, <span class="hljs-keyword">long</span> expireSecond)</span> </span>&#123;<br>        String lockKey = generateKey(key);<br>        Boolean expire = redisTemplate.expire(lockKey, expireSecond, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == expire ? <span class="hljs-keyword">false</span> : expire;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得线程标识</span><br><span class="hljs-comment">     * 只有线程标识相同，才能解锁</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getThreadSignature</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//String mac = ServerRunTimeUtil.getMac();</span><br>        <span class="hljs-comment">//TODO是否可重写</span><br>        String mac = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-comment">//String runtimeMxBeanName = ServerRunTimeUtil.getRuntimeMxBeanName();</span><br>        <span class="hljs-comment">//TODO 是否可重写</span><br>        String runtimeMxBeanName = <span class="hljs-string">&quot;&quot;</span>;<br>        String currentThreadId = String.valueOf(Thread.currentThread().getId());<br>        <span class="hljs-keyword">return</span> mac + <span class="hljs-string">&quot;_&quot;</span> + runtimeMxBeanName + <span class="hljs-string">&quot;_&quot;</span> + currentThreadId;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成锁的key</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">generateKey</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> key;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopUtil</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Class <span class="hljs-title">getClassFromJoinPoint</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> point.getTarget().getClass();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Method <span class="hljs-title">getMethodFromJoinPoint</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        Signature signature = point.getSignature();<br>        MethodSignature methodSignature = (MethodSignature) signature;<br>        <span class="hljs-keyword">return</span> methodSignature.getMethod();<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Object[] getMethodArgsFromJoinPoint(ProceedingJoinPoint point) &#123;<br>        <span class="hljs-keyword">return</span> point.getArgs();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得MethodSignature</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> MethodSignature <span class="hljs-title">getMethodSignature</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == point) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        Signature pointSignature = point.getSignature();<br>        <span class="hljs-keyword">if</span> (!(pointSignature <span class="hljs-keyword">instanceof</span> MethodSignature)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> (MethodSignature) pointSignature;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得Class 全路径</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">(ProceedingJoinPoint point)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == point) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Object target = point.getTarget();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == target) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        Class&lt;?&gt; aClass = target.getClass();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == aClass) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> aClass.getName();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获取spEL表达式代表的值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> key</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> args</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">parseSpelKey</span><span class="hljs-params">(String key, Method method, Object[] args, Class&lt;T&gt; clazz)</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span> (StrUtil.isEmpty(key)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//获取被拦截方法参数名列表(使用Spring支持类库)</span><br>        LocalVariableTableParameterNameDiscoverer u = <span class="hljs-keyword">new</span> LocalVariableTableParameterNameDiscoverer();<br>        String[] paraNameArr = u.getParameterNames(method);<br><br>        <span class="hljs-comment">//使用SPEL进行key的解析</span><br>        ExpressionParser parser = <span class="hljs-keyword">new</span> SpelExpressionParser();<br>        <span class="hljs-comment">//SPEL上下文</span><br>        StandardEvaluationContext context = <span class="hljs-keyword">new</span> StandardEvaluationContext();<br>        <span class="hljs-comment">//把方法参数放入SPEL上下文中</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paraNameArr.length; i++) &#123;<br>            context.setVariable(paraNameArr[i], args[i]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> parser.parseExpression(key).getValue(context, clazz);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@DistributedLock(spelKey = &quot;#accountId&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-comment">//查询余额</span><br>        <span class="hljs-keyword">double</span> blance = accountInfoDao.qryBlanceByUserId(accountId);<br>        <span class="hljs-comment">//余额不足正常逻辑</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> BigDecimal(blance).compareTo(<span class="hljs-keyword">new</span> BigDecimal(money))&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>        &#125;<br><br><span class="hljs-comment">//        TransactionalUtil.afterCommit(() -&gt; &#123;</span><br><span class="hljs-comment">//            ((PayService) AopContext.currentProxy()).updateProductStore(1);</span><br><span class="hljs-comment">//        &#125;);</span><br>        <span class="hljs-comment">//更新余额</span><br>        <span class="hljs-keyword">int</span> retVal = accountInfoDao.updateAccountBlance(accountId,money);<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="异步事务插件（事务提交后执行）"><a href="#异步事务插件（事务提交后执行）" class="headerlink" title="异步事务插件（事务提交后执行）"></a>异步事务插件（事务提交后执行）</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VoidSupplier</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Gets a result.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">get</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ThreadPoolUtil</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池execute</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(String threadPoolName, VoidSupplier supplier)</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = SpringUtil.getBean(threadPoolName, ThreadPoolTaskExecutor.class);<br>        executor.execute(() -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                supplier.get();<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>                log.error(<span class="hljs-string">&quot;Unexpected error occurred invoking thread pool execute&quot;</span>, e);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransactionalUtil</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> DataSource dataSource;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> DataSource MY_DATA_SOURCE;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        MY_DATA_SOURCE = dataSource;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier 执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">(VoidSupplier supplier)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            supplier.get();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                supplier.get();<br>            &#125;<br>        &#125;);<br>    &#125;<br>    <br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 事务提交后异步操作</span><br><span class="hljs-comment">     * 可指定线程池</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> threadPoolName 线程池名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> supplier       执行任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">asyncAfterCommit</span><span class="hljs-params">(String threadPoolName,VoidSupplier supplier)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>            ThreadPoolUtil.execute(threadPoolName, supplier);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronizationAdapter() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>                ThreadPoolUtil.execute(threadPoolName, supplier);<br>            &#125;<br>        &#125;);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-meta">@Target(ElementType.METHOD)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> AsyncAfterCommit &#123;<br>    <span class="hljs-function">String <span class="hljs-title">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> DEFAULT_EXECUTOR_POOL</span>;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Order(1)</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AsyncAfterCommitAspect</span> </span>&#123;<br><br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> AsyncUncaughtExceptionHandler syncUncaughtExceptionHandler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 所有被<span class="hljs-doctag">@AsyncAfterCommit</span>注解的方法，</span><br><span class="hljs-comment">     * 标注这个注解的方法，拥有提交事务后，异步执行的功能</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> point</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> asyncAfterCommit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Around(&quot;@annotation(asyncAfterCommit)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint point, AsyncAfterCommit asyncAfterCommit)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        String value = asyncAfterCommit.value();<br>        Method method = AopUtil.getMethodFromJoinPoint(point);<br>        Class&lt;?&gt; returnType = method.getReturnType();<br><br>        <span class="hljs-comment">// 由于future模式通常需要使用get方法，而【提交事务后】异步执行，无法在方法内获得运算结果。基于此，不提供future模式</span><br>        <span class="hljs-keyword">if</span> (ListenableFuture.class.isAssignableFrom(returnType)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AsyncAfterException(<span class="hljs-string">&quot;@AsyncAfterCommit不支持ListenableFuture模式&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Future.class.isAssignableFrom(returnType)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AsyncAfterException(<span class="hljs-string">&quot;@AsyncAfterCommit不支持Future模式&quot;</span>);<br>        &#125;<br><br>        TransactionalUtil.asyncAfterCommit(value, () -&gt; &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                point.proceed();<br>            &#125; <span class="hljs-keyword">catch</span> (ExecutionException var2) &#123;<br>                handleError(var2.getCause(), method, point.getArgs());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable var3) &#123;<br>                handleError(var3, method, point.getArgs());<br>            &#125;<br>        &#125;);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleError</span><span class="hljs-params">(Throwable ex, Method method, Object... params)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            syncUncaughtExceptionHandler.handleUncaughtException(ex, method, params);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable var5) &#123;<br>            log.error(<span class="hljs-string">&quot;Exception handler for async method &#x27;&quot;</span> + method.toGenericString() + <span class="hljs-string">&quot;&#x27; threw unexpected &quot;</span> +<br>                    <span class="hljs-string">&quot;exception itself&quot;</span>, var5);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> 	<span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@DistributedLock(spelKey = &quot;#accountId&quot;)</span><br>    <span class="hljs-meta">@AsyncAfterCommit</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pay</span><span class="hljs-params">(String accountId, <span class="hljs-keyword">double</span> money)</span> </span>&#123;<br>        <span class="hljs-comment">//查询余额</span><br>        <span class="hljs-keyword">double</span> blance = accountInfoDao.qryBlanceByUserId(accountId);<br>        <span class="hljs-comment">//余额不足正常逻辑</span><br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">new</span> BigDecimal(blance).compareTo(<span class="hljs-keyword">new</span> BigDecimal(money))&lt;<span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot;余额不足&quot;</span>);<br>        &#125;<br><br><span class="hljs-comment">//        TransactionalUtil.afterCommit(() -&gt; &#123;</span><br><span class="hljs-comment">//            ((PayService) AopContext.currentProxy()).updateProductStore(1);</span><br><span class="hljs-comment">//        &#125;);</span><br>        <span class="hljs-comment">//更新余额</span><br>        <span class="hljs-keyword">int</span> retVal = accountInfoDao.updateAccountBlance(accountId,money);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="定制化报错通知报警"><a href="#定制化报错通知报警" class="headerlink" title="定制化报错通知报警"></a>定制化报错通知报警</h2><p>思路：</p>
<p>1、定义一个注解BizService</p>
<p>2、声明一个切面</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BizServiceAspect</span> </span>&#123;<br><br>    <span class="hljs-comment">//切自定义注解</span><br>    <span class="hljs-meta">@Pointcut(&quot;@within(自定义注解)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bizServiceCut</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Around(&quot;bizServiceCut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doAround</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Object[] args = proceedingJoinPoint.getArgs();<br>            <span class="hljs-keyword">return</span> proceedingJoinPoint.proceed(args);<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable e) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 发布告警事件</span><br>                Class bizClazz = proceedingJoinPoint.getTarget().getClass();<br>                Object source = proceedingJoinPoint.getThis();<br>                Signature sig = proceedingJoinPoint.getSignature();<br>                <span class="hljs-keyword">if</span> (sig <span class="hljs-keyword">instanceof</span> MethodSignature) &#123;<br>                    MethodSignature targetMethod = (MethodSignature) sig;<br>                    Method bizMethod = bizClazz.getMethod(targetMethod.getName(), targetMethod.getParameterTypes());<br>                    AppContext.publishEvent(<span class="hljs-keyword">new</span> BizAlertEvent(source, bizClazz, bizMethod, getLogTranceId(), e));<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e1) &#123;<br>                log.warn(<span class="hljs-string">&quot;告警事件发布失败:&quot;</span>, e1);<br>            &#125;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">getLogTranceId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> MDC.get(Constant.LOG_TRACE_ID);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="接口出入参日志打印"><a href="#接口出入参日志打印" class="headerlink" title="接口出入参日志打印"></a>接口出入参日志打印</h2><h3 id="利用切面的方式："><a href="#利用切面的方式：" class="headerlink" title="利用切面的方式："></a>利用切面的方式：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebLogAspect</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> Logger logger = LoggerFactory.getLogger(WebLogAspect.class);    <br>    <span class="hljs-comment">/** 以 controller 包下定义的所有请求为切入点 */</span>    <br>    <span class="hljs-meta">@Pointcut(&quot;execution(public * com.ruankao.controller..*.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">webLog</span><span class="hljs-params">()</span> </span>&#123;&#125;    <br>    <span class="hljs-comment">/**    </span><br><span class="hljs-comment">     * 在切点之前织入    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> joinPoint    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable    </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-meta">@Before(&quot;webLog()&quot;)</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span></span>&#123;<br>        <span class="hljs-comment">// 开始打印请求日志    </span><br>        ServletRequestAttributes attributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();    <br>        HttpServletRequest request = attributes.getRequest();    <br>        <span class="hljs-comment">// 打印请求相关参数    </span><br>        logger.info(<span class="hljs-string">&quot;========================================== Start ==========================================&quot;</span>);    <br>        <span class="hljs-comment">// 打印请求 url    </span><br>        logger.info(<span class="hljs-string">&quot;URL            : &#123;&#125;&quot;</span>, request.getRequestURL().toString());    <br>        <span class="hljs-comment">// 打印 Http method    </span><br>        logger.info(<span class="hljs-string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, request.getMethod());    <br>        <span class="hljs-comment">// 打印调用 controller 的全路径以及执行方法    </span><br>        logger.info(<span class="hljs-string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, joinPoint.getSignature().getDeclaringTypeName(), joinPoint.getSignature().getName());    <br>        <span class="hljs-comment">// 打印请求的 IP    </span><br>        logger.info(<span class="hljs-string">&quot;IP             : &#123;&#125;&quot;</span>, request.getRemoteAddr());    <br>        <span class="hljs-comment">// 打印请求入参    </span><br>        logger.info(<span class="hljs-string">&quot;Request Args   : &#123;&#125;&quot;</span>, joinPoint.getArgs());<br>    &#125;    <br>    <span class="hljs-comment">/**    </span><br><span class="hljs-comment">     * 在切点之后织入    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable    </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-meta">@After(&quot;webLog()&quot;)</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAfter</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <br>        logger.info(<span class="hljs-string">&quot;=========================================== End ===========================================&quot;</span>);    <br>        <span class="hljs-comment">// 每个请求之间空一行    </span><br>        logger.info(<span class="hljs-string">&quot;&quot;</span>);    <br>    &#125;    <br>    <span class="hljs-comment">/**    </span><br><span class="hljs-comment">     * 环绕    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> proceedingJoinPoint    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>    </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Throwable    </span><br><span class="hljs-comment">     */</span>    <br>    <span class="hljs-meta">@Around(&quot;webLog()&quot;)</span>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">doAround</span><span class="hljs-params">(ProceedingJoinPoint proceedingJoinPoint)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;    <br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();    <br>        Object result = proceedingJoinPoint.proceed();    <br>        <span class="hljs-comment">// 打印出参    </span><br>        logger.info(<span class="hljs-string">&quot;Response Args  : &#123;&#125;&quot;</span>,JSON.toJSON(result));<br>        <span class="hljs-comment">// 执行耗时    </span><br>        logger.info(<span class="hljs-string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - startTime);    <br>        <span class="hljs-keyword">return</span> result;    <br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="利用Filter的方式"><a href="#利用Filter的方式" class="headerlink" title="利用Filter的方式:"></a>利用Filter的方式:</h3><p>重新定义request response，读取内容再写入</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebFilter(filterName = &quot;logFilter&quot;, urlPatterns = &quot;/*&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LogFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br><br>    <span class="hljs-meta">@SneakyThrows</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> </span>&#123;<br>        HttpServletResponse httpServletResponse = (HttpServletResponse) servletResponse;<br>        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;<br><br>        <span class="hljs-comment">//转换成代理类</span><br>        ResponseWrapper wrapperResponse = <span class="hljs-keyword">new</span> ResponseWrapper(httpServletResponse);<br>        RequestWrapper requestWrapper = <span class="hljs-keyword">new</span> RequestWrapper(httpServletRequest);<br><br>        <span class="hljs-keyword">long</span> before = System.currentTimeMillis();<br><br>        <span class="hljs-comment">//通过ApplicationContext上下文（spring）找到RequestMappingHandlerMapping这个bean</span><br>        RequestMappingHandlerMapping handlerMapping = ApplicationContextUtil.getBean(RequestMappingHandlerMapping.class);<br>        <span class="hljs-comment">//RequestMappingHandlerMapping是对应url和处理类方法的一个类</span><br>        HandlerExecutionChain handlerChain = handlerMapping.getHandler(requestWrapper);<br>        <span class="hljs-comment">//通过处理链找到对应的HandlerMethod类</span><br>        HandlerMethod handler = (HandlerMethod) handlerChain.getHandler();<br>        <span class="hljs-comment">//HandlerMethod中有bean和method</span><br>        Object bean = handler.getBean();<span class="hljs-comment">//处理请求的类</span><br>        Method method = handler.getMethod();<span class="hljs-comment">//处理请求的方法</span><br><br>        <span class="hljs-comment">// 打印请求相关参数</span><br>        log.info(<span class="hljs-string">&quot;========================================== Start ==========================================&quot;</span>);<br>        <span class="hljs-comment">// 打印请求 url</span><br>        log.info(<span class="hljs-string">&quot;URL            : &#123;&#125;&quot;</span>, httpServletRequest.getRequestURL().toString());<br>        <span class="hljs-comment">// 打印 Http method</span><br>        log.info(<span class="hljs-string">&quot;HTTP Method    : &#123;&#125;&quot;</span>, httpServletRequest.getMethod());<br>        <span class="hljs-comment">// 打印调用 controller 的全路径以及执行方法</span><br>        log.info(<span class="hljs-string">&quot;Class Method   : &#123;&#125;.&#123;&#125;&quot;</span>, bean, method);<br>        <span class="hljs-comment">// 打印请求的 IP</span><br>        log.info(<span class="hljs-string">&quot;IP             : &#123;&#125;&quot;</span>, httpServletRequest.getRemoteAddr());<br>        <span class="hljs-comment">// 打印请求入参</span><br>        log.info(<span class="hljs-string">&quot;Request Args   : &#123;&#125;&quot;</span>, JSON.toJSON(requestWrapper.getBody()));<br><br>        log.info(<span class="hljs-string">&quot;=========================================== End ===========================================&quot;</span>);<br>        <span class="hljs-comment">// 每个请求之间空一行</span><br>        log.info(<span class="hljs-string">&quot;&quot;</span>);<br><br>        filterChain.doFilter(requestWrapper, wrapperResponse);<br>        <span class="hljs-comment">//获取返回值</span><br>        <span class="hljs-keyword">byte</span>[] content = wrapperResponse.getContent();<br>        <span class="hljs-comment">// 打印出参</span><br>        log.info(<span class="hljs-string">&quot;Response Args  : &#123;&#125;&quot;</span>, JSON.toJSON(<span class="hljs-keyword">new</span> String(content)));<br>        <span class="hljs-comment">// 执行耗时</span><br>        log.info(<span class="hljs-string">&quot;Time-Consuming : &#123;&#125; ms&quot;</span>, System.currentTimeMillis() - before);<br><br>        <span class="hljs-comment">//把返回值输出到客户端</span><br>        ServletOutputStream out = httpServletResponse.getOutputStream();<br>        out.write(content);<br>        out.flush();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ResponseWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletResponseWrapper</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ByteArrayOutputStream buffer;<br><br>    <span class="hljs-keyword">private</span> ServletOutputStream out;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ResponseWrapper</span><span class="hljs-params">(HttpServletResponse httpServletResponse)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(httpServletResponse);<br>        buffer = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        out = <span class="hljs-keyword">new</span> WrapperOutputStream(buffer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//Servlet容器通过调用getOutputStream()方法获得的输出流将是我们自定义的包装流WapperedOutputStream</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletOutputStream <span class="hljs-title">getOutputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> out;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flushBuffer</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (out != <span class="hljs-keyword">null</span>) &#123;<br>            out.flush();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() <span class="hljs-keyword">throws</span> IOException &#123;<br>        flushBuffer();<br>        <span class="hljs-keyword">return</span> buffer.toByteArray();<br>    &#125;<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WrapperOutputStream</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServletOutputStream</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> ByteArrayOutputStream bos;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WrapperOutputStream</span><span class="hljs-params">(ByteArrayOutputStream bos)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.bos = bos;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-keyword">int</span> b)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            bos.write(b);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReady</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWriteListener</span><span class="hljs-params">(WriteListener arg0)</span> </span>&#123;<br><br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestWrapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServletRequestWrapper</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String body;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestWrapper</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(request);<br>        StringBuilder stringBuilder = <span class="hljs-keyword">new</span> StringBuilder();<br>        BufferedReader bufferedReader = <span class="hljs-keyword">null</span>;<br>        InputStream inputStream = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            inputStream = request.getInputStream();<br>            <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;<br>                bufferedReader = <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(inputStream));<br>                <span class="hljs-keyword">char</span>[] charBuffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">char</span>[<span class="hljs-number">128</span>];<br>                <span class="hljs-keyword">int</span> bytesRead = -<span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span> ((bytesRead = bufferedReader.read(charBuffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>                    stringBuilder.append(charBuffer, <span class="hljs-number">0</span>, bytesRead);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                stringBuilder.append(<span class="hljs-string">&quot;&quot;</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (inputStream != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    inputStream.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bufferedReader != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    bufferedReader.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>        body = stringBuilder.toString();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletInputStream <span class="hljs-title">getInputStream</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">final</span> ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(body.getBytes());<br>        ServletInputStream servletInputStream = <span class="hljs-keyword">new</span> ServletInputStream() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isFinished</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isReady</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReadListener</span><span class="hljs-params">(ReadListener readListener)</span> </span>&#123;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>                <span class="hljs-keyword">return</span> byteArrayInputStream.read();<br>            &#125;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> servletInputStream;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BufferedReader <span class="hljs-title">getReader</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BufferedReader(<span class="hljs-keyword">new</span> InputStreamReader(<span class="hljs-keyword">this</span>.getInputStream()));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getBody</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.body;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="常见切面-Around-execution表达式"><a href="#常见切面-Around-execution表达式" class="headerlink" title="常见切面@Around execution表达式"></a>常见切面@Around execution表达式</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//@Around(&quot;@annotation(自定义注解)&quot;)//自定义注解标注在方法上的方法执行aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;@annotation(org.springframework.transaction.annotation.Transactional)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;@within(自定义注解)&quot;)//自定义注解标注在的类上；该类的所有方法（不包含子类方法）执行aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;@within(org.springframework.transaction.annotation.Transactional)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;within(包名前缀.*)&quot;)//com.aop.within包下所有类的所有的方法都会执行(不包含子包) aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;within(com.aop.test.*)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;within(包名前缀..*)&quot;)//com.aop.within包下所有的方法都会执行(包含子包)aop 方法</span><br>如：<span class="hljs-meta">@Around(&quot;within(com.aop.test..*)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;this(java类或接口)&quot;)//实现了该接口的类、继承该类、该类本身的类---的所有方法（包括不是接口定义的方法，但不包含父类的方法）都会执行aop方法</span><br>如：<span class="hljs-meta">@Around(&quot;this(com.aop.service.TestService)&quot;)</span><br><br><span class="hljs-comment">//@Around(&quot;target(java类或接口)&quot;)//实现了该接口的类、继承该类、该类本身的类---的所有方法（包括不是接口定义的方法，包含父类的方法）</span><br>如：<span class="hljs-meta">@Around(&quot;this(com.aop.service.TestService)&quot;)</span><br><br></code></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
        <tag>切面应用</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring05-AOP源码</title>
    <url>/2021/07/01/Spring05-AOP%E6%BA%90%E7%A0%81/</url>
    <content><![CDATA[<h1 id="AOP是什么"><a href="#AOP是什么" class="headerlink" title="AOP是什么"></a>AOP是什么</h1><p>​    AOP（Aspect Oriented Programming），可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。</p>
<p>​    它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>​    使用”横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，<strong>比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来</strong>。</p>
<h2 id="AOP核心概念"><a href="#AOP核心概念" class="headerlink" title="AOP核心概念"></a>AOP核心概念</h2><h3 id="横切关注点-对哪些方法进行切入"><a href="#横切关注点-对哪些方法进行切入" class="headerlink" title="横切关注点(对哪些方法进行切入)"></a>横切关注点(对哪些方法进行切入)</h3><p>对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</p>
<h3 id="切面"><a href="#切面" class="headerlink" title="切面"></a>切面</h3><p>​    （aspect,把原来糅杂在业务逻辑代码中的非业务代码抽取出来，把功能相同的放在一个类中形成一个切面）</p>
<p>类是对物体特征的抽象，切面就是对横切关注点的抽象</p>
<h3 id="连接点（joinpoint）（需要切入的点）"><a href="#连接点（joinpoint）（需要切入的点）" class="headerlink" title="连接点（joinpoint）（需要切入的点）"></a>连接点（joinpoint）（需要切入的点）</h3><p>​    被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</p>
<h3 id="切入点（pointcut）"><a href="#切入点（pointcut）" class="headerlink" title="切入点（pointcut）"></a>切入点（pointcut）</h3><p>​    对连接点进行拦截的定义</p>
<h3 id="通知（advice）"><a href="#通知（advice）" class="headerlink" title="通知（advice）"></a>通知（advice）</h3><p>​    所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置、后置、异常、最终、环绕通知五类</p>
<h3 id="目标对象"><a href="#目标对象" class="headerlink" title="目标对象"></a>目标对象</h3><p>​    代理的目标对象</p>
<h3 id="织入（weave）"><a href="#织入（weave）" class="headerlink" title="织入（weave）"></a>织入（weave）</h3><p>​    将切面应用到目标对象并导致代理对象创建的过程</p>
<h3 id="引入（introduction）"><a href="#引入（introduction）" class="headerlink" title="引入（introduction）"></a>引入（introduction）</h3><p>​    在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段</p>
<h2 id="基本案例"><a href="#基本案例" class="headerlink" title="基本案例"></a>基本案例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...div&quot;</span>);<br>        <span class="hljs-keyword">return</span> x / y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...add&quot;</span>);<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CalculateAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(public int com.study.aop.Calculator.*(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pointcut</span><span class="hljs-params">()</span></span>&#123;&#125;;<br><br>    <span class="hljs-meta">@Before(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;前置通知。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@After(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">after</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;后置通知。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterReturning(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturn</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;返回通知。。。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@AfterThrowing(&quot;pointcut()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">()</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;异常通知。。。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-meta">@ComponentScan(basePackages = &#123;&quot;com.study.aop&quot;&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AopMain</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AopConfig.class);<br>        Calculator calculator = context.getBean(Calculator.class);<br>        <span class="hljs-keyword">int</span> add = calculator.add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>        log.info(add+<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">int</span> div = calculator.div(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>);<br>        log.info(div+<span class="hljs-string">&quot;&quot;</span>);<br><br>    &#125;<br>&#125;<br><br>-- 结果<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  CalculateAspect:<span class="hljs-number">17</span> - 前置通知。。。<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  Calculator:<span class="hljs-number">35</span> - Mycaculator...add<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  Calculator:<span class="hljs-number">39</span> - add result:<span class="hljs-number">3</span><br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  CalculateAspect:<span class="hljs-number">22</span> - 后置通知。。。<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  CalculateAspect:<span class="hljs-number">27</span> - 返回通知。。。<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  AopMain:<span class="hljs-number">13</span> - <span class="hljs-number">3</span><br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  CalculateAspect:<span class="hljs-number">17</span> - 前置通知。。。<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  Calculator:<span class="hljs-number">28</span> - Mycaculator...div<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  CalculateAspect:<span class="hljs-number">22</span> - 后置通知。。。<br><span class="hljs-number">2022</span>-09-0822:<span class="hljs-number">23</span>:<span class="hljs-number">55</span> INFO  CalculateAspect:<span class="hljs-number">32</span> - 异常通知。。。<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.ArithmeticException: / by zero<br></code></pre></td></tr></table></figure>

<h1 id="从-EnableAspectJAutoProxy说起"><a href="#从-EnableAspectJAutoProxy说起" class="headerlink" title="从@EnableAspectJAutoProxy说起"></a>从@EnableAspectJAutoProxy说起</h1><p>​    不难看出该注解为我们注入了AnnotationAwareAspectJAutoProxyCreator这个类，分析这个类的继承结构</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210701223116469.png" alt="image-20210701223116469"></p>
<p>不难发现这个类觉有BeanFactoryAware、BeanPostProcessor、InstantiationAwareBeanPostProcessor的特性，因此可以得出下图</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/aopAnnotationAwareAspectJAutoProxyCreator%E7%B1%BB%E5%85%B3%E7%B3%BB%E5%9B%BE.svg" alt="aopAnnotationAwareAspectJAutoProxyCreator类关系图"></p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210701230423945.png" alt="image-20210701230423945"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanFactory</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;<br>	<span class="hljs-keyword">super</span>.setBeanFactory(beanFactory);<br>	<span class="hljs-keyword">if</span> (!(beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory)) &#123;<br>		<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<br>				<span class="hljs-string">&quot;AdvisorAutoProxyCreator requires a ConfigurableListableBeanFactory: &quot;</span> + beanFactory);<br>	&#125;<br>	initBeanFactory((ConfigurableListableBeanFactory) beanFactory);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> </span>&#123;<br>	<span class="hljs-keyword">this</span>.advisorRetrievalHelper = <span class="hljs-keyword">new</span> BeanFactoryAdvisorRetrievalHelperAdapter(beanFactory);<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>	Object cacheKey = getCacheKey(beanClass, beanName);<br><br>	<span class="hljs-keyword">if</span> (!StringUtils.hasLength(beanName) || !<span class="hljs-keyword">this</span>.targetSourcedBeans.contains(beanName)) &#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advisedBeans.containsKey(cacheKey)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>		&#125;<br>		<span class="hljs-keyword">if</span> (isInfrastructureClass(beanClass) || shouldSkip(beanClass, beanName)) &#123;<br>			<span class="hljs-keyword">this</span>.advisedBeans.put(cacheKey, Boolean.FALSE);<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>		&#125;<br>	&#125;<br><br>	<span class="hljs-comment">// Create proxy here if we have a custom TargetSource.</span><br>	<span class="hljs-comment">// Suppresses unnecessary default instantiation of the target bean:</span><br>	<span class="hljs-comment">// The TargetSource will handle target instances in a custom fashion.</span><br>	TargetSource targetSource = getCustomTargetSource(beanClass, beanName);<br>	<span class="hljs-keyword">if</span> (targetSource != <span class="hljs-keyword">null</span>) &#123;<br>		<span class="hljs-keyword">if</span> (StringUtils.hasLength(beanName)) &#123;<br>			<span class="hljs-keyword">this</span>.targetSourcedBeans.add(beanName);<br>		&#125;<br>		Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(beanClass, beanName, targetSource);<br>		Object proxy = createProxy(beanClass, beanName, specificInterceptors, targetSource);<br>		<span class="hljs-keyword">this</span>.proxyTypes.put(cacheKey, proxy.getClass());<br>		<span class="hljs-keyword">return</span> proxy;<br>	&#125;<br><br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldSkip</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> </span>&#123;<br>	<span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Consider optimization by caching the list of the aspect names</span><br>	List&lt;Advisor&gt; candidateAdvisors = findCandidateAdvisors();<br>	<span class="hljs-keyword">for</span> (Advisor advisor : candidateAdvisors) &#123;<br>		<span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> AspectJPointcutAdvisor &amp;&amp;<br>				((AspectJPointcutAdvisor) advisor).getAspectName().equals(beanName)) &#123;<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.shouldSkip(beanClass, beanName);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>	<span class="hljs-keyword">if</span> (bean != <span class="hljs-keyword">null</span>) &#123;<br>		Object cacheKey = getCacheKey(bean.getClass(), beanName);<br>		<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.earlyProxyReferences.contains(cacheKey)) &#123;<br>			<span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>		&#125;<br>	&#125;<br>	<span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="InstantiationAwareBeanPostProcessor的作用"><a href="#InstantiationAwareBeanPostProcessor的作用" class="headerlink" title="InstantiationAwareBeanPostProcessor的作用"></a>InstantiationAwareBeanPostProcessor的作用</h3><p>简述：postProcessBeforeInstantiation()<span style="background:yellow;font-weight:bold">加载事务和AOP的切面并放到缓存中 </span>，加载事务Advisors和AOP的切面转化为Advisors并放到缓存中</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/aop%E6%BA%90%E7%A0%81%E4%B9%8BInstantiationAwareBeanPostProcessor%E7%9A%84%E4%BD%9C%E7%94%A8.svg" alt="aop源码之InstantiationAwareBeanPostProcessor的作用"></p>
<h3 id="BeanPostProcessor的作用"><a href="#BeanPostProcessor的作用" class="headerlink" title="BeanPostProcessor的作用"></a>BeanPostProcessor的作用</h3><p>简述：postProcessAfterInitialization() 判断可以之前缓存的切面是否可以应用到类中，代理目标类</p>
<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/aop%E6%B5%81%E7%A8%8B%E4%B8%89BeanPostProceesor%E5%88%9B%E5%BB%BA%E4%BB%A3%E7%90%86%E5%AF%B9%E8%B1%A1%E6%B5%81%E7%A8%8B.svg" alt="aop流程三BeanPostProceesor创建代理对象流程"></p>
<h3 id="注解参数"><a href="#注解参数" class="headerlink" title="注解参数"></a>注解参数</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnableAspectJAutoProxy(exposeProxy = true,proxyTargetClass = true)</span><br></code></pre></td></tr></table></figure>

<h4 id="proxyTargetClass"><a href="#proxyTargetClass" class="headerlink" title="proxyTargetClass"></a>proxyTargetClass</h4><p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210704164725796.png" alt="image-20210704164725796"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">createProxy</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">			Class&lt;?&gt; beanClass, String beanName, Object[] specificInterceptors, TargetSource targetSource)</span> </span>&#123;<br>        <br>        <span class="hljs-comment">//判断容器的类型ConfigurableListableBeanFactory</span><br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory <span class="hljs-keyword">instanceof</span> ConfigurableListableBeanFactory) &#123;<br>			AutoProxyUtils.exposeTargetClass((ConfigurableListableBeanFactory) <span class="hljs-keyword">this</span>.beanFactory, beanName, beanClass);<br>		&#125;<br>        <br>        <span class="hljs-comment">//创建代理工程</span><br>		ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>		proxyFactory.copyFrom(<span class="hljs-keyword">this</span>);<br>        <br>        <br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * 默认配置下，或用户显式配置 proxy-target-class = &quot;false&quot; 时，</span><br><span class="hljs-comment">         * 这里的 proxyFactory.isProxyTargetClass() 也为 false</span><br><span class="hljs-comment">         */</span><br>		<span class="hljs-keyword">if</span> (!proxyFactory.isProxyTargetClass()) &#123;<br>			<span class="hljs-keyword">if</span> (shouldProxyTargetClass(beanClass, beanName)) &#123;<br>				proxyFactory.setProxyTargetClass(<span class="hljs-keyword">true</span>);<br>			&#125;<br>			<br>			<span class="hljs-keyword">else</span> &#123;<br>			    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                 * 检测 beanClass 是否实现了接口，若未实现，则将 </span><br><span class="hljs-comment">                 * proxyFactory 的成员变量 proxyTargetClass 设为 true</span><br><span class="hljs-comment">                 */</span><br>				evaluateProxyInterfaces(beanClass, proxyFactory);<br>			&#125;<br>		&#125;<br>        <br>        <span class="hljs-comment">//获取容器中的方法增强器</span><br>		Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);<br>		proxyFactory.addAdvisors(advisors);<br>		proxyFactory.setTargetSource(targetSource);<br>		customizeProxyFactory(proxyFactory);<br><br>		proxyFactory.setFrozen(<span class="hljs-keyword">this</span>.freezeProxy);<br>		<span class="hljs-keyword">if</span> (advisorsPreFiltered()) &#123;<br>			proxyFactory.setPreFiltered(<span class="hljs-keyword">true</span>);<br>		&#125;<br>        <br>        <span class="hljs-comment">//创建代理对象</span><br>		<span class="hljs-keyword">return</span> proxyFactory.getProxy(getProxyClassLoader());<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>&#123;<br>		<span class="hljs-keyword">return</span> createAopProxy().getProxy(classLoader);<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">            * 判断使用哪种方式生成代理类</span><br><span class="hljs-comment">            *  optimize 控制通过cglib创建的代理是否使用激进的优化策略(仅适用于CGLIB，对JDK动态代理无效)</span><br><span class="hljs-comment">            *  proxyTargetClass 是否直接代理目标类</span><br><span class="hljs-comment">            *  hasNoUserSuppliedProxyInterfaces 判断有没有用户自定义的代理接口</span><br><span class="hljs-comment">    	*/</span><br><br>		<span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>			Class&lt;?&gt; targetClass = config.getTargetClass();<br>			<span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>						<span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>			&#125;<br>			<span class="hljs-comment">//本类是否接口 注意，一般而言不会进入这个分支</span><br>			<span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>			    <span class="hljs-comment">//jdk代理</span><br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>			&#125;<br>			<span class="hljs-comment">//cglib代理</span><br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>		    jdk代理<br>			<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getProxy</span><span class="hljs-params">(ClassLoader classLoader)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>			logger.debug(<span class="hljs-string">&quot;Creating JDK dynamic proxy: target source is &quot;</span> + <span class="hljs-keyword">this</span>.advised.getTargetSource());<br>		&#125;<br>		Class&lt;?&gt;[] proxiedInterfaces = AopProxyUtils.completeProxiedInterfaces(<span class="hljs-keyword">this</span>.advised, <span class="hljs-keyword">true</span>);<br>		findDefinedEqualsAndHashCodeMethods(proxiedInterfaces);<br>		<span class="hljs-comment">//创建jdk代理对象</span><br>		<span class="hljs-keyword">return</span> Proxy.newProxyInstance(classLoader, proxiedInterfaces, <span class="hljs-keyword">this</span>);<br>	&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="exposeProxy"><a href="#exposeProxy" class="headerlink" title="exposeProxy"></a>exposeProxy</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Calculator</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">div</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...div&quot;</span>);<br>        log.info(<span class="hljs-string">&quot;div result:&#123;&#125;&quot;</span>,x / y);<br>        <span class="hljs-keyword">return</span> x / y;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x,<span class="hljs-keyword">int</span> y)</span></span>&#123;<br>        log.info(<span class="hljs-string">&quot;Mycaculator...add&quot;</span>);<br>        Calculator proxy =(Calculator) AopContext.currentProxy();<br>        proxy.div(x,y);<br><br>        log.info(<span class="hljs-string">&quot;add result:&#123;&#125;&quot;</span>,x+y);<br>        <span class="hljs-keyword">return</span> x + y;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    @EnableAspectJAutoProxy(exposeProxy = true)﻿ 这个东东是用来干什么的？没有配置exposeProxy 暴露代理对象的时候我们方法调用,我们在add方法中 通过this来调用本类的方法div()方法的时候，发现div()的方法不会被拦截,而我们配置了后exposeProxy的属性，我们发现可以通过</p>
<p>int retVal = ((Calculate) AopContext.currentProxy()).div(numA,numB);</p>
<p>​    调用的时候，发现了div()方法可以被拦截</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JdkDynamicAopProxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AopProxy</span>, <span class="hljs-title">InvocationHandler</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>	<span class="hljs-meta">@Override</span><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;	<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;<br>				<span class="hljs-comment">// Make invocation available if necessary.</span><br>				oldProxy = AopContext.setCurrentProxy(proxy);<br>				setProxyContext = <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>原理:把这个exposeProxy设置为true，会把代理对象存放在线程变量中,</strong></p>
<p> AopContext.currentProxy())是从线程变量中获取代理对象（源码中分析）</p>
<h1 id="AOP代理对象的执行流程"><a href="#AOP代理对象的执行流程" class="headerlink" title="AOP代理对象的执行流程"></a>AOP代理对象的执行流程</h1><p>调用过程简述：实际调用 Calculator.add 时，实际上调用的是代理对象的对应方法，以JDK代理为例。运用了<span style="background:yellow;font-weight:bold">责任链模式、代理模式、模板方法</span></p>
<p>JdkDynamicAopProxy#invoke</p>
<ol>
<li>进行一些列判断</li>
<li>判断是否暴露代理对象<ol>
<li>是则把本代理对象设置进入上下文</li>
</ol>
</li>
<li>获取调用方法上的拦截器链chain = getInterceptorsAndDynamicInterceptionAdvice<ol>
<li>缓存获取</li>
<li>获取代理类Advised 保存的所有advisors，遍历根据pointcut匹配该方法的advisor</li>
</ol>
</li>
<li>chain为空，则反射调用目标方法</li>
<li>chain不为空 new ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain).proceed();<ol>
<li>ExposeInvocationInterceptor.invoke(this)</li>
<li>AspectJAfterThrowingAdvice.invoke(this)</li>
<li>AfterReturnAdvice.invoke(this)</li>
<li>AspectJAfterAdvice.invoke(this)</li>
<li>AspectJmethodBeforeAdvice.invoke(this)</li>
<li>执行before方法</li>
<li>mi.proceed() 目标方法</li>
<li>执行finally，执行后置通知(after)</li>
<li>返回通知/异常通知</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>		MethodInvocation invocation;<br>		Object oldProxy = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">boolean</span> setProxyContext = <span class="hljs-keyword">false</span>;<br><br>		TargetSource targetSource = <span class="hljs-keyword">this</span>.advised.targetSource;<br>		Class&lt;?&gt; targetClass = <span class="hljs-keyword">null</span>;<br>		Object target = <span class="hljs-keyword">null</span>;<br><br>		<span class="hljs-keyword">try</span> &#123;<br>		  <br>			Object retVal;<br>            <br>            <span class="hljs-comment">//是否暴露代理对象</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.advised.exposeProxy) &#123;<br>				<span class="hljs-comment">//把代理对象添加到TheadLocal中</span><br>				oldProxy = AopContext.setCurrentProxy(proxy);<br>				setProxyContext = <span class="hljs-keyword">true</span>;<br>			&#125;<br><br>            <span class="hljs-comment">//获取被代理对象</span><br>			target = targetSource.getTarget();<br>			<span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span>) &#123;<br>			    <span class="hljs-comment">//设置被代理对象的class</span><br>				targetClass = target.getClass();<br>			&#125;<br><br>			<span class="hljs-comment">//把增强器转为方法拦截器链</span><br>			List&lt;Object&gt; chain = <span class="hljs-keyword">this</span>.advised.getInterceptorsAndDynamicInterceptionAdvice(method, targetClass);<br><br>		    <span class="hljs-comment">//若方法拦截器链为空</span><br>			<span class="hljs-keyword">if</span> (chain.isEmpty()) &#123;<br>                <span class="hljs-comment">//通过反射直接调用目标方法</span><br>				Object[] argsToUse = AopProxyUtils.adaptArgumentsIfNecessary(method, args);<br>				retVal = AopUtils.invokeJoinpointUsingReflection(target, method, argsToUse);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">//创建方法拦截器调用链条</span><br>				invocation = <span class="hljs-keyword">new</span> ReflectiveMethodInvocation(proxy, target, method, args, targetClass, chain);<br>				<span class="hljs-comment">//执行拦截器链</span><br>				retVal = invocation.proceed();<br>			&#125;<br><br>			<span class="hljs-comment">//获取方法的返回值类型</span><br>			Class&lt;?&gt; returnType = method.getReturnType();<br>			<span class="hljs-keyword">if</span> (retVal != <span class="hljs-keyword">null</span> &amp;&amp; retVal == target &amp;&amp;<br>					returnType != Object.class &amp;&amp; returnType.isInstance(proxy) &amp;&amp;<br>					!RawTargetAccess.class.isAssignableFrom(method.getDeclaringClass())) &#123;<br>				<span class="hljs-comment">//如果方法返回值为 this，即 return this; 则将代理对象 proxy 赋值给 retVal </span><br>				retVal = proxy;<br>			&#125;<br>			<span class="hljs-comment">//如果返回值类型为基础类型，比如 int，long 等，当返回值为 null，抛出异常</span><br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (retVal == <span class="hljs-keyword">null</span> &amp;&amp; returnType != Void.TYPE &amp;&amp; returnType.isPrimitive()) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopInvocationException(<br>						<span class="hljs-string">&quot;Null return value from advice does not match primitive return type for: &quot;</span> + method);<br>			&#125;<br>			<span class="hljs-keyword">return</span> retVal;<br>		&#125;<br>		<span class="hljs-keyword">finally</span> &#123;<br>			<span class="hljs-keyword">if</span> (target != <span class="hljs-keyword">null</span> &amp;&amp; !targetSource.isStatic()) &#123;<br>				<span class="hljs-comment">// Must have come from TargetSource.</span><br>				targetSource.releaseTarget(target);<br>			&#125;<br>			<span class="hljs-keyword">if</span> (setProxyContext) &#123;<br>				<span class="hljs-comment">// Restore old proxy.</span><br>				AopContext.setCurrentProxy(oldProxy);<br>			&#125;<br>		&#125;<br>	&#125;<br><br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">=====================org.springframework.aop.framework.AdvisedSupport#getInterceptorsAndDynamicInterceptionAdvice===========<br>把增强器中转为方法拦截器链<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;<br>		<span class="hljs-comment">//从缓存中获取缓存key 第一次肯定获取不到</span><br>		MethodCacheKey cacheKey = <span class="hljs-keyword">new</span> MethodCacheKey(method);<br>		<span class="hljs-comment">//通过cacheKey获取缓存值</span><br>		List&lt;Object&gt; cached = <span class="hljs-keyword">this</span>.methodCache.get(cacheKey);<br>		<br>		<span class="hljs-comment">//从缓存中没有获取到</span><br>		<span class="hljs-keyword">if</span> (cached == <span class="hljs-keyword">null</span>) &#123;<br>		    <span class="hljs-comment">//获取所有的拦截器</span><br>			cached = <span class="hljs-keyword">this</span>.advisorChainFactory.getInterceptorsAndDynamicInterceptionAdvice(<br>					<span class="hljs-keyword">this</span>, method, targetClass);<br>		    <span class="hljs-comment">//放入缓存.....</span><br>			<span class="hljs-keyword">this</span>.methodCache.put(cacheKey, cached);<br>		&#125;<br>		<span class="hljs-keyword">return</span> cached;<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">=====================org.springframework.aop.framework.AdvisorChainFactory#getInterceptorsAndDynamicInterceptionAdvice====<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Object&gt; <span class="hljs-title">getInterceptorsAndDynamicInterceptionAdvice</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">			Advised config, Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;<br><br>	    <span class="hljs-comment">//创建拦截器集合长度是增强器的长度</span><br>		List&lt;Object&gt; interceptorList = <span class="hljs-keyword">new</span> ArrayList&lt;Object&gt;(config.getAdvisors().length);<br>		<br>		Class&lt;?&gt; actualClass = (targetClass != <span class="hljs-keyword">null</span> ? targetClass : method.getDeclaringClass());<br>		<span class="hljs-keyword">boolean</span> hasIntroductions = hasMatchingIntroductions(config, actualClass);<br>		AdvisorAdapterRegistry registry = GlobalAdvisorAdapterRegistry.getInstance();<br>        <br>        <span class="hljs-comment">//遍历所有的增强器集合</span><br>		<span class="hljs-keyword">for</span> (Advisor advisor : config.getAdvisors()) &#123;<br>			<span class="hljs-comment">//判断增强器是不是PointcutAdvisor</span><br>			<span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> PointcutAdvisor) &#123;<br>				<span class="hljs-comment">//把增强器转为PointcutAdvisor</span><br>				PointcutAdvisor pointcutAdvisor = (PointcutAdvisor) advisor;<br>				<span class="hljs-comment">//通过方法匹配器对增强器进行匹配</span><br>				<span class="hljs-keyword">if</span> (config.isPreFiltered() || pointcutAdvisor.getPointcut().getClassFilter().matches(actualClass)) &#123;<br>					MethodMatcher mm = pointcutAdvisor.getPointcut().getMethodMatcher();<br>					<span class="hljs-comment">//能够匹配</span><br>					<span class="hljs-keyword">if</span> (MethodMatchers.matches(mm, method, actualClass, hasIntroductions)) &#123;<br>						<span class="hljs-comment">//把增强器转为拦截器</span><br>						MethodInterceptor[] interceptors = registry.getInterceptors(advisor);<br>						<span class="hljs-keyword">if</span> (mm.isRuntime()) &#123;<br>							<span class="hljs-comment">// Creating a new object instance in the getInterceptors() method</span><br>							<span class="hljs-comment">// isn&#x27;t a problem as we normally cache created chains.</span><br>							<span class="hljs-keyword">for</span> (MethodInterceptor interceptor : interceptors) &#123;<br>								interceptorList.add(<span class="hljs-keyword">new</span> InterceptorAndDynamicMethodMatcher(interceptor, mm));<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">else</span> &#123;<br>							interceptorList.addAll(Arrays.asList(interceptors));<br>						&#125;<br>					&#125;<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (advisor <span class="hljs-keyword">instanceof</span> IntroductionAdvisor) &#123;<br>				IntroductionAdvisor ia = (IntroductionAdvisor) advisor;<br>				<span class="hljs-keyword">if</span> (config.isPreFiltered() || ia.getClassFilter().matches(actualClass)) &#123;<br>					Interceptor[] interceptors = registry.getInterceptors(advisor);<br>					interceptorList.addAll(Arrays.asList(interceptors));<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				Interceptor[] interceptors = registry.getInterceptors(advisor);<br>				interceptorList.addAll(Arrays.asList(interceptors));<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">return</span> interceptorList;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring05-AOP%E6%BA%90%E7%A0%81/image-20210710173303233.png" alt="image-20210710173303233"></p>
<h1 id="AOP切面如何工作"><a href="#AOP切面如何工作" class="headerlink" title="AOP切面如何工作"></a>AOP切面如何工作</h1><h2 id="第一步：（AOP的概念和如何启用）"><a href="#第一步：（AOP的概念和如何启用）" class="headerlink" title="第一步：（AOP的概念和如何启用）"></a>第一步：（AOP的概念和如何启用）</h2><p>第一点:先跟他说 aop 是什么东西  vs oop<br>第二点:跟他把aop 的基本概念说清楚 ?<br>第三点:@EnableAspectJAutoProxy=====&gt; 导入了AnnotationAwareAspectJAutoProxyCreator组件<br>我们分析出AnnotationAwareAspectJAutoProxyCreator 的继承关系图发现了他具有<br>BeanPostProcessor接口特性和InstantiationAwareBeanPostProcessor的特性.<br>我们发现InstantiationAwareBeanPostProcessor 在实例化之前(调用构造方法之前)执行的.<br>创建第一个bean，根据Bean的生命周期中的createBean的环节<br>resolveBeforeInstantiation连触发我的InstantiationAwareBeanPostProcessor的的before方法.<br>此事在这个环节就会去把我们的切面信息(@Aspectj)的信息找出来 然后进行缓存.</p>
<h2 id="第二步：-创建代理对象的过程"><a href="#第二步：-创建代理对象的过程" class="headerlink" title="第二步：(创建代理对象的过程)"></a>第二步：(创建代理对象的过程)</h2><p>BeanPostProcessor .afterinItialize方法中<br>    创建要切的对象的时候,根据方法进行匹配去找自己的切面(增强器),然后把增强器和被切的对象创成一个代理对象.</p>
<h2 id="第三步-代理对象调用过程（jdk代理-，cglib代理）-proxyTragetClass来指定是否固定cglib"><a href="#第三步-代理对象调用过程（jdk代理-，cglib代理）-proxyTragetClass来指定是否固定cglib" class="headerlink" title="第三步: 代理对象调用过程（jdk代理 ，cglib代理） proxyTragetClass来指定是否固定cglib"></a>第三步: 代理对象调用过程（jdk代理 ，cglib代理） proxyTragetClass来指定是否固定cglib</h2><p>通过责任链模式+递归的来进行调用<br>先执行我们的<br>异常通知…….(catch里面执行异常通知的方法)<br>返回通知:(由于正是在这里返回通知中没有进行任何的try catch处理，，，，那么程序抛出异常 就不会执行返回通知的方法而是直接执行到异常通知了)<br>后置通知:正是因为在后置通知中,代码在finally里中 所以他才是总是被执行的……<br>前置通知:执行我们的前置通知.<br>递归终止条件满足:执行我们的目标方法:<br>1、前置方法<br>2、后置通知<br>3、返回通知/异常通知</p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>AOP</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode100-树</title>
    <url>/2024/01/21/leetcode100-%E6%A0%91/</url>
    <content><![CDATA[<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/">94. 二叉树的中序遍历</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240120175425011.png" alt="image-20240120175425011"></p>
<p><strong>二叉树的先序、中序、后序遍历</strong>是指遍历一颗二树时遍历到父节点的顺序的先后</p>
<p>1、先序：父左右</p>
<p>2、中序：左父右</p>
<p>3、后序：左右父</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A1_94</span></span>&#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">inorderTraversal1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        inOrderDfs(root);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderDfs</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        inOrderDfs(root.left);<br>        result.add(root.val);<br>        inOrderDfs(root.right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/">104. 二叉树的最大深度</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240120180330854.png" alt="image-20240120180330854"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A2_104</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(maxDepth(root.left) ,maxDepth(root.right) );<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240120180820029.png" alt="image-20240120180820029"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">invertTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> root;<br>    &#125;<br>    TreeNode left = invertTree(root.left);<br>    TreeNode right = invertTree(root.right);<br><br>    root.right = left;<br>    root.left = right;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240120181423723.png" alt="image-20240120181423723"></p>
<p>思路：定义出递归函数</p>
<p><img src="/images/leetcode100-%E6%A0%91/image-20240120182317405.png"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A4_101</span></span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> checkSymmetric(root.left,root.right);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkSymmetric</span><span class="hljs-params">(TreeNode left,TreeNode right)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == left &amp;&amp; <span class="hljs-keyword">null</span> == right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == left || <span class="hljs-keyword">null</span> == right)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> left.val == right.val &amp;&amp; checkSymmetric(left.left,right.right) &amp;&amp; checkSymmetric(left.right,right.left);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 迭代写法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isSymmetric1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == root)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-comment">//这里不能用ArrayDeque,因为ArrayDeque无法存储null</span><br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> LinkedList&lt;&gt;();<br>        queue.add(root);<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span>(queue.size() &gt; <span class="hljs-number">0</span>)&#123;<br>            TreeNode left = queue.poll();<br>            TreeNode right = queue.poll();<br>            <span class="hljs-keyword">if</span>(left == <span class="hljs-keyword">null</span> &amp;&amp; right == <span class="hljs-keyword">null</span>)&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span>((left == <span class="hljs-keyword">null</span> || right == <span class="hljs-keyword">null</span>) || left.val != right.val)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br><br>            queue.add(left.left);<br>            queue.add(right.right);<br>            <span class="hljs-keyword">if</span>(left == right)&#123;<br>                <span class="hljs-comment">//queue.add(root);做了2次，避免重复比较</span><br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            queue.add(left.right);<br>            queue.add(right.left);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121154853850.png" alt="image-20240121154853850"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Integer max = <span class="hljs-number">0</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">diameterOfBinaryTree</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       maxDepth(root);<br>       <span class="hljs-keyword">return</span> max;<br>   &#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 首先我们知道一条路径的长度为该路径经过的节点数减一，</span><br><span class="hljs-comment">    * 所以求直径（即求路径长度的最大值）等效于求路径经过节点数的最大值减一。</span><br><span class="hljs-comment">    * root直径 = root.lDept + root.rDept + 1 - 1 = root.lDept + root.rDept</span><br><span class="hljs-comment">    * root深度 = 1 + Math.max(lDept, rDept)</span><br><span class="hljs-comment">    * f(x)：查找root的最大深度的过程中(查找以root为根的最大深度)</span><br><span class="hljs-comment">    * 1、左子树的f(x.left) + f(x.righy) =  x节点的直径</span><br><span class="hljs-comment">    * 2、深度遍历过程中,计算最大的 MAX&#123;f(x.left) + f(x.righy)&#125;</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxDepth</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == root)&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       &#125;<span class="hljs-keyword">else</span>&#123;<br>           <span class="hljs-keyword">int</span> lDept = maxDepth(root.left);<br>           <span class="hljs-keyword">int</span> rDept = maxDepth(root.right);<br>           max = Math.max(max,lDept + rDept);<br>           <span class="hljs-keyword">return</span> <span class="hljs-number">1</span> + Math.max(lDept, rDept);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure>



<h2 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/">102. 二叉树的层序遍历</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121155143461.png" alt="image-20240121155143461"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A6_102</span></span>&#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用深度遍历，且传入层数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder1(TreeNode root) &#123;<br>        dfs(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node,<span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(result.size() == level)&#123;<br>            result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>        &#125;<br>        result.get(level).add(node.val);<br>        dfs(node.left,level+<span class="hljs-number">1</span>);<br>        dfs(node.right,level+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 利用队列实现宽度遍历</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; levelOrder(TreeNode root) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> n = queue.size();<br>            List&lt;Integer&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>            <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>)&#123;<br>                TreeNode node = queue.poll();<br>                data.add(node.val);<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != node.left)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != node.right)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                n--;<br>            &#125;<br>            result.add(data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/">108. 将有序数组转换为二叉搜索树</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121161141492.png" alt="image-20240121161141492"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> sortedArrayToBST(nums,<span class="hljs-number">0</span>,nums.length-<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 有序数组 = 二叉搜索树的中序遍历</span><br><span class="hljs-comment"> * 1、以nums的中点为根节点root，左右两边分别比root小和大，两边再递归这个过程得到leftResult,rightResult,</span><br><span class="hljs-comment"> * 2、root.left = leftResult,root.right = rightResult</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> begin</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> end</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">sortedArrayToBST</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> begin,<span class="hljs-keyword">int</span> end)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == nums || nums.length == <span class="hljs-number">0</span> || end - begin &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = (begin + end) / <span class="hljs-number">2</span>;<br>    TreeNode root = <span class="hljs-keyword">new</span> TreeNode(nums[mid]);<br>    <span class="hljs-comment">//可以不做判断</span><br>    <span class="hljs-keyword">if</span>(mid != begin)&#123;<br>        root.left = sortedArrayToBST(nums,begin,mid-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(mid != end)&#123;<br>        root.right = sortedArrayToBST(nums,mid+<span class="hljs-number">1</span>,end);<br>    &#125;<br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121165201253.png" alt="image-20240121165201253"></p>
<h3 id="解法一：中序-前值preVal"><a href="#解法一：中序-前值preVal" class="headerlink" title="解法一：中序+前值preVal"></a>解法一：中序+前值preVal</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> pre = Long.MIN_VALUE;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 也是利用中序遍历的原理，pre表示已经遍历的中序遍历的数组的最右值，参考方法二</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> node</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST1</span><span class="hljs-params">(TreeNode node)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(!isValidBST1(node.left) || pre &gt;= node.val)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    pre = node.val;<br>    <span class="hljs-keyword">return</span> isValidBST1(node.right);<br><br></code></pre></td></tr></table></figure>

<h3 id="解法二：中序-记录路径List"><a href="#解法二：中序-记录路径List" class="headerlink" title="解法二：中序+记录路径List"></a>解法二：中序+记录路径List</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST2</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    List&lt;Integer&gt; inorderList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    inOrderRead(root,inorderList);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorderList.size() - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span>(inorderList.get(i) &gt;= inorderList.get(i+<span class="hljs-number">1</span>))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrderRead</span><span class="hljs-params">(TreeNode root,List&lt;Integer&gt; list)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root.left != <span class="hljs-keyword">null</span>)&#123;<br>        inOrderRead(root.left,list);<br>    &#125;<br>    list.add(root.val);<br>    <span class="hljs-keyword">if</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>        inOrderRead(root.right,list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：先序遍历思维-左右边界判断"><a href="#解法三：先序遍历思维-左右边界判断" class="headerlink" title="解法三：先序遍历思维 + 左右边界判断"></a>解法三：先序遍历思维 + 左右边界判断</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归（先序遍历）</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> isValidBST(root,Long.MIN_VALUE,Long.MAX_VALUE);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValidBST</span><span class="hljs-params">(TreeNode node,<span class="hljs-keyword">long</span> lower,<span class="hljs-keyword">long</span> upper)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(node.val &lt;= lower || node.val &gt;= upper)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span>  isValidBST(node.left,lower,node.val)<br>            &amp;&amp; isValidBST(node.right,node.val,upper);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121164533955.png" alt="image-20240121164533955"></p>
<h3 id="解法一：中序遍历-count–"><a href="#解法一：中序遍历-count–" class="headerlink" title="解法一：中序遍历 + count–"></a>解法一：中序遍历 + count–</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用中序遍历</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest1</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    count = k;<br>    dfs(root);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode node)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    dfs(node.left);<br>    count--;<br>    <span class="hljs-keyword">if</span>(count == <span class="hljs-number">0</span>)&#123;<br>        result = node.val;<br>    &#125;<br>    dfs(node.right);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解法二：中序遍历 + List维护所有访问路径，result = list.get（k-1）</p>
<p>解法三：小顶堆 + 遍历第k个</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityBlockingQueue&lt;Integer&gt; queue;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 小顶推 + 任意一种遍历</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">kthSmallest2</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    queue = <span class="hljs-keyword">new</span> PriorityBlockingQueue(k);<br>    inOrder(root);<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty())&#123;<br>        k--;<br>        Integer poll = queue.poll();<br>        <span class="hljs-keyword">if</span>(k == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> poll;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inOrder</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    queue.offer(root.val);<br>    inOrder(root.left);<br>    inOrder(root.right);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121175307847.png" alt="image-20240121175307847"></p>
<p>方法一：List+记录层级+<strong>父右左</strong>遍历</p>
<p>方法二：栈+宽度优先</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A10_199</span> </span>&#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        dfs(root,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(result.size() == level)&#123;<br>            result.add(root.val);<br>        &#125;<br>        level = level + <span class="hljs-number">1</span>;<br>        dfs(root.right,level);<br>        dfs(root.left,level);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 宽度优先便利</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">rightSideView</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>        List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Queue&lt;TreeNode&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque();<br>        queue.add(root);<br>        <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>            <span class="hljs-keyword">int</span> size = queue.size();<br>            <span class="hljs-keyword">while</span> (size &gt; <span class="hljs-number">0</span>)&#123;<br>                TreeNode node = queue.poll();<br>                <span class="hljs-keyword">if</span>(node.left != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.left);<br>                &#125;<br>                <span class="hljs-keyword">if</span>(node.right != <span class="hljs-keyword">null</span>)&#123;<br>                    queue.add(node.right);<br>                &#125;<br>                size--;<br>                <span class="hljs-keyword">if</span>(size == <span class="hljs-number">0</span>)&#123;<br>                    result.add(node.val);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/">114. 二叉树展开为链表</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121215727024.png" alt="image-20240121215727024"></p>
<p>方法一：深度遍历+自定义递归，在原空间上边展开、边遍历。</p>
<p>方法二：先序遍历+List记录</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用自生定义递归</span><br><span class="hljs-comment"> * 1、将左子树插入到右子树的地方</span><br><span class="hljs-comment"> * 2、将原来的右子树接到左子树的最右边节点</span><br><span class="hljs-comment"> * 考虑新的右子树的根节点，一直重复上边的过程，直到新的右子树为 null</span><br><span class="hljs-comment"> * f(x) = &#123;</span><br><span class="hljs-comment"> *     left = x.left;</span><br><span class="hljs-comment"> *     right = x.right;</span><br><span class="hljs-comment"> *     x.left = null;</span><br><span class="hljs-comment"> *     x.right = f(left);</span><br><span class="hljs-comment"> *     x = x.right 递归到底;</span><br><span class="hljs-comment"> *     x.right = f(right)</span><br><span class="hljs-comment"> *     </span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    TreeNode left = root.left;<br>    TreeNode right = root.right;<br><br>    flatten(left);<br>    <span class="hljs-comment">//1、将左子树插入到右子树的地方</span><br>    root.right = left;<br>    root.left = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-comment">//2、将原来的右子树接到左子树的最右边节点</span><br>    <span class="hljs-keyword">while</span>(root.right != <span class="hljs-keyword">null</span>)&#123;<br>        root = root.right;<br>    &#125;<br>    flatten(right);<br>    root.right = right;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 借助List&lt;TreeNode&gt;记录先序便利节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flatten1</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    dfs(root);<br>    TreeNode dummyHead = <span class="hljs-keyword">new</span> TreeNode();<br>    TreeNode cur = dummyHead;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nodes.size(); i++) &#123;<br>        TreeNode treeNode = nodes.get(i);<br>        cur.left = <span class="hljs-keyword">null</span>;<br>        cur.right = treeNode;<br>        cur = cur.right;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    nodes.add(root);<br>    dfs(root.left);<br>    dfs(root.right);<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240121222906387.png" alt="image-20240121222906387"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder, <span class="hljs-keyword">int</span>[] inorder)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> preLength = preorder.length;<br>    Map&lt;Integer,Integer&gt; inMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; inorder.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> i1 = inorder[i];<br>        inMap.put(i1,i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> buildTree(preorder,<span class="hljs-number">0</span>,preLength-<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,inorder.length-<span class="hljs-number">1</span>,inMap);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1XXYYYY pre 根节点|左子树|右子树</span><br><span class="hljs-comment"> * XX1YYYY in  左子树|根节点|右子树</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> TreeNode <span class="hljs-title">buildTree</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] preorder,<span class="hljs-keyword">int</span> preLeft, <span class="hljs-keyword">int</span> preRight,<span class="hljs-keyword">int</span> inLeft, <span class="hljs-keyword">int</span> inRight, Map&lt;Integer, Integer&gt; inMap)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>((preLeft &gt; preRight) || (inLeft &gt; inRight))&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-comment">//先序的第一个数是父节点</span><br>    <span class="hljs-keyword">int</span> root = preorder[preLeft];<br>    TreeNode rootNode = <span class="hljs-keyword">new</span> TreeNode(root);<br>    Integer inRootIndex = inMap.get(root);<br>    <span class="hljs-comment">//inRootIndex-inLeft:左子树长度</span><br>    rootNode.left = buildTree(preorder,preLeft+<span class="hljs-number">1</span>,inRootIndex-inLeft+preLeft,inLeft,inRootIndex-<span class="hljs-number">1</span>,inMap);<br>    rootNode.right = buildTree(preorder,inRootIndex-inLeft+preLeft+<span class="hljs-number">1</span>,preRight,inRootIndex+<span class="hljs-number">1</span>,inRight,inMap);<br>    <span class="hljs-keyword">return</span> rootNode;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/">437. 路径总和 III</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240801154343785.png" alt="image-20240801154343785"></p>
<h3 id="解法一：递归-前缀和-回溯"><a href="#解法一：递归-前缀和-回溯" class="headerlink" title="解法一：递归 + 前缀和 + 回溯"></a>解法一：递归 + 前缀和 + 回溯</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Integer result = <span class="hljs-number">0</span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归 + 前缀和 + 回溯</span><br><span class="hljs-comment"> * path(x,y) = path(x)- path(y)：从根节点到x的path -  从根节点到y的path = path(x,y)</span><br><span class="hljs-comment"> * 假设 path(x,y) = target,则满足条件</span><br><span class="hljs-comment"> * 利用前缀和prefix&lt;Integer path,Integer count&gt; 来记录深度遍历过程中，从根节点到某个节点的和为path的个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetSum</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    Map&lt;Long,Integer&gt; prefixMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-comment">//存在从root到node节点的sum = target的场景</span><br>    prefixMap.put(<span class="hljs-number">0L</span>,<span class="hljs-number">1</span>);<br>    dfs(root,targetSum,<span class="hljs-number">0L</span>,prefixMap);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(TreeNode root,<span class="hljs-keyword">int</span> targetSum,<span class="hljs-keyword">long</span> curSum,Map&lt;Long,Integer&gt; prefix)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> val = root.val;<br>    curSum += val;<br>    result += prefix.getOrDefault(curSum-targetSum,<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//保存当前节点的前缀和结果</span><br>    prefix.put(curSum,prefix.getOrDefault(curSum,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//向下递归</span><br>    dfs(root.left,targetSum,curSum,prefix);<br>    dfs(root.right,targetSum,curSum,prefix);<br>    <span class="hljs-comment">//回溯</span><br>    prefix.put(curSum,prefix.getOrDefault(curSum,<span class="hljs-number">0</span>) - <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：复杂灵活递归"><a href="#解法二：复杂灵活递归" class="headerlink" title="解法二：复杂灵活递归"></a>解法二：复杂灵活递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 深度便利+递归</span><br><span class="hljs-comment"> * pathSum(root,target):root下存在路径值为target的路径个数，不要求从root开始</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> targetSum</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathSum1</span><span class="hljs-params">(TreeNode root, <span class="hljs-keyword">int</span> targetSum)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pathFirtstSum(root, (<span class="hljs-keyword">long</span>) targetSum) + pathSum1(root.left,targetSum) + pathSum1(root.right,targetSum);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * pathFirtstSum(root,target):以root为路径第一个节点到某个节点的路劲值为target的个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> rooTreeNode</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">pathFirtstSum</span><span class="hljs-params">(TreeNode rooTreeNode, Long target)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span>(rooTreeNode == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> val = rooTreeNode.val;<br>    <span class="hljs-keyword">if</span>(val ==  target)&#123;<br>        result++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result + pathFirtstSum(rooTreeNode.left,target-val) + pathFirtstSum(rooTreeNode.right,target-val);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240122224457197.png" alt="image-20240122224457197"></p>
<h3 id="解法一：利用递归-List找出p、q的路径，比对路径"><a href="#解法一：利用递归-List找出p、q的路径，比对路径" class="headerlink" title="解法一：利用递归+List找出p、q的路径，比对路径"></a>解法一：利用递归+List找出p、q的路径，比对路径</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 深度遍历+找出p，q2条节点路径，比对路径</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> q</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor2</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    List&lt;TreeNode&gt; pList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;TreeNode&gt; qList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    dfs2(root,p,pList);<br>    dfs2(root,q,qList);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pList.size() ; i++) &#123;<br>        <span class="hljs-keyword">if</span>(qList.contains(pList.get(i)))&#123;<br>            <span class="hljs-keyword">return</span> pList.get(i);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 能从root往下找到p和q</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(TreeNode root,TreeNode target,List&lt;TreeNode&gt; list)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(root == target)&#123;<br>        list.add(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfs2(root.left,target,list))&#123;<br>        list.add(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dfs2(root.right,target,list))&#123;<br>        list.add(root);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：利用特性-复杂递归"><a href="#解法二：利用特性-复杂递归" class="headerlink" title="解法二：利用特性+复杂递归"></a>解法二：利用特性+复杂递归</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> TreeNode ans;<br>	<span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归深度遍历</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> q</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TreeNode <span class="hljs-title">lowestCommonAncestor1</span><span class="hljs-params">(TreeNode root, TreeNode p, TreeNode q)</span> </span>&#123;<br>    dfs1(root,p,q);<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs1</span><span class="hljs-params">(TreeNode root,TreeNode p,TreeNode q)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(root == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">boolean</span> left = dfs1(root.left, p, q);<br>    <span class="hljs-keyword">boolean</span> right = dfs1(root.right, p, q);<br>    <span class="hljs-keyword">boolean</span> rootIsOneOfTarget = root.val == p.val || root.val == q.val;<br>    <span class="hljs-keyword">if</span>((left &amp;&amp; right) || ((left || right) &amp;&amp; rootIsOneOfTarget))&#123;<br>        <span class="hljs-comment">//1、root的左右子树分别包含p或q</span><br>        <span class="hljs-comment">//2、root的左右子树包含p或q 且 root = p或q</span><br>        ans = root;<br>    &#125;<br>    <span class="hljs-comment">//向上传</span><br>    <span class="hljs-keyword">return</span> left || right || rootIsOneOfTarget;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></h2><p><img src="/images/leetcode100-%E6%A0%91/image-20240122232612668.png" alt="image-20240122232612668"></p>
<h3 id="解法一：递归-以root为起始节点的最大路径特性"><a href="#解法一：递归-以root为起始节点的最大路径特性" class="headerlink" title="解法一：递归+以root为起始节点的最大路径特性"></a>解法一：递归+以root为起始节点的最大路径特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Integer max = Integer.MIN_VALUE;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxPathSum</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    dfsMaxPath(root);<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * f(x)以root节点为开始节点的一条路径的最大值</span><br><span class="hljs-comment"> * 1、root.val 本身</span><br><span class="hljs-comment"> * 2、root.val + f(root.left)</span><br><span class="hljs-comment"> * 3、root.val + f(root.right)</span><br><span class="hljs-comment"> * 4、取最大值</span><br><span class="hljs-comment"> * 在递归f(x)的过程中，计算</span><br><span class="hljs-comment"> * 经过root的最大路路径=Max(val+ f(root.left),val+f(root.right),val+ f(root.left)+ f(root.right))</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> root</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">dfsMaxPath</span><span class="hljs-params">(TreeNode root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == root)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> lDept = Math.max(dfsMaxPath(root.left),<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> rDept = Math.max(dfsMaxPath(root.right),<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">int</span> val = root.val;<br>    <span class="hljs-keyword">this</span>.max = Math.max(val + lDept + rDept,<span class="hljs-keyword">this</span>.max);<br>    <span class="hljs-keyword">return</span> Math.max(lDept,rDept) + val;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-Dubbo01-认识分布式</title>
    <url>/2022/06/26/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="分布式架构的发展历史与背景"><a href="#分布式架构的发展历史与背景" class="headerlink" title="分布式架构的发展历史与背景"></a>分布式架构的发展历史与背景</h1><h3 id="理解分布式架构"><a href="#理解分布式架构" class="headerlink" title="理解分布式架构"></a>理解分布式架构</h3><h2 id="软件架构的发展历史"><a href="#软件架构的发展历史" class="headerlink" title="软件架构的发展历史"></a>软件架构的发展历史</h2><p>参考：<a href="https://blog.csdn.net/fdxcg_x/article/details/115708922">https://blog.csdn.net/fdxcg_x/article/details/115708922</a></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/1320926-20200722145816632-206965628.png" alt="1320926-20200722145816632-206965628"></p>
<h3 id="单体架构"><a href="#单体架构" class="headerlink" title="单体架构"></a>单体架构</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>小项目开发快 成本低</li>
<li>架构简单</li>
<li>易于测试</li>
<li>易于部署</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>大项目模块耦合严重，不易开发，维护，沟通成本高</li>
<li>新增业务困难</li>
<li>核心业务与边缘业务混合在一块，出现问题互相影响</li>
</ul>
<h3 id="垂直架构"><a href="#垂直架构" class="headerlink" title="垂直架构"></a>垂直架构</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220628082810793.png" alt="image-20220628082810793"></p>
<p>​    根据业务把项目垂直切割成多个项目，因此这种架构称之为垂直架构。此时用于加速前端页面开发的**Web框架(MVC)**是关键</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><p>1、项目架构简单、前期开发成本低，周期短，适合小型项目</p>
<p>2、通过垂直拆分，原来的项目不至于无线扩大</p>
<p>3、不同项目可以采用不同的技术</p>
<p>4、可针对核心业务服务增加集群节点</p>
<p>1、系统拆分实现了流量切割，降低单体时的流量集中</p>
<p>2、业务拆分，可以针对不同模块优化部署迭代，互不影响</p>
<p>3、方便水平扩展、负载均衡、容错率高</p>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>1、服务之间的调用方式、接口协议不统一</p>
<p>2、服务监控不到位</p>
<p>3、服务ip和端口发生变更时，不好维护</p>
<p>4、搭建集群之后，实现负载均衡比较复杂。比如：内网负载，在迁移得时候会影响调用方的路由，导致线上故障</p>
<h3 id="分布式架构（SOA（Service-Oriented-Architecture））"><a href="#分布式架构（SOA（Service-Oriented-Architecture））" class="headerlink" title="分布式架构（SOA（Service Oriented Architecture））"></a>分布式架构（SOA（Service Oriented Architecture））</h3><p>​    “面向服务的架构，是一个架构模型或者一种设计方法，而并不是服务解决方案。其中包含多个服务， 服务之间通过相互依赖或者通过通信机制，来完成相互通信的，最终提供一系列的功能。一个服务通常以独立的形式存在与操作系统进程中。各个服务之间通过网络调用 。</p>
<p>​    跟 SOA 相提并论的还有一个 <strong>ESB</strong>（企业服务总线），简单来说ESB就是一根管道，用来连接各个服务节点。为了集成不同系统，不同协议的服务，ESB 可以简单理解为：它做了消息的转化解释和路由工作，让不同的服务互联互通；</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/20210424154249684.png" alt="img"></p>
<p><strong>SOA 所解决的核心问题</strong> </p>
<ol>
<li>系统集成：<strong>站在系统的角度，解决企业系统间的通信问题，把原先散乱、无规划的系统间的网状结构，梳理成规整、可治理的系统间星形结构</strong>，这一步往往需要引入 一些产品，比如 ESB、以及技术规范、服务管理规范；这一步解决的核心问题是【有序】</li>
<li>系统的服务化：站在功能的角度，把业务逻辑抽象成可复用、可组装的服务，通过服务的编排实现业务的快速再生。目的：<strong>把原先固有的业务功能转变为通用的业务服务，实现业务逻辑的快速复用</strong>；这一步解决的核心问题是【复用】</li>
<li>业务的服务化：<strong>站在企业的角度，把企业职能抽象成可复用、可组装的服务</strong>；把原先职能化的企业架构转变为服务化的企业架构，进一步提升企业的对外服务能力；<strong>前面两步都是从技术层面来解决系统调用、系统功能复用的问题。第三步，则是以业务驱动把一个 业务单元封装成一项服务</strong>。这一步解决的核心问题是 【高效】 </li>
</ol>
<h4 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h4><p>1、服务以接口为粒度，对调用者屏蔽接口底层细节</p>
<p>2、业务分层后架构更加清晰，业务模块化后职责单一，便于业务功能转化实现快速复用</p>
<p>3、服务间统一的通信协议</p>
<h4 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h4><p>1、服务拆分粒度把控复杂，容易造成服务模块边界不清晰</p>
<p>2、服务接口剧增，调用链路长，容易超时等</p>
<h3 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/2021042415471819.png" alt="img"></p>
<p>SOA架构的一种拓展和变种，强调去中心化、服务拆分粒度更小。</p>
<h4 id="优点-3"><a href="#优点-3" class="headerlink" title="优点"></a>优点</h4><p>1、能够被一个团队单独进行敏捷开发（开发、测试、部署、运维）实现DevOps开发运维一体化</p>
<p>2、<strong>各服务功能单一、粒度小</strong></p>
<p>3、<strong>服务间的依赖性弱、独立性强、各个服务可以独立部署</strong></p>
<h4 id="缺点-3"><a href="#缺点-3" class="headerlink" title="缺点"></a>缺点</h4><p>1、难以管理、服务边界问题</p>
<p>2、调用链路长、链路跟踪、问题定位难度较大</p>
<p>3、分布式事务问题</p>
<h2 id="分布式架构带来的问题"><a href="#分布式架构带来的问题" class="headerlink" title="分布式架构带来的问题"></a>分布式架构带来的问题</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>1、分布式事务</p>
<p>2、分布式任务</p>
<p>3、服务依赖关系复杂，调用链路长，需考虑服务降级、熔断、限流等</p>
<p>4、部署运维成本增加</p>
<p>5、不允许服务有状态</p>
<p>​    无状态服务是指对单次请求的处理，不依赖其他请求，也就是说，处理一次请求所需的全部信息，要么都包含在这个请求里，要么可以从外部获取到（比如说数据库），服务器本身不存储任何信息。</p>
<p>6、分布式会话</p>
<p>​    此仅针对应用层服务，不能将Session 存储在一个服务器上。</p>
<h3 id="改造面临的风险"><a href="#改造面临的风险" class="headerlink" title="改造面临的风险"></a>改造面临的风险</h3><p>1、新功能与旧bug需要2套代码同时维护</p>
<p>2、业务的拆分、完整性问题</p>
<p>3、团队协作方式的转变</p>
<p>4、开发人员的技能提升</p>
<p>5、系统交付部署方式的改变</p>
<p>​    些问题解决涉及业务部门及整个技术部门（开发、测试、运维）协商与工作标准的制定。业务相关问题暂不做讨论,技术架构上应该要清楚自己的职责是，如何通过技术手段把业务波动降至最低、开发成本最低、实施风险最低？</p>
<h2 id="如何选型分布式架构"><a href="#如何选型分布式架构" class="headerlink" title="如何选型分布式架构"></a>如何选型分布式架构</h2><h3 id="RPC远程调用技术"><a href="#RPC远程调用技术" class="headerlink" title="RPC远程调用技术"></a>RPC远程调用技术</h3><table>
<thead>
<tr>
<th><strong>协议</strong></th>
<th><strong>描述</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>RMI</td>
<td>JAVA 远程方法调用、使用原生二进制方式进行序列化</td>
<td>简单易用、SDK支持，提高开发效率</td>
<td>不支持跨语言，不支持负载均衡</td>
</tr>
<tr>
<td>Web Service</td>
<td>比较早系统调用解决方案 ，跨语言, 其基于WSDL 生成 SOAP 进行消息的传递。</td>
<td>SDK支持、跨语言</td>
<td>实现较重，发布繁琐</td>
</tr>
<tr>
<td>Http</td>
<td>采用http +json 实现</td>
<td>简单、轻量、跨语言</td>
<td>不支持SDK</td>
</tr>
<tr>
<td>Hessian</td>
<td>采用http +hessian 序列化实现</td>
<td>简单，轻量、sdk支持</td>
<td>不能跨语言</td>
</tr>
</tbody></table>
<h3 id="RPC调用需要解决的问题"><a href="#RPC调用需要解决的问题" class="headerlink" title="RPC调用需要解决的问题"></a>RPC调用需要解决的问题</h3><p>微服务调用中中，如何实现A-&gt;B的负载均衡、服务发现、健康监测、容错的功能呢？</p>
<p><strong>负载均衡：</strong>这么多个机器调用哪一台?</p>
<p><strong>服务发现：</strong>样发现新的服务地址呢？</p>
<p><strong>健康检测：</strong>服务关宕机或恢复后怎么办？</p>
<p><strong>容错：</strong>如果调用其中一台调用出错了怎么办？</p>
<h3 id="3种代理架构比较"><a href="#3种代理架构比较" class="headerlink" title="3种代理架构比较"></a>3种代理架构比较</h3><p>参考文档：<a href="https://blog.csdn.net/adparking/article/details/114577835">https://blog.csdn.net/adparking/article/details/114577835</a></p>
<p>1、集中式负载均衡（4层代理（F5硬件代理）+7层代理（Nginx软件代理））</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727085907484.png" alt="image-20220727085907484"></p>
<p>2、嵌入应用内部的去中心化架构（服务发现与注册 consul nacos ribbon）</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727085941776.png" alt="image-20220727085941776"></p>
<p>3、基于独立代理进程的Service Mesh（服务网格）架构</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727090005751.png" alt="image-20220727090005751"></p>
<table>
<thead>
<tr>
<th><strong>模式</strong></th>
<th><strong>优点</strong></th>
<th><strong>缺点</strong></th>
<th><strong>适应场景</strong></th>
<th><strong>案例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>集中式负载架构</td>
<td>简单集中式治理与语言无关</td>
<td>配置维护成本高多了一层IO单点问题（硬件F5+软件nginx两层负载，F5以主从HA部署，nginx则以集群多实例部署）</td>
<td>大部分公司都适用，对运维有要求</td>
<td>亿贝、携程、早期互联网公司</td>
</tr>
<tr>
<td>客户端嵌入式架构</td>
<td>无单点性能更好</td>
<td>客户端复杂语言栈要求</td>
<td>中大规模公司、语言栈统一</td>
<td>Dubbo    、Twitter finagle、Spring Cloud Ribbon</td>
</tr>
<tr>
<td>独立进程代理架构</td>
<td>无单点性能更好与语言无关</td>
<td>运维部署复杂开发联调复杂</td>
<td>中大规模公司对运维有要求</td>
<td>Smart StackService Mesh</td>
</tr>
</tbody></table>
<h3 id="RMI-远程调用架构"><a href="#RMI-远程调用架构" class="headerlink" title="RMI 远程调用架构"></a>RMI 远程调用架构</h3><p>​     Java RMI，即 远程方法调用(Remote Method Invocation)，一种用于实现远程过程调用(RPC)(Remote procedure call)的Java API， 能直接传输序列化后的Java对象和分布式垃圾收集。它的实现依赖于Java虚拟机(JVM)，因此它仅支持从一个JVM到另一个JVM的调用。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727084716917.png" alt="image-20220727084716917"></p>
<p>1、注册中心（可以是服务提供者本身）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">LocateRegistry.createRegistry(<span class="hljs-number">8080</span>);<br></code></pre></td></tr></table></figure>

<p>2、注册远程服务</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UserService hello = <span class="hljs-keyword">new</span> UserServiceImpl();<br>Naming.bind(<span class="hljs-string">&quot;rmi://localhost:8080/UserService3&quot;</span>, hello);<br></code></pre></td></tr></table></figure>

<p>3、引用远程服务，并发起调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">UserService userService = (UserService) Naming.lookup(<span class="hljs-string">&quot;rmi://localhost:8080/UserService&quot;</span>);<br>userService.getName(<span class="hljs-number">11</span>);<br></code></pre></td></tr></table></figure>

<hr>
<h3 id="Dubbo架构与设计说明"><a href="#Dubbo架构与设计说明" class="headerlink" title="Dubbo架构与设计说明"></a>Dubbo架构与设计说明</h3><h4 id="架构图"><a href="#架构图" class="headerlink" title="架构图"></a>架构图</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727085813804.png" alt="image-20220727085813804"></p>
<h4 id="流程说明"><a href="#流程说明" class="headerlink" title="流程说明"></a>流程说明</h4><ol>
<li>Provider(提供者)绑定指定端口并启动服务</li>
<li>指供者连接注册中心，并发本机IP、端口、应用信息和提供服务信息发送至注册中心存储</li>
<li>Consumer(消费者），连接注册中心 ，并发送应用信息、所求服务信息至注册中心</li>
<li>注册中心根据 消费 者所求服务信息匹配对应的提供者列表发送至Consumer 应用缓存。</li>
<li>Consumer 在发起远程调用时基于缓存的消费者列表择其一发起调用。</li>
<li>Provider 状态变更会实时通知注册中心、在由注册中心实时推送至Consumer</li>
</ol>
<p><strong>这么设计的意义：</strong></p>
<ol>
<li>Consumer 与Provider 解偶，双方都可以横向增减节点数。</li>
<li>注册中心对本身可做对等集群，可动态增减节点，并且任意一台宕掉后，将自动切换到另一台</li>
<li>去中心化，双方不直接依懒注册中心，即使注册中心全部宕机短时间内也不会影响服务的调用</li>
<li>服务提供者无状态，任意一台宕掉后，不影响使用</li>
</ol>
<h4 id="Dubbo-整体设计"><a href="#Dubbo-整体设计" class="headerlink" title="Dubbo 整体设计"></a>Dubbo 整体设计</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727090423881.png" alt="image-20220727090423881"></p>
<ul>
<li>config <strong>配置层</strong>：对外配置接口，以 ServiceConfig, ReferenceConfig 为中心，可以直接初始化配置类，也可以通过 spring 解析配置生成配置类</li>
<li>proxy <strong>服务代理层</strong>：服务接口透明代理，生成动态代理 扩展接口为 ProxyFactory</li>
<li>registry <strong>注册中心层</strong>：封装服务地址的注册与发现，以服务 URL 为中心，扩展接口为 RegistryFactory, Registry, RegistryService</li>
<li>cluster <strong>路由层</strong>：封装多个提供者的路由及负载均衡，并桥接注册中心，以 Invoker 为中心，扩展接口为 Cluster, Directory, Router, LoadBalance</li>
<li>monitor <strong>监控层</strong>：RPC 调用次数和调用时间监控，以 Statistics 为中心，扩展接口为 MonitorFactory, Monitor, MonitorService</li>
<li>protocol <strong>远程调用层</strong>：封装 RPC 调用，以 Invocation, Result 为中心，扩展接口为 Protocol, Invoker, Exporter</li>
<li>exchange <strong>信息交换层</strong>：封装请求响应模式，同步转异步，以 Request, Response 为中心，扩展接口为 Exchanger, ExchangeChannel, ExchangeClient, ExchangeServer</li>
<li>transport <strong>网络传输层</strong>：抽象 mina 和 netty 为统一接口，以 Message 为中心，扩展接口为 Channel, Transporter, Client, Server, Codec</li>
<li>serialize <strong>数据序列化层</strong>：可复用的一些工具，扩展接口为 Serialization, ObjectInput, ObjectOutput, ThreadPool</li>
</ul>
<p>协作流程如下：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727090534527.png" alt="image-20220727090534527"></p>
<h4 id="Dubbo-中的SPI机制"><a href="#Dubbo-中的SPI机制" class="headerlink" title="Dubbo 中的SPI机制"></a>Dubbo 中的SPI机制</h4><p>java的SPI:具体约定为:当服务的提供者，提供了服务接口的一种实现之后，在jar包的META-INF/services/目录里同时创建一个以服务接口命名的文件。该文件里就是实现该服务接口的具体实现类。而当外部程序装配这个模块的时候，就能通过该jar包META-INF/services/里的配置文件找到具体的实现类名，并装载实例化，完成模块的注入。 基于这样一个约定就能很好的找到服务接口的实现类，而不需要再代码里制定。jdk提供服务实现查找的一个工具类java.util.ServiceLoader</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220727091542633.png" alt="image-20220727091542633"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Iterator&lt;UserService&gt; services = ServiceLoader.load(UserService.class).iterator();<br>    UserService service = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">while</span> (services.hasNext()) &#123;<br>        service = services.next();<br>    &#125;<br>    System.out.println(service.getUser(<span class="hljs-number">111</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Dubbo的SPI机制：</strong></p>
<p>dubbo spi 目录文件</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/wps1.jpg" alt="img"> </p>
<p>dubbo spi  文件内容：</p>
<p>luban=tuling.dubbo.server.LubanFilter</p>
<p>装配自定义Filter</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/wps2.jpg" alt="img"></p>
<h4 id="配置关系图"><a href="#配置关系图" class="headerlink" title="配置关系图"></a>配置关系图</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220728220127188.png" alt="image-20220728220127188"></p>
<h3 id="Dubbo调用模块"><a href="#Dubbo调用模块" class="headerlink" title="Dubbo调用模块"></a>Dubbo调用模块</h3><p>dubbo调用模块核心功能是发起一个远程方法的调用并顺利拿到返回结果，其体系组成如下：</p>
<p><strong>透明代理：</strong>通过动态代理技术，屏蔽远程调用细节以提高编程友好性。</p>
<p><strong>负载均衡：</strong>当有多个提供者是，如何选择哪个进行调用的负载算法。</p>
<p><strong>容错机制：</strong>当服务调用失败时采取的策略</p>
<p><strong>调用方式：</strong>支持同步调用、异步调用</p>
<h4 id="透明代理："><a href="#透明代理：" class="headerlink" title="透明代理："></a>透明代理：</h4><p>参见源码：</p>
<p>com.alibaba.dubbo.config.ReferenceConfig#createProxy</p>
<p>com.alibaba.dubbo.common.bytecode.ClassGenerator</p>
<p>com.alibaba.dubbo.rpc.proxy.javassist.JavassistProxyFactory</p>
<h4 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a><strong>负载均衡</strong></h4><p>Dubbo 目前官方支持以下负载均衡策略：</p>
<ol>
<li><strong>随机</strong>(random)：按权重设置随机概率。此为默认算法.</li>
<li><strong>轮循</strong>(roundrobin):按公约后的权重设置轮循比率。</li>
<li><strong>最少活跃调用数</strong>(leastactive):相同活跃数的随机，活跃数指调用前后计数差。</li>
<li><strong>一致性Hash</strong>(consistenthash ):相同的参数总是发到同一台机器</li>
</ol>
<p>为避免热点问题，一致性哈希使用虚拟节点，增大节点数量，根据指定的参数的hash的结果分散在0-2 31-1 之间</p>
<p>​    一致性哈希（Consistent Hashing）是一种在分布式系统中用于负载均衡的技术。它的主要目标是在动态添加或删除服务器时，最小化已经存在的键-值对与服务器之间的映射关系的变化。</p>
<p>在传统的哈希表中，键通过哈希函数映射到一组固定的桶中，每个桶对应一个特定的服务器或节点。但是，在动态环境中，当节点数量发生变化时，这种静态的映射可能会导致大量的数据迁移，影响系统性能。</p>
<p>​    一致性哈希通过引入虚拟节点（Virtual Nodes）和一种特殊的哈希函数来解决这个问题。具体来说，一致性哈希将哈希空间映射到一个环上，每个服务器或节点在环上对应一个位置。虚拟节点是对实际节点的多次复制，每个节点对应多个虚拟节点，它们也均匀地分布在环上。</p>
<p>​    当需要存储或检索数据时，首先将数据的键哈希到环上的一个位置，然后沿着环顺时针查找，直到找到第一个不小于该位置的节点，这个节点就是负责处理这个键的节点。这样做的好处是，当节点被添加或删除时，只有部分数据会受到影响，大部分数据仍然映射到原来的节点上，从而减少了数据迁移的开销。</p>
<p>​    一致性哈希在构建分布式缓存、分布式数据库等系统时广泛应用，能够提高系统的可扩展性和容错性。</p>
<img src="/images/分布式-Dubbo01-认识分布式/image-20220728222535490.png" alt="image-20220728222535490" style="zoom:50%;">

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220728222812973.png" alt="image-20220728222812973"></p>
<h4 id="容错"><a href="#容错" class="headerlink" title="容错"></a>容错</h4><p>Dubbo 官方目前支持以下容错策略：</p>
<ol>
<li><strong>失败自动切换：</strong>调用失败后基于retries=“2” 属性重试其它服务器</li>
<li><strong>快速失败：</strong>快速失败，只发起一次调用，失败立即报错。</li>
<li><strong>勿略失败：</strong>失败后勿略，不抛出异常给客户端。</li>
<li><strong>失败重试：</strong>失败自动恢复，后台记录失败请求，定时重发。通常用于消息通知操作</li>
<li>**并行调用: **只要一个成功即返回，并行调用指定数量机器，可通过 forks=”2” 来设置最大并行数。</li>
<li><strong>广播调用：</strong>广播调用所有提供者，逐个调用，任意一台报错则报错 </li>
</ol>
<h4 id="异步调用"><a href="#异步调用" class="headerlink" title="异步调用"></a>异步调用</h4><p>异步调用是指发起远程调用之后获取结果的方式。</p>
<ol>
<li>同步等待结果返回（默认）</li>
<li>异步等待结果返回</li>
<li>不需要返回结果</li>
</ol>
<p>Dubbo 中关于异步等待结果返回的实现流程如下图：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/wps1-1659018752888.jpg" alt="img"> </p>
<p>消费者订阅原理</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220702122859080.png" alt="image-20220702122859080"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Dubbo01-%E8%AE%A4%E8%AF%86%E5%88%86%E5%B8%83%E5%BC%8F/image-20220702124112036.png" alt="image-20220702124112036"></p>
<h2 id="什么是Dubbo"><a href="#什么是Dubbo" class="headerlink" title="什么是Dubbo"></a>什么是Dubbo</h2><p>​    Dubbo 是一款高性能、轻量级的开源 Java RPC 框架,核心功能包含服务自动发现与注册、负载均衡、高可用容错、降级、服务监控等。让开发者像调用本地方法一样去调用远程服务，无需关注底层细节，支持SPI做可插拔配置（选择用那种底层通信协议：默认dubbo协议，REST、Hession、Http、WebService、Thrift、gRpc）</p>
]]></content>
      <categories>
        <category>Dubbo</category>
      </categories>
      <tags>
        <tag>分布式</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-MQ-02RabbitMQ高级特性和集群</title>
    <url>/2022/05/18/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="RabbitMQ高级特性和集群"><a href="#RabbitMQ高级特性和集群" class="headerlink" title="RabbitMQ高级特性和集群"></a>RabbitMQ高级特性和集群</h1><h2 id="如何保障消息的可靠性投递"><a href="#如何保障消息的可靠性投递" class="headerlink" title="如何保障消息的可靠性投递"></a>如何保障消息的可靠性投递</h2><h3 id="如何保障消息的百分百投递成功"><a href="#如何保障消息的百分百投递成功" class="headerlink" title="如何保障消息的百分百投递成功"></a>如何保障消息的百分百投递成功</h3><h4 id="什么是生产端的可靠性投递"><a href="#什么是生产端的可靠性投递" class="headerlink" title="什么是生产端的可靠性投递"></a>什么是生产端的可靠性投递</h4><p><strong>1、保障把消息成功发送出去</strong></p>
<p><strong>2、保障MQ服务成功接收到消息</strong></p>
<p><strong>3、消息发送者收到MQ服务的确认应答</strong></p>
<p><strong>4、完善的消息补偿推送机制</strong></p>
<h3 id="方案一：同步落消息表-定时补偿-人工补偿"><a href="#方案一：同步落消息表-定时补偿-人工补偿" class="headerlink" title="方案一：同步落消息表 + 定时补偿 + 人工补偿"></a>方案一：同步落消息表 + 定时补偿 + 人工补偿</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220518091304978.png" alt="image-20220518091304978"></p>
<p><strong>在消息生产者端(也就是订单服务)</strong></p>
<p><strong>正常链路流程</strong> </p>
<p>第一步(该环节调用了操作了二次数据库):在创建订单的操作的时候，把数据插入到订单相关的表中,并且构造调 </p>
<p>用物流模块的数据消息，把消息插入到消息表中,初始状态为0 </p>
<p>第二步: 把物流消息投递到消息队列中, </p>
<p>第三步；消息队列返回一个确认消息,并且由订单服务来监控mq server的确认消息 </p>
<p>第四步:根据收到的确认消息来更新数据库中的消息记录的状态 </p>
<p><strong>异常链路流程</strong> </p>
<p>第一步(该环节调用了操作了二次数据库):在创建订单的操作的时候，把数据插入到订单相关的表中,并且构造调 </p>
<p>用物流模块的数据消息，把消息插入到消息表中,初始状态为0 </p>
<p>第二步: 把物流消息投递到消息队列中, </p>
<p>第三步:由于网络闪断，导致消费端监控mq服务访问的确认消息没有收到，那么在msg_db中的那条消息的 </p>
<p>状态永远就是0状态。这个时候，我们需要对这种情况下做出补偿 </p>
<p><strong>补偿机制:</strong> </p>
<p>​    启动一个分布式的定时任务,不定时的去扫描msg_db的这个表，状态为0的消息记录，在这里我们可以根据 </p>
<p>业务来设置扫描重发规则规则1:插入msg_db 表中5Min后状态还是为0的记录，进行消息重试 </p>
<p>规则2:若重试的次数超过五次状态还是为0的话，我们就把消息状态改为2,此时我们需要人工的去确认状态 </p>
<p>为2的消息是什么原因导致没有成功的 </p>
<p><strong>消息入库打标的缺点:</strong> </p>
<p>​    <strong>在第一步的过程中，既插入了业务数据表，也同时插入了消息记录表，进行了二次db操作，在高并发的环</strong> </p>
<p><strong>境下，这个环境就会造成性能瓶颈</strong> </p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220519222745273.png" alt="image-20220519222745273"></p>
<p>1、消息状态</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220519222352598.png" alt="image-20220519222352598"></p>
<p>2、消息结构</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageContent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String msgId;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> orderNo;<br><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-keyword">private</span> Integer msgStatus;<br><br>    <span class="hljs-keyword">private</span> String exchange;<br><br>    <span class="hljs-keyword">private</span> String routingKey;<br><br>    <span class="hljs-keyword">private</span> String errCause;<br><br>    <span class="hljs-keyword">private</span> Integer maxRetry;<br><br>    <span class="hljs-keyword">private</span> Integer currentRetry=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> Integer productNo;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>设置响应和回退监听处理</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220519232158671.png" alt="image-20220519232158671"></p>
<p>ConfirmCallback</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220519232411268.png" alt="image-20220519232411268"></p>
<p>ReturnCallback</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220519232559024.png" alt="image-20220519232559024"></p>
<h3 id="方案二：延时消息确认-回调检查消息状态补偿"><a href="#方案二：延时消息确认-回调检查消息状态补偿" class="headerlink" title="方案二：延时消息确认 + 回调检查消息状态补偿"></a>方案二：延时消息确认 + 回调检查消息状态补偿</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220518091431630.png" alt="image-20220518091431630"></p>
<p>优点：性能较好</p>
<p>缺点：流程复杂，且没有重试上限机制，缺少人工干预补偿</p>
<h2 id="幂等性以及消息的幂等性"><a href="#幂等性以及消息的幂等性" class="headerlink" title="幂等性以及消息的幂等性"></a>幂等性以及消息的幂等性</h2><p><strong>什么是接口的幂等性?</strong> </p>
<p>​    简而言之，就是对接口发起的一次调用和多次调用，所产生的结果都是 一致的。</p>
<p><strong>接口不幂等的后果</strong></p>
<p>​    案例一:比如订单提交的过程中，用户点了一次提交，但是由于网络等原因，导致后端处理延时，客户就连续点击了多次，在没有幂等性的条件下，那么就会造成订单的重复提交。</p>
<p>​    解决方案:在保存订单的时候，根据生成的系统全局唯一ID(这里订单号+业务类型),并且把该唯一ID 调用 redis 的setnx命令保存起来，在第一次保存的时候，由于redis中没有该key,那么就会 把全局唯一ID 进行设置上，此时订单就会保存成功，。这个时候若出现前端重复点击按钮, 由于第一步已经 setnx上了 就会阻止后面的保存。</p>
<p><a href="https://blog.csdn.net/qq_29978863/article/details/107739744">如何保证接口幂等</a></p>
<h3 id="MQ-是如何解决幂等性的"><a href="#MQ-是如何解决幂等性的" class="headerlink" title="MQ 是如何解决幂等性的"></a>MQ 是如何解决幂等性的</h3><p>MQ发送消息的流程</p>
<img src="/images/分布式-MQ-02RabbitMQ高级特性和集群/image-20220520092020713.png" alt="image-20220520092020713" style="zoom:80%;">

<p>第一步:消息生产者向Mq服务端发送消息<br>第二步:mq 服务端把消息进行落地<br>第三步:消息服务端向消息生产者发送ack<br>第四步；消息消费者消费消息<br>第五步:消费者发送ack<br>第六步: mq服务将落地消息删除</p>
<p><strong>消息重复发送的原因</strong> </p>
<p>​    为了保障消息的百分之百的投递，我们使用了消息重发，确认机制，使得消息可能被重复发送，由上图可知 道，由于网络原因，第三步的上半场ack丢失还是第五步的下半场ack丢失 都会导致消息重复发送</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">1、生产者已把消息发送到mq，在mq给生产者返回ack的时候网络中断，故生产者未收到确<br>定信息，生产者认为消息未发送成功，但实际情况是，mq已成功接收到了消息，在网络重<br>连后，生产者会重新发送刚才的消息，造成mq接收了重复的消息<br><br>2、消费者在消费mq中的消息时，mq已把消息发送给消费者，消费者在给mq返回ack时网<br>络中断，故mq未收到确认信息，该条消息会重新发给其他的消费者，或者在网络重连后再<br>次发送给该消费者，但实际上该消费者已成功消费了该条消息，造成消费者消费了重复的消<br>息；<br></code></pre></td></tr></table></figure>



<p><strong>消息重复发送的导致后果</strong></p>
<p>​    上半场消息生产者是用户支付模块，专门是用来给用户扣费的，而下半场的消息消费者服务是会员卡服务， 是通过接受扣费服务发送的消息来进行发卡的, 由于第三步或者是第五步ack丢失，那么就会导致上游服务重复发送消息就会导致扣一次款，发多次卡</p>
<p><strong>服务端是如何保证幂等性的</strong></p>
<p>​    消息队列的服务中，对每一条消息都会生成一个全局唯一的与业务无关的ID(inner_msg_id),当mq_server 接受到消息的时候，先根据inner_msg_id 是否需要重复发送，再决定消息是否落DB ,这样保证每条消息都 只会落一次DB</p>
<p><strong>消费端如何来做到幂等性的</strong></p>
<p>目前主流做法是 <strong>直接避免代码重复消费</strong> 和 <strong>代码支持重复消费，业务上幂等</strong></p>
<p>1、唯一业务ID</p>
<p>​    代码接受重复消息，但还是业务上结果是幂等的：如果有插入数据库的业务，根据唯一业务id获取分布式锁，进行插入或者更新（重复消费时）<br>2、（唯一业务ID+（辅助标志位（UUID、时间戳等是业务场景而定））or 唯一消息id</p>
<p>​    消费时redis setnx成功则继续消费，失败则视为重复消费，跳过消费返回ack</p>
<h2 id="消息的confirm机制"><a href="#消息的confirm机制" class="headerlink" title="消息的confirm机制"></a>消息的confirm机制</h2><h3 id="mq-的confirm机制"><a href="#mq-的confirm机制" class="headerlink" title="mq 的confirm机制"></a>mq 的confirm机制</h3><p>1:消息的确认:指的是生产者将消息投递后，如何mq-server接受到消息，就会给生产者一个应答. </p>
<p>2:生产者接受到应答，来确保该条消息是否成功发送到了mq-server </p>
<p>3:confirm机制是消息可靠性投递的核心保障</p>
<h3 id="mq的confirm机制的核心流程图"><a href="#mq的confirm机制的核心流程图" class="headerlink" title="mq的confirm机制的核心流程图"></a>mq的confirm机制的核心流程图</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220521145848720.png" alt="image-20220521145848720"></p>
<h3 id="confirm机制的现实步骤"><a href="#confirm机制的现实步骤" class="headerlink" title="confirm机制的现实步骤"></a>confirm机制的现实步骤</h3><p>第一步：在channel 上开启确认模式 channel.confirmSelect(); </p>
<p>第二步:在channel上添加监听，用来监听mq-server返回的应答 </p>
<h3 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.confirmSelect();<br>channel.addConfirmListener(<span class="hljs-keyword">new</span> ConfirmListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleAck</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deliveryTag, <span class="hljs-keyword">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消息deliveryTag&quot;</span>+deliveryTag+<span class="hljs-string">&quot;被正常签收&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleNack</span><span class="hljs-params">(<span class="hljs-keyword">long</span> deliveryTag, <span class="hljs-keyword">boolean</span> multiple)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;消息deliveryTag&quot;</span>+deliveryTag+<span class="hljs-string">&quot;没被签收&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<h2 id="消息return机制"><a href="#消息return机制" class="headerlink" title="消息return机制"></a>消息return机制</h2><h3 id="Return-Listener是用来处理一些不可路由的消息"><a href="#Return-Listener是用来处理一些不可路由的消息" class="headerlink" title="Return Listener是用来处理一些不可路由的消息"></a>Return Listener是用来处理一些不可路由的消息</h3><p>生产者发送消息到broker时</p>
<p>情况一：broker中根本没有对应的exchange交换机来接受该消息</p>
<p>情况二：消息能够投递到broker的交换机上，但是交换机根据routingKey 路由不到某一个队列上</p>
<p><strong>处理一；若在消息生产端 的mandatory设置为true 那么就会调用生产端ReturnListener 来处理</strong></p>
<p><strong>处理二；若消息生产端的mandatory设置为false(默认值也是false) 那么mq-broker就会自动删除消息</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-02RabbitMQ%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220521151501989.png" alt="image-20220521151501989"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.addReturnListener(<span class="hljs-keyword">new</span> ReturnListener() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleReturn</span><span class="hljs-params">(<span class="hljs-keyword">int</span> replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;记录不可达消息........................&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;replaycode=&quot;</span>+replyCode);<br>        System.out.println(<span class="hljs-string">&quot;replyText=&quot;</span>+replyText);<br>        System.out.println(<span class="hljs-string">&quot;exchange=&quot;</span>+exchange);<br>        System.out.println(<span class="hljs-string">&quot;routingKey=&quot;</span>+routingKey);<br>        System.out.println(<span class="hljs-string">&quot;properties=&quot;</span>+properties);<br>        System.out.println(<span class="hljs-string">&quot;body=&quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>        <span class="hljs-comment">//处理消息表消息状态=发送失败</span><br>    &#125;<br>&#125;);<br><br><span class="hljs-comment">//5:通过channel发送消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            String message = <span class="hljs-string">&quot;hello--&quot;</span> + i;<br>            <span class="hljs-comment">//第三个参数是 mandatory</span><br>            channel.basicPublish(<span class="hljs-string">&quot;directchange&quot;</span>, <span class="hljs-string">&quot;directchange.key&quot;</span>,<span class="hljs-keyword">true</span>, basicProperties, message.getBytes());<br>        &#125;<br></code></pre></td></tr></table></figure>

<h2 id="消费端如何做限流量"><a href="#消费端如何做限流量" class="headerlink" title="消费端如何做限流量"></a>消费端如何做限流量</h2><h3 id="什么是消费端的限流"><a href="#什么是消费端的限流" class="headerlink" title="什么是消费端的限流"></a>什么是消费端的限流</h3><p>场景:首先，我们迎来了订单的高峰期，在mq的broker上堆积了成千上万条消息没有处理，这个时候，我们随便打开了 消费者，就会出现下面请 如此多的消息瞬间推送给消费者，我们的消费者不能处理这么多消息 就会导致消费者出现巨大压力，甚至服务器崩溃</p>
<h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>rabbitmq 提供一个钟qos（服务质量保证）,也就是在关闭了消费端的自动ack的前提 下，我们可以设置阈值（出队）的消息数没有被确认（手动确认），那么就不会推送 消息过来. 限流的级别(consumer级别或者是channel级别)</p>
<p>实现的方式 void BasicQos(uint prefetchSize,ushort prefetchCount ,bool global) uint prefetchSize ：指定的是设定消息的大小(rabbitmq还没有该功能，所以一般是填写0表示不限制) ushort perfetchCount ：表示设置消息的阈值，每次过来几条消息(一般是填写1 一条 一条的处理消息) bool global：表示是channel级别的还是 consumer的限制(channel的限制rabbitmq 还没有该功能)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">消费端<br><span class="hljs-comment">//gloabl设置为ture 那么就是channel级别的限流，若为false 就是consumer级别的限制流量</span><br>channel.basicQos(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-keyword">false</span>);<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关闭自动签收</span><br><span class="hljs-comment"> */</span><br>channel.basicConsume(queueName,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">new</span> AngleCustomConsumer(channel));<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AngleCustomConsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultConsumer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new instance and records its association to the passed-in channel.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel the channel to which this consumer is attached</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Channel channel;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AngleCustomConsumer</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(channel);<br>        <span class="hljs-keyword">this</span>.channel = channel;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;自定义的消息消费端&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;consumerTag=&quot;</span>+consumerTag);<br>        System.out.println(<span class="hljs-string">&quot;envelope=&quot;</span>+envelope);<br>        System.out.println(<span class="hljs-string">&quot;properties=&quot;</span>+properties);<br>        System.out.println(<span class="hljs-string">&quot;body=&quot;</span>+<span class="hljs-keyword">new</span> String(body));<br>        <span class="hljs-comment">//消费端的手动签收,假如关闭手动签收，也关闭自动签收，那么消费端只会接收到一条消息</span><br>        <span class="hljs-comment">//channel.basicAck(envelope.getDeliveryTag(),false);</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="消费端的ack"><a href="#消费端的ack" class="headerlink" title="消费端的ack"></a>消费端的ack</h2><h3 id="消费端的ack模式"><a href="#消费端的ack模式" class="headerlink" title="消费端的ack模式"></a>消费端的ack模式</h3><p>消费端的ack类型:<strong>自动ack</strong> 和<strong>手动ack</strong> 做消息限流的时候，我们需要关闭自动ack 然后进行手动ack的确认,若我们业务出现了问题，我们就可以进行nack</p>
<p><strong>手动ack</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.basicAck(envelope.getDeliveryTag(),<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

<h3 id="重回队列"><a href="#重回队列" class="headerlink" title="重回队列"></a>重回队列</h3><p>当消费端进行了nack的操作的时候，我们可以通过设置来进行对消息的重回队列的操作(但是一般我们不会设置重回队列的操作，而是通过告警系统然后人工补偿等手段补偿。因为一般而言，第一次消费报错如果放回队列，还是会报错的，放回队列会导致死循环)</p>
<p><strong>手动nack</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">channel.basicNack(envelope.getDeliveryTag(),<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br></code></pre></td></tr></table></figure>

<h2 id="死信队列-amp-死信交换机"><a href="#死信队列-amp-死信交换机" class="headerlink" title="死信队列&amp;死信交换机"></a>死信队列&amp;死信交换机</h2><h3 id="死信队列DLX-Dead-leater-exchange"><a href="#死信队列DLX-Dead-leater-exchange" class="headerlink" title="死信队列DLX(Dead-leater-exchange)"></a>死信队列DLX(Dead-leater-exchange)</h3><h4 id="什么是死信"><a href="#什么是死信" class="headerlink" title="什么是死信"></a>什么是死信</h4><p>就是在队列中的消息如果没有消费者消费，那么该消息就成为一个死信，那这个消息被重新发送到另外一个exchange上的话， 那么后面这个exhcange就是死信队列</p>
<h4 id="消息变成死信的几种情况"><a href="#消息变成死信的几种情况" class="headerlink" title="消息变成死信的几种情况"></a>消息变成死信的几种情况</h4><p><strong>消息被拒绝</strong>：（basic.reject/basic.nack）并且requeue(重回队列)的属性设置为 false 表示不需要重回队列，那么该消息就是一个死信消息 </p>
<p><strong>消息TTL过期</strong>：消息本身设置了过期时间，或者队列设置了消息过期时间x-message-ttl </p>
<p><strong>队列达到最大长度</strong>：比如队列最大长度是3000 ,那么3001消息就会被送到死信队列上.</p>
<h3 id="如何设置死信队列"><a href="#如何设置死信队列" class="headerlink" title="如何设置死信队列"></a>如何设置死信队列</h3><p>绑定正常队列时</p>
<p>1、声明正常交换机、正常队列、死信队列交换、死信队列</p>
<p>2、声明正常队列时，设置argument：x-dead-letter-exchange属性值=死信队列交换机</p>
<p>3、正常交换机绑定正常队列、死信交换机绑定死信队列</p>
<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><h4 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h4><p>1、设置队列最大长度=5</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;String,Object&gt; argurments= <span class="hljs-keyword">new</span> HashMap&lt;&gt;() ;<br><span class="hljs-comment">//设置正常队列中的死信发往哪个队列</span><br><span class="hljs-comment">//限制队列存储长度</span><br>argurments.put(<span class="hljs-string">&quot;x-max-length&quot;</span>, <span class="hljs-number">5</span>);<br>channel.queueDeclare(normalQueueName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,argurments);<br></code></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLX_CustomConsumer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DefaultConsumer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new instance and records its association to the passed-in channel.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> channel the channel to which this consumer is attached</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Channel channel;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DLX_CustomConsumer</span><span class="hljs-params">(Channel channel)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(channel);<br>        <span class="hljs-keyword">this</span>.channel = channel;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDelivery</span><span class="hljs-params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="hljs-keyword">byte</span>[] body)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;为了测试死信队列,我们进行nack&quot;</span>);<br>        <span class="hljs-comment">//把消息变为死信 通过nack 且requeue不进行重新发送</span><br>        channel.basicNack(envelope.getDeliveryTag(),<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DLX_Consumer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建一个channel</span><br>        Channel channel = connection.createChannel();<br>        String normalExchangeName = <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>        String normalKey = <span class="hljs-string">&quot;normaldlx.key&quot;</span>;<br>        String normalQueueName = <span class="hljs-string">&quot;normal_queue&quot;</span>;<br>        String exchangeType = <span class="hljs-string">&quot;topic&quot;</span>;<br><br>        String dlxExchangeName = <span class="hljs-string">&quot;dlx_exchange&quot;</span>;<br>        String dlxQueueName = <span class="hljs-string">&quot;dlx_queue&quot;</span>;<br><br>        <span class="hljs-comment">//声明一个正常的业务队列</span><br>        channel.exchangeDeclare(normalExchangeName,exchangeType,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        Map&lt;String,Object&gt; argurments= <span class="hljs-keyword">new</span> HashMap&lt;&gt;() ;<br>        <span class="hljs-comment">//设置正常队列中的死信发往哪个队列</span><br>        argurments.put(<span class="hljs-string">&quot;x-dead-letter-exchange&quot;</span>, dlxExchangeName);<br>        <span class="hljs-comment">//限制队列存储长度</span><br>        argurments.put(<span class="hljs-string">&quot;x-max-length&quot;</span>, <span class="hljs-number">5</span>);<br>        channel.queueDeclare(normalQueueName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,argurments);<br>        channel.queueBind(normalQueueName,normalExchangeName,normalKey);<br><br>        <span class="hljs-comment">//声明死信队列</span><br>        channel.exchangeDeclare(dlxExchangeName,exchangeType,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        channel.queueDeclare(dlxQueueName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        channel.queueBind(dlxQueueName,dlxExchangeName,<span class="hljs-string">&quot;#&quot;</span>);<br>        channel.basicConsume(normalQueueName,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">new</span> DLX_CustomConsumer(channel));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h4><p>1、设置消息过期时间</p>
<p>AMQP.BasicProperties basicProperties = new AMQP.BasicProperties().builder().expiration(“10000”)//消息过期 10s</p>
<p>2、一次性发送10条消息（队列限制5条，其余5条被发至死信队列）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqMessageProducter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br><br>        String normalExchangeName = <span class="hljs-string">&quot;normal_exchange&quot;</span>;<br>        String normalKey = <span class="hljs-string">&quot;normaldlx.key&quot;</span>;<br>        <span class="hljs-comment">//3:通过连接工厂创建连接对象</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//4:通过连接创建channel</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//5:通过channel发送消息</span><br>        AMQP.BasicProperties basicProperties = <span class="hljs-keyword">new</span> AMQP.BasicProperties().builder()<br>                <span class="hljs-comment">//.expiration(&quot;10000&quot;)//消息过期 10s</span><br>                .contentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>                .correlationId(UUID.randomUUID().toString())<br>                .build();<br>        <span class="hljs-comment">//channel.basicPublish(normalExchangeName, normalKey,basicProperties, &quot;测试消息被拒绝转为死信队列&quot;.getBytes());</span><br>        channel.basicPublish(normalExchangeName, normalKey,basicProperties, <span class="hljs-string">&quot;测试消息过期转为死信队列&quot;</span>.getBytes());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            channel.basicPublish(normalExchangeName, normalKey,basicProperties, <span class="hljs-string">&quot;测试消息积压转为死信队列&quot;</span>.getBytes());<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="集群搭建"><a href="#集群搭建" class="headerlink" title="集群搭建"></a>集群搭建</h2><p>参考如下</p>
<p><a href="https://blog.csdn.net/u012702547/article/details/121890003">https://blog.csdn.net/u012702547/article/details/121890003</a></p>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-MQ-01RabbitMQ安装以及入门</title>
    <url>/2022/05/11/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-01RabbitMQ%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="RabbitMQ安装以及入门"><a href="#RabbitMQ安装以及入门" class="headerlink" title="RabbitMQ安装以及入门"></a>RabbitMQ安装以及入门</h1><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><h3 id="1、初识RabbitMQ"><a href="#1、初识RabbitMQ" class="headerlink" title="1、初识RabbitMQ"></a>1、初识RabbitMQ</h3><p>​    rabbitmq是一个开源的消息代理和队列服务器，通过普通的协议(Amqp协议)来完成不同应用之间的数据共享（<strong>消费生产和消费者可以跨语言平台</strong>） rabbitmq是通过elang语言来开发的基于amqp协议</p>
<h3 id="2、选择RabbitMQ的原因"><a href="#2、选择RabbitMQ的原因" class="headerlink" title="2、选择RabbitMQ的原因"></a>2、选择RabbitMQ的原因</h3><p>1、图形化界面完善</p>
<p>2、Elang语言开发，跨平台不局限于JAVA</p>
<p>3、提供消息确认机制（发送方确认，消费方确认），死信队列、延迟消息等</p>
<p>4、开源、社区活跃、稳定</p>
<h3 id="3、什么是AMQP协议-Advanced-message-queue-protocol-高级消息队列协议"><a href="#3、什么是AMQP协议-Advanced-message-queue-protocol-高级消息队列协议" class="headerlink" title="3、什么是AMQP协议(Advanced message queue protocol) 高级消息队列协议"></a>3、什么是AMQP协议(Advanced message queue protocol) 高级消息队列协议</h3><p><strong>server</strong> :又称为broker，接受客户端连接，实现amqp实体服务</p>
<p><strong>Connection</strong>: 连接,应用程序与brokder建立网络连接 </p>
<p><strong>channel</strong>：网络通道，几乎所有的操作都是在channel中进行的，是进行消息对象的通道，客户端可以建立 多个通道，每一个channel表示一个会话任务 </p>
<p><strong>Message</strong>: 服务器和应用程序之间传递数据的载体，有properties（消息属性,用来修饰消息,比如消息的优 先级,延时投递）和Body（消息体） </p>
<p><strong>virtual host</strong>(虚拟主机): 是一个逻辑概念,最上层的消息路由，一个虚拟主机中可以包含多个exhange 和 queue 但是一个虚拟主机中不能有名称相同的exchange 和queue </p>
<p><strong>exchange</strong> 交换机: 消息直接投递到交换机上，然后交换机根据消息的路由key 来路由到对应绑定的队列上 </p>
<p><strong>bingding</strong>: 绑定 exchange 与queue的虚拟连接,bingding中可以包含route_key </p>
<p><strong>route_key</strong> 路由key ，他的作用是在交换机上通过route_key来把消息路由到哪个队列上 </p>
<p><strong>queue</strong>：队列，用于来保存消息的载体，有消费者监听，然后消费消息</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-01RabbitMQ%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/image-20220513080448800.png" alt="image-20220513080448800"></p>
<h3 id="4、RabbitMQ的整体架构模型"><a href="#4、RabbitMQ的整体架构模型" class="headerlink" title="4、RabbitMQ的整体架构模型"></a>4、RabbitMQ的整体架构模型</h3><img src="/images/分布式-MQ-01RabbitMQ安装以及入门/image-20220513081348810.png" alt="image-20220513081348810" style="zoom:50%;">

<h3 id="5、RabbitMQ的消息是如何流转的"><a href="#5、RabbitMQ的消息是如何流转的" class="headerlink" title="5、RabbitMQ的消息是如何流转的"></a>5、RabbitMQ的消息是如何流转的</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-01RabbitMQ%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/image-20220513081427272.png" alt="image-20220513081427272"></p>
<h3 id="6、RabbitMQ、RabbitMQ、Kafka比较"><a href="#6、RabbitMQ、RabbitMQ、Kafka比较" class="headerlink" title="6、RabbitMQ、RabbitMQ、Kafka比较"></a>6、RabbitMQ、RabbitMQ、Kafka比较</h3><table>
<thead>
<tr>
<th></th>
<th>Kafka</th>
<th>RabbitMQ</th>
<th>RocketMQ</th>
</tr>
</thead>
<tbody><tr>
<td>设计定位</td>
<td>系统间的数据流通道，实时数据处理。常用于日志收集处理、监控数据处理等大数据量、并发量最高</td>
<td>可靠传输消息、处理普通业务，如下单、充值、消息推送等常规业务，并发量较高</td>
<td>可靠传输消息、并发量较高，高于RabbitMQs</td>
</tr>
<tr>
<td>顺序消费</td>
<td>支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>定时/延迟消息</td>
<td>不支持</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>事务消息</td>
<td>/</td>
<td>/</td>
<td>支持</td>
</tr>
<tr>
<td>消息查询·</td>
<td>/</td>
<td>/</td>
<td>支持类似mysql的语法查询服务器中的消息</td>
</tr>
<tr>
<td>消费方式</td>
<td>cosumer pull</td>
<td>comsumer pull / broker push</td>
<td>broker push</td>
</tr>
<tr>
<td>图形化界面</td>
<td>结合kibana</td>
<td>完美</td>
<td>丑</td>
</tr>
<tr>
<td>总结</td>
<td>优点：高吞吐、低延迟<br>缺点：不支持事务，</td>
<td>优点：生态完善，图形化界面友好、支持多种语言<br>缺点：不支持事务，吞吐能力有限、消息堆积时，性能明显下降</td>
<td>优点：支持事务消息<br>缺点：生态不完善，图形化界面不友好、只支持java</td>
</tr>
</tbody></table>
<p>![](/images/分布式-MQ-01RabbitMQ安装以及入门/MQ对比：Kafka VS Rocketmq VS Rabbitmq_00.png)</p>
<h2 id="RabbitMQ安装与启动"><a href="#RabbitMQ安装与启动" class="headerlink" title="RabbitMQ安装与启动"></a>RabbitMQ安装与启动</h2><p><strong>①</strong>:<strong>安装</strong>rabbitmq<strong>所需要的依赖包</strong> </p>
<p>yum install build-essential openssl openssl-devel unixODBC unixODBC-devel make gcc gcc- </p>
<p>c++ kernel-devel m4 ncurses-devel tk tc xz </p>
<p><strong>②</strong>:<strong>下载安装包</strong> (PS:<strong>老师的下载包的目录是</strong> cd /usr/local/software) </p>
<p>wget <a href="http://www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm">www.rabbitmq.com/releases/erlang/erlang-18.3-1.el7.centos.x86_64.rpm</a> </p>
<p>wget <a href="http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm">http://repo.iotti.biz/CentOS/7/x86_64/socat-1.7.3.2-5.el7.lux.x86_64.rpm</a> </p>
<p>wget <a href="http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm">www.rabbitmq.com/releases/rabbitmq-server/v3.6.5/rabbitmq-server-3.6.5-1.noarch.rpm</a> </p>
<p><strong>③</strong>:<strong>安装服务命令</strong> </p>
<p>#第一步:安装erlang语言环境 </p>
<p>rpm -ivh erlang-18.3-1.el7.centos.x86_64.rpm </p>
<p>#第二步:安装socat加解密软件 </p>
<p>rpm -ivh socat-1.7.3.2-5.el7.lux.x86_64.rpm </p>
<p>#第三步:最后安装rabbitmqrpm -ivh rabbitmq-server-3.6.5-1.noarch.rpm </p>
<p><strong>④</strong>:<strong>修改集群用户与连接心跳检测</strong> </p>
<p><strong>注意修改</strong>vim /usr/lib/rabbitmq/lib/rabbitmq_server-3.6.5/ebin/rabbit.app<strong>文件</strong> </p>
<p>修改：loopback_users 中的 &lt;&lt;”guest”&gt;&gt;,只保留guest（不修改只能通过localhost访问）</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-01RabbitMQ%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/image-20220514124004407.png" alt="image-20220514124004407"></p>
<p>5、下载延时组件</p>
<p>wget <a href="https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip">https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip</a></p>
<p>解压延时插件:  unzip  </p>
<p>rabbitmq_delayed_message_exchange-20171215-3.6.x.zip</p>
<p>把延时插件拷贝到指定目录下:cp rabbitmq_delayed_message_exchange-20171215-3.6.x.ez</p>
<p>/usr/lib/rabbitmq/lib/rabbitmq_server-3.7.5/plugins</p>
<p>启动延时插件: rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p>
<p>6、访问ip:15672 访问rabbitMQ管理控制台</p>
<p>username：guest</p>
<p>password：guest</p>
<h3 id="测试生成和消费消息"><a href="#测试生成和消费消息" class="headerlink" title="测试生成和消费消息"></a>测试生成和消费消息</h3><p>1、生产消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqProducter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//1:创建连接工厂</span><br>        ConnectionFactory connectionFactory = <span class="hljs-keyword">new</span> ConnectionFactory();<br><br>        <span class="hljs-comment">//2设置连接工厂的属性</span><br>        connectionFactory.setHost(<span class="hljs-string">&quot;192.168.136.1&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">//3:通过连接工厂创建连接对象</span><br>        Connection connection = connectionFactory.newConnection();<br><br>        <span class="hljs-comment">//4:通过连接创建channel</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//5:通过channel发送消息</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">5</span>;i++) &#123;<br>            String message = <span class="hljs-string">&quot;hello--&quot;</span>+i;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 老师以前讲过说我们的消息会发送的exchange上，</span><br><span class="hljs-comment">             * 但是在这里我们没有指定交换机?那我们的消息发送到哪里了？？？？</span><br><span class="hljs-comment">             * The default exchange is implicitly bound to every queue, with a routing key equal to the queue name.</span><br><span class="hljs-comment">             * It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.</span><br><span class="hljs-comment">             * 说明:加入我们消息发送的时候没有指定具体的交换机的话，那么就会发送到rabbimtq指定默认的交换机上，</span><br><span class="hljs-comment">             * 那么该交换机就会去根据routing_key 查找对应的queueName 然后发送的该队列上.</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             */</span><br>            channel.basicPublish(<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-string">&quot;test-queue-01&quot;</span>,<span class="hljs-keyword">null</span>,message.getBytes());<br>        &#125;<br><br>        <span class="hljs-comment">//6:关闭连接</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、消费消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConsumer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        ConnectionFactory connectionFactory  = <span class="hljs-keyword">new</span> ConnectionFactory();<br>        connectionFactory.setHost(<span class="hljs-string">&quot;192.168.136.1&quot;</span>);<br>        connectionFactory.setPort(<span class="hljs-number">5672</span>);<br>        connectionFactory.setVirtualHost(<span class="hljs-string">&quot;/&quot;</span>);<br>        connectionFactory.setUsername(<span class="hljs-string">&quot;guest&quot;</span>);<br>        connectionFactory.setPassword(<span class="hljs-string">&quot;guest&quot;</span>);<br><br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = connectionFactory.newConnection();<br><br>        <span class="hljs-comment">//创建一个channel</span><br>        Channel channel = connection.createChannel();<br><br>        <span class="hljs-comment">//声明队列</span><br>        String queueName = <span class="hljs-string">&quot;test-queue-01&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * queue:队列的名称</span><br><span class="hljs-comment">         * durable:是否持久化, 队列的声明默认是存放到内存中的，如果rabbitmq重启会丢失，如果想重启之后还存在就要使队列持久化，</span><br><span class="hljs-comment">         * 保存到Erlang自带的Mnesia数据库中，当rabbitmq重启之后会读取该数据库</span><br><span class="hljs-comment">         * exclusive:当连接关闭时connection.close()该队列是否会自动删除；</span><br><span class="hljs-comment">         * 二：该队列是否是私有的private，如果不是排外的，可以使用两个消费者都访问同一个队列，</span><br><span class="hljs-comment">         * 没有任何问题，如果是排外的，会对当前队列加锁，其他通道channel是不能访问的，如果强制访问会报异常</span><br><span class="hljs-comment">         * com.rabbitmq.client.ShutdownSignalException: channel error; protocol method: #method&lt;channel.close&gt;(reply-code=405, reply-text=RESOURCE_LOCKED - cannot obtain exclusive access to locked queue &#x27;queue_name&#x27; in vhost &#x27;/&#x27;, class-id=50, method-id=20)</span><br><span class="hljs-comment">         * 一般等于true的话用于一个队列只能有一个消费者来消费的场景</span><br><span class="hljs-comment">         * autodelete:是否自动删除，当最后一个消费者断开连接之后队列是否自动被删除，可以通过RabbitMQ Management，</span><br><span class="hljs-comment">         * 查看某个队列的消费者数量，当consumers = 0时队列就会自动删除</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(queueName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">//创建消费者</span><br>        QueueingConsumer queueingConsumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);<br>        channel.basicConsume(queueName,<span class="hljs-keyword">true</span>,queueingConsumer);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            String reserveMsg = <span class="hljs-keyword">new</span> String(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;消费消息:&quot;</span>+reserveMsg);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Rabbitmq交换机详解"><a href="#Rabbitmq交换机详解" class="headerlink" title="Rabbitmq交换机详解"></a>Rabbitmq交换机详解</h2><h3 id="1、作用"><a href="#1、作用" class="headerlink" title="1、作用"></a>1、作用</h3><p>​    接受生产者的消息，然后根据路由键 把消息投递到跟交换机绑定的对应的队列上 </p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-01RabbitMQ%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/image-20220514145837082.png" alt="image-20220514145837082"></p>
<h3 id="2、属性"><a href="#2、属性" class="headerlink" title="2、属性"></a>2、属性</h3><p>Name:交换机的名称 </p>
<p>Type:交换机的类型,direct,topic,fanout,headers </p>
<p>Durability:是否需要持久化 </p>
<p>autodelete:假如没有队列绑定到该交换机，那么该交换机会自动删除 </p>
<p>Internal:当前交换机是否用户rabbitmq内部使用不常用,默认为false </p>
<p>Argurements:扩展参数,用户扩展AMQP 定制化协议</p>
<h3 id="3、类型"><a href="#3、类型" class="headerlink" title="3、类型"></a>3、类型</h3><h4 id="直连交换机-directExchange"><a href="#直连交换机-directExchange" class="headerlink" title="直连交换机 directExchange"></a>直连交换机 directExchange</h4><p>所以发送的direct exhchange 的消息都会被投递到与该交换机绑定且routing key = Key 的queue上。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-01RabbitMQ%E5%AE%89%E8%A3%85%E4%BB%A5%E5%8F%8A%E5%85%A5%E9%97%A8/image-20220514150212644.png" alt="image-20220514150212644"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Consumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br>        Connection connection = ConnectionUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明一个交换机</span><br><span class="hljs-comment">         * exchange:交换机的名称</span><br><span class="hljs-comment">         * type:交换机的类型 常见的有direct,fanout,topic等</span><br><span class="hljs-comment">         * durable:设置是否持久化。durable设置为true时表示持久化，反之非持久化.持久化可以将交换器存入磁盘，在服务器重启的时候不会丢失相关信息</span><br><span class="hljs-comment">         * autodelete:设置是否自动删除。autoDelete设置为true时，则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后，所有与这个交换器绑定的队列或者交换器都与此解绑。</span><br><span class="hljs-comment">         * 不能错误的理解—当与此交换器连接的客户端都断开连接时，RabbitMq会自动删除本交换器</span><br><span class="hljs-comment">         * arguments:其它一些结构化的参数，比如：alternate-exchange</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(<span class="hljs-string">&quot;directChange&quot;</span>,<span class="hljs-string">&quot;direct&quot;</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        String queueName = <span class="hljs-string">&quot;directQueue&quot;</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明一个队列</span><br><span class="hljs-comment">         * durable:表示rabbitmq关闭删除队列</span><br><span class="hljs-comment">         * autodelete:表示没有程序和队列建立连接 那么就会自动删除队列</span><br><span class="hljs-comment">         *</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(queueName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br><br>        channel.queueBind(queueName,<span class="hljs-string">&quot;directChange&quot;</span>,<span class="hljs-string">&quot;directChange.key&quot;</span>);<br>        channel.queueBind(queueName,<span class="hljs-string">&quot;directChange&quot;</span>,<span class="hljs-string">&quot;directChange.key1&quot;</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 创建一个消费者</span><br><span class="hljs-comment">         */</span><br>        QueueingConsumer queueingConsumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 开始消费</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(queueName,<span class="hljs-keyword">true</span>,queueingConsumer);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            String reciverMessage = <span class="hljs-keyword">new</span> String(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;消费消息:-----&quot;</span>+reciverMessage);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Producer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        Connection connection = ConnectionUtils.getConnection();<br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">//定义交换机名称</span><br>        String exchangeName = <span class="hljs-string">&quot;directChange&quot;</span>;<br><br>        <span class="hljs-comment">//定义routingKey</span><br>        String routingKey = <span class="hljs-string">&quot;directChange.key&quot;</span>;<br>        <span class="hljs-comment">//定义routingKey</span><br>        <span class="hljs-comment">//String routingKey = &quot;directChange.key1&quot;;</span><br><br>        <span class="hljs-comment">//消息体内容</span><br>        String messageBody = <span class="hljs-string">&quot;hello handsomeboy &quot;</span>;<br>        channel.basicPublish(exchangeName,routingKey,<span class="hljs-keyword">null</span>,messageBody.getBytes());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="主题交换机-TopicExchange"><a href="#主题交换机-TopicExchange" class="headerlink" title="主题交换机 TopicExchange"></a>主题交换机 TopicExchange</h4><p>​    就是在队列上绑到topic 交换机上的路由key 可以是通过通配符来匹配的通配符的规则是</p>
<p>​    log.#可以匹配一个单词也可以匹配多个单词,</p>
<p>​    比如 log.#可以匹配log.a log.a.b log.a.b </p>
<p>​    log.* 可以匹配一个单词 </p>
<p>​    比如 log.* 可以匹配log.a 但是不可以匹配log.a.b</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA">消费者<span class="hljs-number">1</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutExchangeConsumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">//声明交换机</span><br>        String exchangeName = <span class="hljs-string">&quot;topicExchange&quot;</span>;<br>        String exchangeType = <span class="hljs-string">&quot;topic&quot;</span>;<br>        channel.exchangeDeclare(exchangeName,exchangeType,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//声明队列</span><br>        String quequName = <span class="hljs-string">&quot;topic.queue&quot;</span>;<br>        channel.queueDeclare(quequName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//声明绑定关系</span><br>        String bingdingStr = <span class="hljs-string">&quot;topic.*&quot;</span>;<br>        channel.queueBind(quequName,exchangeName,bingdingStr);<br>        <span class="hljs-comment">//声明一个消费者</span><br>        QueueingConsumer queueingConsumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);<br>        <span class="hljs-comment">//开始消费</span><br>        channel.basicConsume(quequName,<span class="hljs-keyword">true</span>,queueingConsumer);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            System.out.println(<span class="hljs-string">&quot;FanoutExchangeConsumer接受到消息:&quot;</span>+<span class="hljs-keyword">new</span> String(delivery.getBody()));<br>        &#125;<br>    &#125;<br>&#125;<br>FanoutExchangeConsumer接受到消息:我是第一条消息<br>FanoutExchangeConsumer接受到消息:我是第二条消息<br><br><br>消费者<span class="hljs-number">2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutExchangeConsumer1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">//声明交换机</span><br>        String exchangeName = <span class="hljs-string">&quot;topicExchange&quot;</span>;<br>        String exchangeType = <span class="hljs-string">&quot;topic&quot;</span>;<br>        channel.exchangeDeclare(exchangeName,exchangeType,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//声明队列</span><br>        String quequName = <span class="hljs-string">&quot;topic.queue1&quot;</span>;<br>        channel.queueDeclare(quequName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//声明绑定关系</span><br>        String bingdingStr = <span class="hljs-string">&quot;topic.#&quot;</span>;<br>        channel.queueBind(quequName,exchangeName,bingdingStr);<br>        <span class="hljs-comment">//声明一个消费者</span><br>        QueueingConsumer queueingConsumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);<br>        <span class="hljs-comment">//开始消费</span><br>        channel.basicConsume(quequName,<span class="hljs-keyword">true</span>,queueingConsumer);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            System.out.println(<span class="hljs-string">&quot;FanoutExchangeConsumer1接受到消息:&quot;</span>+<span class="hljs-keyword">new</span> String(delivery.getBody()));<br>        &#125;<br>    &#125;<br>&#125;<br>FanoutExchangeConsumer1接受到消息:我是第一条消息<br>FanoutExchangeConsumer1接受到消息:我是第二条消息<br>FanoutExchangeConsumer1接受到消息:我是第三条消息<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TopicExchangeProductor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">//发送消息</span><br>        String exchangeName = <span class="hljs-string">&quot;topicExchange&quot;</span>;<br>        String routingKey1 = <span class="hljs-string">&quot;topic.key1&quot;</span>;<br>        String routingKey2 = <span class="hljs-string">&quot;topic.key2&quot;</span>;<br>        String routingKey3 = <span class="hljs-string">&quot;topic.key.key3&quot;</span>;<br>        channel.basicPublish(exchangeName,routingKey1,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;我是第一条消息&quot;</span>.getBytes());<br>        channel.basicPublish(exchangeName,routingKey2,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;我是第二条消息&quot;</span>.getBytes());<br>        channel.basicPublish(exchangeName,routingKey3,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;我是第三条消息&quot;</span>.getBytes());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="扇形交换机-fanoutExchange"><a href="#扇形交换机-fanoutExchange" class="headerlink" title="扇形交换机 fanoutExchange"></a>扇形交换机 fanoutExchange</h4><p>就是消息通过从交换机到队列上不会通过路由key 所以<strong>该模式的速度是最快的</strong> 只要和交换机绑定的那么消息就会 被分发到与之绑定的队列上</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutExchangeProductor</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">//定义交换机名称</span><br>        String exchangeName = <span class="hljs-string">&quot;fanoutExchange&quot;</span>;<br>        <span class="hljs-comment">//消息体内容</span><br>        String messageBody = <span class="hljs-string">&quot;hello handsome boy &quot;</span>;<br>        channel.basicPublish(exchangeName,<span class="hljs-string">&quot;&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;我是第一条消息&quot;</span>.getBytes());<br>        channel.basicPublish(exchangeName,<span class="hljs-string">&quot;456&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;我是第二条消息&quot;</span>.getBytes());<br>        channel.basicPublish(exchangeName,<span class="hljs-string">&quot;789&quot;</span>,<span class="hljs-keyword">null</span>,<span class="hljs-string">&quot;我是第三条消息&quot;</span>.getBytes());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FanoutExchangeConsumer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建连接工厂</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建channel</span><br>        Channel channel = connection.createChannel();<br>        <span class="hljs-comment">//声明交换机</span><br>        String exchangeName = <span class="hljs-string">&quot;fanoutExchange&quot;</span>;<br>        String exchangeType = <span class="hljs-string">&quot;fanout&quot;</span>;<br>        channel.exchangeDeclare(exchangeName,exchangeType,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//声明队列</span><br>        String quequName = <span class="hljs-string">&quot;fanout.queue&quot;</span>;<br>        channel.queueDeclare(quequName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br>        <span class="hljs-comment">//声明绑定关系</span><br>        channel.queueBind(quequName,exchangeName,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-comment">//声明一个消费者</span><br>        QueueingConsumer queueingConsumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);<br>        <span class="hljs-comment">//开始消费</span><br>        channel.basicConsume(quequName,<span class="hljs-keyword">true</span>,queueingConsumer);<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            System.out.println(<span class="hljs-string">&quot;接受到消息:&quot;</span>+<span class="hljs-keyword">new</span> String(delivery.getBody()));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="队列、绑定、虚拟主机、消息"><a href="#队列、绑定、虚拟主机、消息" class="headerlink" title="队列、绑定、虚拟主机、消息"></a>队列、绑定、虚拟主机、消息</h2><p><strong>绑定</strong>: exchange <strong>与之间的连接关系</strong>(<strong>通过路由规则</strong>) </p>
<p><strong>队列</strong>:<strong>用来存储消息的实体</strong> </p>
<p><strong>队列的属性</strong>: durability <strong>消息是否被持久化</strong> </p>
<p><strong>AutoDelete</strong> :<strong>表示最后一个监听被移除那么该队列就会被删除</strong> </p>
<p><strong>消息</strong>:<strong>用来生产着和消费者之间传递数据的</strong> </p>
<p><strong>消息属性</strong>: <strong>包括消息体</strong>body <strong>和属性</strong> properties </p>
<p><strong>常用属性</strong>:delivery mode <strong>，</strong>headers<strong>，</strong>content_type(<strong>消息类型</strong>) content_encoding(<strong>消息编码</strong>),priporty(<strong>消息优</strong> </p>
<p><strong>先级</strong>) ,correntlation_id(<strong>最为消息唯一的</strong>id),reply_to<strong>（消息失败做重回队列）</strong>,expiretion(<strong>消息的过期时</strong> </p>
<p><strong>间</strong>),message_id(<strong>消息</strong>id);timestamp,type,user_id <strong>，</strong>app_id,cluster_id<strong>等</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqMessageProducter</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException </span>&#123;<br><br>        <span class="hljs-comment">//3:通过连接工厂创建连接对象</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//4:通过连接创建channel</span><br>        Channel channel = connection.createChannel();<br><br>        Map&lt;String, Object&gt; headsMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        headsMap.put(<span class="hljs-string">&quot;company&quot;</span>, <span class="hljs-string">&quot;study&quot;</span>);<br>        headsMap.put(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;handsome boy&quot;</span>);<br><br>        AMQP.BasicProperties basicProperties = <span class="hljs-keyword">new</span> AMQP.BasicProperties().builder()<br>                .deliveryMode(<span class="hljs-number">2</span>)<span class="hljs-comment">//2标识持久化消息  1标识 服务重启后 消息不会被持久化</span><br>                .expiration(<span class="hljs-string">&quot;10000&quot;</span>)<span class="hljs-comment">//消息过期 10s</span><br>                .contentEncoding(<span class="hljs-string">&quot;utf-8&quot;</span>)<br>                .correlationId(UUID.randomUUID().toString())<br>                .headers(headsMap)<br>                .build();<br><br>        <span class="hljs-comment">//5:通过channel发送消息</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            String message = <span class="hljs-string">&quot;hello--&quot;</span> + i;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 老师以前讲过说我们的消息会发送的exchange上，</span><br><span class="hljs-comment">             * 但是在这里我们没有指定交换机?那我们的消息发送到哪里了？？？？</span><br><span class="hljs-comment">             * The default exchange is implicitly bound to every queue, with a routing key equal to the queue name.</span><br><span class="hljs-comment">             * It is not possible to explicitly bind to, or unbind from the default exchange. It also cannot be deleted.</span><br><span class="hljs-comment">             * 说明:加入我们消息发送的时候没有指定具体的交换机的话，那么就会发送到rabbimtq指定默认的交换机上，</span><br><span class="hljs-comment">             * 那么该交换机就会去根据routing_key 查找对应的queueName 然后发送的该队列上.</span><br><span class="hljs-comment">             *</span><br><span class="hljs-comment">             */</span><br>            channel.basicPublish(<span class="hljs-string">&quot;directchange&quot;</span>, <span class="hljs-string">&quot;directchange.key&quot;</span>, basicProperties, message.getBytes());<br>        &#125;<br><br>        <span class="hljs-comment">//6:关闭连接</span><br>        channel.close();<br>        connection.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqMessageConsumer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, TimeoutException, InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建连接</span><br>        Connection connection = ConnectionUtils.getConnection();<br>        <span class="hljs-comment">//创建一个channel</span><br>        Channel channel = connection.createChannel();<br><br>        String exchangeName = <span class="hljs-string">&quot;directchange&quot;</span>;<br>        String exchangeType = <span class="hljs-string">&quot;direct&quot;</span>;<br>        String queueName = <span class="hljs-string">&quot;directqueue&quot;</span>;<br>        String routingKey = <span class="hljs-string">&quot;directchange.key&quot;</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明一个交换机</span><br><span class="hljs-comment">         * exchange:交换机的名称</span><br><span class="hljs-comment">         * type:交换机的类型 常见的有direct,fanout,topic等</span><br><span class="hljs-comment">         * durable:设置是否持久化。durable设置为true时表示持久化，反之非持久化.持久化可以将交换器存入磁盘，在服务器重启的时候不会丢失相关信息</span><br><span class="hljs-comment">         * autodelete:设置是否自动删除。autoDelete设置为true时，则表示自动删除。自动删除的前提是至少有一个队列或者交换器与这个交换器绑定，之后，所有与这个交换器绑定的队列或者交换器都与此解绑。</span><br><span class="hljs-comment">         * 不能错误的理解—当与此交换器连接的客户端都断开连接时，RabbitMq会自动删除本交换器</span><br><span class="hljs-comment">         * arguments:其它一些结构化的参数，比如：alternate-exchange</span><br><span class="hljs-comment">         */</span><br>        channel.exchangeDeclare(exchangeName,exchangeType,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 声明一个队列</span><br><span class="hljs-comment">         */</span><br>        channel.queueDeclare(queueName,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">null</span>);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 队里和交换机绑定</span><br><span class="hljs-comment">         */</span><br>        channel.queueBind(queueName,exchangeName,routingKey);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 创建一个消费者</span><br><span class="hljs-comment">         */</span><br>        QueueingConsumer queueingConsumer = <span class="hljs-keyword">new</span> QueueingConsumer(channel);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 开始消费</span><br><span class="hljs-comment">         */</span><br>        channel.basicConsume(queueName,<span class="hljs-keyword">true</span>,queueingConsumer);<br><br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            QueueingConsumer.Delivery delivery = queueingConsumer.nextDelivery();<br>            String reserveMsg = <span class="hljs-keyword">new</span> String(delivery.getBody());<br>            System.out.println(<span class="hljs-string">&quot;encoding:&quot;</span>+delivery.getProperties().getContentEncoding());<br>            System.out.println(<span class="hljs-string">&quot;company:&quot;</span>+delivery.getProperties().getHeaders().get(<span class="hljs-string">&quot;company&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;correlationId:&quot;</span>+delivery.getProperties().getCorrelationId());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-MQ-05Kafka特性详解&amp;场景介绍</title>
    <url>/2022/06/11/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&amp;%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="Kafka特性详解-amp-场景介绍"><a href="#Kafka特性详解-amp-场景介绍" class="headerlink" title="Kafka特性详解&amp;场景介绍"></a>Kafka特性详解&amp;场景介绍</h1><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220611121058072.png" alt="image-20220611121058072"></p>
<h2 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h2><p>Kafka是最初由Linkedin公司开发，是一个<strong>分布式</strong>、<strong>支持分区</strong>的（partition）、<strong>多副本</strong>的（replica），==基于zookeeper==协调的分布式消息系统（官方称之为commit log）；它的最大的特性就是可以<strong>实时的处理大量数据</strong>以满足各种需求场景：比如基于hadoop的批处理系 统、低延迟的实时系统、Storm/Spark流式处理引擎，<strong>web/nginx日志、访问日志</strong>，消息服务等等，用scala语言编写， Linkedin于2010年贡献给了Apache基金会并成为顶级开源 项目。</p>
<h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><table>
<thead>
<tr>
<th><strong>名称</strong></th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>Broker</td>
<td>消息中间件处理节点，一个Kafka节点就是 一个broker，一个或者多个Broker可以组 成一个Kafka集群</td>
</tr>
<tr>
<td>Topic</td>
<td>Kafka根据topic对消息进行归类，发布到 Kafka集群的每条消息都需要指定一个topic</td>
</tr>
<tr>
<td>Producer</td>
<td>消息生产者，向Broker发送消息的客户端</td>
</tr>
<tr>
<td>Consumer</td>
<td>消息消费者，从Broker读取消息的客户端</td>
</tr>
<tr>
<td>ConsumerGroup</td>
<td>每个Consumer属于一个特定的Consumer Group，一条消息可以被多个不同的 Consumer Group消费，但是一个 Consumer Group中只能有一个Consumer 能够消费该消息</td>
</tr>
<tr>
<td>Partition</td>
<td>物理上的概念，一个topic可以分为多个</td>
</tr>
<tr>
<td>LEO</td>
<td>Log end offset Kafka 分区消息的终点，消息终止偏移，下一条消息的插入位置</td>
</tr>
<tr>
<td>HW</td>
<td>High water mark 高水位 用于控制消息可见性，HW 以下的消息对外可见，HW 的位置可能对应一条消息，但是对外不可见不可以消费，HW 的最大值是 LEO，<strong>分区 HW 就是 leader 副本的 HW 值</strong>=整个ISR分区所有副本的的LEO</td>
</tr>
<tr>
<td>LW</td>
<td>Low water mark，用于控制消息可见性，LW 及以上的消息对外可见</td>
</tr>
<tr>
<td>ISR</td>
<td>In sync replica 指满足副本同步要求的副本集合，包括领导者副本</td>
</tr>
</tbody></table>
<h3 id="主题Topic和消息日志Log"><a href="#主题Topic和消息日志Log" class="headerlink" title="主题Topic和消息日志Log"></a>主题Topic和消息日志Log</h3><p>让我们首先深入理解Kafka提出一个高层次的抽象概念-Topic。 可以理解Topic是一个类别的名称，同类消息发送到同一个Topic下面。对于每一个Topic，下面可以有多个分区</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220611140717313.png" alt="image-20220611140717313"></p>
<p>Partition是一个<strong>有序的message序列</strong>，这些message按顺序添加到一个叫做<strong>commit log的文件</strong>中。每partition中的 消息都有一个唯一的编号，称之为offset，用来唯一标示某个分区中的message；每个partition，都对应一个commit log文件。一个partition中的message的offset都是唯一的，但是不同的 partition中的message的offset可能是相同的。</p>
<p>kafka集群，在配置的时间范围内，维护所有的由producer生成的消息，而不管这些消息有没有被消费。<strong>例如</strong>日志保留( log retention )时间被设置为2天。kafka会维护最近2天生产的所有消息，而2天前的消息会被丢弃。kafka的性能与保留的数据量的大小没有关系，因此保存大量的数据(日志信息)不会有什么影响。 </p>
<p><strong>每个consumer是基于自己在commit log中的消费进度(offset)来进行工作的</strong>。在kafka中，<strong>消费offset由consumer自己来维护</strong>；一般情况下我们按照顺序逐条消费commit log中的消息，当然我可以通过指定offset来重复消费某些消息或者跳过某些消息。 这意味kafka中的consumer对集群的影响是非常小的，添加一个或者减少一个consumer，对于集群或者其他consumer来说，都是没有影响的，因为每个consumer维护各自的offset。<strong>所以说kafka集群是无状态的，性能不会因为consumer数量受太多影响。kafka还将很多关键信息记录在zookeeper里，保证自己的无状态，从而在水平扩容时非常方便。</strong></p>
<p><strong>为什么要对Topic下数据进行分区存储？</strong> </p>
<p>1、commit log文件会受到所在机器的文件系统大小的限制，分区之后，理论上一个topic可以处理任意数量的数据。 </p>
<p>2、为了<strong>提高并行度</strong>。</p>
<h3 id="分布式Distribution"><a href="#分布式Distribution" class="headerlink" title="分布式Distribution"></a>分布式Distribution</h3><p>log的partitions分布在kafka集群中不同的broker上，每个broker可以请求备份其他broker上partition上的数据。kafka 集群支持配置一个partition备份的数量。 针对每个partition，都有一个broker起到“leader”的作用，0个或多个其他的broker作为“follwers”的作用。 </p>
<p><strong>leader处理所有的针对这个partition的读写请求，而followers被动复制leader的结果</strong>。如果这个leader失效了，其中 的一个follower将会自动的变成新的leader</p>
<h3 id="Producers"><a href="#Producers" class="headerlink" title="Producers"></a>Producers</h3><p>生产者将消息发送到topic中去，同时负责选择将message发送到topic的哪一个partition中。通过round­robin做简单的 负载均衡。也可以根据消息中的某一个关键字来进行区分。通常第二种方式使用的更多</p>
<h3 id="Consumers"><a href="#Consumers" class="headerlink" title="Consumers"></a>Consumers</h3><p>传统的消息传递模式有2种：( queue) 和（publish-subscribe） </p>
<p><strong>queue模式</strong>：多个consumer从服务器中读取数据，消息只会到达一个consumer。 </p>
<p><strong>publish-subscribe模式</strong>：消息会被广播给所有的consumer。</p>
<p>Kafka基于这2种模式提供了一种consumer的抽象概念：consumer group。 </p>
<p>​    queue模式：所有的consumer都位于同一个consumer group 下。 </p>
<p>​    publish-subscribe模式：所有的consumer都有着自己唯一的consumer group。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220611142326746.png" alt="image-20220611142326746"></p>
<p>上图说明：由2个broker组成的kafka集群，总共有4个partition(P0-P3)。这个集群由2个Consumer Group， A有2个 consumer instances ，B有四个。 通常一个topic会有几个consumer group，每个consumer group都是一个逻辑上的订阅者（ logical subscriber ）。每个consumer group由多个consumer instance组成，从而达到可扩展和容灾的功能。</p>
<h3 id="消费顺序"><a href="#消费顺序" class="headerlink" title="消费顺序"></a>消费顺序</h3><p><strong>Kafka比传统的消息系统有着更强的顺序保证。 ==一个partition同一个时刻在一个consumer group中只有一个consumer instance在消费，从而保证顺序==。 consumer group中的consumer instance的数量不能比一个Topic中的partition的数量多，否则，多出来的 consumer消费不到消息</strong></p>
<p><strong>严格有序</strong></p>
<p>Kafka只在partition的范围内保证消息消费的局部顺序性，不能在同一个topic中的多个partition中保证总的消费顺序性。如果有在总体上保证消费顺序的需求，那么我们可以通过将topic的partition数量设置为1，将consumer group中的consumer instance数量也设置为1。</p>
<h2 id="Spring-Boot整合Kafka"><a href="#Spring-Boot整合Kafka" class="headerlink" title="Spring Boot整合Kafka"></a><strong>Spring Boot整合Kafka</strong></h2><p><strong>引入spring boot kafka依赖，详见项目实例：spring-boot-kafka</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-study<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.1.3.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span> <span class="hljs-comment">&lt;!-- lookup parent from repository --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kafka-clients<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.kafka<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-kafka<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>application.yml</strong>配置如下：</p>
<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">kafka:</span><br>    <span class="hljs-string">bootstrap‐servers:</span> <span class="hljs-string">localhost:9092,localhost:9093</span><br>    <span class="hljs-attr">producer:</span> <span class="hljs-comment"># 生产者</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">3</span> <span class="hljs-comment"># 设置大于0的值，则客户端会将发送失败的记录重新发送</span><br>      <span class="hljs-string">batch‐size:</span> <span class="hljs-number">16384</span><br>      <span class="hljs-string">buffer‐memory:</span> <span class="hljs-number">33554432</span><br>      <span class="hljs-comment"># 指定消息key和消息体的编解码方式</span><br>      <span class="hljs-string">key‐serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br>      <span class="hljs-string">value‐serializer:</span> <span class="hljs-string">org.apache.kafka.common.serialization.StringSerializer</span><br>    <span class="hljs-attr">consumer:</span><br>      <span class="hljs-string">group‐id:</span> <span class="hljs-string">mygroup</span><br>      <span class="hljs-string">enable‐auto‐commit:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure>

<p><strong>发送者代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaController</span> </span>&#123;<br>    <span class="hljs-meta">@Resource</span><br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String,String&gt; kafkaTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/send&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">()</span> </span>&#123;<br>        kafkaTemplate.send(<span class="hljs-string">&quot;mytopic&quot;</span>, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;key&quot;</span>, <span class="hljs-string">&quot;this is a msg&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>消费者代码：</strong> </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConsumer</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@KafkaListener</span>(groupId = &quot;testGroup&quot;, topicPartitions = &#123;</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@TopicPartition</span>(topic = &quot;topic1&quot;, partitions = &#123;&quot;0&quot;, &quot;1&quot;&#125;),</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@TopicPartition</span>(topic = &quot;topic2&quot;, partitions = &quot;0&quot;,</span><br><span class="hljs-comment">     * partitionOffsets = <span class="hljs-doctag">@PartitionOffset</span>(partition = &quot;1&quot;, initialOffset = &quot;100&quot;))</span><br><span class="hljs-comment">     * &#125;,concurrency = &quot;6&quot;)</span><br><span class="hljs-comment">     * //concurrency就是同组下的消费者个数，就是并发消费数，必须小于等于分区总数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> record</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@KafkaListener(topics = &quot;mytopic&quot;,groupId = &quot;testGroup&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">listen</span><span class="hljs-params">(ConsumerRecord&lt;String, String&gt; record)</span> </span>&#123;<br>        String value = record.value();<br>        System.out.println(value);<br>        System.out.println(record);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Kafka的使用场景"><a href="#Kafka的使用场景" class="headerlink" title="Kafka的使用场景"></a>Kafka的使用场景</h2><p>1、日志收集：一个公司可以用Kafka收集各种服务的log，通过kafka以统一接口服务的方式开放给各种 consumer，例如hadoop、Hbase、Solr等。</p>
<p>2、消息系统：解耦和生产者和消费者、缓存消息等。</p>
<p>3、用户活动跟踪：Kafka经常被用来记录web用户或者app用户的各种活动，如浏览网页、搜索、点击等活动，这 些活动信息被各个服务器发布到kafka的topic中，然后订阅者通过订阅这些topic来做实时的监控分析，或者装载到 hadoop、数据仓库中做离线分析和挖掘。 </p>
<p>4、运营指标：Kafka也经常用来记录运营监控数据。包括收集各种分布式应用的数据，生产各种操作的集中反 馈，比如报警和报告</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220611135409534.png" alt="image-20220611135409534"></p>
<p>普通ELK架构</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/18924448-e7c7d275694f8292.webp" alt="img"></p>
<p>flume替代logstash（Java等语言应用支持直接异步发送消息到kafka）</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220611134540976.png" alt="image-20220611134540976"></p>
<h2 id="Kafka最佳实践"><a href="#Kafka最佳实践" class="headerlink" title="Kafka最佳实践"></a>Kafka最佳实践</h2><p><strong>Kafka可视化管理工具kafka-manager</strong> </p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-05Kafka%E7%89%B9%E6%80%A7%E8%AF%A6%E8%A7%A3&%E5%9C%BA%E6%99%AF%E4%BB%8B%E7%BB%8D/image-20220612164527184.png" alt="image-20220612164527184"></p>
<p>安装及基本使用可参考：<a href="https://www.cnblogs.com/dadonggg/p/8205302.html">https://www.cnblogs.com/dadonggg/p/8205302.html</a> </p>
<h3 id="线上broker机器配置规划"><a href="#线上broker机器配置规划" class="headerlink" title="线上broker机器配置规划"></a>线上broker机器配置规划</h3><p>1、假设某电商公司的日志平台日均10亿条。</p>
<p>2、按照二八原则，80%的流量产生在20%时间内，所以8亿数据分布在4.8个小时里,假设4小时,QPS=6w</p>
<p>3、一般需要在QPS均值上放大5-10倍对应瞬间的流量高峰，也就是 6 * 5 = 30w/s的数据流量</p>
<p>4、topic一般设置副本数=2，也就是10 * 2 = 20亿数据，假设数据默认保留7天，则需要最大容量 20 * 7 =140亿数据</p>
<p>5、假设一条数据平均1kb的大小，140亿 * 1kb = 14T</p>
<p>6、根据第3、5点，规划5-6台物理机部署kafka比较稳妥，每台机器承载几万的QPS,且每台<strong>物理机</strong>分配3-4个T的<strong>机械硬盘（无需SSD，因为Kafka是顺序读写，不需要像Mysql那样随机读写）</strong></p>
<p>7、高峰每秒6w数据/s = 每秒传输60M数据，峰值300M，综合成本考虑用千兆<strong>网卡</strong></p>
<p>8、因为Kafka消息处理时用到的大部分是年轻代，且启动后处理线程较多，应该分配16核，考虑到峰值时1分钟产生18G，可以采用32G内存，老年代空间分配少些。</p>
<p>9、最终采用 6台 16核32G内存的物理机，每台机器配有3T机械硬盘、千兆网卡</p>
<h3 id="JVM参数设置"><a href="#JVM参数设置" class="headerlink" title="JVM参数设置"></a><strong>JVM参数设置</strong></h3><p>kafka是scala语言开发，运行在JVM上，需要对JVM参数合理设置，参看JVM调优专题 修改bin/kafka-start-server.sh中的jvm设置</p>
<figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">export</span> KAFKA_HEAP_OPTS=<span class="hljs-string">&quot;‐Xmx16G ‐Xms16G ‐Xmn12G ‐XX:MetaspaceSize=256M ‐XX:+UseG1GC ‐XX:MaxGCPauseMillis=50&quot;</span><br></code></pre></td></tr></table></figure>

<p>使用G1垃圾收集器的原因：</p>
<p>1、这种大内存的情况一般都要用G1垃圾收集器，因为年轻代内存比较大，用G1可以设置GC最大停顿时间，不至于一次minor gc就花费太长 时间</p>
<h3 id="线上问题及优化"><a href="#线上问题及优化" class="headerlink" title="线上问题及优化"></a>线上问题及优化</h3><h4 id="消息丢失情况"><a href="#消息丢失情况" class="headerlink" title="消息丢失情况"></a>消息丢失情况</h4><p><strong>消息发送端：</strong> </p>
<p>（1）acks=0： 表示producer不需要等待任何broker确认收到消息的回复，就可以继续发送下一条消息。性能最高，但是最容易丢消 息。大数据统计报表场景，对性能要求很高，对数据丢失不敏感的情况可以用这种。 </p>
<p>（2）acks=1： 至少要等待leader已经成功将数据写入本地log，但是不需要等待所有follower是否成功写入。就可以继续发送下一条消 息。这种情况下，如果follower没有成功备份数据，而此时leader又挂掉，则消息会丢失。 （3）acks=-1或all： 这意味着leader需要等待所有备份(min.insync.replicas配置的备份个数)都成功写入日志，这种策略会保证只要有一 个备份存活就不会丢失数据。这是最强的数据保证。一般除非是金融级别，或跟钱打交道的场景才会使用这种配置。当然如果 min.insync.replicas配置的是1则也可能丢消息，跟acks=1情况类似。</p>
<p><strong>min.insync.replicas</strong> 该参数是 Broker 端或主题级别的配置，表示 <strong>允许处理 <code>acks=all</code> 请求的最低 ISR 副本数</strong>（默认值为 1），当新的publisher推新消息时，ISR副本数小于<strong>min.insync.replicas</strong>，则直接拒绝写入。</p>
<p><strong>两者的协同工作流程</strong></p>
<ol>
<li><p><strong>写入流程步骤</strong></p>
<p><strong>步骤 1</strong>：生产者发送消息到 Leader 副本。</p>
<p><strong>步骤 2</strong> Leader 检查当前 ISR 副本数是否 ≥ min.insync.replicas</p>
<p>若否，直接拒绝写入，返回错误</p>
<p>若是，继续等待所有 ISR 副本写入成功</p>
<p><strong>步骤 3</strong>，所有 ISR 副本写入成功后，Leader 返回成功响应给生产者</p>
</li>
<li><p><strong>示例场景</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"><strong>ISR 副本数</strong></th>
<th align="center"><strong><code>min.insync.replicas</code></strong></th>
<th align="center"><strong>写入结果</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center">3</td>
<td align="center">2</td>
<td align="center">需 3 个副本写入成功。</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">2</td>
<td align="center">需 2 个副本写入成功。</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">2</td>
<td align="center">拒绝写入（ISR 副本数 &lt; min 值</td>
</tr>
</tbody></table>
<p><strong>消息消费端</strong>：<br>如果消费这边配置的是自动提交，万一消费到数据还没处理完，就自动提交offset了，但是此时你consumer直接宕机了，未处理完的数据 丢失了，下次也消费不到了。</p>
<p><strong>消息重复消费：</strong></p>
<p>如果发送端配置了重试机制，kafka不会等之前那条消息完全发送成功才去发送下一条消息，这样可能会出现，发送了1，2，3条消息，第 一条超时了，后面两条发送成功，再重试发送第1条消息，这时消息在broker端的顺序就是2，3，1了 所以，是否一定要配置重试要根据业务情况而定。也可以用同步发送的模式去发消息，当然acks不能设置为0，这样也能保证消息从发送 端到消费端全链路有序。</p>
<p><strong>消息积压</strong></p>
<p>1）线上有时因为发送方发送消息速度过快，或者消费方处理消息过慢，可能会导致broker积压大量未消费消息。 此种情况如果积压了上百万未消费消息需要紧急处理，可以修改消费端程序，让其将收到的消息快速转发到其他topic(可以设置很多分 区)，然后再启动多个消费者同时消费新主题的不同分区。</p>
<p>2）由于消息数据格式变动或消费者程序有bug，导致消费者一直消费不成功，也可能导致broker积压大量未消费消息。 此种情况可以将这些消费不成功的消息转发到其它队列里去(类似死信队列)，后面再慢慢分析死信队列里的消息处理问题。</p>
<p><strong>消息回溯</strong> </p>
<p>如果某段时间对已消费消息计算的结果觉得有问题，可能是由于程序bug导致的计算错误，当程序bug修复后，这时可能需要对之前已消 费的消息重新消费，可以指定从多久之前的消息回溯消费，这种可以用consumer的offsetsForTimes、seek等方法指定从某个offset偏移 的消息开始消费，参见上节课的内容。</p>
<p><strong>分区数越多吞吐量越高吗</strong></p>
<p>网络上很多资料都说分区数越多吞吐量越高 ， 但从压测结果来看，分区数到达某个值吞吐量反而开始下降，实际上很多事情都会有一个 临界值，当超过 这个临界值之后，很多原本符合既定逻辑的走向又会变得不同。<strong>一般情况分区数跟集群机器数量相当就差不多了</strong>。 当然吞吐量的数值和走势还会和磁盘、文件系统、 I/O调度策略等因素相关。 注意：如果分区数设置过大，比如设置10000，可能会设置不成功，后台会报错”java.io.IOException : Too many open files”。 异常中最关键的信息是“ Too many open flies”，这是一种常见的 Linux 系统错误，通常意味着文件描述符不足，它一般发生在创建线 程、创建 Socket、打开文件这些场景下 。 在 Linux系统的默认设置下，这个文件描述符的个数不是很多 ，通过 ulimit -n 命令可以查 看：一般默认是1024，可以将该值增大，比如：ulimit -n 65535</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-Redis01-核心数据接口与原理</title>
    <url>/2022/03/28/%E5%88%86%E5%B8%83%E5%BC%8F-Redis01-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h1 id="Redis简介"><a href="#Redis简介" class="headerlink" title="Redis简介"></a>Redis简介</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><p>​    关系型数据天然就是二维的、表格式的，因此存储在数据表的行和列中，支持ACID4大事务特性，数据模型可扩展性差、全文检索功能较弱</p>
<h2 id="NoSQL数据库"><a href="#NoSQL数据库" class="headerlink" title="NoSQL数据库"></a>NoSQL数据库</h2><p>​    Not Only SQL简称NoSQL，有灵活的数据模型，易扩展。有非常高的读写性能。无须事先为要存储的数据建立字段，随时可以存储自定义的数据格式</p>
<h2 id="NoSQL的应用场景"><a href="#NoSQL的应用场景" class="headerlink" title="NoSQL的应用场景"></a>NoSQL的应用场景</h2><p>1、高并发数据读写</p>
<p>2、数据接口易扩展</p>
<p>3、存储大量数据</p>
<p>4、速度快</p>
<p><strong>不适用场景：</strong></p>
<p>1、对事务要求较高的场景</p>
<p>2、不适合结构化的sql查询方案</p>
<h2 id="Redis的定义"><a href="#Redis的定义" class="headerlink" title="Redis的定义"></a>Redis的定义</h2><p>​    redis是一个key-value的内存存储数据结构服务器，一般用作高速缓存、分布式锁、临时数据库等等</p>
<h2 id="Memcache、Redis、MongoDB、HBase区别介绍"><a href="#Memcache、Redis、MongoDB、HBase区别介绍" class="headerlink" title="Memcache、Redis、MongoDB、HBase区别介绍"></a>Memcache、Redis、MongoDB、HBase区别介绍</h2><h3 id="Memcache"><a href="#Memcache" class="headerlink" title="Memcache"></a>Memcache</h3><p>1、支持简单的key-value模式存储，支持的数据结构很单一，仅支持string类型的操作</p>
<p>2、数据存储在内存中，不支持数据的持久化</p>
<h3 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h3><p>1、除了key-value外，还支持丰富的存储接口如string、set、zset、hash、list、hyperLogLog等</p>
<p>2、数据存储在内存中，支持AOF、RDB等持久化方式（支持备份）</p>
<p>3、一般做缓存数据库</p>
<p>4、覆盖Memcache的功能</p>
<h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>1、文档型数据库</p>
<p>2、数据都存在内存中、内存不足时把不常用的数据保存到硬盘</p>
<p>3、虽然是Key-value，但是对value（尤其是json）提供丰富的查询功能（比如sql）</p>
<p>4、支持二进制数据及大型对象</p>
<h3 id="HBase"><a href="#HBase" class="headerlink" title="HBase"></a>HBase</h3><p>1、适用于大数据环境</p>
<p>2、基于Hadoop，数据最终存储在HDFS</p>
<p>3、支持存储非常庞大的表，单表支持10亿行数据，并且支持上百万个列</p>
<h2 id="Redis-VS-MongDB"><a href="#Redis-VS-MongDB" class="headerlink" title="Redis VS MongDB"></a>Redis VS MongDB</h2><p>Redis主要把数据存储在内存中，其“缓存”的性质远大于其“数据存储“的性质，其中数据的增删改查也只是像变量操作一样简单；</p>
<p>MongoDB却是一个“存储数据”的系统，增删改查可以添加很多条件，就像SQL数据库一样灵活，这一点在面试的时候很受用。</p>
<h1 id="Redis安装与使用"><a href="#Redis安装与使用" class="headerlink" title="Redis安装与使用"></a>Redis安装与使用</h1><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs ··cmd">下载地址：http:&#x2F;&#x2F;redis.io&#x2F;download <br>安装步骤： <br># 安装gcc <br>yum install gcc <br># 把下载好的redis‐5.0.3.tar.gz放在&#x2F;usr&#x2F;local文件夹下，并解压 <br>wget http:&#x2F;&#x2F;download.redis.io&#x2F;releases&#x2F;redis‐5.0.3.tar.gz <br>tar xzf redis‐5.0.3.tar.gz<br>cd redis‐5.0.3 <br># 进入到解压好的redis‐5.0.3目录下，进行编译与安装 <br>make <br># 启动并指定配置文件 <br>src&#x2F;redis‐server redis.conf（注意要使用后台启动，所以修改redis.conf里的daemonize改为y es)<br># 验证启动是否成功 <br>ps ‐ef | grep redis <br># 进入redis客户端 <br>src&#x2F;redis‐cli <br># 退出客户端 <br>quit <br># 退出redis服务： <br>（1）pkill redis‐server <br>（2）kill 进程号 <br>（3）src&#x2F;redis‐cli shutdown<br></code></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs redis-6379.conf">pidfile &#x2F;var&#x2F;run&#x2F;redis_6379.pid<br>logfile &quot;6379.log&quot;<br>protected-mode no<br>port 6379<br>logfile &quot;6380.log&quot; <br>dir &#x2F;soft&#x2F;redis‐5.0.3&#x2F;6380 <br># bind 127.0.0.1 注释改行<br></code></pre></td></tr></table></figure>

<h2 id="StringRedisTemplate与RedisTemplate"><a href="#StringRedisTemplate与RedisTemplate" class="headerlink" title="StringRedisTemplate与RedisTemplate"></a><strong>StringRedisTemplate与RedisTemplate</strong></h2><p>spring 封装了 RedisTemplate 对象来进行对redis的各种操作，它支持所有的 redis 原生的 api。在 RedisTemplate中提供了几个常用的接口方法的使用，分别是:</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis01-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220410105536743.png" alt="image-20220410105536743"></p>
<p>StringRedisTemplate继承自RedisTemplate，也一样拥有上面这些操作。 StringRedisTemplate默认采用的是String的序列化策略，保存的key和value都是采用此策略序列化保存 的。RedisTemplate默认采用的是JDK的序列化策略，保存的key和value都是采用此策略序列化保存的。</p>
<p><strong>Redis客户端命令对应的RedisTemplate中的方法列表：</strong></p>
<table>
<thead>
<tr>
<th><strong>String类型结构</strong></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>Redis</td>
<td>RedisTemplate rt</td>
</tr>
<tr>
<td>set key value</td>
<td>rt.opsForValue().set(“key”,”value”)</td>
</tr>
<tr>
<td>get key</td>
<td>rt.opsForValue().get(“key”)</td>
</tr>
<tr>
<td>del key</td>
<td>rt.delete(“key”)</td>
</tr>
<tr>
<td>strlen key</td>
<td>rt.opsForValue().size(“key”)</td>
</tr>
<tr>
<td>getset key value</td>
<td>rt.opsForValue().getAndSet(“key”,”value”)</td>
</tr>
<tr>
<td>getrange key start end</td>
<td>rt.opsForValue().get(“key”,start,end)</td>
</tr>
<tr>
<td>append key value</td>
<td>rt.opsForValue().append(“key”,”value”)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Hash结构</strong></td>
<td></td>
</tr>
<tr>
<td>hmset key field1 value1 field2 value2…</td>
<td>rt.opsForHash().putAll(“key”,map) //map是一个集合对象</td>
</tr>
<tr>
<td>hset key field value</td>
<td>rt.opsForHash().put(“key”,”field”,”value”)</td>
</tr>
<tr>
<td>hexists key field</td>
<td>rt.opsForHash().hasKey(“key”,”field”)</td>
</tr>
<tr>
<td>hgetall key</td>
<td>rt.opsForHash().entries(“key”) //返回Map对象</td>
</tr>
<tr>
<td>hvals key</td>
<td>rt.opsForHash().values(“key”) //返回List对象</td>
</tr>
<tr>
<td>hkeys key</td>
<td>rt.opsForHash().keys(“key”) //返回List对象</td>
</tr>
<tr>
<td>hmget key field1 field2…</td>
<td>rt.opsForHash().multiGet(“key”,keyList)</td>
</tr>
<tr>
<td>hsetnx key field value</td>
<td>rt.opsForHash().putIfAbsent(“key”,”field”,”value”</td>
</tr>
<tr>
<td>hdel key field1 field2</td>
<td>rt.opsForHash().delete(“key”,”field1”,”field2”)</td>
</tr>
<tr>
<td>hget key field</td>
<td>rt.opsForHash().get(“key”,”field”)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>List结构</strong></td>
<td></td>
</tr>
<tr>
<td>lpush list node1 node2 node3…</td>
<td>rt.opsForList().leftPush(“list”,”node”)</td>
</tr>
<tr>
<td>rt.opsForList().leftPushAll(“list”,list) //list是集合对象</td>
<td></td>
</tr>
<tr>
<td>rpush list node1 node2 node3…</td>
<td>rt.opsForList().rightPush(“list”,”node”)</td>
</tr>
<tr>
<td>rt.opsForList().rightPushAll(“list”,list) //list是集合对象</td>
<td></td>
</tr>
<tr>
<td>lindex key index</td>
<td>rt.opsForList().index(“list”, index)</td>
</tr>
<tr>
<td>llen key</td>
<td>rt.opsForList().size(“key”)</td>
</tr>
<tr>
<td>lpop key</td>
<td>rt.opsForList().leftPop(“key”)</td>
</tr>
<tr>
<td>rpop key</td>
<td>rt.opsForList().rightPop(“key”)</td>
</tr>
<tr>
<td>lpushx list node</td>
<td>rt.opsForList().leftPushIfPresent(“list”,”node”)</td>
</tr>
<tr>
<td>rpushx list node</td>
<td>rt.opsForList().rightPushIfPresent(“list”,”node”)</td>
</tr>
<tr>
<td>lrange list start end</td>
<td>rt.opsForList().range(“list”,start,end)</td>
</tr>
<tr>
<td>lrem list count value</td>
<td>rt.opsForList().remove(“list”,count,”value”)</td>
</tr>
<tr>
<td>lset key index value</td>
<td>rt.opsForList().set(“list”,index,”value”)</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
<tr>
<td><strong>Set结构</strong></td>
<td></td>
</tr>
<tr>
<td>sadd key member1 member2…</td>
<td>rt.boundSetOps(“key”).add(“member1”,”member2”,…)</td>
</tr>
<tr>
<td>rt.opsForSet().add(“key”, set) //set是一个集合对象</td>
<td></td>
</tr>
<tr>
<td>scard key</td>
<td>rt.opsForSet().size(“key”)</td>
</tr>
<tr>
<td>sidff key1 key2</td>
<td>rt.opsForSet().difference(“key1”,”key2”) //返回一个集合对象</td>
</tr>
<tr>
<td>sinter key1 key2</td>
<td>rt.opsForSet().intersect(“key1”,”key2”)//同上</td>
</tr>
<tr>
<td>sunion key1 key2</td>
<td>rt.opsForSet().union(“key1”,”key2”)//同上</td>
</tr>
<tr>
<td>sdiffstore des key1 key2</td>
<td>rt.opsForSet().differenceAndStore(“key1”,”key2”,”des”)</td>
</tr>
<tr>
<td>sinter des key1 key2</td>
<td>rt.opsForSet().intersectAndStore(“key1”,”key2”,”des”)</td>
</tr>
<tr>
<td>sunionstore des key1 key2</td>
<td>rt.opsForSet().unionAndStore(“key1”,”key2”,”des”)</td>
</tr>
<tr>
<td>sismember key member</td>
<td>rt.opsForSet().isMember(“key”,”member”)</td>
</tr>
<tr>
<td>smembers key</td>
<td>rt.opsForSet().members(“key”)</td>
</tr>
<tr>
<td>spop key</td>
<td>rt.opsForSet().pop(“key”)</td>
</tr>
<tr>
<td>srandmember key count</td>
<td>rt.opsForSet().randomMember(“key”,count)</td>
</tr>
<tr>
<td>srem key member1 member2…</td>
<td>rt.opsForSet().remove(“key”,”member1”,”member2”,…)</td>
</tr>
</tbody></table>
<h1 id="Lua脚本"><a href="#Lua脚本" class="headerlink" title="Lua脚本"></a>Lua脚本</h1><p>代码示例上面已经给出：</p>
<p><strong>管道（Pipeline）</strong> </p>
<p><strong>客户端可以一次性发送多个请求而不用等待服务器的响应，待所有命令都发送完后再一次性读取服务的响应</strong>，这样可以极大的降低多条命令执行的网络传输开销，管道执行多条命令的网络开销实际上只相当于<strong>一 次命令执行的网络开销</strong>。需要注意到是用pipeline方式打包命令发送，<strong>redis必须在处理完所有命令前先缓存起所有命令的处理结果</strong>。打包的命令越多，缓存消耗内存也越多。所以并不是打包的命令越多越好。 pipeline中发送的每个command都会被server立即执行，如果执行失败，将会在此后的响应中得到信 息；也就是pipeline并不是表达“所有command都一起成功”的语义，管道中前面命令失败，后面命令 不会有影响，继续执行。</p>
<p><strong>特定</strong></p>
<p>1、<strong>减少网络开销</strong>：本来5次网络请求的操作，可以用一个请求完成，原先5次请求的逻辑放在redis服务器 上完成。使用脚本，减少了网络往返时延。这点跟管道类似</p>
<p>2、<strong>原子操作</strong>：Redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。管道不是原子的，不过 redis的批量操作命令(类似mset)是原子的</p>
<p>3、<strong>替代redis的事务功能</strong>：redis自带的事务功能很鸡肋，报错不支持回滚，而redis的lua脚本几乎实现了 常规的事务功能，支持报错回滚操作，官方推荐如果要使用redis的事务功能可以用redis lua替代</p>
<p>注意，不要在Lua脚本中出现死循环和耗时的运算，否则redis会阻塞，将不接受其他的命令， 所以使用 时要注意不能出现死循环、耗时的运算。redis是单进程、单线程执行脚本。管道不会阻塞redis。</p>
<h1 id="Redis核心数据结构与原理"><a href="#Redis核心数据结构与原理" class="headerlink" title="Redis核心数据结构与原理"></a>Redis核心数据结构与原理</h1><h2 id="Redis核心数据结构与应用"><a href="#Redis核心数据结构与应用" class="headerlink" title="Redis核心数据结构与应用"></a>Redis核心数据结构与应用</h2><h3 id="Redis核心数据结构"><a href="#Redis核心数据结构" class="headerlink" title="Redis核心数据结构"></a>Redis核心数据结构</h3><p><strong>5种核心数据结构</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220328223125611.png" alt="image-20220328223125611"></p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p><strong>字符串常用操作</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">SET</span>  key  value 			//存入字符串键值对<br>MSET  key  value [key value ...] 	//批量存储字符串键值对<br>SETNX  key  value 		//存入一个不存在的字符串键值对<br>GET  key 			//获取一个字符串键值<br>MGET  key  [key ...]	 	//批量获取字符串键值<br><span class="hljs-built_in">DEL</span>  key  [key ...] 		//删除一个键<br>EXPIRE  key  seconds 		//设置一个键的过期时间(秒)<br></code></pre></td></tr></table></figure>

<p><strong>原子加减</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">INCR  key 			//将key中储存的数字值加<span class="hljs-number">1</span><br>DECR  key 			//将key中储存的数字值减<span class="hljs-number">1</span><br>INCRBY  key  increment 		//将key所储存的值加上increment<br>DECRBY  key  decrement 	//将key所储存的值减去decrement<br></code></pre></td></tr></table></figure>

<p><strong>String应用场景</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">单值缓存<br><span class="hljs-built_in">SET</span>  key  value 	<br>GET  key <br><br>对象缓存<br><span class="hljs-number">1</span>) <span class="hljs-built_in">SET</span>  user:<span class="hljs-number">1</span>  value(json格式数据)<br><span class="hljs-number">2</span>) MSET  user:<span class="hljs-number">1</span>:name  zhuge   user:<span class="hljs-number">1</span>:balance  <span class="hljs-number">1888</span><br>   MGET  user:<span class="hljs-number">1</span>:name   user:<span class="hljs-number">1</span>:balance <br>   <br>分布式锁<br>SETNX  product:<span class="hljs-number">10001</span>  true 		//返回<span class="hljs-number">1</span>代表获取锁成功<br>SETNX  product:<span class="hljs-number">10001</span>  true 		//返回<span class="hljs-number">0</span>代表获取锁失败<br>。。。执行业务操作<br><span class="hljs-built_in">DEL</span> product:<span class="hljs-number">10001</span>			//执行完业务释放锁<br><span class="hljs-built_in">SET</span> product:<span class="hljs-number">10001</span> true  ex  <span class="hljs-number">10</span>  nx	//防止程序意外终止导致死锁<br><br>计数器<br>INCR article:readcount:&#123;文章id&#125;  <br>GET article:readcount:&#123;文章id&#125; <br><br>Web集群session共享<br>spring session + redis实现session共享<br><br>分布式系统全局序列号(一个机器一次拿<span class="hljs-number">1000</span>个缓存在本地，用完再继续拿)<br>INCRBY  orderId  <span class="hljs-number">1000</span>		//redis批量生成序列号提升性能<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220329211712401.png" alt="image-20220329211712401"></p>
<h4 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h4><p><strong>Hash常用操作</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">HSET  key  field  value 			//存储一个哈希表key的键值<br>HSETNX  key  field  value 		//存储一个不存在的哈希表key的键值<br>HMSET  key  field  value [field value ...] 	//在一个哈希表key中存储多个键值对<br>HGET  key  field 				//获取哈希表key对应的field键值<br>HMGET  key  field  [field ...] 		//批量获取哈希表key中多个field键值<br>HDEL  key  field  [field ...] 		//删除哈希表key中的field键值<br>HLEN  key					//返回哈希表key中field的数量<br>HGETALL  key				//返回哈希表key中所有的键值<br>HINCRBY  key  field  increment 		//为哈希表key中field键的值加上增量increment<br></code></pre></td></tr></table></figure>

<p><strong>Hash应用场景</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">对象缓存<br>HMSET  user  &#123;userId&#125;:name  zhuge &#123;userId&#125;:balance  <span class="hljs-number">1888</span><br>HMSET  user  <span class="hljs-number">1</span>:name  zhuge <span class="hljs-number">1</span>:balance  <span class="hljs-number">1888</span><br>HMGET  user  <span class="hljs-number">1</span>:name  <span class="hljs-number">1</span>:balance<br></code></pre></td></tr></table></figure>

<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">电商购物车<br><span class="hljs-number">1</span>）以用户id为key<br><span class="hljs-number">2</span>）商品id为field<br><span class="hljs-number">3</span>）商品数量为value<br><br>购物车操作<br><span class="hljs-number">1</span>）添加商品hset cart:<span class="hljs-number">1001</span> <span class="hljs-number">10088</span> <span class="hljs-number">1</span><br><span class="hljs-number">2</span>）增加数量hincrby cart:<span class="hljs-number">1001</span> <span class="hljs-number">10088</span> <span class="hljs-number">1</span><br><span class="hljs-number">3</span>）商品总数hlen cart:<span class="hljs-number">1001</span><br><span class="hljs-number">4</span>）删除商品hdel cart:<span class="hljs-number">1001</span> <span class="hljs-number">10088</span><br><span class="hljs-number">5</span>）获取购物车所有商品hgetall cart:<span class="hljs-number">1001</span><br></code></pre></td></tr></table></figure>

<p><strong>优缺点</strong></p>
<p><strong>优点</strong></p>
<p>1）同类数据归类整合储存，方便数据管理<br>2）相比string操作消耗内存与cpu更小<br>3）相比string储存更节省空间</p>
<p><strong>缺点</strong></p>
<p>1）过期功能不能使用在field上，只能用在key上</p>
<p>2）Redis集群架构下不适合大规模使用（由于集群模式根据key来确定存储在那个节点，如果某个hset存储内容过多，会造成某个节点的存储量偏大，造成数据分布不均匀）</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220329212006826.png" alt="image-20220329212006826"></p>
<h4 id="List结构"><a href="#List结构" class="headerlink" title="List结构"></a>List结构</h4><p><strong>List常用操作</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">LPUSH  key  value [value ...] 		//将一个或多个值value插入到key列表的表头(最左边)<br>RPUSH  key  value [value ...]	 	//将一个或多个值value插入到key列表的表尾(最右边)<br>LPOP  key			//移除并返回key列表的头元素<br>RPOP  key			//移除并返回key列表的尾元素<br>LLen  key    		//返回key的长度<br>LRANGE  key  <span class="hljs-built_in">start</span>  stop		//返回列表key中指定区间内的元素，区间以偏移量<span class="hljs-built_in">start</span>和stop指定<br><br>BLPOP  key  [key ...]  timeout	//从key列表表头弹出一个元素，若列表中没有元素，阻塞等待					timeout秒,如果timeout=<span class="hljs-number">0</span>,一直阻塞等待<br>BRPOP  key  [key ...]  timeout 	//从key列表表尾弹出一个元素，若列表中没有元素，阻塞等待					timeout秒,如果timeout=<span class="hljs-number">0</span>,一直阻塞等待<br></code></pre></td></tr></table></figure>

<p><strong>List应用场景</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">Stack(栈) = LPUSH + LPOP  FILO<br>Queue(队列）= LPUSH + RPOP<br>Blocking MQ(阻塞队列）= LPUSH + BRPOP<br></code></pre></td></tr></table></figure>

<p>诸葛微博消息和微信公号消息</p>
<p>微博关注了MacTalk，备胎说车等大V</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">1</span>）MacTalk发微博，消息ID为<span class="hljs-number">10018</span><br>LPUSH  msg:&#123;诸葛老师-ID&#125;  <span class="hljs-number">10018</span><br><span class="hljs-number">2</span>）备胎说车发微博，消息ID为<span class="hljs-number">10086</span><br>LPUSH  msg:&#123;诸葛老师-ID&#125; <span class="hljs-number">10086</span><br><span class="hljs-number">3</span>）查看最新的<span class="hljs-number">5</span>条关注微博消息<br>LRANGE  msg:&#123;诸葛老师-ID&#125;  <span class="hljs-number">0</span>  <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220330220809036.png" alt="image-20220330220809036"></p>
<h4 id="Set结构"><a href="#Set结构" class="headerlink" title="Set结构"></a>Set结构</h4><p><strong>Set常用操作</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">Set</span>常用操作<br>SADD  key  member  [member ...]			//往集合key中存入元素，元素存在则忽略，						若key不存在则新建<br>SREM  key  member  [member ...]			//从集合key中删除元素<br>SMEMBERS  key					//获取集合key中所有元素<br>SCARD  key					//获取集合key的元素个数<br>SISMEMBER  key  member			//判断member元素是否存在于集合key中<br>SRANDMEMBER  key  [count]			//从集合key中选出count个元素，元素不从key中删除<br>SPOP  key  [count]				//从集合key中选出count个元素，元素从key中删除<br><br><span class="hljs-built_in">Set</span>运算操作<br>SINTER  key  [key ...] 				//交集运算<br>SINTERSTORE  destination  key  [key ..]		//将交集结果存入新集合destination中<br>SUNION  key  [key ..] 				//并集运算<br>SUNIONSTORE  destination  key  [key ...]		//将并集结果存入新集合destination中<br>SDIFF  key  [key ...] 				//差集运算<br>SDIFFSTORE  destination  key  [key ...]		//将差集结果存入新集合destination中<br><br></code></pre></td></tr></table></figure>

<p><strong>Set应用场景</strong></p>
<p>微信抽奖小程序</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">1</span>）点击参与抽奖加入集合<br>SADD key &#123;userlD&#125;<br><span class="hljs-number">2</span>）查看参与抽奖所有用户<br>SMEMBERS key	  <br><span class="hljs-number">3</span>）抽取count名中奖者<br>SRANDMEMBER key [count] / SPOP key [count]<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220330221547322.png" alt="image-20220330221547322"></p>
<p>微信微博点赞，收藏，标签</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">微信微博点赞，收藏，标签<br><span class="hljs-number">1</span>) 点赞<br>SADD  like:&#123;消息ID&#125;  &#123;用户ID&#125;<br><span class="hljs-number">2</span>) 取消点赞<br>SREM like:&#123;消息ID&#125;  &#123;用户ID&#125;<br><span class="hljs-number">3</span>) 检查用户是否点过赞<br>SISMEMBER  like:&#123;消息ID&#125;  &#123;用户ID&#125;<br><span class="hljs-number">4</span>) 获取点赞的用户列表<br>SMEMBERS like:&#123;消息ID&#125;<br><span class="hljs-number">5</span>) 获取点赞用户数 <br>SCARD like:&#123;消息ID&#125;<br><br></code></pre></td></tr></table></figure>

<p>集合操作</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">SINTER set1 set2 set3   &#123; c &#125;<br>SUNION set1 set2 set3 	&#123; a,b,c,d,e &#125;<br>SDIFF set1 set2 set3 	&#123; a &#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220330222741101.png" alt="image-20220330222741101"></p>
<p>集合操作实现微博微信关注模型</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">集合操作实现微博微信关注模型<br><span class="hljs-number">1</span>) 诸葛老师关注的人: <br>zhugeSet-&gt; &#123;yangguo, sima, luban&#125;<br><span class="hljs-number">2</span>) 杨过老师关注的人:<br> yangguoSet--&gt; &#123;zhuge, sima, luban,guojia&#125;<br><span class="hljs-number">3</span>) 司马老师关注的人: <br>simaSet-&gt; &#123;zhuge, yangguo, guojia, luban, xunyu)<br><span class="hljs-number">4</span>) 我和杨过老师共同关注: <br>SINTER zhugeSet yangguoSet--&gt; &#123;sima, luban&#125;<br><span class="hljs-number">5</span>) 我关注的人也关注他(杨过老师): <br>SISMEMBER simaSet yangguo <br>SISMEMBER lubanSet yangguo<br><span class="hljs-number">6</span>) 我可能认识的人: <br>SDIFF yangguoSet zhugeSet-&gt;(zhuge, guojia&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220330222922268.png" alt="image-20220330222922268"></p>
<p>集合操作实现电商商品筛选</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">集合操作实现电商商品筛选<br>SADD  brand:huawei  P30<br>SADD  brand:xiaomi  mi-<span class="hljs-number">6</span>X<br>SADD  brand:iPhone iphone8<br>SADD os:android  P30  mi-<span class="hljs-number">6</span>X<br>SADD cpu:brand:intel  P30  mi-<span class="hljs-number">6</span>X<br>SADD ram:<span class="hljs-number">8</span>G  P30  mi-<span class="hljs-number">6</span>X  iphone8<br><br>SINTER  os:android  cpu:brand:intel  ram:<span class="hljs-number">8</span>G   &#123;P30，mi-<span class="hljs-number">6</span>X&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220330223600732.png" alt="image-20220330223600732"></p>
<h4 id="Zset结构"><a href="#Zset结构" class="headerlink" title="Zset结构"></a>Zset结构</h4><p><strong>ZSet常用操作</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">ZSet常用操作<br>ZADD key score member [[score member]…]	//往有序集合key中加入带分值元素<br>ZREM key member [member …]		//从有序集合key中删除元素<br>ZSCORE key member 			//返回有序集合key中元素member的分值<br>ZINCRBY key increment member		//为有序集合key中元素member的分值加上increment <br>ZCARD key				//返回有序集合key中元素个数<br>ZRANGE key <span class="hljs-built_in">start</span> stop [WITHSCORES]	//正序获取有序集合key从<span class="hljs-built_in">start</span>下标到stop下标的元素<br>ZREVRANGE key <span class="hljs-built_in">start</span> stop [WITHSCORES]	//倒序获取有序集合key从<span class="hljs-built_in">start</span>下标到stop下标的元素<br>Zset集合操作<br>ZUNIONSTORE destkey numkeys key [key ...] 	//并集计算<br>ZINTERSTORE destkey numkeys key [key …]	//交集计算<br></code></pre></td></tr></table></figure>

<p><strong>Zset应用场景</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">Zset集合操作实现排行榜<br><span class="hljs-number">1</span>）点击新闻<br>ZINCRBY  hotNews:<span class="hljs-number">20190819</span>  <span class="hljs-number">1</span>  守护香港<br><span class="hljs-number">2</span>）展示当日排行前十<br>ZREVRANGE  hotNews:<span class="hljs-number">20190819</span>  <span class="hljs-number">0</span>  <span class="hljs-number">10</span>  WITHSCORES <br><span class="hljs-number">3</span>）七日搜索榜单计算<br>ZUNIONSTORE  hotNews:<span class="hljs-number">20190813</span>-<span class="hljs-number">20190819</span>  <span class="hljs-number">7</span> <br><span class="hljs-function">hotNews:20190813  <span class="hljs-title">hotNews</span>:20190814... <span class="hljs-title">hotNews</span>:20190819</span><br><span class="hljs-function">4）展示七日排行前十</span><br><span class="hljs-function"><span class="hljs-title">ZREVRANGE</span> <span class="hljs-title">hotNews</span>:20190813-20190819  0  10  <span class="hljs-title">WITHSCORES</span></span><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F05-Redis%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220330224305930.png" alt="image-20220330224305930"></p>
<h4 id="HyperLogLog"><a href="#HyperLogLog" class="headerlink" title="HyperLogLog"></a>HyperLogLog</h4><p>​    Redis HyperLogLog 是用来做基数统计的算法</p>
<p>​    基数计算（cardinality counting）指的是统计一批数据中的不重复元素的个数，常见于计算独立用户数（UV）、维度的独立取值数等等</p>
<h4 id="Redis更多应用场景"><a href="#Redis更多应用场景" class="headerlink" title="Redis更多应用场景"></a>Redis更多应用场景</h4><p>微博、微信、陌陌&lt;附近的人&gt;<br>微信&lt;摇一摇&gt;&lt;抢红包&gt;<br>滴滴打车、摩拜单车&lt;附近的车&gt;<br>美团和饿了么&lt;附近的餐馆&gt;<br>搜索自动补全<br>布隆过滤器<br>。。。</p>
<h2 id="Redis核心原理"><a href="#Redis核心原理" class="headerlink" title="Redis核心原理"></a>Redis核心原理</h2><h3 id="Redis-为什么一开始选择单线程模型"><a href="#Redis-为什么一开始选择单线程模型" class="headerlink" title="Redis 为什么一开始选择单线程模型"></a>Redis 为什么一开始选择单线程模型</h3><p>​    因为Redis是一个基于内存的数据库，还要处理大量的外部的网络请求，这就不可避免的要进行多次IO。好在Redis使用了很多优秀的机制来保证了它的高效率。那么为什么Redis要设计成单线程模式的呢？</p>
<h4 id="1、IO多路复用"><a href="#1、IO多路复用" class="headerlink" title="1、IO多路复用"></a>1、IO多路复用</h4><p>Redis在网络I/O模型上采用了多路复用技术，来减少网络瓶颈带来的影响。很多场景中使用单线程模型并不意味着程序不能并发的处理任务。<strong>Redis 虽然使用单线程模型处理用户的请求，但是它却使用 I/O 多路复用技术“并行”处理来自客户端的多个连接，同时等待多个连接发送的请求</strong>。使用 I/O 多路复用技术能极大地减少系统的开销，系统不再需要为每个连接创建专门的监听线程，避免了由于大量的线程创建带来的巨大性能开销。</p>
<h4 id="2、可维护性"><a href="#2、可维护性" class="headerlink" title="2、可维护性"></a>2、可维护性</h4><p>多线程模型虽然在某些方面表现优异，但是它却引入了程序执行顺序的不确定性，带来了并发读写的一系列问题。单线程模式下，可以方便地进行调试和测试。</p>
<h4 id="3、基于内存操作"><a href="#3、基于内存操作" class="headerlink" title="3、基于内存操作"></a>3、基于内存操作</h4><p>多线程能够充分利用 CPU 的资源，但对于Redis来说，由于基于内存速度那是相当的高，能达到在一秒内处理10万个用户请求，如果一秒十万还不能满足，那我们就可以使用 Redis 分片的技术来交给不同的 Redis 服务器。这样的做饭避免了在同一个 Redis 服务中引入大量的多线程操作。 而且基于内存，除非是要进行 AOF 备份，否则基本上不会涉及任何的 I/O 操作。这些数据的读写由于只发生在内存中，所以处理速度是非常快的；用多线程模型处理全部的外部请求可能不是一个好的方案</p>
<h4 id="4、线程上下文切换问题"><a href="#4、线程上下文切换问题" class="headerlink" title="4、线程上下文切换问题"></a>4、线程上下文切换问题</h4><p>多线程场景下会发生线程上下文切换。线程是由 CPU 调度的，CPU 的一个核在一个时间片内只能同时执行一个线程，在 CPU 由线程A切换到线程B的过程中会发生一系列的操作，主要过程包括保存线程A的执行现场，然后载入线程B的执行现场，这个过程就是“线程上下文切换”。其中涉及线程相关指令的保存和恢复。 频繁的线程上下文切换可能会导致性能急剧下降，这会导致我们不仅没有提升处理请求的速度，反而降低了性能。</p>
<h3 id="Redis6-0之前的版本真的是单线程？"><a href="#Redis6-0之前的版本真的是单线程？" class="headerlink" title="Redis6.0之前的版本真的是单线程？"></a>Redis6.0之前的版本真的是单线程？</h3><p>​    Redis在处理客户端的请求时，包括获取 (socket 读)、解析、执行、内容返回 (socket 写) 等都由一个顺序串行的主线程处理，这就是所谓的“单线程”。但如果严格来讲从Redis4.0之后并不是单线程，除了主线程外，它也有后台线程在处理一些较为缓慢的操作，例如清理脏数据、无用连接的释放、大key的删除等等</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis01-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20221218205038561.png" alt="image-20221218205038561"></p>
<h3 id="Redis6-0为什么引入多线程？"><a href="#Redis6-0为什么引入多线程？" class="headerlink" title="Redis6.0为什么引入多线程？"></a>Redis6.0为什么引入多线程？</h3><p>​    <a href="https://blog.csdn.net/wuhuayangs/article/details/121924027">参考文档</a></p>
<p>​    简单来说，可以充分利用服务器CPU资源，目前主线程只能利用一个核，多线程任务可以分摊Redis同步IO读写负荷。</p>
<p>Redis 将所有数据放在内存中，内存的响应时长大约为100纳秒，对于小数据包，Redis 服务器可以处理80,000到100,000 QPS，这也是Redis处理的极限了，对于80%的公司来说，单线程的Redis已经足够使用了。</p>
<p>但随着越来越复杂的业务场景，有些公司动不动就上亿的交易量，因此需要更大的QPS。</p>
<p>常见的解决方案是在分布式架构中对数据进行分区并采用多个服务器，但该方案有非常大的缺点，例如要管理的Redis服务器太多，维护代价大；某些适用于单个 Redis 服务器的命令不适用于数据分区；数据分区无法解决热点读/写问题；数据偏斜，重新分配和放大/缩小变得更加复杂等等。</p>
<p>虽然现在很多服务器都是多个 CPU 核的，但是对于Redis来说，因为使用了单线程，在一次数据操作的过程中，有大量的 CPU 时间片是耗费在了网络 IO 的同步处理上的，并没有充分的发挥出多核的优势。</p>
<p>如果能采用多线程，使得网络处理的请求并发进行，就可以大大的提升性能。多线程除了可以减少由于网络 I/O 等待造成的影响，还可以充分利用 CPU 的多核优势。</p>
<p>​    <strong>Redis6.0引入的多线程部分，实际上只是用来处理网络数据的读写和协议解析，执行命令仍然是单一工作线程</strong>，而且多线程开关默认关闭</p>
<h3 id="Zset的底层原理"><a href="#Zset的底层原理" class="headerlink" title="Zset的底层原理"></a>Zset的底层原理</h3><h4 id="底层结构"><a href="#底层结构" class="headerlink" title="底层结构"></a>底层结构</h4><p>底层实现 = hash（映射分数和成员） +  压缩列表(zipList) 或者 跳表(skipList)</p>
<h4 id="什么是跳表"><a href="#什么是跳表" class="headerlink" title="什么是跳表"></a>什么是跳表</h4><p>跳表在 Redis 的 zset 中主要用于支持范围查询操作，因为它能够在对数时间复杂度内完成查找、插入和删除操作。跳表实际上是一种多层有序链表，每一层链表都是有序的，且层数越高的链表包含的节点越少，这样通过多层链表的辅助，可以快速定位到目标节点。</p>
<h4 id="什么时候用跳表"><a href="#什么时候用跳表" class="headerlink" title="什么时候用跳表"></a>什么时候用跳表</h4><p>当 ZSET 中的元素数量较小时，Redis 会选择使用有序数组作为底层实现。这是因为有序数组在内存使用效率上更高，而且对于较小的集合来说，插入、删除和查找操作的时间复杂度都很低。</p>
<p>然而，当 ZSET 中的元素数量较大时，Redis 会自动将底层实现从有序数组切换为跳跃表。跳跃表在处理大型有序集合时更加高效，因为它可以在对数时间内完成插入、删除和查找操作，并且在内存占用上也比较合理。</p>
<h4 id="跳表和红黑树的对比"><a href="#跳表和红黑树的对比" class="headerlink" title="跳表和红黑树的对比"></a>跳表和红黑树的对比</h4><p>总的来说，跳表和红黑树的查询复杂度都能达到O(LogN)，但是红黑树在增删过程中需要平衡，实现难度比较复杂，而跳表需要维护多个链表，就空间而言需要更多内存，但更为直观。</p>
<h4 id="使用zipList的条件"><a href="#使用zipList的条件" class="headerlink" title="使用zipList的条件"></a>使用zipList的条件</h4><ol>
<li><strong>成员数量小于128个：</strong> 当成员数量较少时，使用有序数组作为底层实现更为合适。有序数组可以通过紧凑的方式存储成员和分数，节省内存空间，并且在插入、删除和查找操作上有较低的时间复杂度。因此，当成员数量较少时，使用有序数组可以更有效地利用内存和提高性能。</li>
<li><strong>每个成员的字符串长度小于64个字节：</strong> 在有序数组中，每个成员都需要存储其对应的字符串以及相关的分数。为了保持内存占用的合理性，限制每个成员的字符串长度可以有效控制存储空间的使用。较短的字符串长度意味着每个成员占用的空间更小，从而可以存储更多的成员在有限的内存空间内。</li>
</ol>
<h2 id="其他高级命令"><a href="#其他高级命令" class="headerlink" title="其他高级命令"></a>其他高级命令</h2><h3 id="keys"><a href="#keys" class="headerlink" title="keys"></a>keys</h3><p>keys： 全量遍历键，用来列出所有满足特定正则字符串规则的key，当redis数据量比较大时， 性能比较差，要避免使用</p>
<p>1、keys  *</p>
<p>2、keys  a*</p>
<h3 id="scan"><a href="#scan" class="headerlink" title="scan"></a>scan</h3><p><strong>scan：渐进式遍历键</strong>：SCAN cursor [MATCH pattern] [COUNT count] scan 参数提供了三个参数，第一个是 cursor 整数值，第二个是 key 的正则模式，第三个是一次遍 历的key的数量，并不是符合条件的结果数量。第一次遍历时，cursor 值为 0，然后将返回结果中第 一个整数值作为下一次遍历的 cursor。一直遍历到返回的 cursor 值为 0 时结束。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis01-%E6%A0%B8%E5%BF%83%E6%95%B0%E6%8D%AE%E6%8E%A5%E5%8F%A3%E4%B8%8E%E5%8E%9F%E7%90%86/image-20220404200315343.png" alt="image-20220404200315343"></p>
<h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a><strong>Info</strong></h3><p><strong>Info：</strong>查看redis服务运行信息，分为 9 大块，每个块都有非常多的参数，这 9 个块分别是: </p>
<p>Server 服务器运行的环境参数 </p>
<p>Clients 客户端相关信息 </p>
<p>Memory 服务器运行内存统计数据 </p>
<p>Persistence 持久化信息 </p>
<p>Stats 通用统计数据 </p>
<p>Replication 主从复制相关信息 </p>
<p>CPU CPU 使用情况 </p>
<p>Cluster 集群信息 </p>
<p>KeySpace 键值对统计数量信息</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-Redis04-缓存设计与性能优化</title>
    <url>/2022/04/13/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h1 id="缓存设计与性能优化"><a href="#缓存设计与性能优化" class="headerlink" title="缓存设计与性能优化"></a>缓存设计与性能优化</h1><h2 id="多级缓存架构"><a href="#多级缓存架构" class="headerlink" title="多级缓存架构"></a>多级缓存架构</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8F%E7%94%B5%E5%95%86%E7%BD%91%E7%AB%99%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.png" alt="img"></p>
<h2 id="缓存设计"><a href="#缓存设计" class="headerlink" title="缓存设计"></a>缓存设计</h2><h3 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h3><p>定义：缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220417105957154.png" alt="image-20220417105957154"></p>
<p>​    <strong>缓存穿透是指查询一个根本不存在的数据， 缓存层和存储层都不会命中， 通常出于容错的考虑， 如果从存储层查不到数据则不写入缓存层</strong>：缓存穿透将导致不存在的数据每次请求都要到存储层去查询， 失去了缓存保护后端存储的意义。</p>
<h4 id="造成缓存穿透的原因"><a href="#造成缓存穿透的原因" class="headerlink" title="造成缓存穿透的原因"></a><strong>造成缓存穿透的原因</strong></h4><p>1、恶意攻击、爬虫等照成大量空命中</p>
<p>2、自身业务代码或者数据出现错误</p>
<h4 id="解决办法"><a href="#解决办法" class="headerlink" title="解决办法"></a>解决办法</h4><p>1、缓存空对象（<strong>设置较短的过期时间</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、布隆过滤器(redisson有实现)</p>
<p>对于恶意攻击，向服务器请求大量不存在的数据造成的缓存穿透，还可以用布隆过滤器先做一次过滤，对于不存在的数据布隆过滤器一般都能够过滤掉，不让请求再往后端发送。<strong>当布隆过滤器说某个值存在时，这个值可能不存在；当它说不存在时，那就肯定不存在。布隆过滤器就是一个大型的位数组和几个不一样的无偏 hash 函数</strong>。所谓无偏就是能够把元素的 hash 值算得 比较均匀。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20220417111129125.png" alt="image-20220417111129125"></p>
<p>向布隆过滤器中添加 key 时，会使用多个 hash 函数对 key 进行 hash 算得一个整数索引值然后对位数组长度进行取模运算得到一个位置，每个 hash 函数都会算得一个不同的位置。再把位数组的这几个位置都置为 1 就完成了 add 操作。</p>
<p>向布隆过滤器询问 key 是否存在时，跟 add 一样，也会把 hash 的几个位置都算出来，看看位数组中这几个位置是否都为 1，只要有一个位为 0，那么说明布隆过滤器中这个key 不存在。如果都是 1，这并不能说明这个 key 就一定存在，只是极有可能存在，因为这些位被置为 1 可能是因为其它的 key 存在所致。如果这个位数组比较稀疏，这个概率就会很大，如果这个位数组比较拥挤，这个概率就会降低。</p>
<p><strong>这种方法适用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景， 代码维护较为复杂， 但是缓存空间占用很少</strong>。使用布隆过滤器需要把<strong>所有数据提前放入布隆过滤器</strong>，并且在增加数据时也要往布隆过滤器里放。</p>
<p><strong>注意事项</strong></p>
<p>1、提前放入所有key</p>
<p>2、布隆过滤器不能删除数据，如果要删除得重新初始化数据。</p>
<p>3、用于数据命中不高、 数据相对固定、 实时性低（通常是数据集较大） 的应用场景</p>
<p>布隆过滤器缓存过滤伪代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//初始化布隆过滤器</span><br>RBloomFilter&lt;String&gt; bloomFilter = redisson.getBloomFilter(<span class="hljs-string">&quot;nameList&quot;</span>);<br><span class="hljs-comment">//初始化布隆过滤器：预计元素为100000000L,误差率为3%</span><br>bloomFilter.tryInit(<span class="hljs-number">100000000L</span>,<span class="hljs-number">0.03</span>);<br>        <br><span class="hljs-comment">//把所有数据存入布隆过滤器</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">for</span> (String key: keys) &#123;<br>        bloomFilter.put(key);<br>    &#125;<br>&#125;<br><br><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从布隆过滤器这一级缓存判断下key是否存在</span><br>    Boolean exist = bloomFilter.contains(key);<br>    <span class="hljs-keyword">if</span>(!exist)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">// 如果存储数据为空， 需要设置一个过期时间(300秒)</span><br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, <span class="hljs-number">60</span> * <span class="hljs-number">5</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="缓存失效（击穿）"><a href="#缓存失效（击穿）" class="headerlink" title="缓存失效（击穿）"></a>缓存失效（击穿）</h3><p>定义：热点数据过期失效后，大量用户并发请求同时读缓存没有读取到，又同时去数据库查询，造成数据库瞬间压力巨大甚至挂掉</p>
<p>解决办法：</p>
<p>1、<strong>避免多个热点key同时失效：缓存过期时间设置为一个时间段内的不同时间</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从缓存中获取数据</span><br>    String cacheValue = cache.get(key);<br>    <span class="hljs-comment">// 缓存为空</span><br>    <span class="hljs-keyword">if</span> (StringUtils.isBlank(cacheValue)) &#123;<br>        <span class="hljs-comment">// 从存储中获取</span><br>        String storageValue = storage.get(key);<br>        cache.set(key, storageValue);<br>        <span class="hljs-comment">//设置一个过期时间(300到600之间的一个随机数)</span><br>        <span class="hljs-keyword">int</span> expireTime = <span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">300</span>)  + <span class="hljs-number">300</span>;<br>        <span class="hljs-keyword">if</span> (storageValue == <span class="hljs-keyword">null</span>) &#123;<br>            cache.expire(key, expireTime);<br>        &#125;<br>        <span class="hljs-keyword">return</span> storageValue;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// 缓存非空</span><br>        <span class="hljs-keyword">return</span> cacheValue;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、<strong>单个热点key失效设置缓存时设置互斥锁</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function">String <span class="hljs-title">get</span><span class="hljs-params">(String key)</span> </span>&#123;<br>    <span class="hljs-comment">// 从Redis中获取数据</span><br>    String value = redis.get(key);<br>    <span class="hljs-comment">// 如果value为空， 则开始重构缓存</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-comment">// 只允许一个线程重建缓存， 使用nx， 并设置过期时间ex</span><br>        String mutexKey = <span class="hljs-string">&quot;mutext:key:&quot;</span> + key;<br>        <span class="hljs-keyword">if</span> (redis.set(mutexKey, <span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;ex 180&quot;</span>, <span class="hljs-string">&quot;nx&quot;</span>)) &#123;<br>             <span class="hljs-comment">// 从数据源获取数据</span><br>            value = db.get(key);<br>            <span class="hljs-comment">// 回写Redis， 并设置过期时间</span><br>            redis.setex(key, timeout, value);<br>            <span class="hljs-comment">// 删除key_mutex</span><br>            redis.delete(mutexKey);<br>        &#125;<span class="hljs-comment">// 其他线程休息50毫秒后重试</span><br>        <span class="hljs-keyword">else</span> &#123;<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>            get(key);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> value;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h3><p>定义：<strong>缓存雪崩指的是缓存层支撑不住或宕掉后， 流量会像奔逃的野牛一样（或者大量热点key同时失效）， 打向后端存储层</strong>，最终可能导致数据库层崩溃进而整个服务挂掉。由于缓存层承载着大量请求， 有效地保护了存储层， 但是如果缓存层由于某些原因不能提供服务(比如超大并发过来，缓存层支撑不住，或者由于缓存设计不好，类似大量请求访问bigkey，导致缓存能支撑的并发急剧下降)， 于是大量请求都会打到存储层， 存储层的调用量会暴增， 造成存储层也会级联宕机的情况。 </p>
<h4 id="预防和解决缓存雪崩问题"><a href="#预防和解决缓存雪崩问题" class="headerlink" title="预防和解决缓存雪崩问题"></a>预防和解决缓存雪崩问题</h4><p>0、预防的措施和缓存失效基本一致，预防key同时失效</p>
<p>1、保证缓存层服务的高可用性，比如采用集群或者哨兵模式</p>
<p>2、依赖隔离组件为后端限流熔断并降级。比如使用Sentinel或Hystrix限流降级组件，限制同一个key只有一个请求能打到DB层，其他线程短时等待、重试、快速失败。</p>
<p>3、提前演练。 在项目上线前， 演练缓存层宕掉后， 应用以及后端的负载情况以及可能出现的问题， 在此基础上做一些预案设定。</p>
<h3 id="热点缓存key重建优化"><a href="#热点缓存key重建优化" class="headerlink" title="热点缓存key重建优化"></a>热点缓存key重建优化</h3><p>开发人员使用“缓存+过期时间”的策略既可以加速数据读写， 又保证数据的定期更新， 这种模式基本能够满足绝大部分需求。 但是有两个问题如果同时出现， 可能就会对应用造成致命的危害：</p>
<ul>
<li>当前key是一个热点key（例如一个热门的娱乐新闻），并发量非常大。</li>
<li>重建缓存不能在短时间完成， 可能是一个复杂计算， 例如复杂的SQL、 多次IO、 多个依赖等。</li>
</ul>
<p>在缓存失效的瞬间， 有大量线程来重建缓存， 造成后端负载加大， 甚至可能会让应用崩溃。</p>
<p>要解决这个问题主要就是要避免大量线程同时重建缓存。</p>
<p>我们可以利用互斥锁来解决，此方法只允许一个线程重建缓存， 其他线程等待重建缓存的线程执行完， 重新从缓存获取数据即可。</p>
<p>示例伪代码：上边已出现</p>
<h3 id="缓存与数据库不一致"><a href="#缓存与数据库不一致" class="headerlink" title="缓存与数据库不一致"></a>缓存与数据库不一致</h3><p>这里不一致指的是：<strong>数据库的数据跟缓存的数据不一致</strong></p>
<p><strong>双写不一致</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard.png" alt="img"></p>
<p><strong>读写不一致</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard-1650178193285.png" alt="img"></p>
<p><strong>解决方案：</strong></p>
<p>1、对于并发几率很小的数据(如个人维度的订单数据、用户数据等)，这种几乎不用考虑这个问题，很少会发生缓存不一致，可以给缓存数据加上过期时间，每隔一段时间触发读的主动更新即可。</p>
<p>2、就算并发很高，如果业务上能容忍短时间的缓存数据不一致(如商品名称，商品分类菜单等)，缓存加上过期时间依然可以解决大部分业务对于缓存的要求。</p>
<p>3、对于双写不一致，可以采用把更新和删除缓存统一为<strong>删除缓存</strong>，减少维护复杂度，避免双写问题。</p>
<p>4、采用<strong>旁路缓存策略</strong>的延迟双删，操作数据前删一次缓存，更新完成后，延迟一定时间再次清除缓存。这种方案在极端情况下也会有缓存不一致的问题</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/image-20241022232758085.png" alt="image-20241022232758085"></p>
<p>5、如果不能容忍缓存数据不一致，可以通过加<strong>分布式读写锁</strong>保证并发读写或写写的时候按顺序排好队，<strong>读读的时候相当于无锁</strong></p>
<p>6、用阿里开源的canal通过监听数据库的binlog日志及时的去修改缓存，但是引入了新的中间件，增加了系统的复杂度</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis04-%E7%BC%93%E5%AD%98%E8%AE%BE%E8%AE%A1%E4%B8%8E%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/clipboard-1650179170290.png" alt="img"></p>
<h2 id="开发规范与性能优化"><a href="#开发规范与性能优化" class="headerlink" title="开发规范与性能优化"></a>开发规范与性能优化</h2><h3 id="一、键值设计"><a href="#一、键值设计" class="headerlink" title="一、键值设计"></a>一、键值设计</h3><h4 id="1-key名设计"><a href="#1-key名设计" class="headerlink" title="1. key名设计"></a>1. key名设计</h4><p><strong>1. key名设计</strong></p>
<ul>
<li>(1)【建议】: 可读性和可管理性</li>
</ul>
<p>以业务名(或数据库名)为前缀(防止key冲突)，用冒号分隔，比如业务名:表名:id</p>
<p>​                trade:order:1              </p>
<ul>
<li>(2)【建议】：简洁性</li>
</ul>
<p>保证语义的前提下，控制key的长度，当key较多时，内存占用也不容忽视，例如：</p>
<p>​                user:{uid}:friends:messages:{mid} 简化为 u:{uid}:fr:m:{mid}              </p>
<ul>
<li>(3)【强制】：不要包含特殊字符</li>
</ul>
<p>反例：包含空格、换行、单双引号以及其他转义字符</p>
<h4 id="2-value设计"><a href="#2-value设计" class="headerlink" title="2. value设计"></a>2. value设计</h4><ul>
<li>(1)【强制】：拒绝bigkey(防止网卡流量、慢查询)</li>
</ul>
<p>在Redis中，一个字符串最大512MB，一个二级数据结构（例如hash、list、set、zset）可以存储大约40亿个(2^32-1)个元素，但实际中如果下面两种情况，我就会认为它是bigkey。</p>
<ol>
<li>字符串类型：它的big体现在单个value值很大，一般认为超过10KB就是bigkey。</li>
<li>非字符串类型：哈希、列表、集合、有序集合，它们的big体现在元素个数太多。</li>
</ol>
<p>一般来说，string类型控制在10KB以内，hash、list、set、zset元素个数不要超过5000。</p>
<p>反例：一个包含200万个元素的list。</p>
<p>非字符串的bigkey，不要使用del删除，使用hscan、sscan、zscan方式渐进式删除，同时要注意防止bigkey过期时间自动删除问题(例如一个200万的zset设置1小时过期，会触发del操作，造成阻塞）</p>
<h4 id="bigkey的危害"><a href="#bigkey的危害" class="headerlink" title="bigkey的危害"></a>bigkey的危害</h4><p>1.导致redis阻塞</p>
<p>2.网络拥塞（占用网络带宽）</p>
<h4 id="bigkey的产生"><a href="#bigkey的产生" class="headerlink" title="bigkey的产生"></a>bigkey的产生</h4><p>(1) 社交类：粉丝列表，如果某些明星或者大v不精心设计下，必是bigkey。</p>
<p>(2) 统计类：例如按天存储某项功能或者网站的用户集合，除非没几个人用，否则必是bigkey。</p>
<p>(3) 缓存类：将数据从数据库load出来序列化放到Redis里，这个方式非常常用，但有两个地方需要注意，第一，是不是有必要把所有字段都缓存；第二，有没有相关关联的数据，有的同学为了图方便把相关数据都存一个key下，产生bigkey。</p>
<h4 id="如何优化bigkey"><a href="#如何优化bigkey" class="headerlink" title="如何优化bigkey"></a>如何优化bigkey</h4><p>1、分拆法</p>
<p>big list： list1、list2、…listN</p>
<p>big hash：可以讲数据分段存储，比如一个大的key，假设存了1百万的用户数据，可以拆分成200个key，每个key下面存放5000个用户数据</p>
<p>如果bigkey不可避免，也要思考一下要不要每次把所有元素都取出来(例如有时候仅仅需要hmget，而不是hgetall)，删除也是一样，尽量使用优雅的方式来处理。</p>
<p>2、选择适合的数据类型。</p>
<p>例如：实体类型(要合理控制和使用数据结构，但也要注意节省内存和性能之间的平衡)</p>
<p>反例：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">set</span> user:<span class="hljs-number">1</span>:name tom <span class="hljs-built_in">set</span> user:<span class="hljs-number">1</span>:age <span class="hljs-number">19</span> <span class="hljs-built_in">set</span> user:<span class="hljs-number">1</span>:favor football              <br></code></pre></td></tr></table></figure>

<p>正例:  </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">hmset user:<span class="hljs-number">1</span> name tom age <span class="hljs-number">19</span> favor football              <br></code></pre></td></tr></table></figure>

<p>3、控制key的生命周期，redis不是垃圾桶。</p>
<p>建议使用expire设置过期时间(条件允许可以打散过期时间，防止集中过期)。           </p>
<h3 id="二、命令使用"><a href="#二、命令使用" class="headerlink" title="二、命令使用"></a>二、命令使用</h3><p>1、O(N)命令关注N的数量</p>
<p>例如hgetall、lrange、smembers、zrange、sinter等并非不能使用，但是需要明确N的值。有遍历的需求可以使用hscan、sscan、zscan代替。</p>
<p>2、禁用命令</p>
<p>禁止线上使用keys、flushall、flushdb等，通过redis的rename机制禁掉命令，或者使用scan的方式渐进式处理。</p>
<p>3、合理使用select</p>
<p>redis的多数据库较弱，使用数字进行区分，很多客户端支持较差，同时多业务用多数据库实际还是单线程处理，会有干扰。</p>
<p>4、使用批量操作提高效率：</p>
<p>原生命令：例如mget、mset。 </p>
<p>非原生命令：可以使用pipeline提高效率。          </p>
<p><strong>pipeline与lua的区别</strong>    ：lua具备原子性，pipeling仅仅是批量传输，不具备原子性</p>
<p>5、Redis事务功能较弱，不建议过多使用，可以用lua替代</p>
<h3 id="三、客户端使用"><a href="#三、客户端使用" class="headerlink" title="三、客户端使用"></a>三、客户端使用</h3><p>1.【推荐】避免多个应用使用一个Redis实例</p>
<p>正例：不相干的业务拆分，公共数据做服务化。</p>
<p>固定使用database=0 且一个应用使用一个实例，尽量不共享使用redis</p>
<p>2、使用redis连接池，可以有效控制连接，同时提高效率</p>
<p>连接池参数含义：</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>参数名</th>
<th>含义</th>
<th>默认值</th>
<th>使用建议</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>maxTotal</td>
<td>资源池中最大连接数</td>
<td>8</td>
<td>设置建议见下面</td>
</tr>
<tr>
<td>2</td>
<td>maxIdle</td>
<td>资源池允许最大空闲的连接数</td>
<td>8</td>
<td>设置建议见下面</td>
</tr>
<tr>
<td>3</td>
<td>minIdle</td>
<td>资源池确保最少空闲的连接数</td>
<td>0</td>
<td>设置建议见下面</td>
</tr>
<tr>
<td>4</td>
<td>blockWhenExhausted</td>
<td>当资源池用尽后，调用者是否要等待。只有当为true时，下面的maxWaitMillis才会生效</td>
<td>true</td>
<td>建议使用默认值</td>
</tr>
<tr>
<td>5</td>
<td>maxWaitMillis</td>
<td>当资源池连接用尽后，调用者的最大等待时间(单位为毫秒)</td>
<td>-1：表示永不超时</td>
<td>不建议使用默认值</td>
</tr>
<tr>
<td>6</td>
<td>testOnBorrow</td>
<td>向资源池借用连接时是否做连接有效性检测(ping)，无效连接会被移除</td>
<td>false</td>
<td>业务量很大时候建议设置为false(多一次ping的开销)。</td>
</tr>
<tr>
<td>7</td>
<td>testOnReturn</td>
<td>向资源池归还连接时是否做连接有效性检测(ping)，无效连接会被移除</td>
<td>false</td>
<td>业务量很大时候建议设置为false(多一次ping的开销)。</td>
</tr>
<tr>
<td>8</td>
<td>jmxEnabled</td>
<td>是否开启jmx监控，可用于监控</td>
<td>true</td>
<td>建议开启，但应用本身也要开启</td>
</tr>
</tbody></table>
<p><strong>优化建议：</strong></p>
<p>1）<strong>maxTotal</strong>：最大连接数，早期的版本叫maxActive实际上这个是一个很难回答的问题，考虑的因素比较多：</p>
<ul>
<li>业务希望Redis并发量</li>
<li>客户端执行命令时间</li>
<li>Redis资源：例如 nodes(例如应用个数) * maxTotal 是不能超过redis的最大连接数maxclients。</li>
<li>资源开销：例如虽然希望控制<strong>空闲连接</strong>(连接池此刻可马上使用的连接)，但是不希望因为连接池的频繁释放创建连接造成不必靠开销。</li>
</ul>
<p><strong>以一个例子说明</strong>，假设:</p>
<ul>
<li>一次命令时间（borrow|return resource + Jedis执行命令(含网络) ）的平均耗时约为1ms，一个连接的QPS大约是1000</li>
<li>业务期望的QPS是50000</li>
</ul>
<p>那么理论上需要的资源池大小是50000 / 1000 = 50个。但事实上这是个理论值，还要考虑到要比理论值预留一些资源，通常来讲maxTotal可以比理论值大一些。</p>
<p>但这个值不是越大越好，一方面连接太多占用客户端和服务端资源，另一方面对于Redis这种高QPS的服务器，一个大命令的阻塞即使设置再大资源池仍然会无济于事。</p>
<p>2）<strong>maxIdle和minIdle</strong></p>
<p>maxIdle实际上才是业务需要的最大连接数，maxTotal是为了<strong>给出余量</strong>，所以maxIdle不要设置过小，否则会有new Jedis(新连接)开销。</p>
<p><strong>连接池的最佳性能是maxTotal = maxIdle</strong>，这样就避免连接池伸缩带来的性能干扰。但是如果并发量不大或者maxTotal设置过高，会导致不必要的连接资源浪费。一般推荐maxIdle可以设置为按上面的业务期望QPS计算出来的理论连接数，maxTotal可以再放大一倍。</p>
<p>minIdle（最小空闲连接数），与其说是最小空闲连接数，不如说是”<strong>至少需要保持的空闲连接数</strong>“，在使用连接的过程中，如果连接数超过了minIdle，那么继续建立连接，如果超过了maxIdle，当超过的连接执行完业务后会慢慢被移出连接池释放掉。</p>
<p>如果系统启动完马上就会有很多的请求过来，那么可以给redis连接池做<strong>预热</strong>，比如快速的创建一些redis连接，执行简单命令，类似ping()，快速的将连接池里的空闲连接提升到minIdle的数量。</p>
<p><strong>连接池预热示例代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;Jedis&gt; minIdleJedisList = <span class="hljs-keyword">new</span> ArrayList&lt;Jedis&gt;(jedisPoolConfig.getMinIdle());<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;<br>    Jedis jedis = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        jedis = pool.getResource();<br>        minIdleJedisList.add(jedis);<br>        jedis.ping();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">//注意，这里不能马上close将连接还回连接池，否则最后连接池里只会建立1个连接。。</span><br>        <span class="hljs-comment">//jedis.close();</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//统一将预热的连接还回连接池</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; jedisPoolConfig.getMinIdle(); i++) &#123;<br>    Jedis jedis = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        jedis = minIdleJedisList.get(i);<br>        <span class="hljs-comment">//将连接归还回连接池</span><br>        jedis.close();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        logger.error(e.getMessage(), e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="对于过期键有三种清除策略"><a href="#对于过期键有三种清除策略" class="headerlink" title="对于过期键有三种清除策略"></a>对于过期键有三种清除策略</h4><ol>
<li>被动删除：当读/写一个已经过期的key时，会触发惰性删除策略，直接删除掉这个过期key</li>
<li>主动删除：由于惰性删除策略无法保证冷数据被及时删掉，所以Redis会定期(默认每100ms)主动淘汰一批<strong>已过期</strong>的key，这里的一批只是部分过期key，所以可能会出现部分key已经过期但还没有被清理掉的情况，导致内存并没有被释放</li>
<li>当前已用内存超过maxmemory限定时，触发<strong>主动清理策略</strong></li>
</ol>
<h4 id="主动清理策略"><a href="#主动清理策略" class="headerlink" title="主动清理策略"></a>主动清理策略</h4><p><strong>主动清理策略</strong>在Redis 4.0 之前一共实现了 6 种内存淘汰策略，在 4.0 之后，又增加了 2 种策略，总共8种：</p>
<p><strong>a) 针对设置了过期时间的key做处理：</strong></p>
<ol>
<li>volatile-ttl：在筛选时，会针对设置了过期时间的键值对，根据过期时间的先后进行删除，越早过期的越先被删除。</li>
<li>volatile-random：就像它的名称一样，在设置了过期时间的键值对中，进行随机删除。</li>
<li><strong>volatile-lru</strong>：会使用 LRU 算法筛选设置了过期时间的键值对删除。</li>
<li>volatile-lfu：会使用 LFU 算法筛选设置了过期时间的键值对删除。</li>
</ol>
<p><strong>b) 针对所有的key做处理：</strong></p>
<ol>
<li>allkeys-random：从所有键值对中随机选择并删除数据。</li>
<li>allkeys-lru：使用 LRU 算法在所有数据中进行筛选删除。</li>
<li>allkeys-lfu：使用 LFU 算法在所有数据中进行筛选删除。</li>
</ol>
<p><strong>c) 不处理（默认策略）：</strong></p>
<ol>
<li>noeviction：不会剔除任何数据，拒绝所有写入操作并返回客户端错误信息”(error) OOM command not allowed when used memory”，此时Redis只响应读操作。</li>
</ol>
<p><strong>LRU 算法</strong>（Least Recently Used，最近最少使用</p>
<p>淘汰很久没被访问过的数据，以<strong>最近一次访问时间</strong>作为参考。</p>
<p><strong>LFU 算法</strong>（Least Frequently Used，最不经常使用）</p>
<p>淘汰最近一段时间被访问次数最少的数据，以<strong>次数</strong>作为参考。</p>
<p>当存在热点数据时，LRU的效率很好，但偶发性的、周期性的批量操作会导致LRU命中率急剧下降，缓存污染情况比较严重。这时使用LFU可能更好点。</p>
<p>根据自身业务类型，配置好maxmemory-policy(默认是<strong>noeviction</strong>)，推荐使用volatile-lru。如果不设置最大内存，当 Redis 内存超出物理内存限制时，内存的数据会开始和磁盘产生频繁的交换 (swap)，会让 Redis 的性能急剧下降。</p>
<p>当Redis运行在主从模式时，只有主结点才会执行过期删除策略，然后把删除操作”del key”同步到从结点删除数据。</p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-zookeeper01-简介与客户端使用</title>
    <url>/2022/04/23/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="一、概要、背景及作用"><a href="#一、概要、背景及作用" class="headerlink" title="一、概要、背景及作用"></a>一、概要、背景及作用</h1><h2 id="zookeeper产生背景"><a href="#zookeeper产生背景" class="headerlink" title="zookeeper产生背景"></a>zookeeper产生背景</h2><p>项目从单体到分布式转变之后，将会产生<strong>多个节点之间协同的问题</strong>。如</p>
<p>1、定时任务由哪个节点来执行</p>
<p>2、RPC调用时的服务与发现</p>
<p>3、如何实现分布式锁（保证并发请求的幂等性）</p>
<p>4、……</p>
<p>这些问题可以统一归纳为多节点协调问题，如果靠节点自身进行协调这是非常不可靠的，性能上也不可取。必须由一个独立的服务做协调工作，它必须可靠，而且保证性能</p>
<h2 id="zookeeper概要"><a href="#zookeeper概要" class="headerlink" title="zookeeper概要"></a>zookeeper概要</h2><p>ZooKeeper是在<strong>分布式</strong>应用程序中<strong>提供协调服务</strong>的apache项目。它公开了一组简单的API，分布式应用程序可以基于这些API用于同步，节点状态、配置等信息、服务注册等信息。其由JAVA编写。</p>
<img src="/images/分布式-zookeeper01-简介与客户端使用/image-20220423165903801.png" alt="image-20220423165903801" style="zoom:67%;">

<h2 id="znode节点"><a href="#znode节点" class="headerlink" title="znode节点"></a>znode节点</h2><p>zookeeper 中数据基本单元叫节点，<strong>节点之下可包含子节点，最后以树级方式程现</strong>。<strong>每个节点拥有唯一的路径path</strong>。客户端基于PATH上传节点数据，zookeeper 收到后会实时通知对该路径进行监听的客户端。</p>
<img src="/images/分布式-zookeeper01-简介与客户端使用/image-20220423170723134.png" alt="image-20220423170723134" style="zoom: 50%;">

<h2 id="Zookeeper工作机制"><a href="#Zookeeper工作机制" class="headerlink" title="Zookeeper工作机制"></a>Zookeeper工作机制</h2><p>​    Zookeeper从设计模式角度来理解：是一个基于<strong>观察者模式</strong>设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者(客户端)的注 册，一旦这些数据的状态发生变化，Zookeeper就 将负责通知已经在Zookeeper上注册的那些观察者(客户端)做出相应的反应。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/da6794017cb1417684810ce7ccba1f79.png" alt="img"></p>
<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>1）Zookeeper：一个领导者（Leader），多个跟随者（Follower）组成的集群。<br>2）过半机制：集群中只要有<strong>半数以上</strong>节点存活，Zookeeper集群就能正常服务。所 以Zookeeper适合安装<strong>奇数台</strong>服务器<br>3）全局数据一致：每个Server保存一份相同的数据副本，Client无论连接到哪个Server，数据都是一致的。<br>4）更新请求顺序执行，来自同一个Client的更新请求按其发送顺序依次执行。<br>5）数据更新原子性，一次数据更新要么成功，要么失败。<br>6）实时性，在一定时间范围内，Client能读到最新数据.</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/72444eeb5f0f490a91c8ae93bad2b3e7.png" alt="img"></p>
<h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>提供的服务包括：统一命名服务、统一配置管理、统一集群管理、服务器节点动态上下线、软负载均衡等.</p>
<h3 id="服务发现与注册（在dubbo中使用）"><a href="#服务发现与注册（在dubbo中使用）" class="headerlink" title="服务发现与注册（在dubbo中使用）"></a>服务发现与注册（在dubbo中使用）</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/65be00a325e45c02b57b1dcff86c35db_720w.jpg" alt="img"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/6d37c4f193d373f9476f7ced5bb1906c.png" alt="6d37c4f193d373f9476f7ced5bb1906c.png"></p>
<h3 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h3><p>1）分布式环境下，配置文件同步非常常见。<br>（1）一般要求一个集群中，所有节点的配置信息是一致的，比如 Kafka 集群。<br>（2）对配置文件修改后，希望能够快速同步到各个节点上。</p>
<p>2）配置管理可交由ZooKeeper实现。<br>（1）可将配置信息写入ZooKeeper上的一个Znode<br>（2）各个客户端服务器监听这个Znode。<br>（3）一 旦Znode中的数据被修改，ZooKeeper将通知各个客户端服务器。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/b67eee64039a4d258548cafeaeaeb87e.png" alt="在这里插入图片描述"></p>
<h3 id="软负载均衡"><a href="#软负载均衡" class="headerlink" title="软负载均衡"></a>软负载均衡</h3><p>在Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/bae63cc5c73841d5a42ed509ca93a613.png" alt="img"></p>
<h3 id="分布式锁"><a href="#分布式锁" class="headerlink" title="分布式锁"></a>分布式锁</h3><h3 id="多节点系统定时任务"><a href="#多节点系统定时任务" class="headerlink" title="多节点系统定时任务"></a>多节点系统定时任务</h3><h1 id="二、部署与常规配置"><a href="#二、部署与常规配置" class="headerlink" title="二、部署与常规配置"></a>二、部署与常规配置</h1><p>zookeeper 基于JAVA开发，下载后只要有对应JVM环境即可运行。其默认的端口号是2181运行前得保证其不冲突。</p>
<h2 id="具体部署流程："><a href="#具体部署流程：" class="headerlink" title="具体部署流程："></a>具体部署流程：</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">cd</span> /soft<br>#下载<br>wget https://mirrors.tuna.tsinghua.edu.cn/apache/zookeeper/current/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin.tar.gz<br>#解压<br>tar -zxvf apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin.tar.gz<br>#拷贝默认配置<br><span class="hljs-built_in">cd</span>  &#123;zookeeper_home&#125;/conf <br>cp zoo_sample.cfg zoo.cfg<br>#配置环境变量<br>vim /etc/profile<br>#补充这面这句到<span class="hljs-built_in">PATH</span>=$<span class="hljs-built_in">PATH</span>后面<br>:/soft/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin<br>#立即生效<br>source etc/profile<br>#启动<br>zkServer.sh <span class="hljs-built_in">start</span><br>#连接客户端<br>zkClish.sh <br></code></pre></td></tr></table></figure>

<h2 id="配置文件修改："><a href="#配置文件修改：" class="headerlink" title="配置文件修改："></a>配置文件修改：</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># zookeeper时间配置中的基本单位 (毫秒)<br>tickTime=<span class="hljs-number">2000</span><br># 允许follower初始化连接到leader最大时长，它表示tickTime时间倍数 即:initLimit*tickTime<br>initLimit=<span class="hljs-number">10</span><br># 允许follower与leader数据同步最大时长,它表示tickTime时间倍数 <br>syncLimit=<span class="hljs-number">5</span><br>#zookeper 数据存储目录<br>dataDir=/soft/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin/dataDir<br>#对客户端提供的端口号<br>clientPort=<span class="hljs-number">2181</span><br>#单个客户端与zookeeper最大并发连接数<br>maxClientCnxns=<span class="hljs-number">60</span><br># 保存的数据快照数量，之外的将会被清除<br>autopurge.snapRetainCount=<span class="hljs-number">3</span><br>#自动触发清除任务时间间隔，小时为单位。默认为<span class="hljs-number">0</span>，表示不自动清除。<br>autopurge.purgeInterval=<span class="hljs-number">1</span><br>#跳过acl<br>skipACL=yes<br></code></pre></td></tr></table></figure>

<h2 id="客户端命令"><a href="#客户端命令" class="headerlink" title="客户端命令"></a>客户端命令</h2><p><strong>基本命令列表</strong><br> <strong>close</strong><br> 关闭当前会话<br><strong>connect host:port</strong><br>重新连接指定Zookeeper服务<br><strong>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</strong><br>创建节点<br><strong>delete [-v version] path</strong><br>删除节点，(不能存在子节点）<br><strong>deleteall path</strong><br> 删除路径及所有子节点<br><strong>setquota -n|-b val path</strong><br>设置节点限额 -n 子节点数 -b 字节数<br> <strong>listquota path</strong><br>查看节点限额<br><strong>delquota [-n|-b] path</strong><br>删除节点限额<br> <strong>get [-s] [-w] path</strong><br>查看节点数据 -s 包含节点状态 -w 添加监听<br>getAcl [-s] path<br><strong>ls [-s] [-w] [-R] path</strong><br>列出子节点 -s状态 -R 递归查看所有子节点 -w 添加监听<br><strong>printwatches on|off</strong><br>是否打印监听事件<br><strong>quit</strong><br>退出客户端<br> <strong>history</strong><br>查看执行的历史记录<br><strong>redo cmdno</strong><br>重复 执行命令，history 中命令编号确定<br>removewatches path [-c|-d|-a] [-l]<br><strong>删除指定监听</strong><br>set [-s] [-v version] path data<br><strong>设置值</strong><br><strong>setAcl [-s] [-v version] [-R] path acl</strong><br>为节点设置ACL权限<br><strong>stat [-w] path</strong><br>查看节点状态 -w 添加监听<br><strong>sync path</strong><br>强制同步节点<br><strong>node数据的增删改查</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 列出子节点 <br>ls /<br>#创建节点<br>create /luban &quot;luban is good man&quot;<br># 查看节点<br>get /luban<br># 创建子节点 <br>create /luban/sex &quot;man&quot;<br># 删除节点<br>delete /luban/sex<br># 删除所有节点 包括子节点<br>deleteall /luban<br></code></pre></td></tr></table></figure>

<h1 id="三、Zookeeper节点与原生API介绍"><a href="#三、Zookeeper节点与原生API介绍" class="headerlink" title="三、Zookeeper节点与原生API介绍"></a>三、Zookeeper节点与原生API介绍</h1><p>zookeeper 中节点叫znode存储结构上跟文件系统类似，以树级结构进行存储。不同之外在于znode没有目录的概念，不能执行类似cd之类的命令。znode结构包含如下：</p>
<ul>
<li><strong>path</strong>:唯一路径 </li>
<li><strong>childNode</strong>：子节点</li>
<li><strong>stat</strong>:状态属性</li>
<li><strong>type</strong>:节点类型</li>
</ul>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>PERSISTENT(默认)</strong></td>
<td align="left">持久节点</td>
</tr>
<tr>
<td align="left">PERSISTENT_SEQUENTIAL</td>
<td align="left">持久序号节点</td>
</tr>
<tr>
<td align="left">EPHEMERAL</td>
<td align="left"><strong>临时节点(不可在拥有子节点)</strong>-会话断开后删除</td>
</tr>
<tr>
<td align="left">EPHEMERAL_SEQUENTIAL</td>
<td align="left">临时序号节点(不可在拥有子节点)</td>
</tr>
</tbody></table>
<ol>
<li>PERSISTENT（持久节点）</li>
</ol>
<p>持久化保存的节点，也是默认创建的</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#默认创建的就是持久节点<br>create /test<br></code></pre></td></tr></table></figure>

<ol>
<li>PERSISTENT_SEQUENTIAL(持久序号节点)</li>
</ol>
<p>创建时zookeeper 会在路径上加上序号作为后缀，。非常适合用于分布式锁、分布式选举等场景。创建时添加 -s 参数即可。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#创建序号节点<br>create -s /test<br>#返回创建的实际路径<br>Created /test0000000001<br>create -s /test<br>#返回创建的实际路径<span class="hljs-number">2</span><br>Created /test0000000002<br></code></pre></td></tr></table></figure>

<ol>
<li>EPHEMERAL（临时节点）</li>
</ol>
<p>临时节点会在客户端会话断开后自动删除。适用于心跳，服务发现等场景。创建时添加参数-e 即可。</p>
<figure class="highlight gauss"><table><tr><td class="code"><pre><code class="hljs gauss"><span class="hljs-meta">#创建临时节点， 断开会话 在连接将会自动删除</span><br><span class="hljs-keyword">create</span> -e /temp<br></code></pre></td></tr></table></figure>

<ol>
<li>EPHEMERAL_SEQUENTIAL（临时序号节点）</li>
</ol>
<p>与持久序号节点类似，不同之处在于EPHEMERAL_SEQUENTIAL是临时的会在会话断开后删除。创建时添加 -e -s </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">create -e -s /temp/seq<br></code></pre></td></tr></table></figure>

<h2 id="节点属性"><a href="#节点属性" class="headerlink" title="节点属性"></a>节点属性</h2><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 查看节点属性</span><br><span class="hljs-built_in">stat</span> /luban<br></code></pre></td></tr></table></figure>

<p>其属性说明如下表：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#创建节点的事物ID</span><br><span class="hljs-attribute">cZxid</span> = <span class="hljs-number">0</span>x<span class="hljs-number">385</span><br><span class="hljs-comment">#创建时间</span><br><span class="hljs-attribute">ctime</span> = Tue Sep <span class="hljs-number">24</span> <span class="hljs-number">17</span>:<span class="hljs-number">26</span>:<span class="hljs-number">28</span> CST <span class="hljs-number">2019</span><br><span class="hljs-comment">#修改节点的事物ID</span><br><span class="hljs-attribute">mZxid</span> = <span class="hljs-number">0</span>x<span class="hljs-number">385</span><br><span class="hljs-comment">#最后修改时间</span><br><span class="hljs-attribute">mtime</span> = Tue Sep <span class="hljs-number">24</span> <span class="hljs-number">17</span>:<span class="hljs-number">26</span>:<span class="hljs-number">28</span> CST <span class="hljs-number">2019</span><br><span class="hljs-comment"># 子节点变更的事物ID</span><br><span class="hljs-attribute">pZxid</span> = <span class="hljs-number">0</span>x<span class="hljs-number">385</span><br><span class="hljs-comment">#这表示对此znode的子节点进行的更改次数（不包括子节点）</span><br><span class="hljs-attribute">cversion</span> = <span class="hljs-number">0</span><br><span class="hljs-comment"># 数据版本，变更次数</span><br><span class="hljs-attribute">dataVersion</span> = <span class="hljs-number">0</span><br><span class="hljs-comment">#权限版本，变更次数</span><br><span class="hljs-attribute">aclVersion</span> = <span class="hljs-number">0</span><br><span class="hljs-comment">#临时节点所属会话ID</span><br><span class="hljs-attribute">ephemeralOwner</span> = <span class="hljs-number">0</span>x<span class="hljs-number">0</span><br><span class="hljs-comment">#数据长度</span><br><span class="hljs-attribute">dataLength</span> = <span class="hljs-number">17</span><br><span class="hljs-comment">#子节点数(不包括子子节点)</span><br><span class="hljs-attribute">numChildren</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th><strong>cZxid</strong></th>
<th>创建节点的事物ID</th>
</tr>
</thead>
<tbody><tr>
<td><strong>mZxid</strong></td>
<td>最新一次修改节点的事物ID</td>
</tr>
<tr>
<td><strong>pZxid</strong></td>
<td>子节点变更的事物ID</td>
</tr>
<tr>
<td><strong>cversion</strong></td>
<td>这表示对此znode的子节点进行的更改次数（不包括子节点）</td>
</tr>
<tr>
<td><strong>dataVersion</strong></td>
<td>数据版本，变更次数</td>
</tr>
<tr>
<td><strong>aclVersion</strong></td>
<td>权限版本，变更次数</td>
</tr>
</tbody></table>
<p>ZXID是一个长度64位的数字，其中低32位是按照数字递增，任何数据的变更都会导致,低32位的数字简单加1。高32位是leader周期编号，每当选举出一个新的leader时，新的leader就从本地事物日志中取出ZXID,然后解析出高32位的周期编号，进行加1，再将低32位的全部设置为0。这样就保证了每次新选举的leader后，保证了ZXID的唯一性而且是保证递增的。 </p>
<h3 id="acl权限设置"><a href="#acl权限设置" class="headerlink" title="acl权限设置"></a>acl权限设置</h3><p>ACL全称为Access Control List（访问控制列表），用于控制资源的访问权限。ZooKeeper使用ACL来控制对其znode的防问。基于scheme: id :permission的方式进行权限控制。scheme表示授权模式、id模式对应值、permission即具体的增删改权限位。</p>
<p><strong>scheme:认证模型</strong></p>
<table>
<thead>
<tr>
<th align="left">方案</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">world</td>
<td align="left">开放模式，world表示全世界都可以访问（这是默认设置）</td>
</tr>
<tr>
<td align="left">ip</td>
<td align="left">ip模式，限定客户端IP防问</td>
</tr>
<tr>
<td align="left">auth</td>
<td align="left">用户密码认证模式，只有在会话中添加了认证才可以防问</td>
</tr>
<tr>
<td align="left">digest</td>
<td align="left">与auth类似，区别在于auth用明文密码，而digest 用sha-1+base64加密后的密码。在实际使用中digest 更常见。</td>
</tr>
</tbody></table>
<p><strong>permission权限位</strong></p>
<table>
<thead>
<tr>
<th align="left">权限位</th>
<th align="left">权限</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">c</td>
<td align="left">CREATE</td>
<td align="left">可以创建子节点</td>
</tr>
<tr>
<td align="left">d</td>
<td align="left">DELETE</td>
<td align="left">可以删除子节点（仅下一级节点）</td>
</tr>
<tr>
<td align="left">r</td>
<td align="left">READ</td>
<td align="left">可以读取节点数据及显示子节点列表</td>
</tr>
<tr>
<td align="left">w</td>
<td align="left">WRITE</td>
<td align="left">可以设置节点数据</td>
</tr>
<tr>
<td align="left">a</td>
<td align="left">ADMIN</td>
<td align="left">可以设置节点访问控制列表权限</td>
</tr>
</tbody></table>
<p><strong>acl 相关命令：</strong></p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">使用方式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">getAcl</td>
<td align="left">getAcl <path></path></td>
<td align="left">读取ACL权限</td>
</tr>
<tr>
<td align="left">setAcl</td>
<td align="left">setAcl <path></path> <acl></acl></td>
<td align="left">设置ACL权限</td>
</tr>
<tr>
<td align="left">addauth</td>
<td align="left">addauth <scheme> <auth></auth></scheme></td>
<td align="left">添加认证用户</td>
</tr>
</tbody></table>
<p><strong>world权限示例</strong><br>语法： setAcl <path></path> world:anyone:&lt;权限位&gt;<br>注：world模式中anyone是唯一的值,表示所有人</p>
<ol>
<li>查看默认节点权限：</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#创建一个节点<br>create -e /testAcl<br>#查看节点权限<br>getAcl /testAcl<br>#返回的默认权限表示 ，所有人拥有所有权限。<br>&#x27;world,&#x27;anyone: cdrwa<br></code></pre></td></tr></table></figure>

<ol>
<li>修改默认权限为 读写</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#设置为rw权限 <br>setAcl /testAcl world:anyone:rw<br># 可以正常读<br>get /testAcl<br># 无法正常创建子节点<br>create -e /testAcl/t &quot;hi&quot;<br># 返回没有权限的异常<br>Authentication is <span class="hljs-keyword">not</span> valid : /testAcl/t<br></code></pre></td></tr></table></figure>

<p><strong>IP权限示例：</strong><br>语法： setAcl <path></path> ip:&lt;ip地址|地址段&gt;:&lt;权限位&gt;</p>
<p><strong>auth模式示例:</strong><br>语法： </p>
<ol>
<li>setAcl <path></path> auth:&lt;用户名&gt;:&lt;密码&gt;:&lt;权限位&gt;</li>
<li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li>
</ol>
<p><strong>digest 权限示例：</strong><br>语法： </p>
<ol>
<li>setAcl <path></path> digest :&lt;用户名&gt;:&lt;密钥&gt;:&lt;权限位&gt;</li>
<li>addauth digest &lt;用户名&gt;:&lt;密码&gt;</li>
</ol>
<p>注1：密钥 通过sha1与base64组合加密码生成，可通过以下命令生成</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> -n &lt;用户名&gt;:&lt;密码&gt; | openssl dgst -binary -sha1 | openssl base64<br></code></pre></td></tr></table></figure>

<p>注2：为节点设置digest 权限后，访问前必须执行addauth，当前会话才可以防问。</p>
<ol>
<li>设置digest 权限</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#先 sha1 加密，然后base64加密<br><span class="hljs-built_in">echo</span> -n luban:<span class="hljs-number">123456</span> | openssl dgst -binary -sha1 | openssl base64<br>#返回密钥<br><span class="hljs-number">2</span>Rz3ZtRZEs5RILjmwuXW/wT13Tk=<br>#设置digest权限<br>setAcl /luban digest:luban:<span class="hljs-number">2</span>Rz3ZtRZEs5RILjmwuXW/wT13Tk=:cdrw<br></code></pre></td></tr></table></figure>

<ol>
<li>查看节点将显示没有权限</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#查看节点<br>get /luban<br>#显示没有权限访问<br><span class="hljs-function">org.apache.zookeeper.KeeperException$NoAuthException: <span class="hljs-title">KeeperErrorCode</span> = <span class="hljs-title">NoAuth</span> <span class="hljs-title">for</span> /<span class="hljs-title">luban</span></span><br></code></pre></td></tr></table></figure>

<ol>
<li>给当前会话添加认证后在次查看</li>
</ol>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#给当前会话添加权限帐户<br>addauth digest luban:<span class="hljs-number">123456</span><br>#在次查看<br>get /luban<br>#获得返回结果<br>luban is good man<br></code></pre></td></tr></table></figure>

<p>ACL的特殊说明：<br>权限仅对当前节点有效，不会让子节点继承。如限制了IP防问A节点，但不妨碍该IP防问A的子节点 /A/B。</p>
<h1 id="四、集群部署"><a href="#四、集群部署" class="headerlink" title="四、集群部署"></a>四、集群部署</h1><p>zookeeper集群的目的是为了保证系统的性能承载更多的客户端连接设专门提供的机制。通过集群可以实现以下功能：</p>
<ul>
<li>读写分离：提高承载，为更多的客户端提供连接，并保障性能。</li>
<li>主从自动切换：提高服务容错性，部分节点故障不会影响整个服务集群。</li>
</ul>
<p><strong>半数以上运行机制说明：</strong><br>集群至少需要三台服务器，并且强烈建议使用奇数个服务器。因为zookeeper 通过判断大多数节点的存活来判断整个服务是否可用。比如3个节点，挂掉了2个表示整个集群挂掉，而用偶数4个，挂掉了2个也表示其并不是大部分存活，因此也会挂掉。</p>
<ol>
<li>集群部署</li>
</ol>
<p>配置语法：<br>server.节点ID=IP:数据同步端口:选举端口</p>
<ul>
<li><strong>节点ID</strong>：服务id手动指定1至125之间的数字，并写到对应服务节点的 {dataDir}/myid 文件中。</li>
<li><strong>IP地址：</strong>节点的远程IP地址，可以相同。但生产环境就不能这么做了，因为在同一台机器就无法达到容错的目的。所以这种称作为伪集群。</li>
<li><strong>数据同步端口：</strong>主从同时数据复制端口，（做伪集群时端口号不能重复）。</li>
<li><strong>选举端口：</strong>主从节点选举端口，（做伪集群时端口号不能重复）。</li>
</ul>
<p>配置文件示例：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">tickTime=<span class="hljs-number">2000</span><br>dataDir=/soft/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin/dataDir/<span class="hljs-number">1</span><br>clientPort=<span class="hljs-number">2181</span><br>initLimit=<span class="hljs-number">5</span><br>syncLimit=<span class="hljs-number">2</span><br>#以下为集群配置，必须配置在所有节点的zoo.cfg文件中<br>server.<span class="hljs-number">1</span>=zoo1:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br>server.<span class="hljs-number">2</span>=zoo2:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br>server.<span class="hljs-number">3</span>=zoo3:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br></code></pre></td></tr></table></figure>

<h2 id="集群配置流程："><a href="#集群配置流程：" class="headerlink" title="集群配置流程："></a>集群配置流程：</h2><p>1、分别创建3个data目录用于存储各节点数据</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">mkdir</span> data<br><span class="hljs-built_in">mkdir</span> data/<span class="hljs-number">1</span><br><span class="hljs-built_in">mkdir</span> data/<span class="hljs-number">3</span><br><span class="hljs-built_in">mkdir</span> data/<span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>2、编写myid文件</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">echo</span> <span class="hljs-number">1</span> &gt; data/<span class="hljs-number">1</span>/myid<br><span class="hljs-built_in">echo</span> <span class="hljs-number">3</span> &gt; data/<span class="hljs-number">3</span>/myid<br><span class="hljs-built_in">echo</span> <span class="hljs-number">2</span> &gt; data/<span class="hljs-number">2</span>/myid<br></code></pre></td></tr></table></figure>

<p>3、编写配置文件<br><em>conf/zoo1.cfg</em></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">tickTime=<span class="hljs-number">2000</span><br>initLimit=<span class="hljs-number">10</span><br>syncLimit=<span class="hljs-number">5</span><br>dataDir=/soft/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin/dataDir/<span class="hljs-number">1</span><br>clientPort=<span class="hljs-number">2181</span><br>#集群配置<br>server.<span class="hljs-number">1</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br>server.<span class="hljs-number">2</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br>server.<span class="hljs-number">3</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure>

<p><em>conf/zoo2.cfg</em></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">tickTime=<span class="hljs-number">2000</span><br>initLimit=<span class="hljs-number">10</span><br>syncLimit=<span class="hljs-number">5</span><br>dataDir=d/soft/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin/dataDir/<span class="hljs-number">2</span><br>clientPort=<span class="hljs-number">2182</span><br>#集群配置<br>server.<span class="hljs-number">1</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br>server.<span class="hljs-number">2</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br>server.<span class="hljs-number">3</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure>

<p><em>conf/zoo3.cfg</em></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">tickTime=<span class="hljs-number">2000</span><br>initLimit=<span class="hljs-number">10</span><br>syncLimit=<span class="hljs-number">5</span><br>dataDir=/soft/apache-zookeeper-<span class="hljs-number">3</span>.<span class="hljs-number">5</span>.<span class="hljs-number">5</span>-bin/dataDir/<span class="hljs-number">3</span><br>clientPort=<span class="hljs-number">2183</span><br>#集群配置<br>server.<span class="hljs-number">1</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2887</span>:<span class="hljs-number">3887</span><br>server.<span class="hljs-number">2</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2888</span>:<span class="hljs-number">3888</span><br>server.<span class="hljs-number">3</span>=<span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2889</span>:<span class="hljs-number">3889</span><br></code></pre></td></tr></table></figure>

<p>4、分别启动</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">./bin/zkServer.sh <span class="hljs-built_in">start</span> conf/zoo1.cfg<br>./bin/zkServer.sh <span class="hljs-built_in">start</span> conf/zoo2.cfg<br>./bin/zkServer.sh <span class="hljs-built_in">start</span> conf/zoo3.cfg<br></code></pre></td></tr></table></figure>

<p>5、分别查看状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">./bin/zkServer.sh status conf/zoo1.cfg<br><span class="hljs-function">Mode: <span class="hljs-title">follower</span></span><br><span class="hljs-function">./<span class="hljs-title">bin</span>/<span class="hljs-title">zkServer.sh</span> <span class="hljs-title">status</span> <span class="hljs-title">conf</span>/<span class="hljs-title">zoo2.cfg</span></span><br><span class="hljs-function"><span class="hljs-title">Mode</span>: <span class="hljs-title">leader</span></span><br><span class="hljs-function">./<span class="hljs-title">bin</span>/<span class="hljs-title">zkServer.sh</span> <span class="hljs-title">status</span> <span class="hljs-title">conf</span>/<span class="hljs-title">zoo3.cfg</span></span><br><span class="hljs-function"><span class="hljs-title">Mode</span>: <span class="hljs-title">follower</span></span><br></code></pre></td></tr></table></figure>

<p><strong>检查集群复制情况：</strong><br>1、分别连接指定节点<br>zkCli.sh 后加参数-server 表示连接指定IP与端口。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">./bin/zkCli.sh -server <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2181</span><br>./bin/zkCli.sh -server <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2182</span><br>./bin/zkCli.sh -server <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">2183</span><br></code></pre></td></tr></table></figure>

<p>2、任意节点中创建数据，查看其它节点已经同步成功。</p>
<p>注意： -server参数后同时连接多个服务节点，并用逗号隔开 127.0.0.1:2181,127.0.0.1:2182</p>
<p><strong>集群角色说明</strong></p>
<p>zookeeper 集群中总共有三种角色，分别是leader（主节点）follower(子节点) observer（次级子节点）</p>
<table>
<thead>
<tr>
<th align="left">角色</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>leader</strong></td>
<td align="left">主节点，又名领导者。用于写入数据，通过选举产生，如果宕机将会选举新的主节点。</td>
</tr>
<tr>
<td align="left"><strong>follower</strong></td>
<td align="left">子节点，又名追随者。用于实现数据的读取。同时他也是主节点的备选节点，并用拥有投票权。</td>
</tr>
<tr>
<td align="left"><strong>observer</strong></td>
<td align="left">次级子节点，又名观察者。用于读取数据，与fllower区别在于没有投票权，不能选为主节点。并且在计算集群可用状态时不会将observer计算入内。</td>
</tr>
</tbody></table>
<p><strong>observer配置：</strong><br>只要在集群配置中加上observer后缀即可，示例如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">server</span>.<span class="hljs-number">3</span>=<span class="hljs-number">127.0.0.1:2889</span>:<span class="hljs-number">3889</span>:observer<br></code></pre></td></tr></table></figure>

<h3 id="选举机制"><a href="#选举机制" class="headerlink" title="选举机制"></a>选举机制</h3><p>通过 ./bin/zkServer.sh status &lt;zoo配置文件&gt; 命令可以查看到节点状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">./bin/zkServer.sh status conf/zoo1.cfg<br><span class="hljs-function">Mode: <span class="hljs-title">follower</span></span><br><span class="hljs-function">./<span class="hljs-title">bin</span>/<span class="hljs-title">zkServer.sh</span> <span class="hljs-title">status</span> <span class="hljs-title">conf</span>/<span class="hljs-title">zoo2.cfg</span></span><br><span class="hljs-function"><span class="hljs-title">Mode</span>: <span class="hljs-title">leader</span></span><br><span class="hljs-function">./<span class="hljs-title">bin</span>/<span class="hljs-title">zkServer.sh</span> <span class="hljs-title">status</span> <span class="hljs-title">conf</span>/<span class="hljs-title">zoo3.cfg</span></span><br><span class="hljs-function"><span class="hljs-title">Mode</span>: <span class="hljs-title">follower</span></span><br></code></pre></td></tr></table></figure>

<p><strong>投票机制说明：</strong></p>
<ul>
<li>选举原则：比较每个节点的(zxid,myid),在当选节点的票数&gt;总节点数/2（该原则可以避免zk集群的脑裂问题），<strong>zxid大者当选</strong>，<strong>若zxid相同再比较myid，myid大者当选</strong>；若当前已发生投票节点数未过半，则继续等待投票</li>
</ul>
<h5 id="Zookeeper选举机制——启动阶段的leader选举"><a href="#Zookeeper选举机制——启动阶段的leader选举" class="headerlink" title="Zookeeper选举机制——启动阶段的leader选举"></a>Zookeeper选举机制——启动阶段的leader选举</h5><p>zk集群至少要有3个节点，假如有5个节点1、2、3、4、5先后启动，它们启动时的zxid都是一样的(设为0):</p>
<p>-&gt;节点1进入looking选举状态，给自己投票，发出(0,1)，此时当选节点票数=1&lt;节点总数的一半=2.5，故节点1仍保持looking状态继续等待选举</p>
<p>-&gt;节点2进入looking选举状态，给自己投票，发出(0,2)，myid为2最大，2当选，但此时当选节点票数=2&lt;节点总数的一半=2.5，故节点2仍保持looking状态继续等待选举</p>
<p>-&gt;节点3进入looking选举状态，给自己投票，发出(0,3)，myid为3最大，3当选，且此时当选节点票数=3&gt;节点总数的一半=2.5，故节点3当选leader</p>
<p>-&gt;节点4进入looking选举状态，给自己投票，发出(0,4)，但此时集群leader已选出，所以节点4仍成为follwer</p>
<p>-&gt;节点5进入looking选举状态，给自己投票，发出(0,5)，但此时集群leader已选出，所以节点5仍成为follwer</p>
<p>-&gt;选举完成后，leader的状态由looking变为leading，follower的状态由looking变为following</p>
<p><strong>总的来说，启动阶段的选举当选的必然为位于中间的节点</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper01-%E7%AE%80%E4%BB%8B%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BD%BF%E7%94%A8/d307740d854d49919567abd2e7813a2f.png" alt="image-20220424234345562"></p>
<h5 id="Zookeeper选举机制——运行阶段的选举"><a href="#Zookeeper选举机制——运行阶段的选举" class="headerlink" title="Zookeeper选举机制——运行阶段的选举"></a>Zookeeper选举机制——运行阶段的选举</h5><p>运行阶段每个节点的zxid都可能不同，但选举原则与启动阶段一样，都是先比较zxid,再比较myid，假如主节点3运行中挂掉了，其他所有从节点全部进入looking状态，节点1、2、4、5的zxid为121、122、124、125，且各从节点都推举自己为下一个leader，节点1发出（121,1），节点2发出（122，2），节点4发出（124，4），由于节点4的zxid比1、2的大，故4当选，且当选节点票数=3&gt;总节点数/2=5/2=2.5,所以4当选新一代leader，节点5发出（125，5），但此时已经选举出leader，所以5成为follwer，最后leader变更状态为leading，follower变更为following</p>
]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-zookeeper02-常用应用场景</title>
    <url>/2022/04/25/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/</url>
    <content><![CDATA[<h1 id="zookeeper-应用场景"><a href="#zookeeper-应用场景" class="headerlink" title="zookeeper 应用场景"></a>zookeeper 应用场景</h1><h2 id="一、分布式集群管理"><a href="#一、分布式集群管理" class="headerlink" title="一、分布式集群管理"></a>一、分布式集群管理</h2><ol>
<li>主动查看线上服务节点</li>
<li>查看服务节点资源使用情况</li>
<li>服务离线通知</li>
<li>服务资源（CPU、内存、硬盘）超出阀值通知</li>
</ol>
<p><strong>架构设计：</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220426081710019.png" alt="image-20220426081710019"></p>
<h3 id="节点结构："><a href="#节点结构：" class="headerlink" title="节点结构："></a>节点结构：</h3><p>server-manager  //根节点</p>
<p>​    server00000001:<json> //服务节点</json></p>
<p>​    server00000002:<json> //服务节点</json></p>
<p>​    server00000003:<json> //服务节点</json></p>
<h3 id="服务状态信息"><a href="#服务状态信息" class="headerlink" title="服务状态信息:"></a>服务状态信息:</h3><p>a. ip </p>
<p>b. cpu </p>
<p>c. memory </p>
<p>d. disk</p>
<h3 id="功能实现"><a href="#功能实现" class="headerlink" title="功能实现"></a>功能实现</h3><p>各个服务节点数据生成与上报</p>
<p>集群管理中心<strong>主动查询</strong>（拉）</p>
<p>监听<strong>被动通知</strong>节点变化情况，根据规则实时告警等（推）</p>
<p>关键示例代码： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Agent.premain(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">null</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String server = <span class="hljs-string">&quot;192.168.136.1:2181&quot;</span>;<br>    ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Agent instance;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String rootPath = <span class="hljs-string">&quot;/server-manger&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String servicePath = rootPath + <span class="hljs-string">&quot;/service&quot;</span>;<br>    <span class="hljs-keyword">private</span> String nodePath;<br>    <span class="hljs-keyword">private</span> Thread stateThread;<br>    List&lt;OsBean&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">premain</span><span class="hljs-params">(String args, Instrumentation instrumentation)</span> </span>&#123;<br>        instance = <span class="hljs-keyword">new</span> Agent();<br>        <span class="hljs-keyword">if</span> (args != <span class="hljs-keyword">null</span>) &#123;<br>            instance.server = args;<br>        &#125;<br>        instance.init();<br>    &#125;<br><br>    <span class="hljs-comment">// 初始化连接</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(server);<br>        System.out.println(<span class="hljs-string">&quot;zk连接成功&quot;</span> + server);<br>        buildRoot();<br>        createServerNode();<br>        <span class="hljs-comment">//启动更新线程</span><br>        stateThread = <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                updateServerNode();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">2000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;zk_stateThread&quot;</span>);<br>        stateThread.setDaemon(<span class="hljs-keyword">true</span>);<br>        stateThread.start();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 构建根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(rootPath)) &#123;<br>            zkClient.createPersistent(rootPath);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 生成服务节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createServerNode</span><span class="hljs-params">()</span> </span>&#123;<br>        nodePath = zkClient.createEphemeralSequential(servicePath, getOsInfo());<br>        System.out.println(<span class="hljs-string">&quot;创建节点:&quot;</span> + nodePath);<br>    &#125;<br><br>    <span class="hljs-comment">// 监听服务节点状态改变</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateServerNode</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient.writeData(nodePath, getOsInfo());<br>    &#125;<br><br>    <span class="hljs-comment">// 更新服务节点状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOsInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        OsBean bean = <span class="hljs-keyword">new</span> OsBean();<br><br>        bean.lastUpdateTime = System.currentTimeMillis();<br>        bean.ip = getLocalIp();<br>        bean.cpu = CPUMonitorCalc.getInstance().getProcessCpu();<br>        MemoryUsage memoryUsag = ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();<br>        bean.usableMemorySize = memoryUsag.getUsed() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        bean.maxMemorySize = memoryUsag.getMax() / <span class="hljs-number">1024</span> / <span class="hljs-number">1024</span>;<br>        <span class="hljs-keyword">return</span> JSON.toJSONString(bean);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateNode</span><span class="hljs-params">(String path, Object data)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (zkClient.exists(path)) &#123;<br>            zkClient.writeData(path, data);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            zkClient.createEphemeral(path, data);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getLocalIp</span><span class="hljs-params">()</span> </span>&#123;<br>        InetAddress addr = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            addr = InetAddress.getLocalHost();<br>        &#125; <span class="hljs-keyword">catch</span> (UnknownHostException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>        &#125;<br>        <span class="hljs-keyword">return</span> addr.getHostAddress();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20230201215016793.png" alt="image-20230201215016793"></p>
<p>效果图：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220427210231006.png" alt="image-20220427210231006"></p>
<h2 id="⼆-、分布式注册中⼼-（服务发现与注册）"><a href="#⼆-、分布式注册中⼼-（服务发现与注册）" class="headerlink" title="⼆ 、分布式注册中⼼ （服务发现与注册）"></a>⼆ 、分布式注册中⼼ （服务发现与注册）</h2><p>​    在单体式服务中，通常是由多个客户端去调用一个服务，只要在客户端中配置唯一服务节点地址即可，当升级到分布式后，服务节点变多，像阿里一线大厂服务节点更是上万之多，这么多节点不可能手动配置在客户端，这里就需要一个中间服务，专门用于帮助客户端发现服务节点，即许多技术书籍经常提到的<strong>服务发现</strong>。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220427211711658.png" alt="image-20220427211711658"></p>
<p>一个完整的注册中心涵盖以下功能特性：</p>
<ul>
<li><strong>服务注册：</strong>提供者上线时将自提供的服务提交给注册中心。</li>
<li><strong>服务注销：</strong>通知注册心提供者下线。</li>
<li><strong>服务订阅</strong>：动态实时接收服务变更消息。</li>
<li><strong>可靠</strong>：注册服务本身是集群的，数据冗余存储。避免单点故障，及数据丢失。</li>
<li><strong>容错</strong>：当服务提供者出现宕机，断电等极情况时，注册中心能够动态感知并通知客户端服务提供者的状态。</li>
</ul>
<h3 id="Dubbo-对zookeeper的使用"><a href="#Dubbo-对zookeeper的使用" class="headerlink" title="Dubbo 对zookeeper的使用"></a>Dubbo 对zookeeper的使用</h3><p>阿里著名的开源项目Dubbo 是一个基于JAVA的RCP框架，其中必不可少的注册中心可基于多种第三方组件实现，但其官方推荐的还是Zookeeper做为注册中心服务。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220427213409554.png" alt="image-20220427213409554"></p>
<p>​                <img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220427213417707.png" alt="image-20220427213417707">    </p>
<p><strong>节点说明：</strong></p>
<table>
<thead>
<tr>
<th align="left"><strong>类别</strong></th>
<th align="left"><strong>属性</strong></th>
<th align="left"><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>Root</strong></td>
<td align="left">持久节点</td>
<td align="left">根节点名称，默认是 “dubbo”</td>
</tr>
<tr>
<td align="left"><strong>Service</strong></td>
<td align="left">持久节点</td>
<td align="left">服务名称，完整的服务类名</td>
</tr>
<tr>
<td align="left"><strong>type</strong></td>
<td align="left">持久节点</td>
<td align="left">可选值：providers(提供者)、consumers（消费者）、configurators(动态配置)、routers</td>
</tr>
<tr>
<td align="left"><strong>URL</strong></td>
<td align="left">临时节点</td>
<td align="left">url名称 包含服务提供者的 IP 端口 及配置等信息。</td>
</tr>
</tbody></table>
<p><strong>流程说明</strong></p>
<ol>
<li>服务提供者启动时: 向 /dubbo/com.foo.BarService/providers 目录下写入自己的 URL 地址</li>
<li>服务消费者启动时: 订阅 /dubbo/com.foo.BarService/providers 目录下的提供者 URL 地址。并向 /dubbo/com.foo.BarService/consumers 目录下写入自己的 URL 地址</li>
<li>监控中心启动时: 订阅 /dubbo/com.foo.BarService 目录下的所有提供者和消费者 URL 地址。</li>
</ol>
<h3 id="与其他服务发现与注册的区别"><a href="#与其他服务发现与注册的区别" class="headerlink" title="与其他服务发现与注册的区别"></a>与其他服务发现与注册的区别</h3><p><a href="https://glory.blog.csdn.net/article/details/100023415?spm=1001.2101.3001.6650.1&amp;utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.pc_relevant_default&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~default-1.pc_relevant_default&amp;utm_relevant_index=2">参考</a></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220502223617004.png" alt="image-20220502223617004"></p>
<h2 id="三、分布式JOB"><a href="#三、分布式JOB" class="headerlink" title="三、分布式JOB"></a>三、分布式JOB</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20230110230730374.png" alt="image-20230110230730374"></p>
<ol>
<li>多个服务节点只允许其中一个主节点运行JOB任务。</li>
<li>当主节点挂掉后能自动切换主节点，继续执行JOB任务。</li>
</ol>
<p><strong>node结构：</strong></p>
<ol>
<li>server-master</li>
<li>server0001:master</li>
<li>server0002:slave</li>
<li>server000n:slave</li>
</ol>
<p><strong>选举流程：</strong><br>服务启动：</p>
<ol>
<li>在server-master下创建server子节点，值为slave</li>
<li>获取所有server-master 下所有子节点</li>
<li>判断是否存在master 节点</li>
<li>如果没有设置自己为master节点</li>
</ol>
<p>子节点删除事件触发：</p>
<ol>
<li>获取所有server-master 下所有子节点</li>
<li>判断是否存在master 节点</li>
<li>如果没有设置最小值序号为master 节点</li>
</ol>
<h2 id="四、分布式锁"><a href="#四、分布式锁" class="headerlink" title="四、分布式锁"></a>四、分布式锁</h2><h3 id="锁的的基本概念："><a href="#锁的的基本概念：" class="headerlink" title="锁的的基本概念："></a><strong>锁的的基本概念：</strong></h3><p>开发中锁的概念并不陌生，通过锁可以实现在多个线程或多个进程间在争抢资源时，能够合理的分配置资源的所有权。在单体应用中我们可以通过 synchronized 或ReentrantLock 来实现锁。但在分布式系统中，仅仅是加synchronized 是不够的，需要借助第三组件来实现。比如一些简单的做法是使用 关系型数据行级锁来实现不同进程之间的互斥，但大型分布式系统的性能瓶颈往往集中在数据库操作上。为了提高性能得采用如Redis、Zookeeper之内的组件实现分布式锁。</p>
<p><strong>共享锁：</strong>也称作只读锁，当一方获得共享锁之后，其它方也可以获得共享锁。但其只允许读取。在共享锁全部释放之前，其它方不能获得写锁。<br><strong>排它锁：</strong>也称作读写锁，获得排它锁后，可以进行数据的读写。在其释放之前，其它方不能获得任何锁。</p>
<h3 id="锁的获取："><a href="#锁的获取：" class="headerlink" title="锁的获取："></a>锁的获取：</h3><p>某银行帐户，可以同时进行帐户信息的读取，但读取其间不能修改帐户数据。其帐户ID为:888</p>
<h4 id="获得读锁流程："><a href="#获得读锁流程：" class="headerlink" title="获得读锁流程："></a>获得读锁流程：</h4><p>1、基于资源ID创建临时序号读锁节点 /lock/888.R0000000002 Read </p>
<p>2、获取 /lock 下所有⼦节点，判断其最⼩的节点是否为读锁，如果是则获锁成功 </p>
<p>3、最⼩节点不是读锁，则阻塞等待。添加lock/ ⼦节点变更监听。 </p>
<p>4、当节点变更监听触发，执⾏第2步 </p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220428223014338.png" alt="image-20220428223014338"></p>
<p><strong>数据结构：</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220428223333405.png" alt="image-20220428223333405"></p>
<h4 id="获得写锁流程："><a href="#获得写锁流程：" class="headerlink" title="获得写锁流程："></a>获得写锁流程：</h4><p>1、基于资源ID创建临时序号写锁节点  /lock/888.R0000000002 Write<br>2、获取 /lock 下所有子节点，判断其最小的节点是否为自己，如果是则获锁成功<br>3、最小节点不是自己，则阻塞等待。添加lock/ 子节点变更监听。<br>4、当节点变更监听触发，执行第2步</p>
<h4 id="释放锁："><a href="#释放锁：" class="headerlink" title="释放锁："></a>释放锁：</h4><p>读取完毕后，⼿动删除临时节点，如果获锁期间宕机，则会在会话失效后⾃动删除。</p>
<h4 id="关于羊群效应："><a href="#关于羊群效应：" class="headerlink" title="关于羊群效应："></a>关于羊群效应：</h4><p>​    在等待锁获得期间，所有等待节点都在监听 Lock节点，一但lock 节点变更所有等待节点都会被触发，然后在同时反查Lock 子节点。如果等待对例过大会使用Zookeeper承受非常大的流量压力。</p>
<p>​    为了改善这种情况，可以采用监听链表的方式，每个等待对列只监听前一个节点（如果本身是读锁，则监听自己之前的最近的一个读锁），如果前一个节点释放锁的时候，才会被触发通知。这样就形成了一个监听链表。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220428224410828.png" alt="image-20220428224410828"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-zookeeper02-%E5%B8%B8%E7%94%A8%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF/image-20220428224523002.png" alt="image-20220428224523002"></p>
<h3 id="ZkClient自定义实现分布式锁"><a href="#ZkClient自定义实现分布式锁" class="headerlink" title="ZkClient自定义实现分布式锁"></a>ZkClient自定义实现分布式锁</h3><h4 id="自定义实现"><a href="#自定义实现" class="headerlink" title="自定义实现"></a>自定义实现</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String server = <span class="hljs-string">&quot;192.168.0.149:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String rootPath = <span class="hljs-string">&quot;/tuling-lock&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZookeeperLock</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(server, <span class="hljs-number">5000</span>, <span class="hljs-number">20000</span>);<br>        buildRoot();<br>    &#125;<br><br>    <span class="hljs-comment">// 构建根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(rootPath)) &#123;<br>            zkClient.createPersistent(rootPath);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lock <span class="hljs-title">lock</span><span class="hljs-params">(String lockId, <span class="hljs-keyword">long</span> timeout)</span> </span>&#123;<br>        Lock lockNode = createLockNode(lockId);<br>        lockNode = tryActiveLock(lockNode);<span class="hljs-comment">// 尝试激活锁</span><br>        <span class="hljs-keyword">if</span> (!lockNode.isActive()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (lockNode) &#123;<br>                    lockNode.wait(timeout);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!lockNode.isActive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot; lock  timeout&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lockNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Lock lock)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (lock.isActive()) &#123;<br>            zkClient.delete(lock.getPath());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// 尝试激活锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Lock <span class="hljs-title">tryActiveLock</span><span class="hljs-params">(Lock lockNode)</span> </span>&#123;<br>        <span class="hljs-comment">// 判断当前是否为最小节点</span><br>        List&lt;String&gt; list = zkClient.getChildren(rootPath)<br>                .stream()<br>                .sorted()<br>                .map(p -&gt; rootPath + <span class="hljs-string">&quot;/&quot;</span> + p)<br>                .collect(Collectors.toList());<br>        String firstNodePath = list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (firstNodePath.equals(lockNode.getPath())) &#123;<br>            lockNode.setActive(<span class="hljs-keyword">true</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String upNodePath = list.get(list.indexOf(lockNode.getPath()) - <span class="hljs-number">1</span>);<br>            zkClient.subscribeDataChanges(upNodePath, <span class="hljs-keyword">new</span> IZkDataListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-comment">// 事件处理 与心跳 在同一个线程，如果Debug时占用太多时间，将导致本节点被删除，从而影响锁逻辑。</span><br>                    System.out.println(<span class="hljs-string">&quot;节点删除:&quot;</span> + dataPath);<br>                     Lock lock = tryActiveLock(lockNode);<br>                    <span class="hljs-keyword">synchronized</span> (lockNode) &#123;<br>                        <span class="hljs-keyword">if</span> (lock.isActive()) &#123;<br>                            lockNode.notify();<br>                        &#125;<br>                    &#125;<br>                    zkClient.unsubscribeDataChanges(upNodePath, <span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lockNode;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lock <span class="hljs-title">createLockNode</span><span class="hljs-params">(String lockId)</span> </span>&#123;<br>        String nodePath = zkClient.createEphemeralSequential(rootPath + <span class="hljs-string">&quot;/&quot;</span> + lockId, <span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Lock(lockId, nodePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String lockId;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Lock</span><span class="hljs-params">(String lockId, String path)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.lockId = lockId;<br>        <span class="hljs-keyword">this</span>.path = path;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> Boolean isActive;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPath</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> path;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPath</span><span class="hljs-params">(String path)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.path = path;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">isActive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isActive;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setActive</span><span class="hljs-params">(Boolean active)</span> </span>&#123;<br>        isActive = active;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">getActive</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isActive;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="代码存在的漏洞"><a href="#代码存在的漏洞" class="headerlink" title="代码存在的漏洞"></a>代码存在的漏洞</h4><p>1、监听的节点可能在添加监听前释放了，导致线程卡死</p>
<p>2、即使监听前判断了节点是否存在，监听的节点可能在添加监听过程中释放了，导致线程卡死</p>
<h4 id="自定义实现1-0-wait-notify"><a href="#自定义实现1-0-wait-notify" class="headerlink" title="自定义实现1.0-wait|notify"></a>自定义实现1.0-wait|notify</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperLock1</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String server = <span class="hljs-string">&quot;zookeeper01.com:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String rootPath = <span class="hljs-string">&quot;/distribute-lock&quot;</span>;<br>    <span class="hljs-keyword">private</span> Logger logger = LoggerFactory.getLogger(ZookeeperLock1.class);<br>    <span class="hljs-keyword">private</span> Random random  = <span class="hljs-keyword">new</span> Random();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZookeeperLock1</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(server, <span class="hljs-number">5000</span>, <span class="hljs-number">20000</span>);<br>        buildRoot();<br>    &#125;<br><br>    <span class="hljs-comment">// 构建根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(rootPath)) &#123;<br>            zkClient.createPersistent(rootPath);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lock <span class="hljs-title">lock</span><span class="hljs-params">(String lockId, <span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Lock lockNode = createLockNode(lockId);<br>        lockNode = tryActiveLock(lockNode);<span class="hljs-comment">// 尝试激活锁</span><br>        <span class="hljs-keyword">if</span> (!lockNode.isActive()) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">synchronized</span> (lockNode) &#123;<br>                    logger.warn(<span class="hljs-string">&quot;wait()&quot;</span>);<br>                    lockNode.wait(timeout);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!lockNode.isActive()) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(<span class="hljs-string">&quot; lock  timeout&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> lockNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(Lock lock)</span> </span>&#123;<br>        logger.info(<span class="hljs-string">&quot;释放锁：&quot;</span>+lock.getPath());<br>        zkClient.delete(lock.getPath());<br><span class="hljs-comment">//        if (lock.isActive()) &#123;</span><br><span class="hljs-comment">//        &#125;</span><br>    &#125;<br><br>    <span class="hljs-comment">// 尝试激活锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Lock <span class="hljs-title">tryActiveLock</span><span class="hljs-params">(Lock lockNode)</span> </span>&#123;<br>        <span class="hljs-comment">// 判断当前是否为最小节点</span><br>        List&lt;String&gt; list = zkClient.getChildren(rootPath)<br>                .stream()<br>                .sorted()<br>                .map(p -&gt; rootPath + <span class="hljs-string">&quot;/&quot;</span> + p)<br>                .collect(Collectors.toList());<br>        String firstNodePath = list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (firstNodePath.equals(lockNode.getPath())) &#123;<br>            lockNode.setActive(<span class="hljs-keyword">true</span>);<br>            logger.info(lockNode.getPath()+<span class="hljs-string">&quot;成功获取锁&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String upNodePath = list.get(list.indexOf(lockNode.getPath()) - <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                Thread.sleep(random.nextInt(<span class="hljs-number">10</span>) * <span class="hljs-number">200L</span> );<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>            doListenPreNode(lockNode, upNodePath);<br>            logger.info(lockNode.getPath()+<span class="hljs-string">&quot;成功监听&quot;</span>+upNodePath);<br>            <span class="hljs-keyword">if</span>(!zkClient.exists(upNodePath))&#123;<br>                logger.info(upNodePath+<span class="hljs-string">&quot;已被删除，监听无效，从新尝试获取锁&quot;</span>);<br>                <span class="hljs-keyword">return</span> tryActiveLock(lockNode);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> lockNode;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doListenPreNode</span><span class="hljs-params">(Lock lockNode, String upNodePath)</span> </span>&#123;<br>        zkClient.subscribeDataChanges(upNodePath, <span class="hljs-keyword">new</span> IZkDataListener() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                <span class="hljs-comment">// 事件处理 与心跳 在同一个线程，如果Debug时占用太多时间，将导致本节点被删除，从而影响锁逻辑。</span><br>                logger.info(<span class="hljs-string">&quot;监听到节点删除:&quot;</span> + dataPath);<br>                Lock lock = tryActiveLock(lockNode);<br>                <span class="hljs-keyword">synchronized</span> (lockNode) &#123;<br>                    <span class="hljs-keyword">if</span> (lock.isActive()) &#123;<br>                        logger.info(dataPath+<span class="hljs-string">&quot;节点监听后抢到锁:&quot;</span> + lock.getPath());<br>                        lockNode.notify();<br>                    &#125;<br>                &#125;<br>                zkClient.unsubscribeDataChanges(upNodePath, <span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Lock <span class="hljs-title">createLockNode</span><span class="hljs-params">(String lockId)</span> </span>&#123;<br>        String nodePath = zkClient.createEphemeralSequential(rootPath + <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Lock(lockId, nodePath);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer i = <span class="hljs-number">0</span>;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br>        Logger logger = LoggerFactory.getLogger(LockTest.class);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                i = i+<span class="hljs-number">1</span>;<br>            &#125;).start();<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        i  = <span class="hljs-number">0</span>;<br>        ZookeeperLock1 zookeeperLock1 = <span class="hljs-keyword">new</span> ZookeeperLock1();<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span>; j++) &#123;<br>            String lockId = j + <span class="hljs-string">&quot;&quot;</span>;<br>            executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    String lock = <span class="hljs-keyword">null</span>;<br>                    Lock lock1 = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock1 = zookeeperLock1.lock(lockId, <span class="hljs-number">5000L</span>);<br>                        i = i + Integer.parseInt(lockId);<br>                        logger.info(<span class="hljs-string">&quot;i:&quot;</span>+i);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                        logger.info(<span class="hljs-string">&quot;执行异常&quot;</span>);<br>                    &#125;<span class="hljs-keyword">finally</span> &#123;<br>                        zookeeperLock1.unlock(lock1);<br>                    &#125;<br><br><br>                &#125;<br>            &#125;);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义实现2-0-利用CountDownLatch阻塞"><a href="#自定义实现2-0-利用CountDownLatch阻塞" class="headerlink" title="自定义实现2.0-利用CountDownLatch阻塞"></a>自定义实现2.0-利用CountDownLatch阻塞</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZookeeperLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String server = <span class="hljs-string">&quot;zookeeper01.com:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String rootPath = <span class="hljs-string">&quot;/distribute-lock&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZookeeperLock</span><span class="hljs-params">()</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(server, <span class="hljs-number">50000</span>,<span class="hljs-number">50000</span>);<br>        buildRoot();<br>    &#125;<br><br>    <span class="hljs-comment">// 构建根节点</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildRoot</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(rootPath)) &#123;<br>            zkClient.createPersistent(rootPath);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lock</span><span class="hljs-params">(String lockId)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//第一步：肯定是去创建临时节点，如果创建后的节点的第一个节点就是自己，</span><br>        <span class="hljs-comment">// 说明锁就抢到了</span><br>        String lockNode = createLockNode(lockId);<br>        tryGetDisLock(lockNode);<br>        <span class="hljs-keyword">return</span> lockNode;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 超时返回null，不超时返回分布式锁的节点值</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> lockId </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeout</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">lock</span><span class="hljs-params">(String lockId, <span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//第一步：肯定是去创建临时节点，如果创建后的节点的第一个节点就是自己，</span><br>        <span class="hljs-comment">// 说明锁就抢到了</span><br>        String lockNode = createLockNode(lockId);<br>        <span class="hljs-keyword">if</span>(tryGetDisLock(lockNode,timeout))&#123;<br>            <span class="hljs-keyword">return</span> lockNode;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">(String lock)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;释放：&quot;</span>+ lock);<br>        zkClient.delete(lock);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tryGetDisLock</span><span class="hljs-params">(String lockNode)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">// 判断当前是否为最小节点</span><br>        List&lt;String&gt; list = zkClient.getChildren(rootPath)<br>                .stream()<br>                .sorted()<br>                .map(p -&gt; rootPath + <span class="hljs-string">&quot;/&quot;</span> + p)<br>                .collect(Collectors.toList());<br>        String firstNodePath = list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (firstNodePath.equals(lockNode)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String upNodePath = list.get(list.indexOf(lockNode) - <span class="hljs-number">1</span>);<br>            CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            zkClient.subscribeDataChanges(upNodePath, <span class="hljs-keyword">new</span> IZkDataListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;监控到了，&quot;</span> + dataPath + <span class="hljs-string">&quot;节点发生变化了&quot;</span>);<br>                    countDownLatch.countDown();<br>                    zkClient.unsubscribeDataChanges(upNodePath,<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">if</span> (!zkClient.exists(upNodePath))&#123;<br>                tryGetDisLock(lockNode);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            countDownLatch.await();<br>            tryGetDisLock(lockNode);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Boolean <span class="hljs-title">tryGetDisLock</span><span class="hljs-params">(String lockNode, <span class="hljs-keyword">long</span> timeout)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 判断当前是否为最小节点</span><br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>        List&lt;String&gt; list = zkClient.getChildren(rootPath)<br>                .stream()<br>                .sorted()<br>                .map(p -&gt; rootPath + <span class="hljs-string">&quot;/&quot;</span> + p)<br>                .collect(Collectors.toList());<br>        String firstNodePath = list.get(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">if</span> (firstNodePath.equals(lockNode)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            String upNodePath = list.get(list.indexOf(lockNode) - <span class="hljs-number">1</span>);<br>            CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            zkClient.subscribeDataChanges(upNodePath, <span class="hljs-keyword">new</span> IZkDataListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>                &#125;<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;监控到了，&quot;</span> + dataPath + <span class="hljs-string">&quot;节点发生变化了&quot;</span>);<br>                    countDownLatch.countDown();<br>                    zkClient.unsubscribeDataChanges(upNodePath,<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;);<br>            <span class="hljs-keyword">if</span> (!zkClient.exists(upNodePath))&#123;<br>                timeout = System.currentTimeMillis() - begin;<br>                <span class="hljs-keyword">if</span>(timeout &lt; <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> tryGetDisLock(lockNode,timeout);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(!countDownLatch.await(timeout,TimeUnit.MILLISECONDS))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            timeout = System.currentTimeMillis() - begin;<br>            <span class="hljs-keyword">if</span>(timeout &lt; <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> tryGetDisLock(lockNode,timeout);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">createLockNode</span><span class="hljs-params">(String lockId)</span> </span>&#123;<br>        String nodePath = zkClient.createEphemeralSequential(rootPath + <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-string">&quot;lock&quot;</span>);<br>        <span class="hljs-keyword">return</span> nodePath;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LockTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Integer i = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException, KeeperException </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                i = i+<span class="hljs-number">1</span>;<br>            &#125;).start();<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">100</span>);<br>        System.out.println(i);<br>        i  = <span class="hljs-number">0</span>;<br>        ZookeeperLock zookeeperLock = <span class="hljs-keyword">new</span> ZookeeperLock();<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><span class="hljs-comment">//        for (int j = 1; j &lt;= 1000; j++) &#123;</span><br><span class="hljs-comment">//            String lockId = j + &quot;&quot;;</span><br><span class="hljs-comment">//            executorService.submit(new Runnable() &#123;</span><br><span class="hljs-comment">//                @Override</span><br><span class="hljs-comment">//                public void run() &#123;</span><br><span class="hljs-comment">//                    String lock = null;</span><br><span class="hljs-comment">//                    try &#123;</span><br><span class="hljs-comment">//                        lock = zookeeperLock.lock(lockId);</span><br><span class="hljs-comment">//                    &#125; catch (InterruptedException e) &#123;</span><br><span class="hljs-comment">//                        e.printStackTrace();</span><br><span class="hljs-comment">//                    &#125;</span><br><span class="hljs-comment">//                    i = i + Integer.parseInt(lockId);</span><br><span class="hljs-comment">//                    System.out.println(&quot;lockId:&quot;+lockId);</span><br><span class="hljs-comment">//                    System.out.println(&quot;lock:&quot;+lock);</span><br><span class="hljs-comment">//                    System.out.println(&quot;i:&quot;+i);</span><br><span class="hljs-comment">//                    zookeeperLock.unlock(lock);</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//                &#125;</span><br><span class="hljs-comment">//            &#125;);</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">1000</span>; j++) &#123;<br>            String lockId = j + <span class="hljs-string">&quot;&quot;</span>;<br>            executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    String lock = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        lock = zookeeperLock.lock(lockId,<span class="hljs-number">15000L</span>);<br>                        <span class="hljs-keyword">if</span>(Objects.nonNull(lock))&#123;<br>                            i = i + Integer.parseInt(lockId);<br>                            System.out.println(<span class="hljs-string">&quot;lockId:&quot;</span>+lockId);<br>                            System.out.println(<span class="hljs-string">&quot;lock:&quot;</span>+lock);<br>                            System.out.println(<span class="hljs-string">&quot;i:&quot;</span>+i);<br>                            zookeeperLock.unlock(lock);<br>                        &#125;<span class="hljs-keyword">else</span>&#123;<br>                            System.out.println(<span class="hljs-string">&quot;lockId:&quot;</span>+lockId+<span class="hljs-string">&quot;获取锁超时失败&quot;</span>);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br><br><br>                &#125;<br>            &#125;);<br>        &#125;<br><br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="ZK分布式锁的成熟框架curator"><a href="#ZK分布式锁的成熟框架curator" class="headerlink" title="ZK分布式锁的成熟框架curator"></a>ZK分布式锁的成熟框架curator</h3><figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs POM">&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;curator-framework&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;4.3.0&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;curator-recipes&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;4.3.0&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br>&lt;dependency&gt;<br>    &lt;groupId&gt;org.apache.curator&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;curator-client&lt;&#x2F;artifactId&gt;<br>    &lt;version&gt;4.3.0&lt;&#x2F;version&gt;<br>&lt;&#x2F;dependency&gt;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 使用curator实现分布式锁</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorLock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setI</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.i = i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getI</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        CuratorLock curatorLock = <span class="hljs-keyword">new</span> CuratorLock();<br>        CuratorFramework client = CuratorFrameworkFactory.builder()<br>                .connectString(<span class="hljs-string">&quot;zookeeper01.com:2181&quot;</span>)<br>                .connectionTimeoutMs(<span class="hljs-number">10000</span>)<br>                .sessionTimeoutMs(<span class="hljs-number">10000</span>)<br>                .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">3000</span>, <span class="hljs-number">4</span>)).build();<br>        client.start();<br>        InterProcessMutex lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, <span class="hljs-string">&quot;/distributedLock&quot;</span>);<br>        ExecutorService pool = Executors.newCachedThreadPool();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            pool.submit(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    lock.acquire();<br>                    curatorLock.setI(curatorLock.getI() + <span class="hljs-number">1</span>);<br>                    lock.release();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;);<br>        &#125;<br>        Thread.sleep(<span class="hljs-number">10000</span>);<br>        System.out.println(curatorLock.getI());<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>zookeeper</category>
      </categories>
      <tags>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式01-IO模型介绍</title>
    <url>/2022/01/28/%E5%88%86%E5%B8%83%E5%BC%8F01-IO%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="一、IO模型介绍"><a href="#一、IO模型介绍" class="headerlink" title="一、IO模型介绍"></a>一、IO模型介绍</h1><h2 id="BIO-Blocking-IO"><a href="#BIO-Blocking-IO" class="headerlink" title="BIO(Blocking IO)"></a>BIO(Blocking IO)</h2><h3 id="1、是什么"><a href="#1、是什么" class="headerlink" title="1、是什么"></a>1、是什么</h3><p>​    同步阻塞模型，一个客户端连接对应一个处理线程</p>
<h3 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h3><p>1、IO代码里read操作是阻塞操作，如果连接不做数据读写操作会导致线程阻塞，浪费线程资源 </p>
<p>2、如果线程很多，会导致服务器线程太多，压力太大。</p>
<h3 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h3><p>​    <strong>BIO方式适用于连接数目比较小且固定的架构</strong>， 这种方式对服务器资源要求比较高， 但程序简单易理解。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F01-IO%E6%A8%A1%E5%9E%8B/image-20220128105718185.png" alt="image-20220128105718185"></p>
<h3 id="4、代码示例"><a href="#4、代码示例" class="headerlink" title="4、代码示例"></a>4、代码示例</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">服务端<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket(<span class="hljs-number">9000</span>);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            System.out.println(<span class="hljs-string">&quot;等待连接。。&quot;</span>);<br>            Socket accept = serverSocket.accept();<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接了。。&quot;</span>);<br>            <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    handler(accept);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException | InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handler</span><span class="hljs-params">(Socket socket)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        System.out.println(<span class="hljs-string">&quot;准备read。。&quot;</span>);<br><span class="hljs-comment">//        while(-1 != (read = socket.getInputStream().read(bytes)))&#123;</span><br><span class="hljs-comment">//            System.out.println(&quot;接收到客户端的数据：&quot; + new String(bytes, 0, read));</span><br><span class="hljs-comment">//        &#125;</span><br><span class="hljs-comment">//        System.out.println(&quot;read完毕。。&quot;);</span><br><span class="hljs-comment">//        System.out.println(&quot;thread id = &quot; + Thread.currentThread().getId());</span><br>        <span class="hljs-keyword">int</span> read = socket.getInputStream().read(bytes);<br>        System.out.println(<span class="hljs-string">&quot;read完毕。。&quot;</span>);<br>        <span class="hljs-keyword">if</span> (read != -<span class="hljs-number">1</span> ) &#123;<br>            System.out.println(<span class="hljs-string">&quot;接收到客户端的数据：&quot;</span> + <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<br>            System.out.println(<span class="hljs-string">&quot;thread id = &quot;</span> + Thread.currentThread().getId());<br>        &#125;<br>        socket.getOutputStream().write(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        socket.getOutputStream().flush();<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>            socket.getOutputStream().write(<span class="hljs-string">&quot;ping&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>            socket.getOutputStream().flush();<br>        &#125;<br>    &#125;<br>&#125;<br><br>客户端<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SocketClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Socket socket = <span class="hljs-keyword">new</span> Socket(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">9000</span>);<br>        <span class="hljs-comment">//向服务端发送数据</span><br>        socket.getOutputStream().write(<span class="hljs-string">&quot;Hello Server&quot;</span>.getBytes(<span class="hljs-string">&quot;UTF-8&quot;</span>));<br>        socket.getOutputStream().flush();<br>        System.out.println(<span class="hljs-string">&quot;向服务端发送数据结束&quot;</span>);<br>        <span class="hljs-comment">//接收服务端回传的数据</span><br>        <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = -<span class="hljs-number">1</span>;<br>        System.out.println(<span class="hljs-string">&quot;准备read。。&quot;</span>);<br>        <span class="hljs-keyword">while</span> (-<span class="hljs-number">1</span> != (read = socket.getInputStream().read(bytes)))&#123;<br>            System.out.println(<span class="hljs-string">&quot;接收到服务端的数据：&quot;</span> + <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-number">0</span>, read));<br>        &#125;<br>        socket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">Server:<br>等待连接。。<br>有客户端连接了。。<br>等待连接。。<br>准备read。。<br>read完毕。。<br>接收到客户端的数据：Hello Server<br>thread id = 12<br>有客户端连接了。。<br>等待连接。。<br>准备read。。<br>read完毕。。<br>接收到客户端的数据：Hello Server<br>thread id = 13<br><br>Client:<br>向服务端发送数据结束<br>准备read。。<br>接收到服务端的数据：HelloClient<br>接收到服务端的数据：ping<br>接收到服务端的数据：ping<br>接收到服务端的数据：ping<br>......<br></code></pre></td></tr></table></figure>



<h2 id="NIO-Non-Blocking-IO"><a href="#NIO-Non-Blocking-IO" class="headerlink" title="NIO(Non Blocking IO)"></a>NIO(Non Blocking IO)</h2><h3 id="1、是什么-1"><a href="#1、是什么-1" class="headerlink" title="1、是什么"></a>1、是什么</h3><p>​    同步非阻塞，服务器实现模式为<strong>一个线程可以处理多个请求(连接)，客户端发送的连接请求都会注册到多路复用器selector上，多路复用器轮询到连接有IO请求就进行处理。</strong></p>
<p>I/O多路复用底层一般用的Linux API（select，poll，epoll）来实现，他们的区别如下表：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th>select</th>
<th>poll</th>
<th>epoll(jdk 1.5及以上)</th>
</tr>
</thead>
<tbody><tr>
<td align="left">操作方式</td>
<td>遍历</td>
<td>遍历</td>
<td>回调</td>
</tr>
<tr>
<td align="left">底层实现</td>
<td>数组</td>
<td>链表</td>
<td>哈希表</td>
</tr>
<tr>
<td align="left">IO效率</td>
<td>每次调用都进行线性遍历，时间复杂 度为O(n)</td>
<td>每次调用都进行 线性遍历，时间 复杂度为O(n)</td>
<td>事件通知方式，每当有IO事件就绪，系统注册的回调函数就会被调用，时间复杂度O(1)</td>
</tr>
<tr>
<td align="left">最大连接</td>
<td>有上限</td>
<td>无上限</td>
<td>无上限</td>
</tr>
</tbody></table>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F01-IO%E6%A8%A1%E5%9E%8B/image-20220128111929551.png" alt="image-20220128111929551"></p>
<p>NIO 有三大核心组件： <strong>Channel(通道)， Buffer(缓冲区)，Selector(选择器)</strong> </p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F01-IO%E6%A8%A1%E5%9E%8B/image-20220128112130433.png" alt="image-20220128112130433"></p>
<p>1、channel 类似于流，每个 channel 对应一个 buffer缓冲区，buffer 底层就是个数组<br>2、channel 会注册到 selector 上，由selector根据channel读写事件的发生将其交由某个空闲的线程处理<br>3、selector 可以对应一个或多个线程<br>4、NIO 的 Buffer 和 channel 都是既可以读也可以写</p>
<h3 id="2、优点"><a href="#2、优点" class="headerlink" title="2、优点"></a>2、优点</h3><p>​    一个线程可以处理多个请求，提高CPU资源利用率</p>
<h3 id="3、应用场景-1"><a href="#3、应用场景-1" class="headerlink" title="3、应用场景"></a>3、应用场景</h3><p>​    NIO方式适用于<strong>连接数目多且连接比较短（轻操作） 的架构</strong>， 比如聊天服务器， 弹幕系统， 服务器间通讯，编程比较复杂， JDK1.4 开始支持</p>
<h3 id="4、示例代码"><a href="#4、示例代码" class="headerlink" title="4、示例代码"></a>4、示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NIOServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">// 创建一个在本地端口进行监听的服务Socket通道.并设置为非阻塞方式</span><br>        ServerSocketChannel ssc = ServerSocketChannel.open();<br>        <span class="hljs-comment">//必须配置为非阻塞才能往selector上注册，否则会报错，selector模式本身就是非阻塞模式</span><br>        ssc.configureBlocking(<span class="hljs-keyword">false</span>);<br>        ssc.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        <span class="hljs-comment">// 创建一个选择器selector</span><br>        Selector selector = Selector.open();<br>        <span class="hljs-comment">// 把ServerSocketChannel注册到selector上，并且selector对客户端accept连接操作感兴趣</span><br>        ssc.register(selector, SelectionKey.OP_ACCEPT);<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-comment">// 轮询监听channel里的key，select是阻塞的，accept()也是阻塞的 20</span><br>            System.out.println(<span class="hljs-string">&quot;等待事件发生。。&quot;</span>);<br>            <span class="hljs-keyword">int</span> select = selector.select();<br>            <span class="hljs-comment">// 有客户端请求，被轮询监听到</span><br>            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span>(it.hasNext())&#123;<br>                SelectionKey key = it.next();<br>                it.remove();<br>                handle(key);<br>            &#125;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handle</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">if</span>(key.isAcceptable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端连接事件发生了。。&quot;</span>);<br>            ServerSocketChannel ssc = (ServerSocketChannel) key.channel();<br>            <span class="hljs-comment">//NIO非阻塞体现：此处accept方法是阻塞的，但是这里因为是发生了连接事件，所以这个方法会马上执行完，不会阻塞</span><br>            <span class="hljs-comment">//处理完连接请求不会继续等待客户端的数据发送</span><br>            SocketChannel sc = ssc.accept();<br>            sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>            sc.register(key.selector(),SelectionKey.OP_READ);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isReadable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;有客户端数据可读事件发生了。。&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-comment">//NIO非阻塞体现:首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定是发生了客户端发送数据的事件</span><br>            <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>            <span class="hljs-keyword">if</span> (len != -<span class="hljs-number">1</span>) &#123;<br>                System.out.println(<span class="hljs-string">&quot;读取到客户端发送的数据：&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>            &#125;<br><br>            <span class="hljs-comment">//sc.write(ByteBuffer.wrap(scanner.nextLine().getBytes(StandardCharsets.UTF_8)));</span><br>            sc.write(ByteBuffer.wrap(<span class="hljs-string">&quot;收到 over&quot;</span>.getBytes(StandardCharsets.UTF_8)));<br>            <span class="hljs-comment">//key.interestOps(SelectionKey.OP_WRITE);</span><br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(key.isWritable())&#123;<br>            System.out.println(<span class="hljs-string">&quot;write事件&quot;</span>);<br>            SocketChannel sc = (SocketChannel) key.channel();<br>            <span class="hljs-comment">// NIO事件触发是水平触发</span><br>            <span class="hljs-comment">// 使用Java的NIO编程的时候，在没有数据可以往外写的时候要取消写事件，</span><br>            <span class="hljs-comment">// 在有数据往外写的时候再注册写事件</span><br>            key.interestOps(SelectionKey.OP_READ);<br>            <span class="hljs-comment">//sc.close();</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//客户端</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClient</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        NioClient client = <span class="hljs-keyword">new</span> NioClient();<br>        client.initClient(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">8888</span>);<br>        client.connect();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *获得一个Socket通道，并对该通道做一些初始化的工作</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span> ip 连接的服务器的ip</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@param</span> port 连接的服务器的端口号</span><br><span class="hljs-comment">     *  <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initClient</span><span class="hljs-params">(String ip, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SocketChannel channel = SocketChannel.open();<br>        channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">this</span>.selector = Selector.open();<br>        channel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(ip,port));<br>        channel.register(selector, SelectionKey.OP_CONNECT);<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 采用轮询的方式监听selector上是否有需要处理的事件，如果有，则进行处理</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> IOException</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>            <span class="hljs-keyword">int</span> select = selector.select();<br>            Iterator&lt;SelectionKey&gt; it = selector.selectedKeys().iterator();<br>            <span class="hljs-keyword">while</span> (it.hasNext())&#123;<br>                SelectionKey selectionKey = it.next();<br>                <span class="hljs-keyword">if</span>(selectionKey.isConnectable())&#123;<br>                    <span class="hljs-comment">// 连接事件发生</span><br>                    SocketChannel channel = (SocketChannel) selectionKey.channel();<br>                    channel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                    <span class="hljs-keyword">if</span>(channel.isConnectionPending())&#123;<br>                        <span class="hljs-comment">// 如果正在连接，则完成连接</span><br>                        channel.finishConnect();<br>                    &#125;<br>                    ByteBuffer buffer = ByteBuffer.wrap(scanner.nextLine().getBytes());<br>                    channel.write(buffer);<br>                    channel.register(selector, SelectionKey.OP_READ);<br>                &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(selectionKey.isReadable())&#123;<br>                    read(selectionKey);<br>                &#125;<br>                it.remove();<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;有数据可读事件发生了。。&quot;</span>);<br>        SocketChannel sc = (SocketChannel) key.channel();<br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>        <span class="hljs-comment">//NIO非阻塞体现:首先read方法不会阻塞，其次这种事件响应模型，当调用到read方法时肯定是发生了客户端发送数据的事件</span><br>        <span class="hljs-keyword">int</span> len = sc.read(buffer);<br>        <span class="hljs-keyword">if</span> (len != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;读取到服务端发送的数据：&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>        &#125;<br>        sc.write(ByteBuffer.wrap(scanner.nextLine().getBytes(StandardCharsets.UTF_8)));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//服务端</span><br>等待事件发生。。<br>有客户端连接事件发生了。。<br>等待事件发生。。<br>有客户端数据可读事件发生了。。<br>读取到客户端发送的数据：<span class="hljs-number">1</span><br>等待事件发生。。<br>有客户端数据可读事件发生了。。<br>读取到客户端发送的数据：<span class="hljs-number">2</span><br>等待事件发生。。<br>有客户端数据可读事件发生了。。<br>读取到客户端发送的数据：<span class="hljs-number">3</span><br>等待事件发生。。<br><br><span class="hljs-comment">//客户端</span><br><span class="hljs-number">1</span><br>有数据可读事件发生了。。<br>读取到服务端发送的数据：收到 over<br><span class="hljs-number">2</span><br>有数据可读事件发生了。。<br>读取到服务端发送的数据：收到 over<br><span class="hljs-number">3</span><br>有数据可读事件发生了。。<br>读取到服务端发送的数据：收到 over<br></code></pre></td></tr></table></figure>

<h4 id="1、NIO服务端程序详细分析"><a href="#1、NIO服务端程序详细分析" class="headerlink" title="1、NIO服务端程序详细分析"></a>1、NIO服务端程序详细分析</h4><p>1、创建一个 ServerSocketChannel 和 Selector ，并将 ServerSocketChannel 注册到 Selector 上 </p>
<p>2、 selector 通过 select() 方法监听 channel 事件，当客户端连接时，selector 监听到连接事件， 获取到 ServerSocketChannel 注册时绑定的 selectionKey </p>
<p>3、selectionKey 通过 channel() 方法可以获取绑定的 ServerSocketChannel </p>
<p>4、ServerSocketChannel 通过 accept() 方法得到 SocketChannel </p>
<p>5、将 SocketChannel 注册到 Selector 上，关心 read 事件 </p>
<p>6、注册后返回一个 SelectionKey, 会和该 SocketChannel 关联</p>
<p>7、selector 继续通过 select() 方法监听事件，当客户端发送数据给服务端，selector 监听到read事件，获取到 SocketChannel 注册时绑定的 selectionKey </p>
<p>8、selectionKey 通过 channel() 方法可以获取绑定的 socketChannel </p>
<p>9、将 socketChannel 里的数据读取出来 </p>
<p>10、用 socketChannel将服务端数据写回客户端</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F01-IO%E6%A8%A1%E5%9E%8B/image-20220204222338797.png" alt="image-20220204222338797"></p>
<h4 id="2、总结"><a href="#2、总结" class="headerlink" title="2、总结"></a>2、总结</h4><p><strong>NIO模型的selector 就像一个大总管，负责监听各种IO事件，然后转交给后端线程去处理</strong> </p>
<p>NIO相对于BIO非阻塞的体现就在，BIO的后端线程需要阻塞等待客户端写数据(比如read方法)，如果客户端不写数据线程就要阻塞， </p>
<p>NIO把等待客户端操作的事情交给了大总管 selector，selector 负责轮询所有已注册的客户端，发现有事件发生了才转交给后端线程处理，后端线程不需要做任何阻塞等待，直接处理客户端事件的数据即可，处理完马上结束，或返回线程池供其他客户端事件继续使用。还有就是 channel 的读写是非阻塞的。 </p>
<h5 id="Redis线程模型"><a href="#Redis线程模型" class="headerlink" title="Redis线程模型"></a>Redis线程模型</h5><p><strong>Redis就是典型的NIO线程模型，selector收集所有连接的事件并且转交给后端线程，线程连续执行所有事件命令并将结果写回客户端</strong></p>
<h2 id="AIO-NIO-2-0"><a href="#AIO-NIO-2-0" class="headerlink" title="AIO(NIO 2.0)"></a>AIO(NIO 2.0)</h2><h3 id="1、是什么-2"><a href="#1、是什么-2" class="headerlink" title="1、是什么"></a>1、是什么</h3><p>​    异步非阻塞， 由操作系统完成后回调通知服务端程序启动线程去处理， 一般适用于连接数较多且连接时间较长的应用,比如相册服务器，充分调用 OS 参与并发操作，JDK7 开始支持。</p>
<h3 id="2、代码实例"><a href="#2、代码实例" class="headerlink" title="2、代码实例"></a>2、代码实例</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIOServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> AsynchronousServerSocketChannel serverChannel = AsynchronousServerSocketChannel.open().bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">9000</span>));<br>        serverChannel.accept(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(AsynchronousSocketChannel socketChannel, Object attachment)</span> </span>&#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    serverChannel.accept(attachment,<span class="hljs-keyword">this</span>);<br>                    System.out.println(socketChannel.getRemoteAddress());<br>                    ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                    socketChannel.read(buffer,buffer, <span class="hljs-keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completed</span><span class="hljs-params">(Integer result, ByteBuffer attachment)</span> </span>&#123;<br>                            buffer.flip();<br>                            System.out.println(<span class="hljs-keyword">new</span> String(buffer.array(),<span class="hljs-number">0</span>,result));<br>                            socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;HelloClient&quot;</span>.getBytes()));<br>                        &#125;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;<br>                            exc.printStackTrace();<br>                        &#125;<br>                    &#125;);<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">failed</span><span class="hljs-params">(Throwable exc, Object attachment)</span> </span>&#123;<br>                exc.printStackTrace();<br>            &#125;<br>        &#125;);<br>        Thread.sleep(Integer.MAX_VALUE);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AIOClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, ExecutionException, InterruptedException </span>&#123;<br>        AsynchronousSocketChannel socketChannel = AsynchronousSocketChannel.open();<br>        socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>,<span class="hljs-number">9000</span>)).get();<br>        socketChannel.write(ByteBuffer.wrap(<span class="hljs-string">&quot;HelloServer&quot;</span>.getBytes()));<br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">512</span>);<br>        Integer len = socketChannel.read(buffer).get();<br>        <span class="hljs-keyword">if</span> (len != -<span class="hljs-number">1</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot;客户端收到信息：&quot;</span> + <span class="hljs-keyword">new</span> String(buffer.array(), <span class="hljs-number">0</span>, len));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="BIO、NIO、AIO-对比"><a href="#BIO、NIO、AIO-对比" class="headerlink" title="BIO、NIO、AIO 对比"></a>BIO、NIO、AIO 对比</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F01-IO%E6%A8%A1%E5%9E%8B/image-20220204230047817.png" alt="image-20220204230047817"></p>
<p><strong>同步异步与阻塞非阻塞</strong>(段子) </p>
<p>老张爱喝茶，废话不说，煮开水。 </p>
<p>出场人物：老张，水壶两把（普通水壶，简称水壶；会响的水壶，简称响水壶）。 </p>
<p>1 老张把水壶放到火上，立等水开。<strong>（同步阻塞）</strong> </p>
<p>老张觉得自己有点傻 </p>
<p>2 老张把水壶放到火上，去客厅看电视，时不时去厨房看看水开没有。<strong>（同步非阻塞）</strong> </p>
<p>老张还是觉得自己有点傻，于是变高端了，买了把会响笛的那种水壶。水开之后，能大声发出嘀~~~~的噪音。 </p>
<p>3 老张把响水壶放到火上，立等水开。<strong>（异步阻塞）</strong> </p>
<p>老张觉得这样傻等意义不大 </p>
<p>4 老张把响水壶放到火上，去客厅看电视，水壶响之前不再去看它了，响了再去拿壶。<strong>（异步非阻塞）</strong> </p>
<p>老张觉得自己聪明了。 </p>
<p>所谓同步异步，只是对于水壶而言。 </p>
<p>普通水壶，同步；响水壶，异步。 </p>
<p>虽然都能干活，但响水壶可以在自己完工之后，提示老张水开了。这是普通水壶所不能及的。 </p>
<p>同步只能让调用者去轮询自己（情况2中），造成老张效率的低下。 </p>
<p>所谓阻塞非阻塞，仅仅对于老张而言。 </p>
<p>立等的老张，阻塞；看电视的老张，非阻塞。 </p>
]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO模型</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式02-Netty简介</title>
    <url>/2022/02/05/%E5%88%86%E5%B8%83%E5%BC%8F02-Netty%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h1 id="Netty简介"><a href="#Netty简介" class="headerlink" title="Netty简介"></a>Netty简介</h1><h2 id="1、Netty初探"><a href="#1、Netty初探" class="headerlink" title="1、Netty初探"></a>1、Netty初探</h2><h3 id="1、为什么使用netty"><a href="#1、为什么使用netty" class="headerlink" title="1、为什么使用netty"></a>1、为什么使用netty</h3><p>​    NIO的类库和API繁杂，使用麻烦：需要熟练掌握Selector、ServerSocketChannel、SocketChannel、ByteBuffer等，开发工作量和难度都非常大：例如客户端面临断连重连，网络闪断，心跳闪断，<strong>半包读写</strong>，网络拥塞和异常流的处理等等；</p>
<p>​    NIO中有一些Bug:例如Epoll Bug，它会导致Selector 空轮询，最终导致CPU 100%</p>
<p>​    <strong>Netty对JDK自带的NIO的API进行了良好的封装</strong>，解决了上述问题。且Netty拥有<strong>高性能</strong>、<strong>吞吐量更高</strong>，<strong>延迟更低</strong>，<strong>减少资源消耗</strong>，<strong>最小化不必要的内存复制</strong>等优点。Netty现在都在用的是4.x，5.x版本已经废弃，Netty4.x需要JDK6以上版本支持</p>
<h3 id="2、Netty的使用场景："><a href="#2、Netty的使用场景：" class="headerlink" title="2、Netty的使用场景："></a>2、Netty的使用场景：</h3><p>​    1、互联网行业：在分布式系统中，各个节点之间需要远程服务调用，高性能的 RPC 框架必不可少，Netty 作为异步高性能的通信框架，往往作为基础通信组件被这些 RPC 框架使用。典型的应用有：阿里分布式服务框架 Dubbo 的 RPC 框架使用 Dubbo 协议进行节点间通信，Dubbo 协议默认使用 Netty 作为基础通信组件，用于实现各进程节点之间的内部通信。<br>​    2、游戏行业：无论是手游服务端还是大型的网络游戏，Java 语言得到了越来越广泛的应用。Netty 作为高性能的基础通信组件，它本身提供了 TCP/UDP 和 HTTP 协议栈。非常方便定制和开发私有协议栈，账号登录服务器，地图服务器之间可以方便的通过 Netty 进行高性能的通信。<br>​    3、大数据领域：经典的 Hadoop 的高性能通信和序列化组件 Avro 的 RPC 框架，默认采用 Netty 进行跨界点通信，它的 Netty Service 基于 Netty 框架二次封装实现</p>
<h2 id="2、Netty线程模型"><a href="#2、Netty线程模型" class="headerlink" title="2、Netty线程模型"></a>2、Netty线程模型</h2><p>可以先理解下《Scalable IO in Java》这篇文章里说的一些IO处理模式，Netty的线程模型如下图所示：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F02-Netty%E7%AE%80%E4%BB%8B/image-20220205162948814.png" alt="image-20220205162948814"></p>
<p><strong>模型解释：</strong></p>
<p>1、Netty 抽象出两组线程池<strong>BossGroup</strong>和<strong>WorkerGroup</strong>，<strong>BossGroup专门负责接收客户端的连接, WorkerGroup专门负责网络的读写</strong></p>
<p>2、BossGroup和WorkerGroup类型都是NioEventLoopGroup </p>
<p>3、NioEventLoopGroup 相当于一个事件循环线程组, 这个组中含有多个事件循环线程 ， 每一个事件循环线程是NioEventLoop</p>
<p>4、每个NioEventLoop都有一个selector , 用于监听注册在其上的socketChannel的网络通讯</p>
<p>5、每个Boss NioEventLoop线程内部循环执行的步骤有3步</p>
<ul>
<li>处理accept事件 , 与client 建立连接 , 生成 NioSocketChannel </li>
<li>将NioSocketChannel注册到某个worker NIOEventLoop上的selector </li>
<li>处理任务队列的任务 ， 即runAllTasks</li>
</ul>
<p>6、 每个worker NIOEventLoop线程循环执行的步骤</p>
<ul>
<li>轮询注册到自己selector上的所有NioSocketChannel 的read, write事件 </li>
<li>处理 I/O 事件， 即read , write 事件， 在对应NioSocketChannel 处理业务 </li>
<li>runAllTasks处理任务队列TaskQueue的任务 ，一些耗时的业务处理一般可以放入</li>
</ul>
<p>7、每个worker NIOEventLoop处理NioSocketChannel业务时，会使用 pipeline (管道)，管道中维护 了很多 handler 处理器用来处理 channel 中的数据</p>
<h2 id="3、Netty模块组件"><a href="#3、Netty模块组件" class="headerlink" title="3、Netty模块组件"></a>3、Netty模块组件</h2><p>【Bootstrap、ServerBootstrap】<br>    Bootstrap 意思是引导，一个 Netty 应用通常由一个 Bootstrap 开始，主要作用是配置整个 Netty 程 序，串联各个组件，Netty 中 Bootstrap 类是客户端程序的启动引导类，ServerBootstrap 是服务端启动引导类。</p>
<p>【Future、ChannelFuture】</p>
<p>​    正如前面介绍，在 Netty 中所有的 IO 操作都是异步的，不能立刻得知消息是否被正确处理。 但是可以过一会等它执行完成或者直接注册一个监听，具体的实现就是通过 Future 和 ChannelFutures，他们可以注册一个监听，当操作执行成功或失败时监听会自动触发注册的监听事 件</p>
<p>【Channel】</p>
<p>Netty 网络通信的组件，能够用于执行网络 I/O 操作。Channel 为用户提供：</p>
<p>​    1）当前网络连接的通道的状态（例如是否打开？是否已连接？）【NioEventLoop】<br>​    2）网络连接的配置参数 （例如接收缓冲区大小）<br>​    3）提供异步的网络 I/O 操作(如建立连接，读写，绑定端口)，异步调用意味着任何 I/O 调用都将立即返回，并且不保证在调用结束时所请求的 I/O 操作已完成。<br>​    4）调用立即返回一个 ChannelFuture 实例，通过注册监听器到 ChannelFuture 上，可以 I/O 操作成功、失败或取消时回调通知调用方。<br>​    5）支持关联 I/O 操作与对应的处理程序。不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">NioSocketChannel，异步的客户端 TCP Socket 连接。 <br>NioServerSocketChannel，异步的服务器端 TCP Socket 连接。<br>NioDatagramChannel，异步的 UDP 连接。 <br>NioSctpChannel，异步的客户端 Sctp 连接。 <br>NioSctpServerChannel，异步的 Sctp 服务器端连接，这些通道涵盖了 UDP 和 TCP 网络 IO 以及文件IO<br></code></pre></td></tr></table></figure>

<p>【Selector】</p>
<p>​    Netty 基于 Selector 对象实现 I/O 多路复用，通过 Selector 一个线程可以监听多个连接的 Channel 事件。 当向一个 Selector 中注册 Channel 后，Selector 内部的机制就可以自动不断地查询(Select) 这些注册 的 Channel 是否有已就绪的 I/O 事件（例如可读，可写，网络连接完成等），这样程序就可以很简单 地使用一个线程高效地管理多个 Channel 。</p>
<p>不同协议、不同的阻塞类型的连接都有不同的 Channel 类型与之对应。 </p>
<p>【NioEventLoop】<br>    NioEventLoop 中维护了一个线程和任务队列，支持异步提交执行任务，线程启动时会调用 NioEventLoop 的 run 方法，执行 I/O 任务和非 I/O 任务： I/O 任务，即 selectionKey 中 ready 的事件，如 accept、connect、read、write 等，由 processSelectedKeys 方法触发。非 IO 任务，添加到 taskQueue 中的任务，如 register0、bind0 等任务，由 runAllTasks 方法触发。</p>
<p>【NioEventLoopGroup】</p>
<p>​    NioEventLoopGroup，主要管理 eventLoop 的生命周期，可以理解为一个线程池，内部维护了一组线程，每个线程(NioEventLoop)负责处理多个 Channel 上的事件，而一个 Channel 只对应于一个线程。</p>
<p>【ChannelHandler】<br>    ChannelHandler 是一个接口，处理 I/O 事件或拦截 I/O 操作，并将其转发到其 ChannelPipeline(业务处理链)中的下一个处理程序。 ChannelHandler 本身并没有提供很多方法，因为这个接口有许多的方法需要实现，方便使用期间， 可以继承它的子类或者使用以下适配器类： ：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">1</span> ChannelInboundHandler 用于处理入站 I/O 事件。 <br><span class="hljs-number">2</span> ChannelOutboundHandler 用于处理出站 I/O 操作。<br><span class="hljs-number">1</span> ChannelInboundHandlerAdapter 用于处理入站 I/O 事件。<br><span class="hljs-number">2</span> ChannelOutboundHandlerAdapter 用于处理出站 I/O 操作。<br></code></pre></td></tr></table></figure>

<p>【ChannelHandlerContext】</p>
<p>​    保存 Channel 相关的所有上下文信息，同时关联一个 ChannelHandler 对象。 </p>
<p>【ChannelPipline】</p>
<p>​    保存 ChannelHandler 的 List，用于处理或拦截 Channel 的入站事件和出站操作。 ChannelPipeline 实现了一种高级形式的拦截过滤器模式，使用户可以完全控制事件的处理方式，以 及 Channel 中各个的 ChannelHandler 如何相互交互</p>
<p>​    在 Netty 中每个 Channel 都有且仅有一个 ChannelPipeline 与之对应，它们的组成关系如下： </p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F02-Netty%E7%AE%80%E4%BB%8B/image-20220205173946714.png" alt="image-20220205173946714"></p>
<p>​    一个 Channel 包含了一个 ChannelPipeline，而 ChannelPipeline 中又维护了一个由 ChannelHandlerContext 组成的双向链表，并且每个 ChannelHandlerContext 中又关联着一个 ChannelHandler。 read事件(入站事件)和write事件(出站事件)在一个双向链表中，入站事件会从链表 head 往后传递到最 后一个入站的 handler，出站事件会从链表 tail 往前传递到最前一个出站的 handler，两种类型的 handler 互不干扰</p>
<h2 id="4、Netty通讯示例"><a href="#4、Netty通讯示例" class="headerlink" title="4、Netty通讯示例"></a>4、Netty通讯示例</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F02-Netty%E7%AE%80%E4%BB%8B/image-20220205231934772.png" alt="image-20220205231934772"></p>
<h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建2个线程组，一个负责处理客户端accept连接时间，一个负责客户端IO读写事件</span><br>        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//NioEventLoop默认线程是cpu核数的2倍</span><br>        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一 个客户端连接。</span><br>                    <span class="hljs-comment">// 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel socketChannel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            socketChannel.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;netty server start。。&quot;</span>);<br>            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步 事件的执行情况</span><br>            <span class="hljs-comment">// 启动服务器(并绑定端口)，bind是异步操作，sync方法是等待异步操作执行完毕</span><br>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">9000</span>).sync();<br>            cf.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口9000成功&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口9000失败&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//对通道关闭进行监听，closeFuture是异步操作，监听通道关闭</span><br>            <span class="hljs-comment">// 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成</span><br>            cf.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;服务器读取线程 &quot;</span> + Thread.currentThread().getName());<br>        <span class="hljs-comment">//Channel channel = ctx.channel();</span><br>        <span class="hljs-comment">// ChannelPipeline pipeline = ctx.pipeline();</span><br>        <span class="hljs-comment">// 本质是一个双向链接, 出站入站 </span><br>        <span class="hljs-comment">//将 msg 转成一个 ByteBuf，类似NIO 的 ByteBuffer</span><br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;客户端发送消息是:&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;HelloClient&quot;</span>, CharsetUtil.UTF_8);<br>        ctx.writeAndFlush(buf);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//客户端需要一个事件循环组</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建客户端启动对象</span><br>            <span class="hljs-comment">// 注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;netty client start&quot;</span>);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9000</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;HelloServer&quot;</span>, CharsetUtil.UTF_8);<br>        ctx.writeAndFlush(buf);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;收到服务端的消息:&quot;</span> + buf.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;服务端的地址: &quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelReadComplete</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Thread.sleep(<span class="hljs-number">2000L</span>);<br>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;HelloClient&quot;</span>, CharsetUtil.UTF_8);<br>        ctx.writeAndFlush(buf);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5、Netty实现聊天室"><a href="#5、Netty实现聊天室" class="headerlink" title="5、Netty实现聊天室"></a>5、Netty实现聊天室</h2><p>服务端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.chatroom;<br><span class="hljs-keyword">import</span> io.netty.bootstrap.ServerBootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.*;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">//当服务器请求处理线程全满时，用于临时存放已完成三次握手的请求的队列的最大长度。</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-comment">//向pipeline加入解码器</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());<br>                            <span class="hljs-comment">//向pipeline加入编码器</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());<br>                            <span class="hljs-comment">//加入自己的业务处理handler</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> ChatServerHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;聊天室server启动。。&quot;</span>);<br>            ChannelFuture channelFuture = bootstrap.bind(<span class="hljs-number">9000</span>).sync();<br>            <span class="hljs-comment">//关闭通道</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">package</span> netty.chatroom;<br><br><span class="hljs-keyword">import</span> io.netty.channel.Channel;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><span class="hljs-keyword">import</span> io.netty.channel.group.ChannelGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.group.DefaultChannelGroup;<br><span class="hljs-keyword">import</span> io.netty.util.concurrent.GlobalEventExecutor;<br><br><span class="hljs-keyword">import</span> java.text.SimpleDateFormat;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span> </span>&#123;<br>    <span class="hljs-comment">//GlobalEventExecutor.INSTANCE是全局的事件执行器，是一个单例</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ChannelGroup channelGroup = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);<br>    SimpleDateFormat sdf = <span class="hljs-keyword">new</span> SimpleDateFormat(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//将该客户加入聊天的信息推送给其它在线的客户端</span><br>        <span class="hljs-comment">//该方法会将 channelGroup 中所有的 channel 遍历，并发送消息</span><br>        Channel channel = ctx.channel();<br>        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[ 客户端 ]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 上线了 &quot;</span> + sdf.format(<span class="hljs-keyword">new</span> Date())+ <span class="hljs-string">&quot;\n&quot;</span>);<br>        <span class="hljs-comment">//将当前 channel 加入到 channelGroup</span><br>        channelGroup.add(channel);<br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 上线了&quot;</span>+ <span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Channel channel = ctx.channel();<br>        <span class="hljs-comment">//将客户离开信息推送给当前在线的客户</span><br>        channelGroup.writeAndFlush(<span class="hljs-string">&quot;[ 客户端 ]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 下线了&quot;</span>+ <span class="hljs-string">&quot;\n&quot;</span>);<br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot; 下线了&quot;</span>+ <span class="hljs-string">&quot;\n&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;channelGroup size=&quot;</span> + channelGroup.size());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取到当前 channel</span><br>        Channel channel = ctx.channel();<br>        <span class="hljs-comment">//这时我们遍历 channelGroup, 根据不同的情况， 回送不同的消息</span><br>        channelGroup.forEach(ch -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (channel != ch) &#123; <span class="hljs-comment">//不是当前的 channel,转发消息</span><br>                ch.writeAndFlush(<span class="hljs-string">&quot;[ 客户端 ]&quot;</span> + channel.remoteAddress() + <span class="hljs-string">&quot; 发送了消息：&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//回显自己发送的消息给自己</span><br>                ch.writeAndFlush(<span class="hljs-string">&quot;[ 自己 ]发送了消息：&quot;</span> + msg + <span class="hljs-string">&quot;\n&quot;</span>);<br>            &#125;<br>        &#125;);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//关闭通道</span><br>        ctx.close();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F02-Netty%E7%AE%80%E4%BB%8B/image-20220213151217634.png" alt="image-20220213151217634"></p>
<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.chatroom;<br><br><span class="hljs-keyword">import</span> io.netty.bootstrap.Bootstrap;<br><span class="hljs-keyword">import</span> io.netty.channel.*;<br><span class="hljs-keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.SocketChannel;<br><span class="hljs-keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringDecoder;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.string.StringEncoder;<br><br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap()<br>                    .group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringEncoder());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> StringDecoder());<br><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> ChatClientHandler());<br>                        &#125;<br>                    &#125;);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9000</span>).sync();<br>            Channel channel = channelFuture.channel();<br>            <span class="hljs-comment">//客户端需要输入信息， 创建一个扫描器</span><br>            Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>            <span class="hljs-keyword">while</span> (scanner.hasNextLine()) &#123;<br>                String msg = scanner.nextLine();<br>                <span class="hljs-comment">//通过 channel 发送到服务器端</span><br>                channel.writeAndFlush(msg);<br>            &#125;<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">package</span> netty.chatroom;<br><br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(msg.trim());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F02-Netty%E7%AE%80%E4%BB%8B/image-20220213151137416.png" alt="image-20220213151137416"></p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式03-Netty粘包-拆包-零拷贝</title>
    <url>/2022/02/13/%E5%88%86%E5%B8%83%E5%BC%8F03-Netty%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h1 id="Netty编解码、粘包、拆包、零拷贝详解"><a href="#Netty编解码、粘包、拆包、零拷贝详解" class="headerlink" title="Netty编解码、粘包、拆包、零拷贝详解"></a>Netty编解码、粘包、拆包、零拷贝详解</h1><h2 id="Netty编解码"><a href="#Netty编解码" class="headerlink" title="Netty编解码"></a>Netty编解码</h2><p>​    Netty涉及到编解码的组件有Channel、ChannelHandler、ChannelPipe等，先大概了解下这几个组件的作用。</p>
<h3 id="ChannelHandler"><a href="#ChannelHandler" class="headerlink" title="ChannelHandler"></a>ChannelHandler</h3><p>​    <strong>ChannelHandler充当了处理入站和出站数据的应用程序逻辑容器</strong>。例如，实现ChannelInboundHandler接口（或ChannelInboundHandlerAdapter），你就可以接收入站事件和数据，这些数据随后会被你的应用程序的业务逻辑处理。当你要给连接的客户端发送响应时，也可以从<strong>ChannelInboundHandler</strong>冲刷数据。你的业务逻辑通常写在一个或者多个ChannelInboundHandler中。<strong>ChannelOutboundHandler</strong>原理一样，只不过它是用来处理出站数据的。</p>
<p>​    分两种，<strong>ChannelInboundHandler</strong>和<strong>ChannelOutboundHandler</strong></p>
<h3 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h3><p>​    <strong>ChannelPipeline提供了ChannelHandler链的容器</strong>。以客户端应用程序为例，如果事件的运动方向是从客户端到服务端的，那么我们称这些事件为出站的，即客户端发送给服务端的数据会通过pipeline中的一系列ChannelOutboundHandler(ChannelOutboundHandler调用是从tail到head方向逐个调用每个handler的逻辑)，并被这些Handler处理，反之则称为入站的，入站只调用pipeline里的ChannelInboundHandler逻辑(ChannelInboundHandler调用是从head到tail方向逐个调用每个handler的逻辑)。</p>
<p>​    简单来说：<strong>不论对服务端合适客户端来说，消息发送出去就是出站(pipeline是从tail-&gt;head)，接受消息就是入站(pipeline是从head-&gt;tail)</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F03-Netty%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20220213235051475.png" alt="image-20220213235051475"></p>
<h3 id="编码解码器"><a href="#编码解码器" class="headerlink" title="编码解码器"></a>编码解码器</h3><p>​    当你通过Netty发送或者接受一个消息的时候，就将会发生一次数据转换。入站消息会被解码：从字节转换为另一种格式（比如java对象）；如果是出站消息，它会被编码成字节。Netty提供了一系列实用的编码解码器，他们都实现了ChannelInboundHadnler或者ChannelOutcoundHandler接口。在这些类中，channelRead方法已经被重写了。以入站为例，对于每个从入站Channel读取的消息，这个方法会被调用。随后，它将调用由已知解码器所提供的decode()方法进行解码，并将已经解码的字节转发给ChannelPipeline中的下一个ChannelInboundHandler。Netty提供了很多编解码器，比如编解码字符串的StringEncoder和StringDecoder，编解码对象的ObjectEncoder和ObjectDecoder等。</p>
<p>​    <strong>当然也可以通过集成ByteToMessageDecoder、MessageToByteEncoder自定义编解码器。</strong></p>
<h2 id="Netty粘包拆包"><a href="#Netty粘包拆包" class="headerlink" title="Netty粘包拆包"></a>Netty粘包拆包</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><p>​    TCP粘包拆包是指发送方发送的若干包数据到接收方接收时粘成一包或某个数据包被拆开接收。如下图所示，client发了两个数据包D1和D2，但是server端可能会收到如下几种情况的数据。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F03-Netty%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20220215233305991.png" alt="image-20220215233305991"></p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>​    TCP是面向连接的，面向流的，提供高可靠性服务。收发两端（客户端和服务器端）都要有成对的socket，因此，发送端为了将多个发给接收端的包，更有效的发给对方，使用了优化方法（Nagle算法），将多次间隔较小且数据量小的数据，合并成一个大的数据块，然后进行封包。这样做虽然提高了效率，但是接收端就难于分辨出完整的数据包了，因为面向流的通信是无消息保护边界的。</p>
<p>​    简单理解：TCP传输协议有个缓冲区，传输数据时是以缓冲区大小为单位传输的。</p>
<p>​    当D1D2消息发送间隔较短且数据包较小会发生合并（粘包）</p>
<p>​    当D2太大，被拆分成多个运输（拆包）</p>
<p>​    当D1D2两个包都刚好满足TCP缓冲区的大小，或者说其等待时间已经达到TCP等待时长，从而还是使用两个独立的包进行发送</p>
<h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><h4 id="格式化数据"><a href="#格式化数据" class="headerlink" title="格式化数据"></a>格式化数据</h4><p>​    每条数据有固定的格式（开始符、结束符），这种方法简单易行，但选择开始符和结束符的时候一定要注意每条数据的 内部一定不能出现开始符或结束符</p>
<h4 id="发送数据长度"><a href="#发送数据长度" class="headerlink" title="发送数据长度"></a>发送数据长度</h4><p>​    发送每条数据的时候，将数据的长度一并发送，比如可以选择每条数据的前4位是数据的长度，应用层处理时可以根据长度来判断每条数据的开始和结束。</p>
<h4 id="发送数据长度解决粘包拆包问题代码示例"><a href="#发送数据长度解决粘包拆包问题代码示例" class="headerlink" title="发送数据长度解决粘包拆包问题代码示例"></a>发送数据长度解决粘包拆包问题代码示例</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F03-Netty%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20220216000033499.png" alt="image-20220216000033499"></p>
<p>关键代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> netty.splitpackage;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageProtocol</span> </span>&#123;<br>    <span class="hljs-comment">//定义一次发送包体长度</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> len;<br>    <span class="hljs-comment">//一次发送包体内容</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] content;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLen</span><span class="hljs-params">(<span class="hljs-keyword">int</span> len)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.len = len;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContent</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] content)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getLen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> len;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] getContent() &#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">MyMessageProtocol</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, MyMessageProtocol msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMessageEncoder encode 方法被调用&quot;</span>);<br>        out.writeInt(msg.getLen());<br>        out.writeBytes(msg.getContent());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span></span>&#123;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyMessageDecoder decode 被调用&quot;</span>);<br>        <span class="hljs-comment">//需要将得到二进制字节码-&gt; MyMessageProtocol 数据包(对象)</span><br>        System.out.println(in);<br>        <span class="hljs-keyword">while</span> (in.readableBytes() &gt;= <span class="hljs-number">4</span>)&#123;<br>            <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span>)&#123;<br>                length = in.readInt();<br>            &#125;<br>            <span class="hljs-keyword">if</span>(in.readableBytes() &lt; length)&#123;<br>                System.out.println(<span class="hljs-string">&quot;当前可读数据不够，继续等待。。&quot;</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>            in.readBytes(data);<br>            <span class="hljs-comment">//封装成MyMessageProtocol对象，传递到下一个handler业务处理</span><br>            MyMessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MyMessageProtocol();<br>            messageProtocol.setLen(length);<br>            messageProtocol.setContent(data);<br>            out.add(messageProtocol);<br>            length = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MyMessageProtocol</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt; <span class="hljs-number">200</span>; i++) &#123;<br>            String msg = <span class="hljs-string">&quot;你好，我是张三！&quot;</span>;<br>            <span class="hljs-comment">//创建协议包对象</span><br>            MyMessageProtocol messageProtocol = <span class="hljs-keyword">new</span> MyMessageProtocol();<br>            messageProtocol.setLen(msg.getBytes(CharsetUtil.UTF_8).length);<br>            messageProtocol.setContent(msg.getBytes(CharsetUtil.UTF_8));<br>            ctx.writeAndFlush(messageProtocol);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">MyMessageProtocol</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> count;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, MyMessageProtocol msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;====服务端接收到消息如下====&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;长度=&quot;</span> + msg.getLen());<br>        System.out.println(<span class="hljs-string">&quot;内容=&quot;</span> + <span class="hljs-keyword">new</span> String(msg.getContent(), CharsetUtil.UTF_8));<br><br>        System.out.println(<span class="hljs-string">&quot;服务端接收到消息包数量=&quot;</span> + (++<span class="hljs-keyword">this</span>.count));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Netty心跳检测机制"><a href="#Netty心跳检测机制" class="headerlink" title="Netty心跳检测机制"></a>Netty心跳检测机制</h2><p>​    所谓心跳, 即在 TCP 长连接中, 客户端和服务器之间定期发送的一种特殊的数据包, 通知对方自己还在线, 以确保 TCP 连接的有效性. </p>
<p>​    在 Netty 中, 实现心跳机制的关键是 IdleStateHandler, 看下它的构造器：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">IdleStateHandler</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-keyword">long</span> readerIdleTime, <span class="hljs-keyword">long</span> writerIdleTime, <span class="hljs-keyword">long</span> allIdleTime,</span></span><br><span class="hljs-function"><span class="hljs-params">        TimeUnit unit)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>(<span class="hljs-keyword">false</span>, readerIdleTime, writerIdleTime, allIdleTime, unit);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    <strong>readerIdleTimeSeconds</strong>: 读超时. 即当在指定的时间间隔内没有从 Channel 读取到数据时, 会触发一个 READER_IDLE 的 IdleStateEvent 事件.</p>
<p>​    <strong>writerIdleTimeSeconds</strong>: 写超时. 即当在指定的时间间隔内没有数据写入到 Channel 时, 会触发一个 WRITER_IDLE 的 IdleStateEvent 事件</p>
<p>​     <strong>allIdleTimeSeconds</strong>: 读/写超时. 即当在指定的时间间隔内没有读或写操作时, 会触发一个 ALL_IDLE 的 IdleStateEvent 事件.</p>
<p>​    注：这三个参数默认的时间单位是秒。若需要指定其他时间单位，可以使用另一个构造方法：</p>
<h3 id="IdleStateHandler源码"><a href="#IdleStateHandler源码" class="headerlink" title="IdleStateHandler源码"></a>IdleStateHandler源码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IdleStateHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelDuplexHandler</span> </span>&#123;<br>    ...<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> readerIdleTimeNanos;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> writerIdleTimeNanos;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> allIdleTimeNanos;<br><br>    <span class="hljs-keyword">private</span> ScheduledFuture&lt;?&gt; readerIdleTimeout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastReadTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> firstReaderIdleEvent = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">private</span> ScheduledFuture&lt;?&gt; writerIdleTimeout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastWriteTime;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> firstWriterIdleEvent = <span class="hljs-keyword">true</span>;<br><br>    <span class="hljs-keyword">private</span> ScheduledFuture&lt;?&gt; allIdleTimeout;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> firstAllIdleEvent = <span class="hljs-keyword">true</span>;<br>    <br>    <span class="hljs-comment">//透传给下一个handler</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (readerIdleTimeNanos &gt; <span class="hljs-number">0</span> || allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            reading = <span class="hljs-keyword">true</span>;<br>            firstReaderIdleEvent = firstAllIdleEvent = <span class="hljs-keyword">true</span>;<br>        &#125;<br>        ctx.fireChannelRead(msg);<br>    &#125;<br>    <span class="hljs-comment">//客户端连接建立,调用initialize</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        initialize(ctx);<br>        <span class="hljs-keyword">super</span>.channelActive(ctx);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<br>            <br>            state) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        state = <span class="hljs-number">1</span>;<br>        initOutputChanged(ctx);<br><br>        lastReadTime = lastWriteTime = ticksInNanos();<br>        <span class="hljs-keyword">if</span> (readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> ReaderIdleTimeoutTask(ctx),<br>                    readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> WriterIdleTimeoutTask(ctx),<br>                    writerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> AllIdleTimeoutTask(ctx),<br>                    allIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReaderIdleTimeoutTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractIdleTask</span> </span>&#123;<br><br>        ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;<br>            <span class="hljs-keyword">super</span>(ctx);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>            <span class="hljs-keyword">long</span> nextDelay = readerIdleTimeNanos;<br>            <span class="hljs-keyword">if</span> (!reading) &#123;<br>                <span class="hljs-comment">//用当前时间减去最后一次channelRead方法调用的时间，假如这个结果是6s，说明最后一次调用channelRead已经是6s 之前的事情了，你设置的是5s，那么nextDelay则为-1，说明超时了，则会触发下一个handler的userEventTriggered方法：</span><br>                nextDelay -= ticksInNanos() - lastReadTime;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>                readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>                <span class="hljs-keyword">boolean</span> first = firstReaderIdleEvent;<br>                firstReaderIdleEvent = <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    IdleStateEvent event = newIdleStateEvent(IdleState.READER_IDLE, first);<br>                    <span class="hljs-comment">//触发下一个handler的userEventTriggered方法：</span><br>                    channelIdle(ctx, event);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                    ctx.fireExceptionCaught(t);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartBeatClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(eventLoopGroup).channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());<br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> HeartBeatClientHandler());<br>                        &#125;<br>                    &#125;);<br><br>            System.out.println(<span class="hljs-string">&quot;netty client start。。&quot;</span>);<br>            Channel channel = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9000</span>).sync().channel();<br>            String text = <span class="hljs-string">&quot;Heartbeat Packet&quot;</span>;<br>            Random random = <span class="hljs-keyword">new</span> Random();<br>            <span class="hljs-keyword">while</span> (channel.isActive()) &#123;<br>                <span class="hljs-keyword">int</span> num = random.nextInt(<span class="hljs-number">10</span>);<br>                <span class="hljs-comment">//Thread.sleep(2 * 1000);</span><br>				Thread.sleep(num * <span class="hljs-number">1000</span>);<br>                channel.writeAndFlush(text);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartBeatClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot; client received :&quot;</span> + msg);<br>            <span class="hljs-keyword">if</span> (msg != <span class="hljs-keyword">null</span> &amp;&amp; msg.equals(<span class="hljs-string">&quot;idle close&quot;</span>)) &#123;<br>                System.out.println(<span class="hljs-string">&quot; 服务端关闭连接，客户端也关闭&quot;</span>);<br>                ctx.channel().closeFuture();<br>            &#125;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartBeatServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup boss = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup worker = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(boss, worker)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> StringDecoder());<br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> StringEncoder());<br>                            <span class="hljs-comment">//IdleStateHandler的readerIdleTime参数指定超过3秒还没收到客户端的连接，</span><br>                            <span class="hljs-comment">//会触发IdleStateEvent事件并且交给下一个handler处理，下一个handler必须</span><br>                            <span class="hljs-comment">//实现userEventTriggered方法处理对应事件</span><br>                            pipeline.addLast(<span class="hljs-keyword">new</span> IdleStateHandler(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.SECONDS));<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> HeartBeatServerHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;netty server start。。&quot;</span>);<br>            ChannelFuture future = bootstrap.bind(<span class="hljs-number">9000</span>).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            worker.shutdownGracefully();<br>            boss.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeartBeatServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">int</span> readIdleTimes = <span class="hljs-number">0</span>;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String s)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot; ====== &gt; [server] message received : &quot;</span> + s);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;Heartbeat Packet&quot;</span>.equals(s)) &#123;<br>            ctx.channel().writeAndFlush(<span class="hljs-string">&quot;ok&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot; 其他信息处理 ... &quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.err.println(<span class="hljs-string">&quot;=== &quot;</span> + ctx.channel().remoteAddress() + <span class="hljs-string">&quot; is active ===&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">userEventTriggered</span><span class="hljs-params">(ChannelHandlerContext ctx, Object evt)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        IdleStateEvent event = (IdleStateEvent) evt;<br>        <span class="hljs-keyword">boolean</span> first = event.isFirst();<br>        String eventType = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">switch</span> (event.state()) &#123;<br>            <span class="hljs-keyword">case</span> READER_IDLE:<br>                eventType = <span class="hljs-string">&quot;读空闲&quot;</span>;<br>                readIdleTimes++; <span class="hljs-comment">// 读空闲的计数加1</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> WRITER_IDLE:<br>                eventType = <span class="hljs-string">&quot;写空闲&quot;</span>;<br>                <span class="hljs-comment">// 不处理</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> ALL_IDLE:<br>                eventType = <span class="hljs-string">&quot;读写空闲&quot;</span>;<br>                <span class="hljs-comment">// 不处理</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>        System.out.println(ctx.channel().remoteAddress() + <span class="hljs-string">&quot;超时事件：&quot;</span> + eventType + <span class="hljs-string">&quot;是否连续超时：&quot;</span> + !first);<br>        <span class="hljs-keyword">if</span> (readIdleTimes &gt; <span class="hljs-number">3</span>) &#123;<br>            System.out.println(<span class="hljs-string">&quot; [server]读空闲超过3次，关闭连接，释放更多资源&quot;</span>);<br>            ctx.channel().writeAndFlush(<span class="hljs-string">&quot;idle close&quot;</span>);<br>            ctx.channel().close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>结果：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第一种场景</span><br>客户端<br><span class="hljs-keyword">while</span> (channel.isActive()) &#123;<br>    <span class="hljs-keyword">int</span> num = random.nextInt(<span class="hljs-number">10</span>);<br>    Thread.sleep(<span class="hljs-number">20</span> * <span class="hljs-number">1000</span>);<br>    channel.writeAndFlush(text);<br>&#125;<br>netty client start。。<br>服务端关闭连接，客户端也关闭<br><br>服务端<br>=== /<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62678</span> is active ===<br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62678</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">false</span><br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62678</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">true</span><br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62678</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">true</span><br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62678</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">true</span><br> [server]读空闲超过<span class="hljs-number">3</span>次，关闭连接，释放更多资源 <br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//第二种场景</span><br>客户端<br><span class="hljs-keyword">while</span> (channel.isActive()) &#123;<br>    <span class="hljs-keyword">int</span> num = random.nextInt(<span class="hljs-number">10</span>);<br>    Thread.sleep(num * <span class="hljs-number">1000</span>);<br>    channel.writeAndFlush(text);<br>&#125;<br>netty client start。。<br> client received :ok<br> client received :ok<br> client received :ok<br> client received :ok<br> client received :ok<br> client received :idle close<br> 服务端关闭连接，客户端也关闭<br><br>服务端<br>=== /<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62921</span> is active ===<br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62921</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">false</span><br> ====== &gt; [server] message received : Heartbeat Packet<br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62921</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">false</span><br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62921</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">true</span><br> ====== &gt; [server] message received : Heartbeat Packet<br> ====== &gt; [server] message received : Heartbeat Packet<br> ====== &gt; [server] message received : Heartbeat Packet<br> ====== &gt; [server] message received : Heartbeat Packet<br>/<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>:<span class="hljs-number">62921</span>超时事件：读空闲是否连续超时：<span class="hljs-keyword">false</span><br> [server]读空闲超过<span class="hljs-number">3</span>次，关闭连接，释放更多资源<br></code></pre></td></tr></table></figure>



<h2 id="Netty零拷贝"><a href="#Netty零拷贝" class="headerlink" title="Netty零拷贝"></a>Netty零拷贝</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>​    Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，<strong>使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝</strong>（一句话说就是Netty采用直接内存进行Socket读写时，发生0次物理内存到堆内存的拷贝）。 如果使用传统的JVM堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才能写入Socket 中。J<strong>VM堆内存的数据是不能直接写入Socket中的</strong>。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。 可以看下netty的读写源码，比如read源码NioByteUnsafe.read()    </p>
<p>NettyClientHandler.channelActive -&gt; </p>
<p>​    ctx.writeAndFlush(buf) -&gt; </p>
<p>​        NioByteUnsafe.read() -&gt; </p>
<p>​            AbstractByteBufAllocator.oBuffer(int) -&gt;</p>
<p>​                AbstractByteBufAllocator-&gt;directBuffer(initialCapacity);</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123; <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf buf = Unpooled.copiedBuffer(<span class="hljs-string">&quot;HelloServer&quot;</span>, CharsetUtil.UTF_8);<br>        ctx.writeAndFlush(buf);<span class="hljs-comment">//第一步</span><br>    &#125;<br> &#125;<br><br> <span class="hljs-keyword">protected</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioByteUnsafe</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractNioUnsafe</span> </span>&#123;<br><br>     <span class="hljs-meta">@Override</span><br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> </span>&#123;<br>         <span class="hljs-keyword">final</span> ChannelConfig config = config();<br>         <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>             clearReadPending();<br>             <span class="hljs-keyword">return</span>;<br>         &#125;<br>         <span class="hljs-keyword">final</span> ChannelPipeline pipeline = pipeline();<br>         <span class="hljs-keyword">final</span> ByteBufAllocator allocator = config.getAllocator();<br>         <span class="hljs-keyword">final</span> RecvByteBufAllocator.Handle allocHandle = recvBufAllocHandle();<br>         allocHandle.reset(config);<br><br>         ByteBuf byteBuf = <span class="hljs-keyword">null</span>;<br>         <span class="hljs-keyword">boolean</span> close = <span class="hljs-keyword">false</span>;<br>         <span class="hljs-keyword">try</span> &#123;<br>             <span class="hljs-keyword">do</span> &#123;<br>                 byteBuf = allocHandle.allocate(allocator);<br>                 allocHandle.lastBytesRead(doReadBytes(byteBuf));<br>                 <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                     <span class="hljs-comment">// nothing was read. release the buffer.</span><br>                     byteBuf.release();<br>                     byteBuf = <span class="hljs-keyword">null</span>;<br>                     close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                     <span class="hljs-keyword">if</span> (close) &#123;<br>                         <span class="hljs-comment">// There is nothing left to read as we received an EOF.</span><br>                         readPending = <span class="hljs-keyword">false</span>;<br>                     &#125;<br>                     <span class="hljs-keyword">break</span>;<br>                 &#125;<br><br>                 allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>                 readPending = <span class="hljs-keyword">false</span>;<br>                 pipeline.fireChannelRead(byteBuf);<br>                 byteBuf = <span class="hljs-keyword">null</span>;<br>             &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>             allocHandle.readComplete();<br>             pipeline.fireChannelReadComplete();<br><br>             <span class="hljs-keyword">if</span> (close) &#123;<br>                 closeOnRead(pipeline);<br>             &#125;<br>         &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>             handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>         &#125; <span class="hljs-keyword">finally</span> &#123;<br>             <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>                 removeReadOp();<br>             &#125;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F03-Netty%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20220217215700345.png" alt="image-20220217215700345"></p>
<p>​    直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，某些情况下这部分内存也会被频繁地使用，而且也可能导致OutOfMemoryError异常出现。Java里用DirectByteBuffer可以分配一块直接内存(堆外内存)，元空间对应的内存也叫作直接内存，它们对应的都是机器的物理内存。</p>
<h3 id="直接内存与堆内存的比较"><a href="#直接内存与堆内存的比较" class="headerlink" title="直接内存与堆内存的比较"></a>直接内存与堆内存的比较</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DirectMemoryTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapAccess</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-comment">//分配堆内存</span><br>        ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">200</span>; j++) &#123;<br>                buffer.putInt(j);<br>            &#125;<br>            buffer.flip();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">200</span>; j++) &#123;<br>                buffer.getInt();<br>            &#125;<br>            buffer.clear();<br>        &#125;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;堆内存访问:&quot;</span> + (endTime - startTime));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directAccess</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-comment">//分配直接内存</span><br>        ByteBuffer buffer = ByteBuffer.allocateDirect(<span class="hljs-number">1000</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">200</span>; j++) &#123;<br>                buffer.putInt(j);<br>            &#125;<br>            buffer.flip();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">200</span>; j++) &#123;<br>                buffer.getInt();<br>            &#125;<br>            buffer.clear();<br>        &#125;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;直接内存访问:&quot;</span> + (endTime - startTime));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heapAllocate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            ByteBuffer.allocate(<span class="hljs-number">100</span>);<br>        &#125;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;堆内存申请:&quot;</span> + (endTime - startTime));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">directAllocate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> startTime = System.currentTimeMillis();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>            ByteBuffer.allocateDirect(<span class="hljs-number">100</span>);<br>        &#125;<br>        <span class="hljs-keyword">long</span> endTime = System.currentTimeMillis();<br>        System.out.println(<span class="hljs-string">&quot;直接内存申请:&quot;</span> + (endTime - startTime));<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            heapAccess();<br>            directAccess();<br>        &#125;<br>        System.out.println();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            heapAllocate();<br>            directAllocate();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F03-Netty%E7%B2%98%E5%8C%85-%E6%8B%86%E5%8C%85-%E9%9B%B6%E6%8B%B7%E8%B4%9D/image-20220217220802414.png" alt="image-20220217220802414"></p>
<p>​    从程序运行结果看出直接内存申请较慢，但访问效率高。在java虚拟机实现上，本地IO会直接操作直接内存（直接内存=&gt;系统调用=&gt;硬盘/网卡），而非直接内存则需要二次拷贝（堆内存=&gt;直接内存=&gt;系统调用=&gt;硬盘/网卡）。</p>
<h3 id="使用直接内存的优缺点"><a href="#使用直接内存的优缺点" class="headerlink" title="使用直接内存的优缺点"></a><strong>使用直接内存的优缺点</strong></h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>​    1、不占用堆内存空间，减少了发生GC的可能</p>
<p>​    2、运行较快（jvm虚拟机实现中，本地IO会操作直接内存，而如果是堆内存的话，操作IO需要多一步从直接内存复制到堆内存或者从堆内存写会直接内存）</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>​    1、初始分配慢</p>
<p>​    2、没有JVM直接帮助管理内存，容易发生内存溢出。</p>
<p>​    为了避免一直没有FullGC,最终导致直接内存把物理内存被耗完，我们可以通过-XX：MaxDirectMemorySize来指定直接内存最大值（<strong>JVM堆内存大小可以通过-Xmx来设置，同样的direct ByteBuffer可以通过-XX:MaxDirectMemorySize来设置</strong>），当达到阈值的时候，系统会自动调用system.gc来进行一次FULL GC， 间接把那些没有被使用的直接内存回收掉。</p>
]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>Netty</tag>
        <tag>粘包</tag>
        <tag>拆包</tag>
        <tag>零拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式04-Netty核心源码解析与应用</title>
    <url>/2022/02/20/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="Netty核心源码解析与应用"><a href="#Netty核心源码解析与应用" class="headerlink" title="Netty核心源码解析与应用"></a>Netty核心源码解析与应用</h1><h2 id="Netty线程模型图"><a href="#Netty线程模型图" class="headerlink" title="Netty线程模型图"></a>Netty线程模型图</h2><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220220212257538.png" alt="image-20220220212257538"></p>
<h2 id="Netty线程模型源码剖析图"><a href="#Netty线程模型源码剖析图" class="headerlink" title="Netty线程模型源码剖析图"></a>Netty线程模型源码剖析图</h2><p><a href="!%5Bimg%5D(https://note.youdao.com/yws/public/resource/ab45dc97644411c44fbd27ee95d8244e/xmlnote/27ABFFC5A76E455281D97034FD4F191D/85410)">参考文档</a></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/Netty%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90.png" alt="img"></p>
<p><strong>具体深入源码，后续深入学习时分析</strong></p>
<h2 id="Netty高并发高性能架构设计精髓"><a href="#Netty高并发高性能架构设计精髓" class="headerlink" title="Netty高并发高性能架构设计精髓"></a>Netty高并发高性能架构设计精髓</h2><ul>
<li>主从Reactor线程模型<ul>
<li>bossGroup负责接收连接，workerGroup负责读写，大大提升了Netty的并发能力和性能</li>
</ul>
</li>
<li>NIO多路复用非阻塞</li>
<li>无锁串行化设计思想<ul>
<li>各个worker线程都是串行化运行，减少线程切换带来的损耗</li>
</ul>
</li>
<li>支持高性能序列化协议</li>
<li>零拷贝(直接内存的使用)</li>
<li>ByteBuf内存池设计</li>
<li>灵活的TCP参数配置能力</li>
<li>并发优化</li>
</ul>
<h3 id="无锁串行化设计"><a href="#无锁串行化设计" class="headerlink" title="无锁串行化设计"></a>无锁串行化设计</h3><p>在大多数场景下，并行多线程处理可以提升系统的并发性能。但是，如果对于共享资源的并发访问处理不当，会带来严重的锁竞争，这最终会导致性能的下降。为了尽可能的避免锁竞争带来的性能损耗，可以通过串行化设计，即消息的处理尽可能在同一个线程内完成，期间不进行线程切换，这样就避免了多线程竞争和同步锁。NIO的多路复用就是一种无锁串行化的设计思想(理解下Redis和Netty的线程模型)</p>
<p>为了尽可能提升性能，Netty采用了串行无锁化设计，在IO线程内部进行串行操作，避免多线程竞争导致的性能下降。表面上看，串行化设计似乎CPU利用率不高，并发程度不够。但是，通过调整NIO线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。</p>
<p>Netty的NioEventLoop读取到消息之后，直接调用ChannelPipeline的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由NioEventLoop调用到用户的Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。</p>
<h2 id="常用handler介绍"><a href="#常用handler介绍" class="headerlink" title="常用handler介绍"></a>常用handler介绍</h2><h3 id="IdleStateHandler（IN-amp-OUT）"><a href="#IdleStateHandler（IN-amp-OUT）" class="headerlink" title="IdleStateHandler（IN &amp; OUT）"></a>IdleStateHandler（IN &amp; OUT）</h3><p>new IdleStateHandler(this.readerIdleTime, this.writerIdleTime, this.allIdleTime, this.timeUnit))<br>readerIdleTime 读取时间<br>writerIdleTime 写时间<br>timeUnit 读+写总共时间<br>根据你设置的超时参数的类型和值，循环去检测channelRead和write方法多久没有被调用了，如果这个时间超过了你设置的值，那么就会触发对应的事件，read触发read，write触发write，all触发all</p>
<h3 id="netty粘包处理-netty解码器-IN"><a href="#netty粘包处理-netty解码器-IN" class="headerlink" title="netty粘包处理/netty解码器(IN)"></a>netty粘包处理/netty解码器(IN)</h3><p>netty提供了多种编码器用于处理半包，这些编码器包含<br>LineBasedFrameDecoder 时间解码器<br>DelimiterBasedFrameDecoder 分隔符解码器<br>FixedLengthFrameDecoder 定长解码器</p>
<h3 id="ChunkedWriteHandler-OUT"><a href="#ChunkedWriteHandler-OUT" class="headerlink" title="ChunkedWriteHandler(OUT)"></a>ChunkedWriteHandler(OUT)</h3><p>在进行大文件传输的时候，一次将文件的全部内容映射到内存中，很有可能导致内存溢出。为了解决大文件传输过程中的内存溢出，Netty提供了ChunkedWriteHandler来解决大文件或者码流传输过程中可能发生的内存溢出问题</p>
<p>ChunkedWriteHandler异步写大型数据流，不会导致大量内存消耗</p>
<h3 id="HttpObjectAggregator-INT"><a href="#HttpObjectAggregator-INT" class="headerlink" title="HttpObjectAggregator(INT)"></a>HttpObjectAggregator(INT)</h3><p>聚合消息:将HttpMessage及其后续HttpContent聚合为单个 FullHttpRequest或FullHttpResponse的ChannelHandler（取决于它是否用于处理请求或响应）。当您不想处理传输编码为“分块”的 HTTP 消息时（Http1.1中新增加内容, Transfer-<a href="https://so.csdn.net/so/search?q=Encoding&spm=1001.2101.3001.7020">Encoding</a>: chunked  译为:分包传输），它很有用。如果用于处理响应，则在ChannelPipeline 中的HttpResponseDecoder 之后插入此处理程序，如果用于处理请求，则在ChannelPipeline 中的HttpRequestDecoder 和HttpResponseEncoder 之后插入此处理程序。</p>
<p>​    前面我们讲了， 一个HTTP请求最少也会在HttpRequestDecoder里分成两次往后传递，第一次是消息行和消息头，第二次是消息体，哪怕没有消息体，也会传一个空消息体。如果发送的消息体比较大的话，可能还会分成好几个消息体来处理，往后传递多次，这样使得我们后续的处理器可能要写多个逻辑判断，比较麻烦，那能不能把消息都整合成一个完整的，再往后传递呢，当然可以，用HttpObjectAggregator。</p>
<h3 id="HttpServerCodec（INT-amp-OUT）"><a href="#HttpServerCodec（INT-amp-OUT）" class="headerlink" title="HttpServerCodec（INT &amp; OUT）"></a>HttpServerCodec（INT &amp; OUT）</h3><p>HttpServerCodec = HttpRequestDecoder + HttpResponseEncoder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ChannelPipeline pipeline = ch.pipeline();<br>pipeline.addLast(<span class="hljs-string">&quot;http-decodec&quot;</span>,<span class="hljs-keyword">new</span> HttpRequestDecoder());<br>pipeline.addLast(<span class="hljs-string">&quot;http-encodec&quot;</span>,<span class="hljs-keyword">new</span> HttpResponseEncoder());<br>pipeline.addLast(<span class="hljs-string">&quot;http-aggregator&quot;</span>,<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">65536</span>));<br>pipeline.addLast(<span class="hljs-string">&quot;http-chunked&quot;</span>,<span class="hljs-keyword">new</span> ChunkedWriteHandler());<br>     <span class="hljs-comment">/*</span><br><span class="hljs-comment">   pipeline.addLast(new HttpServerCodec());</span><br><span class="hljs-comment">   pipeline.addLast(new HttpObjectAggregator(64*1024));</span><br><span class="hljs-comment">   pipeline.addLast(new ChunkedWriteHandler());</span><br><span class="hljs-comment">*/</span><br></code></pre></td></tr></table></figure>

<h3 id="Codec编解码Handler"><a href="#Codec编解码Handler" class="headerlink" title="Codec编解码Handler"></a>Codec编解码Handler</h3><h4 id="ByteToLongDecoder-amp-LongToByteEncoder"><a href="#ByteToLongDecoder-amp-LongToByteEncoder" class="headerlink" title="ByteToLongDecoder &amp; LongToByteEncoder"></a>ByteToLongDecoder &amp; LongToByteEncoder</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToLongDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ByteToMessageDecoder</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ByteToLongDecoder decode 被调用&quot;</span>);<br>        <span class="hljs-keyword">if</span>(in.readableBytes() &gt;= <span class="hljs-number">8</span>)&#123;<br>            <span class="hljs-comment">//因为 long 8个字节, 需要判断有8个字节，才能读取一个long</span><br>            out.add(in.readLong());<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongToByteEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Long msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;LongToByteEncoder encode被调用&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;msg=&quot;</span> + msg);<br>        out.writeLong(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//创建2个线程组，一个负责处理客户端accept连接时间，一个负责客户端IO读写事件</span><br>        NioEventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">1</span>);<br>        <span class="hljs-comment">//NioEventLoop默认线程是cpu核数的2倍</span><br>        NioEventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br><br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    <span class="hljs-comment">// 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一 个客户端连接。</span><br>                    <span class="hljs-comment">// 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理</span><br>                    .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ByteToLongDecoder());<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;netty server start。。&quot;</span>);<br>            <span class="hljs-comment">//绑定一个端口并且同步, 生成了一个ChannelFuture异步对象，通过isDone()等方法可以判断异步 事件的执行情况</span><br>            <span class="hljs-comment">// 启动服务器(并绑定端口)，bind是异步操作，sync方法是等待异步操作执行完毕</span><br>            ChannelFuture cf = bootstrap.bind(<span class="hljs-number">9000</span>).sync();<br>            cf.addListener(<span class="hljs-keyword">new</span> ChannelFutureListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">operationComplete</span><span class="hljs-params">(ChannelFuture channelFuture)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-keyword">if</span> (cf.isSuccess()) &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口9000成功&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        System.out.println(<span class="hljs-string">&quot;监听端口9000失败&quot;</span>);<br>                    &#125;<br>                &#125;<br>            &#125;);<br><br>            <span class="hljs-comment">//对通道关闭进行监听，closeFuture是异步操作，监听通道关闭</span><br>            <span class="hljs-comment">// 通过sync方法同步等待通道关闭处理完毕，这里会阻塞等待通道关闭完成</span><br>            cf.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;从客户端读取到Long：&quot;</span> + (Long)msg);<br>        <span class="hljs-comment">//给客户端发回一个long数据</span><br>        ctx.writeAndFlush(<span class="hljs-number">2000L</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//客户端需要一个事件循环组</span><br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建客户端启动对象</span><br>            <span class="hljs-comment">// 注意客户端使用的不是 ServerBootstrap 而是 Bootstrap</span><br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> LongToByteEncoder());<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                        &#125;<br>                    &#125;);<br>            System.out.println(<span class="hljs-string">&quot;netty client start&quot;</span>);<br>            ChannelFuture channelFuture = bootstrap.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9000</span>).sync();<br>            channelFuture.channel().closeFuture().sync();<br><br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到服务器消息:&quot;</span> + msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyClientHandler发送数据&quot;</span>);<br>        ctx.writeAndFlush(<span class="hljs-number">1000L</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="Object-String-Decoder-Encoder"><a href="#Object-String-Decoder-Encoder" class="headerlink" title="(Object/String)(Decoder/Encoder)"></a>(Object/String)(Decoder/Encoder)</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>        bootstrap.group(bossGroup, workerGroup)<br>            .channel(NioServerSocketChannel.class)<br>            <span class="hljs-comment">// 初始化服务器连接队列大小，服务端处理客户端连接请求是顺序处理的,所以同一时间只能处理一 个客户端连接。</span><br>            <span class="hljs-comment">// 多个客户端同时来的时候,服务端将不能处理的客户端连接请求放在队列中等待处理</span><br>            .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>)<br>            .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                   <span class="hljs-comment">//ch.pipeline().addLast(new StringDecoder());</span><br>                   ch.pipeline().addLast(<span class="hljs-keyword">new</span> ObjectDecoder(Integer.MAX_VALUE, ClassResolvers.cacheDisabled(<span class="hljs-keyword">null</span>)));<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyServerHandler());<br>                &#125;<br>            &#125;);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//System.out.println(&quot;从客户端读取到String：&quot; + msg.toString());</span><br>        System.out.println(<span class="hljs-string">&quot;从客户端读取到Object：&quot;</span> + ((User)msg).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.group(group)<br>            .channel(NioSocketChannel.class)<br>            .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                    <span class="hljs-comment">//ch.pipeline().addLast(new StringEncoder());</span><br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> ObjectEncoder());<br>                    ch.pipeline().addLast(<span class="hljs-keyword">new</span> NettyClientHandler());<br>                &#125;<br>            &#125;);<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NettyClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;MyClientHandler发送数据&quot;</span>);<br>        <span class="hljs-comment">//ctx.writeAndFlush(&quot;测试String编解码&quot;);</span><br>        <span class="hljs-comment">//测试对象编解码</span><br>        ctx.writeAndFlush(<span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;zhuge&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="常用ChannelOption"><a href="#常用ChannelOption" class="headerlink" title="常用ChannelOption"></a>常用ChannelOption</h2><p>​    ChannelOption的各种属性在套接字选项中都有对应，下面简单的总结一下ChannelOption的含义已及使用的场景。</p>
<h3 id="ChannelOption-SO-BACKLOG"><a href="#ChannelOption-SO-BACKLOG" class="headerlink" title="ChannelOption.SO_BACKLOG"></a>ChannelOption.SO_BACKLOG</h3><blockquote>
<p>​    ChannelOption.SO_BACKLOG对应的是tcp/ip协议listen函数中的backlog。函数listen(int socketfd, int backlog)用来初始化服务端可连接队列。</p>
<p>​    服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理，<strong>backlog参数指定了阻塞等待队列的大小</strong>。</p>
</blockquote>
<h3 id="ChannelOption-SO-REUSEADDR"><a href="#ChannelOption-SO-REUSEADDR" class="headerlink" title="ChannelOption.SO_REUSEADDR"></a>ChannelOption.SO_REUSEADDR</h3><blockquote>
<p>​    ChanneOption.SO_REUSEADDR对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口。</p>
<p>​    比如，某个服务器进程占用了TCP的80端口进行监听，此时再次监听该端口就会返回错误，使用该参数就可以解决问题，该参数允许共用该端口，这个在服务器程序中比较常使用。比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR就无法正常使用该端口。</p>
</blockquote>
<h3 id="ChannelOption-SO-KEEPALIVE"><a href="#ChannelOption-SO-KEEPALIVE" class="headerlink" title="ChannelOption.SO_KEEPALIVE"></a>ChannelOption.SO_KEEPALIVE</h3><blockquote>
<p>​    Channeloption.SO_KEEPALIVE参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的连接。</p>
<p>​    当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。</p>
</blockquote>
<h3 id="ChannelOption-SO-SNDBUF-SO-RCVBUF"><a href="#ChannelOption-SO-SNDBUF-SO-RCVBUF" class="headerlink" title="ChannelOption.SO_SNDBUF/SO_RCVBUF"></a>ChannelOption.SO_SNDBUF/SO_RCVBUF</h3><blockquote>
<p>​    ChannelOption.SO_SNDBUF参数对应于套接字选项中的SO_SNDBUF，ChannelOption.SO_RCVBUF参数对应于套接字选项中的SO_RCVBUF这两个参数用于操作发送缓冲区大小和接受缓冲区大小。</p>
<p>​    接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功.</p>
<p>​    发送缓冲区用于保存发送数据，直到发送成功。</p>
<p><a href="https://www.cnblogs.com/kex1n/p/7801343.html">为了达到最大网络吞吐，socket send buffer size(SO_SNDBUF)不应该小于带宽和延迟的乘积</a></p>
</blockquote>
<h3 id="ChannelOption-SO-LINGER"><a href="#ChannelOption-SO-LINGER" class="headerlink" title="ChannelOption.SO_LINGER"></a>ChannelOption.SO_LINGER</h3><blockquote>
<p>​    ChannelOption.SO_LINGER参数对应于套接字选项中的SO_LINGER，Linux内核默认的处理方式是当用户调用close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证会发送剩余的数据，造成了数据的不确定性，使用SO_LINGER可以阻塞close()的调用时间，直到数据完全发送。</p>
</blockquote>
<h3 id="ChannelOption-TCP-NODELAY"><a href="#ChannelOption-TCP-NODELAY" class="headerlink" title="ChannelOption.TCP_NODELAY"></a>ChannelOption.TCP_NODELAY</h3><blockquote>
<p>​    ChannelOption.TCP_NODELAY参数对应于套接字选项中的TCP_NODELAY,该参数的使用与Nagle算法有关。</p>
<p>​    Nagle算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次，因此在数据包不足的时候会等待其他数据的到来，组装成大的数据包进行发送，虽然该算法有效提高了网络的有效负载，但是却造成了延时。</p>
<p>​    而该参数的作用就是禁止使用Nagle算法，使用于小数据即时传输。和TCP_NODELAY相对应的是TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送数据，适用于文件传输。</p>
</blockquote>
<h3 id="TCP参数表"><a href="#TCP参数表" class="headerlink" title="TCP参数表"></a>TCP参数表</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/20170703144810032.jfif" alt="img"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/20170703144854985.jfif" alt="img"></p>
<h1 id="Netty应用"><a href="#Netty应用" class="headerlink" title="Netty应用"></a>Netty应用</h1><h2 id="弹幕系统应用"><a href="#弹幕系统应用" class="headerlink" title="弹幕系统应用"></a>弹幕系统应用</h2><h3 id="弹幕系统概要设计"><a href="#弹幕系统概要设计" class="headerlink" title="弹幕系统概要设计"></a>弹幕系统概要设计</h3><h4 id="弹幕系统特点-参考B站"><a href="#弹幕系统特点-参考B站" class="headerlink" title="弹幕系统特点(参考B站)"></a>弹幕系统特点(参考B站)</h4><p>1、实时性高</p>
<p>2、并发量大</p>
<h4 id="弹幕系统架构设计"><a href="#弹幕系统架构设计" class="headerlink" title="弹幕系统架构设计"></a>弹幕系统架构设计</h4><p>业务架构</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220220222209048.png" alt="image-20220220222209048"></p>
<p>方案一</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220220222241502.png" alt="image-20220220222241502"></p>
<p>方案二</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220220222315381.png" alt="image-20220220222315381"></p>
<h3 id="WebScoket协议解析实现"><a href="#WebScoket协议解析实现" class="headerlink" title="WebScoket协议解析实现"></a>WebScoket协议解析实现</h3><h4 id="webSocket协议简介"><a href="#webSocket协议简介" class="headerlink" title="webSocket协议简介"></a>webSocket协议简介</h4><p>​    webSocket是html5开始提供的⼀种浏览器与服务器间进⾏<span style="color:red">全双工</span><strong>⼆进制</strong>通信协议（先建立HTTP/HTTPS，通过请求头升级为ws或者wss），其基于TCP双向全双工作进⾏消息传递，同⼀时刻即可以发⼜可以接收消息，相⽐Http的半双⼯协议性能有很⼤的提升</p>
<h4 id="webSocket特点"><a href="#webSocket特点" class="headerlink" title="webSocket特点"></a>webSocket特点</h4><p>1、单⼀TCP⻓连接，采⽤全双⼯通信模式</p>
<p>2、对代理、防火墙和路由器透明（和<strong>HTTP共用同一个端口</strong>，且ws连接开始前客户端通过HTTP请求表示切换到ws协议）</p>
<p>3、⽆头部信息、消息更精简</p>
<p>4、通过ping/pong来保活</p>
<p>5、服务器可以主动发送消息给客户端，无需客户端轮询</p>
<h4 id="WebSocket协议报⽂格式"><a href="#WebSocket协议报⽂格式" class="headerlink" title="WebSocket协议报⽂格式"></a>WebSocket协议报⽂格式</h4><p>​    我们知道，任何应⽤协议都有其特有的报⽂格式，⽐如Http协议通过空格换⾏组成其报⽂。如http协议不同在于WebSocket属于⼆进制协议，通过规范进⼆进位来组成其报⽂。具体组成如下图：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220220225004670.png" alt="image-20220220225004670"></p>
<p>报⽂说明：</p>
<p>FIN标识是否为此消息的最后⼀个数据包，占1bitRSV1,RSV2,RSV3:⽤于扩展协议，⼀般为0，各占1bit</p>
<p>Opcode数据包类型（frame type），占4bits</p>
<p>0x0：标识⼀个中间数据包<br>0x1：标识⼀个text类型数据包<br>0x2：标识⼀个binary类型数据包<br>0x3-7：保留<br>0x8：标识⼀个断开连接类型数据包<br>0x9：标识⼀个ping类型数据包<br>0xA：表示⼀个pong类型数据包<br>0xB-F：保留<br>MASK：占1bits⽤于标识PayloadData是否经过掩码处理。如果是1，Masking-key域的数据即是掩码密钥，⽤于解码<br>PayloadData。客户端发出的数据帧需要进⾏掩码处理，所以此位是1。<br>Payload length Payload data的⻓度，占7bits，7+16bits，7+64bits：<br>    如果其值在0-125，则是payload的真实⻓度。<br>    如果值是126，则后⾯2个字节形成的16bits⽆符号整型数的值是payload的真实长度。注意，网络字节序，需要转换。<br>    如果值是127，则后⾯8个字节形成的64bits⽆符号整型数的值是payload的真实长度。注意，网络字节序，需要转换。<br>Payload data应⽤层数据</p>
<p>​    WebSocket在浏览当中的使⽤Http连接与webSocket连接建⽴示意图：通过javaScript中的API可以直接操作WebSocket对象，其示例如下：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F04-Netty-%E6%A0%B8%E5%BF%83%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/image-20220220225503110.png" alt="image-20220220225503110"></p>
<h3 id="弹幕系统代码实现"><a href="#弹幕系统代码实现" class="headerlink" title="弹幕系统代码实现"></a>弹幕系统代码实现</h3><p>通过javaScript中的API可以直接操作WebSocket对象，其示例如下： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&quot;ws://localhost:8080&quot;</span>); <br>ws.onopen = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>    <span class="hljs-comment">// 建立成功之后触发的事件 </span><br>	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;打开连接&quot;</span>);<br>    ws.send(<span class="hljs-string">&quot;ddd&quot;</span>); <span class="hljs-comment">// 发送消息</span><br>&#125;; <br>ws.onmessage = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123; <span class="hljs-comment">// 接收服务器消息</span><br>    <span class="hljs-built_in">console</span>.log(evt.data); <br>&#125;; <br>ws.onclose = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123; <br><span class="hljs-built_in">console</span>.log(“WebSocketClosed!”); <span class="hljs-comment">// 关闭连接 &#125;; </span><br>ws.onerror = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) </span>&#123; <br> 	<span class="hljs-built_in">console</span>.log(“WebSocketError!”); <span class="hljs-comment">// 连接异常</span><br>&#125;; <br></code></pre></td></tr></table></figure>

<p>后端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Websocket 聊天服务器-服务端</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsocketDanmuServer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> port;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WebsocketDanmuServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">2</span>); <span class="hljs-comment">// (1)</span><br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup(<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap b = <span class="hljs-keyword">new</span> ServerBootstrap(); <span class="hljs-comment">// (2)</span><br>            b.group(bossGroup, workerGroup)<br>             .channel(NioServerSocketChannel.class) <span class="hljs-comment">// (3)</span><br>             .childHandler(<span class="hljs-keyword">new</span> WebsocketDanmuServerInitializer())  <span class="hljs-comment">//(4)</span><br>             .option(ChannelOption.SO_BACKLOG, <span class="hljs-number">128</span>)          <span class="hljs-comment">// (5)</span><br>             .childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-keyword">true</span>); <span class="hljs-comment">// (6)       </span><br>          System.out.println(<span class="hljs-string">&quot;SnakeGameServer 启动了&quot;</span> + port);   <br>            <span class="hljs-comment">// 绑定端口，开始接收进来的连接</span><br>            ChannelFuture f = b.bind(port).sync(); <span class="hljs-comment">// (7)</span><br>            <span class="hljs-comment">// 等待服务器  socket 关闭 。</span><br>            <span class="hljs-comment">// 在这个例子中，这不会发生，但你可以优雅地关闭你的服务器。</span><br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            workerGroup.shutdownGracefully();<br>            bossGroup.shutdownGracefully();  <br>          System.out.println(<span class="hljs-string">&quot;SnakeGameServer 关闭了&quot;</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> port;<br>        <span class="hljs-keyword">if</span> (args.length &gt; <span class="hljs-number">0</span>) &#123;<br>            port = Integer.parseInt(args[<span class="hljs-number">0</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            port = <span class="hljs-number">8080</span>;<br>        &#125;<br>        <span class="hljs-keyword">new</span> WebsocketDanmuServer(port).run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 服务端 ChannelInitializer</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebsocketDanmuServerInitializer</span> <span class="hljs-keyword">extends</span></span><br><span class="hljs-class">        <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;    <span class="hljs-comment">//1</span><br><br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<span class="hljs-comment">//2</span><br>      ChannelPipeline pipeline = ch.pipeline();<br>      pipeline.addLast(<span class="hljs-string">&quot;http-decodec&quot;</span>,<span class="hljs-keyword">new</span> HttpRequestDecoder());<br>      pipeline.addLast(<span class="hljs-string">&quot;http-encodec&quot;</span>,<span class="hljs-keyword">new</span> HttpResponseEncoder());<br>      pipeline.addLast(<span class="hljs-string">&quot;http-aggregator&quot;</span>,<span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">65536</span>));<br>      pipeline.addLast(<span class="hljs-string">&quot;http-chunked&quot;</span>,<span class="hljs-keyword">new</span> ChunkedWriteHandler());<br>       <span class="hljs-comment">/*</span><br><span class="hljs-comment">         pipeline.addLast(new HttpServerCodec());</span><br><span class="hljs-comment">         pipeline.addLast(new HttpObjectAggregator(64*1024));</span><br><span class="hljs-comment">         pipeline.addLast(new ChunkedWriteHandler());</span><br><span class="hljs-comment">      */</span><br>      pipeline.addLast(<span class="hljs-string">&quot;http-request&quot;</span>,<span class="hljs-keyword">new</span> HttpRequestHandler(<span class="hljs-string">&quot;/ws&quot;</span>));<br>      pipeline.addLast(<span class="hljs-string">&quot;WebSocket-protocol&quot;</span>,<span class="hljs-keyword">new</span> WebSocketServerProtocolHandler(<span class="hljs-string">&quot;/ws&quot;</span>));<br>      pipeline.addLast(<span class="hljs-string">&quot;WebSocket-request&quot;</span>,<span class="hljs-keyword">new</span> TextWebSocketFrameHandler());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="HttpRequestHandler"><a href="#HttpRequestHandler" class="headerlink" title="HttpRequestHandler"></a>HttpRequestHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理 Http 请求</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpRequestHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">FullHttpRequest</span>&gt; </span>&#123; <span class="hljs-comment">//1</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String wsUri;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> File INDEX;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        URL location = HttpRequestHandler.class.getProtectionDomain().getCodeSource().getLocation();<br>        <span class="hljs-keyword">try</span> &#123;<br>            String path = location.toURI() + <span class="hljs-string">&quot;WebsocketDanMu.html&quot;</span>;<br>            path = !path.contains(<span class="hljs-string">&quot;file:&quot;</span>) ? path : path.substring(<span class="hljs-number">5</span>);<br>            INDEX = <span class="hljs-keyword">new</span> File(path);<br>        &#125; <span class="hljs-keyword">catch</span> (URISyntaxException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Unable to locate WebsocketChatClient.html&quot;</span>, e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HttpRequestHandler</span><span class="hljs-params">(String wsUri)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.wsUri = wsUri;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, FullHttpRequest request)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (wsUri.equalsIgnoreCase(request.uri())) &#123;<br>            ctx.fireChannelRead(request.retain());<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//处理Expect:100-continue(参考：https://www.jianshu.com/p/154c310748db)</span><br>            <span class="hljs-keyword">if</span> (HttpHeaders.is100ContinueExpected(request)) &#123;<br>                send100Continue(ctx);<br>            &#125;<br><br>            RandomAccessFile file = <span class="hljs-keyword">new</span> RandomAccessFile(INDEX, <span class="hljs-string">&quot;r&quot;</span>);<br><br>            HttpResponse response = <span class="hljs-keyword">new</span> DefaultHttpResponse(request.getProtocolVersion(), HttpResponseStatus.OK);<br>            response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>);<br><br>            <span class="hljs-keyword">boolean</span> keepAlive = HttpHeaders.isKeepAlive(request);<br><br>            <span class="hljs-keyword">if</span> (keepAlive) &#123;<br>                response.headers().set(HttpHeaderNames.CONTENT_LENGTH, file.length());<br>                response.headers().set(HttpHeaderNames.CONNECTION,  HttpHeaderValues.KEEP_ALIVE);<br>            &#125;<br>            ctx.write(response);<br><br>            <span class="hljs-keyword">if</span> (ctx.pipeline().get(SslHandler.class) == <span class="hljs-keyword">null</span>) &#123;<br>                ctx.write(<span class="hljs-keyword">new</span> DefaultFileRegion(file.getChannel(), <span class="hljs-number">0</span>, file.length()));<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                ctx.write(<span class="hljs-keyword">new</span> ChunkedNioFile(file.getChannel()));<br>            &#125;<br>            ChannelFuture future = ctx.writeAndFlush(LastHttpContent.EMPTY_LAST_CONTENT);<br>            <span class="hljs-keyword">if</span> (!keepAlive) &#123;<br>                future.addListener(ChannelFutureListener.CLOSE);<br>            &#125;<br>            <br>            file.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send100Continue</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(HttpVersion.HTTP_1_1, HttpResponseStatus.CONTINUE);<br>        ctx.writeAndFlush(response);<br>    &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span></span><br><span class="hljs-function">         <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       Channel incoming = ctx.channel();<br>      System.out.println(<span class="hljs-string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="hljs-string">&quot;异常&quot;</span>);<br>        <span class="hljs-comment">// 当出现异常就关闭连接</span><br>        cause.printStackTrace();<br>        ctx.close();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="TextWebSocketFrameHandler"><a href="#TextWebSocketFrameHandler" class="headerlink" title="TextWebSocketFrameHandler"></a>TextWebSocketFrameHandler</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 处理TextWebSocketFrame</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextWebSocketFrameHandler</span> <span class="hljs-keyword">extends</span></span><br><span class="hljs-class">        <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">TextWebSocketFrame</span>&gt; </span>&#123;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ChannelGroup channels = <span class="hljs-keyword">new</span> DefaultChannelGroup(GlobalEventExecutor.INSTANCE);<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx,</span></span><br><span class="hljs-function"><span class="hljs-params">         TextWebSocketFrame msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// (1)</span><br>      Channel incoming = ctx.channel();<br>      <span class="hljs-keyword">for</span> (Channel channel : channels) &#123;<br>            <span class="hljs-keyword">if</span> (channel != incoming)&#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(msg.text()));<br>         &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;我发送的&quot;</span>+msg.text() ));<br>         &#125;<br>        &#125;<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerAdded</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">// (2)</span><br>        Channel incoming = ctx.channel();<br>        channels.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;[SERVER] - &quot;</span> + incoming.remoteAddress() + <span class="hljs-string">&quot; 加入&quot;</span>));<br>        <br>        channels.add(incoming);<br>      System.out.println(<span class="hljs-string">&quot;Client:&quot;</span>+incoming.remoteAddress() +<span class="hljs-string">&quot;加入&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handlerRemoved</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <span class="hljs-comment">// (3)</span><br>        Channel incoming = ctx.channel();<br>        channels.writeAndFlush(<span class="hljs-keyword">new</span> TextWebSocketFrame(<span class="hljs-string">&quot;[SERVER] - &quot;</span> + incoming.remoteAddress() + <span class="hljs-string">&quot; 离开&quot;</span>));<br>        <br>      System.err.println(<span class="hljs-string">&quot;Client:&quot;</span>+incoming.remoteAddress() +<span class="hljs-string">&quot;离开&quot;</span>);<br>    &#125;<br>       <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// (5)</span><br>        Channel incoming = ctx.channel();<br>      System.out.println(<span class="hljs-string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="hljs-string">&quot;在线&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelInactive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// (6)</span><br>        Channel incoming = ctx.channel();<br>      System.err.println(<span class="hljs-string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="hljs-string">&quot;掉线&quot;</span>);<br>   &#125;<br>   <br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span>    <span class="hljs-comment">// (7)</span></span><br><span class="hljs-function">         <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>       Channel incoming = ctx.channel();<br>      System.err.println(<span class="hljs-string">&quot;Client:&quot;</span>+incoming.remoteAddress()+<span class="hljs-string">&quot;异常&quot;</span>);<br>            <span class="hljs-comment">// 当出现异常就关闭连接</span><br>            cause.printStackTrace();<br>        ctx.close();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Netty</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Netty</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程01-JMM&amp;volatile</title>
    <url>/2021/08/29/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&amp;volatile/</url>
    <content><![CDATA[<blockquote>
<p>参考文档：一文解决内存屏障 <a href="https://www.jianshu.com/p/64240319ed60">https://www.jianshu.com/p/64240319ed60</a></p>
</blockquote>
<h1 id="现代计算机理论模型与工作原理"><a href="#现代计算机理论模型与工作原理" class="headerlink" title="现代计算机理论模型与工作原理"></a>现代计算机理论模型与工作原理</h1><h2 id="冯诺依曼计算机模型"><a href="#冯诺依曼计算机模型" class="headerlink" title="冯诺依曼计算机模型"></a>冯诺依曼计算机模型</h2><p>简介：</p>
<p>​    现代计算机模型是基于-冯诺依曼计算机模型 计算机在运行时，先从内存中取出第一条指令，通过控制器的译码，按指令的要求，从存 储器中取出数据进行指定的运算和逻辑操作等加工，然后再按地址把结果送到内存中去。接下来，再取出第二条指令，在控制器的指挥下完成规定操作。依此进行下去，直至遇到停止指令。</p>
<h3 id="计算机五大核心组成部分"><a href="#计算机五大核心组成部分" class="headerlink" title="计算机五大核心组成部分"></a>计算机五大核心组成部分</h3><ul>
<li>控制器</li>
<li>运算器</li>
<li>存储器</li>
<li>输入</li>
<li>输出</li>
</ul>
<h3 id="冯诺依曼计算机模型图"><a href="#冯诺依曼计算机模型图" class="headerlink" title="冯诺依曼计算机模型图"></a>冯诺依曼计算机模型图</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210829224323237.png" alt="image-20210829224323237"></p>
<h3 id="现代计算机硬件结构原理图"><a href="#现代计算机硬件结构原理图" class="headerlink" title="现代计算机硬件结构原理图"></a>现代计算机硬件结构原理图</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210829224618735.png" alt="image-20210829224618735"></p>
<h1 id="CPU多核缓存架构"><a href="#CPU多核缓存架构" class="headerlink" title="CPU多核缓存架构"></a>CPU多核缓存架构</h1><img src="/images/并发编程01JMM&volatile/image-20210829232930566.png">

<h3 id="CPU内部结构划分"><a href="#CPU内部结构划分" class="headerlink" title="CPU内部结构划分"></a>CPU内部结构划分</h3><ul>
<li>控制单元（包含指令计数器、指令寄存器等）</li>
<li>运算单元</li>
<li>存储单元</li>
</ul>
<p><strong>多CPU</strong></p>
<p>​    一个现代计算机通常由两个或者多个CPU，如果要运行多个程序（<strong>进程</strong>）的话，<strong>假如只有 一个CPU的话，就意味着要经常进行进程上下文切换</strong>，因为单CPU即便是多核的，也只是多个处理器核心，其他设备都是共用的，所以多个进程就必然要<strong>经常进行进程上下文切换，这个代价是很高</strong>的</p>
<p><strong>CPU多核</strong> （<strong>支持进程内同时跑多个线程</strong>）</p>
<p>​    一个现代CPU除了<strong>处理器核心</strong>之外还包括寄存器、L1L2L3缓存这些存储设备、浮点运算 单元、整数运算单元等一些辅助运算设备以及内部总线等。<strong>一个多核的CPU也就是一个CPU上 有多个处理器核心</strong>，这样有什么好处呢？比如说现在我们要在一台计算机上跑一个多线程的程序，因为是一个进程里的线程，所以需要一些共享一些存储变量，如果这台计算机都是单核单线程CPU的话，就意味着<strong>这个程序的不同线程需要经常在CPU之间的外部总线上通信</strong>，<strong>同时还要处理不同CPU之间不同缓存导致数据不一致的问题</strong>，所以在这种场景下多核单CPU的架构就能发挥很大的优势，通信都在内部总线，共用同一个缓存。</p>
<p><strong>CPU寄存器</strong></p>
<p>​    CPU在寄存器上执行操作的 速度远大于在主存上执行的速度。<strong>这是因为CPU访问寄存器的速度远大于主存。大概是几十到几百倍</strong> </p>
<p><strong>CPU缓存</strong></p>
<p>​    即高速缓冲存储器，是位于CPU与主内存间的一种容量较小但速度很高的存储器。由于 CPU的速度远高于主内存，CPU直接从内存中存取数据要等待一定时间周期，Cache中保存着CPU刚用过或循环使用的一部分数据，当CPU再次使用该部分数据时可从Cache中直接调用, 减少CPU的等待时间，提高了系统的效率。 一级Cache(L1 Cache) 二级Cache(L2 Cache) 三级Cache(L3 Cache)，运行速度 寄存器&gt;L1&gt;L2&gt;L3&gt;内存</p>
<p><strong>内存</strong></p>
<p>​    一个计算机还包含一个主存。所有的CPU都可以访问主存。主存通常比CPU中的缓存大得 多</p>
<h1 id="缓存一致性协议（MESI）"><a href="#缓存一致性协议（MESI）" class="headerlink" title="缓存一致性协议（MESI）"></a>缓存一致性协议（MESI）</h1><h2 id="MESI协议的作用"><a href="#MESI协议的作用" class="headerlink" title="MESI协议的作用"></a>MESI协议的作用</h2><p><strong>多线程环境下存在的问题：缓存一致性问题</strong> </p>
<p>​    在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是 也引入了新的问题：缓存一致性（CacheCoherence）。当多个处理器的运算任务都涉及同一 块主内存区域时，将可能导致各自的缓存数据不一致的情况，如果真的发生这种情况，那同步回到主内存时以谁的缓存数据为准呢？</p>
<p>​    为了解决一致性的问题，需要各个处理器访问缓存时都 遵循一些协议，在读写时要根据协议来进行操作，这类协议有MSI、 <strong>MESI</strong>（IllinoisProtocol）、MOSI、Synapse、Firefly及DragonProtocol，等等</p>
<p>​                                                                    <strong>MESI缓存一致性协议</strong></p>
<table>
<thead>
<tr>
<th><strong>状态</strong></th>
<th><strong>描述</strong></th>
<th><strong>监听任务</strong></th>
</tr>
</thead>
<tbody><tr>
<td>M 修改 (Modified)</td>
<td>该Cache line有效，数据被修改了，和内存中的数据不一致，数据只存在于本Cache中。</td>
<td>缓存行必须时刻监听所有试图读该缓存行相对就主存的操作，这种操作必须在缓存将该缓存行写回主存并将状态变成S（共享）状态之前被延迟执行。</td>
</tr>
<tr>
<td>E 独享、互斥 (Exclusive)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据只存在于本Cache中。</td>
<td>缓存行也必须监听其它缓存读主存中该缓存行的操作，一旦有这种操作，该缓存行需要变成S（共享）状态。</td>
</tr>
<tr>
<td>S 共享 (Shared)</td>
<td>该Cache line有效，数据和内存中的数据一致，数据存在于很多Cache中。</td>
<td>缓存行也必须监听其它缓存使该缓存行无效或者独享该缓存行的请求，并将该缓存行变成无效（Invalid）。</td>
</tr>
<tr>
<td>I 无效 (Invalid)</td>
<td>该Cache line无效。</td>
<td>无</td>
</tr>
</tbody></table>
<p> 缓存行：CPU缓存的最小存储单元</p>
<p>总线嗅探机制：多个cpu读取同一份内存变量A到cpu缓存后会嗅探别的cpu对该变量A的读取而修改状态</p>
<p>指令周期内会进行裁决：多个cpu同时向总线递交modified时，指令周期内会裁决A,B哪个线程生效，如果A生效，另一个线程B 标记invalid且已执行过程序（类似代码跑完了，对这个线程来说却实际没有生效）</p>
<h2 id="缓存一致性协议失效的情况："><a href="#缓存一致性协议失效的情况：" class="headerlink" title="缓存一致性协议失效的情况："></a>缓存一致性协议失效的情况：</h2><p>1、要缓存的数据大于一个缓存行的大小，只能加总线锁（一个缓存行可以存多个数据）</p>
<p>2、CPU本身不支持缓存一致性协议    </p>
<h1 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​    现代操作系统在运行一个程序时，会为其创建一个进程。例如，启动一个Java程序，操作系统就会创建一个Java进程。<strong>进程是系统分配资源的基本单位</strong></p>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><p>​    <strong>现代操作系统调度CPU的最小单元是线程</strong>，也叫轻量级进程 （Light Weight Process），在一个进程里可以创建多个线程，这些线程都拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。处理器在这些线程上高速切换， 让使用者感觉到这些线程在同时执行。</p>
<h3 id="线程分为两类"><a href="#线程分为两类" class="headerlink" title="线程分为两类"></a>线程分为两类</h3><ul>
<li><strong>用户线程（User-Level Thread）ULT-对应用户空间</strong><ul>
<li>指不需要内核支持而在用户程序中实现的线程，其不依赖于操作系统核心，应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。另外，用户线程 是由应用进程利用线程库创建和管理，不依赖于操作系统核心。不需要用户态/核心态切换， 速度快。操作系统内核不知道多线程的存在，因此一个线程阻塞将使得整个进程（包括它的所 有线程）阻塞。<strong>由于这里的处理器时间片分配是以进程为基本单位，所以每个线程执行的时间相对减少。</strong> </li>
</ul>
</li>
<li><strong>内核线程(Kernel-Level Tread) KLT-对应内核空间</strong><ul>
<li>线程的所有管理操作都是由操作系统内核完成的。内核保存线程的状态和上下 文信息，当一个线程执行了引起阻塞的系统调用时，内核可以调度该进程的其他线程执行。<strong>在 多处理器系统上，内核可以分派属于同一进程的多个线程在多个处理器上运行，提高进程执行的并行度</strong>。由于需要内核完成线程的创建、调度和管理，所以和用户级线程相比这些操作要慢 得多，但是仍然比进程的创建和管理操作要快。大多数市场上的操作系统，如Windows， Linux等都支持内核级线程</li>
</ul>
</li>
</ul>
<p>在 4 GB 的内存空间中，只有 3 GB 可以用于用户应用程序。一个进程只能运行 在用户方式（usermode）或内核方式（kernelmode）下。用户程序运行在用户方式下，而系统调用运行在内核方式下。在这两种方式下所用的堆栈不一样：用户方式下用的是一般的堆栈，而内核方式下用的是固定大小的堆栈（一般为一个内存页的大小） 每个进程都有自己的 3 G 用户空间，它们共享1GB的内核空间。当一个进程从用户空间进 入内核空间时，它就不再有自己的进程空间了。<strong>这也就是为什么我们经常说线程上下文切换会 涉及到用户态到内核态的切换原因所在</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830151211718.png"></p>
<h3 id="Java线程与内核线程的关系"><a href="#Java线程与内核线程的关系" class="headerlink" title="Java线程与内核线程的关系"></a>Java线程与内核线程的关系</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830151225845.png" alt="image-20210830151225845"></p>
<h3 id="Java线程生命状态"><a href="#Java线程生命状态" class="headerlink" title="Java线程生命状态"></a>Java线程生命状态</h3><ul>
<li>新建</li>
<li>就绪</li>
<li>运行</li>
<li>终止</li>
<li>阻塞</li>
<li>等待</li>
<li>超时等待</li>
</ul>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830152624403.png" alt="image-20210830152624403"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/640.webp" alt="图片"></p>
<h1 id="并发（多线程）的意义"><a href="#并发（多线程）的意义" class="headerlink" title="并发（多线程）的意义"></a>并发（多线程）的意义</h1><h2 id="并发的作用"><a href="#并发的作用" class="headerlink" title="并发的作用"></a>并发的作用</h2><p><strong>1、充分利用多核CPU的计算能力</strong></p>
<blockquote>
<p>​    在单cpu系统中，每一时间点只能有一道程序执行，即微观上这些程序是分时的交替执行，因为分时交替运行的时间是非常短的，只不过给人的感觉是同时运行，在宏观上并发和并行一样都是同时在进行但是在微观上是不一样的。在多个cpu的操作系统中，这些可以并发执行的程序便可以分配到多个处理器（cpu），实现多任务并行执行，就是利用每个处理器来处理一个可以并发执行的程序，这样<strong>多个程序便可以同时执行</strong>。核越多，并行处理的程序越多，可以大大<strong>提高电脑的运行效率</strong>。如果能够合理地使用多线程，将能够缩减复杂应用程序的开发和维护成本，并能提供更好的性能。通过将异步工作流转换为多个序列化工作流，多线程可以更好地对人类的工作和交互方式建模。使用多线程，很多复杂的代码将变得更加直截了当，因此更容易编写、阅读和维护，但是使用多线程也意味着有很大的<strong>风险</strong>。</p>
</blockquote>
<p><strong>2、方便进行业务拆分，提升应用性能</strong></p>
<h2 id="并发产生的问题"><a href="#并发产生的问题" class="headerlink" title="并发产生的问题"></a>并发产生的问题</h2><p>1、产生频繁的上下文切换</p>
<p>2、多线程安全问题，容器出现死锁，产生的死锁会造成系统功能的阻塞或者不可用</p>
<p>3、代码复杂度提升。。。</p>
<h1 id="JMM模型"><a href="#JMM模型" class="headerlink" title="JMM模型"></a>JMM模型</h1><h2 id="JMM概念（Java-Memory-Model）"><a href="#JMM概念（Java-Memory-Model）" class="headerlink" title="JMM概念（Java Memory Model）"></a>JMM概念（Java Memory Model）</h2><p>JMM与JVM内存区域划分是不同的概念层次，JMM描述的是一组规则，通过这种规则控制程序中各个变量在工作内存和主内存的访问方式，JMM是围绕着<strong>原子性</strong>、<strong>有序性</strong>、<strong>可见性</strong>展开的。</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830175453639.png" alt="image-20210830175453639"></p>
<h2 id="JMM与硬件内存架构的关系"><a href="#JMM与硬件内存架构的关系" class="headerlink" title="JMM与硬件内存架构的关系"></a>JMM与硬件内存架构的关系</h2><p>​    <strong>JMM模型是依据现代计算机理论模型，以CPU多核缓存架构（硬件内存架构）为基础，屏蔽底层操作系统实现而抽象出来的一种抽象模型</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830175639511.png" alt="image-20210830175639511"></p>
<h2 id="JMM内存交互操作"><a href="#JMM内存交互操作" class="headerlink" title="JMM内存交互操作"></a>JMM内存交互操作</h2><ol>
<li>lock(锁定)：作用于主内存的变量，把一个变量标记为一条线程独占状态</li>
<li>unlock(解锁)：作用于主内存的变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定</li>
<li>read(读取)：作用于主内存的变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用</li>
<li>load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中</li>
<li>use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎</li>
<li>assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量</li>
<li>store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作</li>
<li>write(写入)：作用于主内存中的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中</li>
</ol>
<p>现代计算机主要结构组成</p>
<p>​    把一个变量从主内存中复制到工作内存中，就需要按顺序地执行read和load操作，如果把变量从工作内存中同步到主内存中，就需要按顺序地执行store和write操作。<strong>但Java内存模型只要求上述8大操作(原子操作)必须按顺序执行，而没有保证必须是连续执行。</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210830181231664.png" alt="image-20210830181231664"></p>
<p>​    </p>
<h2 id="JMM内存同步规则"><a href="#JMM内存同步规则" class="headerlink" title="JMM内存同步规则"></a>JMM内存同步规则</h2><ol>
<li>不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中</li>
<li>一个新的<strong>变量只能在主内存中诞生</strong>，不允许在工作内存中直接使用一个未被初始化（load或者assign）的变量。即就是对一个变量实施use和store操作之前，必须先自行assign和load操作。</li>
<li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。<strong>lock和unlock必须成对出现</strong>。</li>
<li>如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量之前需要重新执行load或assign操作初始化变量的值。</li>
<li>如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）</li>
</ol>
<h1 id="volatile原理与内存语义"><a href="#volatile原理与内存语义" class="headerlink" title="volatile原理与内存语义"></a>volatile原理与内存语义</h1><p><strong>volatile是Java虚拟机提供的轻量级的同步机制</strong></p>
<p><strong>volatile语义</strong>有如下两个作用<br>    <strong>可见性</strong>：保证被volatile修饰的共享变量对所有线程总数可见的，也就是当一个线程修改了一个被volatile修饰共享变量的值，新值总是可以被其他线程立即得知。</p>
<p>​    <strong>有序性</strong>：禁止指令重排序优化(通过内存屏障)。</p>
<p><strong>volatile缓存可见性实现原理</strong></p>
<p>​    JMM内存交互层面：volatile修饰的变量的read、load、use操作和assign、store、write必须是连续的，即修改后必须立即同步会主内存，使用时必须从主内存刷新，由此保证volatile变量的可见性。</p>
<p>​    底层实现：通过汇编lock前缀指令，它会锁定变量缓存行区域并写回主内存，这个操作称为“缓存锁定”，缓存一致性机制会阻止同时修改被两个以上处理器缓存的内存区域数据。一个处理器的缓存回写到内存内存会导致其他处理器的缓存无效</p>
<p>​    汇编代码查看<br>-XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly -Xcomp</p>
<h1 id="可见性-amp-原子性-amp-有序性"><a href="#可见性-amp-原子性-amp-有序性" class="headerlink" title="可见性&amp;原子性&amp;有序性"></a>可见性&amp;原子性&amp;有序性</h1><p>并发编程三大特性</p>
<ul>
<li><p>可见性：当一个线程修改了某个共享变量的值，其他线程是否能够马上得知这个修改的值（高速缓存操作和指令重排会导致可见性丢失）</p>
</li>
<li><p>原子性：原子性指的是一个操作是不可中断的，即使是在多线程环境下，一个操作一旦开始就不会 </p>
<p>被其他线程影响。</p>
</li>
<li><p>有序性：<strong>Java允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行</strong>，却会影响到多线程并发执行的正确性。</p>
</li>
</ul>
<p>​    volatile保证可见性与有序性，但是不能保证原子性，要保证原子性需要借助synchronized、Lock锁机制，同理也能保证有序性与可见性。因为synchronized和Lock能够保证任一时刻只有一个线程访问该代码块。</p>
<h2 id="有序性-amp-指令重排"><a href="#有序性-amp-指令重排" class="headerlink" title="有序性&amp;指令重排"></a>有序性&amp;指令重排</h2><p>​    java语言规范规定JVM线程内部维持顺序化语义。单线程内保证串行语义执行的一致性:<strong>即只要程序的最终结果与它顺序化情况的结果相等，那么指令的执行顺序可以与代码顺序不一致，此过程叫指令的重排序</strong>。<br>​    指令重排序的意义：JVM能根据处理器特性（CPU多级缓存系统、多核处理器等）适当的对机器指令进行重排序，使机器指令能更符合CPU的执行特性，最大限度的发挥机器性能。可以理解为：只要不影响程序单线程、顺序执行的结果，就可以对两个指令重排序。<br>在<strong>编译器</strong>与<strong>CPU</strong>处理器中都能执行<strong>指令重排优化操作</strong></p>
<h2 id="JMM如何解决原子性-amp-可见性-amp-有序性问题"><a href="#JMM如何解决原子性-amp-可见性-amp-有序性问题" class="headerlink" title="JMM如何解决原子性&amp;可见性&amp;有序性问题"></a><strong>JMM如何解决原子性&amp;可见性&amp;有序性问题</strong></h2><h3 id="as-if-serial语义"><a href="#as-if-serial语义" class="headerlink" title="as-if-serial语义"></a><strong>as-if-serial语义</strong></h3><p>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编译器、runtime和处理器都必须遵守as-if-serial语义。<br>为了遵守as-if-serial语义，编译器和处理器不会对存在数据依赖关系的操作做重排序，因为这种重排序会改变执行结果。但是，如果操作之间不存在数据依赖关系，这些操作就可能被 编译器和处理器重排序。 </p>
<h3 id="happens-before-原则"><a href="#happens-before-原则" class="headerlink" title="happens-before 原则"></a>happens-before 原则</h3><p>从JDK 5开始，Java使用新的JSR-133内存模型，提供了 happens-before 原则来辅助保证程序执行的原子性、可见性以及有序性的问题，它是判断数据是否存在竞争、线程是否安全的依据，happens-before 原则内容如下 </p>
<p>1、程序顺序原则：即在一个线程内必须保证语义串行性，也就是说按照代码顺序执行。 </p>
<p>2、锁规则：解锁(unlock)操作必然发生在后续的同一个锁的加锁(lock)之前，也就是说， 如果对于一个锁解锁后，再加锁，那么加锁的动作必须在解锁动作之后(同一个锁)。 </p>
<p>3、volatile规则：volatile变量的写，先发生于读，这保证了volatile变量的可见性，简单的理解就是，volatile变量在每次被线程访问时，都强迫从主内存中读该变量的值，而当该变量发生变化时，又会强迫将最新的值刷新到主内存，任何时刻，不同的线程总是能够看到该变量的最新值。 </p>
<p>4、线程启动规则：线程的start()方法先于它的每一个动作，即如果线程A在执行线程B的start方法之前修改了共享变量的值，那么当线程B执行start方法时，线程A对共享变量的修改对线程B可见 </p>
<p>5、传递性：A先于B ，B先于C 那么A必然先于C </p>
<p>6、线程终止规则：线程的所有操作先于线程的终结，Thread.join()方法的作用是等待当前执行的线程终止。假设在线程B终止之前，修改了共享变量，线程A从线程B的join方法成功返回后，线程B对共享变量的修改将对线程A可见。 </p>
<p>7、 线程中断规则：对线程 interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过Thread.interrupted()方法检测线程是否中断。 </p>
<p>8、对象终结规则：对象的构造函数执行，结束先于finalize()方法 </p>
<h3 id="volatile保证可见性"><a href="#volatile保证可见性" class="headerlink" title="volatile保证可见性"></a><strong>volatile保证可见性</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileVisibilitySample</span> </span>&#123;<br>    <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> initFlag = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.initFlag = <span class="hljs-keyword">true</span>;<br>        String threadname = Thread.currentThread().getName();<br>        System.out.println(<span class="hljs-string">&quot;线程：&quot;</span>+threadname+<span class="hljs-string">&quot;:修改共享变量initFlag&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">load</span><span class="hljs-params">()</span></span>&#123;<br>        String threadname = Thread.currentThread().getName();<br>        <span class="hljs-keyword">while</span> (!initFlag)&#123;<br>            System.out.println(<span class="hljs-string">&quot;线程：&quot;</span>+threadname+<span class="hljs-string">&quot;当前线程还在跑空循环&quot;</span>);<br>            <span class="hljs-comment">//线程在此处空跑，等待initFlag状态改变</span><br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;线程：&quot;</span>+threadname+<span class="hljs-string">&quot;当前线程嗅探到initFlag的状 态的改变&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        VolatileVisibilitySample sample = <span class="hljs-keyword">new</span> VolatileVisibilitySample();<br>        Thread threadA = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; sample.save(); &#125;,<span class="hljs-string">&quot;threadA&quot;</span>);<br>        Thread threadB = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123; sample.load(); &#125;,<span class="hljs-string">&quot;threadB&quot;</span>);<br>        threadB.start();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        threadA.start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="volatile无法保证原子性"><a href="#volatile无法保证原子性" class="headerlink" title="volatile无法保证原子性"></a><strong>volatile无法保证原子性</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * volatile无法保证原子性</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileAtomicSample</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> counter = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>            Thread thread = <span class="hljs-keyword">new</span> Thread(()-&gt;&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">1000</span>; j++) &#123;<br>                    counter++; <span class="hljs-comment">//不是一个原子操作,第一轮循环结果是没有刷入主存，这一轮循环已经无效</span><br>                    <span class="hljs-comment">//1 load counter 到工作内存</span><br>                    <span class="hljs-comment">//2 add counter 执行自加</span><br>                    <span class="hljs-comment">//其他的代码段？</span><br>                &#125;<br>            &#125;);<br>            thread.start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br>        System.out.println(counter);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="volatile禁止重排优化"><a href="#volatile禁止重排优化" class="headerlink" title="volatile禁止重排优化"></a><strong>volatile禁止重排优化</strong></h3><p>案例一：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">VolatileReOrderSample</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b =<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (;;)&#123;<br>            i++;<br>            x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;<br>            a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>;<br>            Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span><br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">1000</span>));<br>                    a = <span class="hljs-number">1</span>; <span class="hljs-comment">//是读还是写？store，volatile写</span><br>                    <span class="hljs-comment">//storeload ,读写屏障，不允许volatile写与第二部volatile读发生重排</span><br>                    <span class="hljs-comment">//手动加内存屏障</span><br>                    <span class="hljs-comment">//UnsafeInstance.reflectGetUnsafe().storeFence();</span><br>                    x = b; <span class="hljs-comment">// 读还是写？读写都有，先读volatile，写普通变量</span><br>                    <span class="hljs-comment">//分两步进行，第一步先volatile读，第二步再普通写</span><br>                &#125;<br>            &#125;);<br>            Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">100</span>));<br>                    b = <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//UnsafeInstance.reflectGetUnsafe().storeFence();</span><br>                    y = a;<br>                &#125;<br>            &#125;);<br>            t1.start();<br>            t2.start();<br>            t1.join();<br>            t2.join();<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * cpu或者jit对我们的代码进行了指令重排？</span><br><span class="hljs-comment">             * 1,1</span><br><span class="hljs-comment">             * 0,1</span><br><span class="hljs-comment">             * 1,0</span><br><span class="hljs-comment">             * 0,0</span><br><span class="hljs-comment">             */</span><br>            String result = <span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次 (&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;）&quot;</span>;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>                System.err.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(result);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shortWait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> interval)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">long</span> end;<br>        <span class="hljs-keyword">do</span>&#123;<br>            end = System.nanoTime();<br>        &#125;<span class="hljs-keyword">while</span>(start + interval &gt;= end);<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>案例二：DCL 单例模式-双重检查</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DoubleCheckLock</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> DoubleCheckLock instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">DoubleCheckLock</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> DoubleCheckLock <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != instance)&#123;<br>            <span class="hljs-keyword">synchronized</span> (DoubleCheckLock.class)&#123;<br>                <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == instance)&#123;<br>                    instance = <span class="hljs-keyword">new</span> DoubleCheckLock();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>因为instance = new DoubleCheckLock();可以分为以下3步完成(伪代码) </p>
<p>memory = allocate();//1.分配对象内存空间 </p>
<p>instance(memory);//2.初始化对象 </p>
<p>instance = memory;//3.设置instance指向刚分配的内存地址，此时 </p>
<p>instance！=null </p>
<p>由于步骤2和步骤3间可能会重排序，如下： </p>
<p>memory=allocate();//1.分配对象内存空间 </p>
<p>instance=memory;//3.设置instance指向刚分配的内存地址，此时instance！ </p>
<p>=null，但是对象还没有初始化完成！ </p>
<p>instance(memory);//2.初始化对象 </p>
<p>由于步骤2和步骤3不存在数据依赖关系，而且无论重排前还是重排后程序的执行结果在单 </p>
<p>线程中并没有改变，因此这种重排优化是允许的。但是指令重排只会保证串行语义的执行的一 </p>
<p>致性(单线程)，但并不会关心多线程间的语义一致性。所以当一条线程访问instance不为null </p>
<p>时，由于instance实例未必已初始化完成，也就造成了线程安全问题。那么该如何解决呢，很 </p>
<p>简单，我们使用volatile禁止instance变量被执行指令重排优化即可。</p>
</blockquote>
<h3 id="内存屏障-Memory-Barrier）"><a href="#内存屏障-Memory-Barrier）" class="headerlink" title="内存屏障(Memory Barrier）"></a>内存屏障(Memory Barrier）</h3><blockquote>
<p>内存屏障，又称内存栅栏，是一个CPU指令，它的作用有两个，<strong>一是保证特定操作的执行</strong> </p>
<p><strong>顺序</strong>，<strong>二是保证某些变量的内存可见性（利用该特性实现volatile的内存可见性）</strong>。由于编译 </p>
<p>器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器 </p>
<p>和CPU，不管什么指令都不能和这条Memory Barrier指令重排序，也就是说通过插入内存屏 </p>
<p>障禁止在内存屏障前后的指令执行重排序优化。Memory Barrier的另外一个作用是强制刷出 </p>
<p>各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。总之， </p>
<p><strong>volatile变量正是通过内存屏障实现其在内存中的语义，即可见性和禁止重排优化</strong></p>
</blockquote>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20210831163732484.png" alt="image-20210831163732484"></p>
<p>为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来 禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数 几乎不可能。为此，JMM采取保守策略。<strong>下面是基于保守策略的JMM内存屏障插入策略：</strong> </p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障。 </li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障。 </li>
<li>在每个volatile读操作的后面插入一个LoadLoad屏障。 </li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
<p>先简单了解两个指令：</p>
<p>Store：将处理器缓存的数据刷新到内存中。</p>
<p>Load：将内存存储的数据拷贝到处理器的缓存中。</p>
<h4 id="JMM定义的内存屏障规范"><a href="#JMM定义的内存屏障规范" class="headerlink" title="JMM定义的内存屏障规范"></a>JMM定义的内存屏障规范</h4><blockquote>
<table>
<thead>
<tr>
<th align="left">屏障类型</th>
<th align="left">指令示例</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">LoadLoad Barriers</td>
<td align="left">Load1;LoadLoad;Load2</td>
<td align="left">该屏障确保Load1数据的装载先于Load2及其后所有装载指令的的操作</td>
</tr>
<tr>
<td align="left">StoreStore Barriers</td>
<td align="left">Store1;StoreStore;Store2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存(使其对其他处理器可见)的操作先于Store2及其后所有存储指令的操作</td>
</tr>
<tr>
<td align="left">LoadStore Barriers</td>
<td align="left">Load1;LoadStore;Store2</td>
<td align="left">确保Load1的数据装载先于Store2及其后所有的存储指令刷新数据到内存的操作</td>
</tr>
<tr>
<td align="left">StoreLoad Barriers</td>
<td align="left">Store1;StoreLoad;Load2</td>
<td align="left">该屏障确保Store1立刻刷新数据到内存的操作先于Load2及其后所有装载装载指令的操作。它会使该屏障之前的所有内存访问指令(存储指令和访问指令)完成之后,才执行该屏障之后的内存访问指令</td>
</tr>
</tbody></table>
</blockquote>
<p>StoreLoad Barriers同时具备其他三个屏障的效果，因此也称之为<code>全能屏障</code>（mfence），是目前大多数处理器所支持的；但是相对其他屏障，该屏障的开销相对昂贵。</p>
<h4 id="硬件级别和JVM底层对于内存屏障的实现"><a href="#硬件级别和JVM底层对于内存屏障的实现" class="headerlink" title="硬件级别和JVM底层对于内存屏障的实现"></a>硬件级别和JVM底层对于内存屏障的实现</h4><p><img src="images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B01JMM&volatile/image-20240403004036768.png" alt="image-20240403004036768"></p>
<p><strong>对于volatile写操作：</strong></p>
<ul>
<li>在写操作前，通常不需要特别的屏障，因为写屏障（Store Memory Barrier）是放在写操作之后的。</li>
<li>在写操作后，会插入一个<strong>写屏障</strong>（Store Barrier）。这个写屏障确保了所有在<code>volatile</code>写操作之前的写操作都已经被刷新到主内存，并且后续的读操作能够看到这个<code>volatile</code>写操作的结果。</li>
</ul>
<p><strong>对于volatile读操作：</strong></p>
<ul>
<li>在读操作前，会插入一个<strong>读屏障</strong>（Load Barrier）。这个读屏障确保了在<code>volatile</code>读操作执行时，能够从主内存读取最新的值，防止了从本地缓存或寄存器中读取旧值。</li>
<li>在读操作后，通常不需要特别的屏障，因为读屏障是放在读操作之前的。</li>
</ul>
<p>volatile关键字与CAS使用过多会产生什么问题？有没有听过总线风暴</p>
<p>1、Cpu工作内存与主内存存在大量交互，且大量的无效工作内存变量产生</p>
<p>嗅探机制</p>
<p>读内存、写内存</p>
<p>无效交互</p>
<p>无效变量产生</p>
<p>导致IO总线通道被大量无效占据，导致总线风暴</p>
<p>2、解决办法：适当使用synchronize关键字</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>JMM</tag>
        <tag>volatile</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程03AQS&amp;ReentrantLock</title>
    <url>/2021/10/26/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&amp;ReentrantLock/</url>
    <content><![CDATA[<h1 id="同步框架AQS"><a href="#同步框架AQS" class="headerlink" title="同步框架AQS"></a>同步框架AQS</h1><h2 id="并发之父"><a href="#并发之父" class="headerlink" title="并发之父"></a>并发之父</h2><p><em>Doug Lea</em>：生平不识<em>Doug Lea</em>，学懂并发也枉然</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221018090541555.png" alt="image-20221018090541555"></p>
<h2 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h2><p>​    Java并发编程核心在于java.util.concurrent包而juc当中的大多数同步器实现都是围绕着共同的基础行为，比如等待队列、条件队列、独占获取、共享获取等，而这个行为的抽象就是基于AbstractQueuedSynchronizer简称AQS，<strong>AQS定义了一套多线程访问共享资源的同步器框架，是一个依赖状态(state)的同步器</strong>。</p>
<p>AQS具备特性</p>
<ol>
<li>阻塞等待队列</li>
<li>共享/独占</li>
<li>公平/非公平</li>
<li>可重入</li>
<li>可中断</li>
</ol>
<p>  例如Java.concurrent.util当中同步器的实现如Lock,Latch,Barrier等，都是基 于AQS框架实现，一般通过定义内部类Sync继承AQS将同步器所有调用都映射到Sync对应的方法 AQS内部维护属性volatile int state (32位) state表示资源的可用状态 </p>
<p><strong>State三种访问方式</strong> </p>
<p>​    getState()、setState()、compareAndSetState() </p>
<p><strong>AQS定义两种资源共享方式</strong> </p>
<p>​    Exclusive-独占，只有一个线程能执行，如ReentrantLock </p>
<p>​    Share-共享，多个线程可以同时执行，如Semaphore/CountDownLatch </p>
<p><strong>AQS定义两种队列</strong> </p>
<p>​    同步等待队列 </p>
<p>​    条件等待队列 </p>
<p>​    不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源state的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS已经在顶层实现好了。自定义同步器 实现时主要实现以下几种方法： </p>
<p>​    **isHeldExclusively()**：该线程是否正在独占资源。只有用到 condition才需要去实现它。 </p>
<p>​    **tryAcquire(int)**：独占方式。尝试获取资源，成功则返回true，失败则返回false。 </p>
<p>​    **tryRelease(int)**：独占方式。尝试释放资源，成功则返回true，失败则返回false。 </p>
<p>​    **tryAcquireShared(int)**：共享方式。尝试获取资源。负数表示失败； 0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。 </p>
<p>​    **tryReleaseShared(int)**：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</p>
<p><strong>同步等待队列</strong> </p>
<p>​    AQS当中的同步等待队列也称CLH队列，CLH队列是Craig、Landin、Hagersten三人发明的一种基于双向链表数据结构的队列，是FIFO先入先出线程等待队列，<strong>Java中的CLH队列是原CLH队列的一个变种,线程由原自旋机制改为阻塞机制。</strong> </p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20211026231223938.png" alt="image-20211026231223938"></p>
<p><strong>条件等待队列</strong> </p>
<p>​    Condition是一个多线程间协调通信的工具类，使得某个，或者某些线程一 起等待某个条件（Condition）,只有当该条件具备时，这些等待线程才会被唤醒，从而重新争夺锁</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20211026231300145.png" alt="image-20211026231300145"></p>
<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><p>​    <strong>如果Node在条件队列当中，Node必须是独占模式</strong></p>
<h3 id="AQS结构"><a href="#AQS结构" class="headerlink" title="AQS结构"></a>AQS结构</h3><p>详细结构解析查看：<a href="https://www.bilibili.com/video/BV12K411G7Fg">https://www.bilibili.com/video/BV12K411G7Fg</a></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/AbstractQueuedSynchronizer.png" alt="AbstractQueuedSynchronizer"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20211026231827654.png" alt="image-20211026231827654"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractQueuedSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractOwnableSynchronizer</span></span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指向同步等待队列的头节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 指向同步等待队列的尾节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 同步资源状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> state;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 给各自子类实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *默认实现，且不允许子类修改</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">acquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg) &amp;&amp;<br>                acquireQueued(addWaiter(Node.EXCLUSIVE), arg))<br>            selfInterrupt();<br>    &#125;<br>    <br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 已经在队列当中的Thread节点，准备阻塞等待获取锁</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">acquireQueued</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Node node, <span class="hljs-keyword">int</span> arg)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> failed = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">boolean</span> interrupted = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<span class="hljs-comment">//死循环</span><br>                <span class="hljs-keyword">final</span> Node p = node.predecessor();<span class="hljs-comment">//找到当前结点的前驱结点</span><br>                <span class="hljs-keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;<span class="hljs-comment">//如果前驱结点是头结点，才tryAcquire，其他结点是没有机会tryAcquire的。</span><br>                    setHead(node);<span class="hljs-comment">//获取同步状态成功，将当前结点设置为头结点。</span><br>                    p.next = <span class="hljs-keyword">null</span>; <span class="hljs-comment">// help GC</span><br>                    failed = <span class="hljs-keyword">false</span>;<br>                    <span class="hljs-keyword">return</span> interrupted;<br>                &#125;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 如果前驱节点不是Head，通过shouldParkAfterFailedAcquire判断是否应该阻塞</span><br><span class="hljs-comment">                 * 前驱节点信号量为-1，当前线程可以安全被parkAndCheckInterrupt用来阻塞线程</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;<br>                        parkAndCheckInterrupt())<br>                    interrupted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (failed)<br>                cancelAcquire(node);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">shouldParkAfterFailedAcquire</span><span class="hljs-params">(Node pred, Node node)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> ws = pred.waitStatus;<br>        <span class="hljs-keyword">if</span> (ws == Node.SIGNAL)<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 若前驱结点的状态是SIGNAL，意味着当前结点可以被安全地park</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">if</span> (ws &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 前驱节点状态如果被取消状态，将被移除出队列</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                node.prev = pred = pred.prev;<br>            &#125; <span class="hljs-keyword">while</span> (pred.waitStatus &gt; <span class="hljs-number">0</span>);<br>            pred.next = node;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             * 当前驱节点waitStatus为 0 or PROPAGATE状态时</span><br><span class="hljs-comment">             * 将其设置为SIGNAL状态，然后当前结点才可以可以被安全地park</span><br><span class="hljs-comment">             */</span><br>            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addWaiter</span><span class="hljs-params">(Node mode)</span> </span>&#123;<br>        <span class="hljs-comment">// 1. 将当前线程构建成Node类型</span><br>        Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), mode);<br>        <span class="hljs-comment">// Try the fast path of enq; backup to full enq on failure</span><br>        Node pred = tail;<br>        <span class="hljs-comment">// 2. 1当前尾节点是否为null？</span><br>        <span class="hljs-keyword">if</span> (pred != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-comment">// 2.2 将当前节点尾插入的方式</span><br>            node.prev = pred;<br>            <span class="hljs-comment">// 2.3 CAS将节点插入同步队列的尾部</span><br>            <span class="hljs-keyword">if</span> (compareAndSetTail(pred, node)) &#123;<br>                pred.next = node;<br>                <span class="hljs-keyword">return</span> node;<br>            &#125;<br>        &#125;<br>        enq(node);<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">AQS的静态内部类<br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>&#123;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 标记节点未共享模式</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node SHARED = <span class="hljs-keyword">new</span> Node();<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  标记节点为独占模式</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Node EXCLUSIVE = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 在同步队列中等待的线程等待超时或者被中断，需要从同步队列中取消等待</span><br><span class="hljs-comment">         * */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CANCELLED =  <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  后继节点的线程处于等待状态，而当前的节点如果释放了同步状态或者被取消，</span><br><span class="hljs-comment">         *  将会通知后继节点，使后继节点的线程得以运行。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SIGNAL    = -<span class="hljs-number">1</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  节点在等待队列中，节点的线程等待在Condition上，当其他线程对Condition调用了signal()方法后，</span><br><span class="hljs-comment">         *  该节点会从等待队列中转移到同步队列中，加入到同步状态的获取中</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CONDITION = -<span class="hljs-number">2</span>;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 表示下一次共享式同步状态获取将会被无条件地传播下去</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> PROPAGATE = -<span class="hljs-number">3</span>;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 标记当前节点的信号量状态 (1,0,-1,-2,-3)5种状态</span><br><span class="hljs-comment">         * 使用CAS更改状态，volatile保证线程可见性，高并发场景下，</span><br><span class="hljs-comment">         * 即被一个线程修改后，状态会立马让其他线程可见。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> waitStatus;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 前驱节点，当前节点加入到同步队列中被设置</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> Node prev;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 后继节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> Node next;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 节点同步状态的线程</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">volatile</span> Thread thread;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 等待队列中的后继节点，如果当前节点是共享的，那么这个字段是一个SHARED常量，</span><br><span class="hljs-comment">         * 也就是说节点类型(独占和共享)和等待队列中的后继节点共用同一个字段。</span><br><span class="hljs-comment">         */</span><br>        Node nextWaiter;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Returns true if node is waiting in shared mode.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShared</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> nextWaiter == SHARED;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 返回前驱节点</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> Node <span class="hljs-title">predecessor</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> NullPointerException </span>&#123;<br>            Node p = prev;<br>            <span class="hljs-keyword">if</span> (p == <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>            <span class="hljs-keyword">else</span><br>                <span class="hljs-keyword">return</span> p;<br>        &#125;<br><br>        Node() &#123;    <span class="hljs-comment">// Used to establish initial head or SHARED marker</span><br>        &#125;<br><br>        Node(Thread thread, Node mode) &#123;     <span class="hljs-comment">// Used by addWaiter</span><br>            <span class="hljs-keyword">this</span>.nextWaiter = mode;<br>            <span class="hljs-keyword">this</span>.thread = thread;<br>        &#125;<br><br>        Node(Thread thread, <span class="hljs-keyword">int</span> waitStatus) &#123; <span class="hljs-comment">// Used by Condition</span><br>            <span class="hljs-keyword">this</span>.waitStatus = waitStatus;<br>            <span class="hljs-keyword">this</span>.thread = thread;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="acquire的过程"><a href="#acquire的过程" class="headerlink" title="acquire的过程"></a>acquire的过程</h3><ol>
<li>tryAcquire尝试获取锁<ol>
<li>尝试失败，入队等待队列</li>
<li>入队后循环尝试获取锁<ol>
<li>判断该节前驱结点为头结点，tryacquire</li>
<li>判断是否要阻塞该线程<ol>
<li>判断是否要阻塞<ol>
<li>前驱结点是就绪状态，说明前置结点也只等待拿锁，则本节点可以阻塞 返回true</li>
<li>前驱结点状态&gt;0是取消，则递归移除前驱结点 返回false</li>
<li>否则设置该节点的前置结点为signal就绪状态 返回false</li>
</ol>
</li>
<li>根据第一点结果是否阻塞阻塞<ol>
<li>阻塞</li>
<li>不阻塞，从新回到循环  2.判断是否要阻塞该线程</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="release的过程"><a href="#release的过程" class="headerlink" title="release的过程"></a>release的过程</h3><ol>
<li>tryRelease<ol>
<li>释放成功 返回true<ol>
<li>如果头节点不为空且状态不=0<ol>
<li>将等待状态waitStatus设置为初始值0</li>
<li>后继结点为空，或状态为CANCEL（已失效），则从后尾部往前遍历找到最前的一个处于正常阻塞状态的结点进行唤醒</li>
<li>唤醒查到的节点</li>
</ol>
</li>
</ol>
</li>
<li>失败，返回false</li>
</ol>
</li>
</ol>
<p>ReentrantLock的特点</p>
<p>1、是独占锁</p>
<p>2、同步等待队列的Node是通过魔术类UnSafe.park()/unPark（） 方法来实现阻塞和唤醒</p>
<h3 id="state字段"><a href="#state字段" class="headerlink" title="state字段"></a>state字段</h3><p>​    state是一个非常重要的组成部分，它是一个volatile修饰的变量，用来记录同步状态的值。这个state的含义并不是一成不变的，它会根据具体实现类的作用不同而表示不同的含义。例如，在Semaphore信号量中，state表示的是剩余许可证的数量；在ReentrantLock中，state用来标记是否有线程占有锁以及重入的次数；在CountDownLatch中，state用来标记占有锁的线程个数。因此，state的具体含义完全取决于用户如何使用AQS。</p>
<p>​    另外，AQS提供了compareAndSetState()方法用于修改state的值，这是一个原子操作，保证了在多线程环境下的安全性。</p>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p><strong>1、唤醒操作为啥 不从head开始向后遍历，而是从尾节点开始向前遍历</strong></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221026231349547.png" alt="image-20221026231349547"></p>
<p>入队操作时：enq()方法</p>
<p>if条件内的代码并不是原子的，线程A通过CAS进入if语句块之后，发生上下文切换，此时线程B同样执行了该方法，并且执行完毕。然后线程C调用了<code>unparkSuccessor</code>方法。就可能造成遍历到node2后，没有后续节点了，但是tail节点 ！= node2，从尾部向前遍历则不存在这个问题</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221026231638666.png" alt="image-20221026231638666"></p>
<p><strong>2、parkAndCheckInterupt()方法返回return Thread.interrupterd()是什么意思？</strong></p>
<p>Thread.interrupterd()该方法用于检测线程是否中断，以及清除中断标志位。当第二次调用这个方法的时候就会返回false。</p>
<p>1、当前线程处于等待队列中（并且处于挂起中时）时无法响应外部的中断请求，因为unsafe.park()操作导致阻塞的线程遇到中断时不像wait()，sleep()遇到中断时一样，即可抛出中断异常，而是修改线程的中断标志位。</p>
<p>2、只有当该线程拿到锁后，通过获取判断该标志位才能响应中断请求</p>
<p><strong>3、Thread中Thread.interrupted()和this.isInterrupted()方法的区别</strong></p>
<table>
<thead>
<tr>
<th></th>
<th>Thread.interrupted()</th>
<th>this.isInterrupted()</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>静态方法，作用于当前线程</td>
<td>成员方法，作用于Thread实例</td>
</tr>
<tr>
<td>2</td>
<td>返回中断状态同时清除了状态位状态</td>
<td>只返回中断状态</td>
</tr>
</tbody></table>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221030201335028.png" alt="image-20221030201335028"></p>
<h1 id="ReenTrantLock"><a href="#ReenTrantLock" class="headerlink" title="ReenTrantLock"></a>ReenTrantLock</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>ReentrantLock，直译可重入锁，基于AQS，它实现了<strong>公平锁与非公平锁，可重入</strong>，在开发中可以使用它对资源进行同步操作。</p>
<p>与Synchronized（基于对象锁Monitor）的区别是它基于<strong>CAS算法</strong>，无需锁住同步资源（这里指对象锁）属于乐观锁。</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/%E5%9B%BE%E7%89%87.png" alt="图片"></p>
<p><strong>继承结构</strong></p>
<img src="/images/并发编程03AQS&ReentrantLock/ReentrantLock.png" alt="ReentrantLock" style="zoom: 50%;">

<h3 id="Lock接口"><a href="#Lock接口" class="headerlink" title="Lock接口"></a>Lock接口</h3><p>ReentrantLock继承了Lock，继承以下方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取锁</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//获取锁，区别在于如果当前线程在等待锁的过程中被中断，则退出等待，抛出中断异常</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lockInterruptibly</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><span class="hljs-comment">//尝试获取锁，成功与否都立即返回，不等待，获取成功返回true，失败返回false</span><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//尝试获取锁,失败则等待，设置最多等待时长，超时后，返回false</span><br>   <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">(<span class="hljs-keyword">long</span> time, TimeUnit unit)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>;<br><span class="hljs-comment">//释放锁</span><br>   <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br><span class="hljs-comment">//新建一个绑定在当前lock对象上的condition对象</span><br><span class="hljs-comment">//TIPS∶Condition对象是什么?简单来说，它表示一个条件，不同线程可以通过该条件来进行通信。比如某线程可以通过 await 方法注册在condition对象上进行等待，然后通过condition对象的signal方法将该线程唤醒。这有点类似Object锁的wait和notify方法。但不同的是，一个Lock对象可以关联多个Condition对象，多个线程可以被绑定在不同的Condition对象上，这样就可以分组等待,唤醒。此外，Condition对象还提供了和限时、中断相关的功能，丰富了线程的调度策略。</span><br>   <span class="hljs-function">Condition <span class="hljs-title">newCondition</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure>

<h2 id="Sync内部类"><a href="#Sync内部类" class="headerlink" title="Sync内部类"></a>Sync内部类</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Sync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractQueuedSynchronizer</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">5179523762034025860L</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">nonfairTryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>            <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>            <span class="hljs-keyword">int</span> c = getState();<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                    setExclusiveOwnerThread(current);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>                <span class="hljs-keyword">int</span> nextc = c + acquires;<br>                <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>) <span class="hljs-comment">// overflow</span><br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>                setState(nextc);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryRelease</span><span class="hljs-params">(<span class="hljs-keyword">int</span> releases)</span> </span>&#123;<br>            <span class="hljs-keyword">int</span> c = getState() - releases;<br>            <span class="hljs-keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalMonitorStateException();<br>            <span class="hljs-keyword">boolean</span> free = <span class="hljs-keyword">false</span>;<br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>                free = <span class="hljs-keyword">true</span>;<br>                setExclusiveOwnerThread(<span class="hljs-keyword">null</span>);<br>            &#125;<br>            setState(c);<br>            <span class="hljs-keyword">return</span> free;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isHeldExclusively</span><span class="hljs-params">()</span> </span>&#123;          <br>            <span class="hljs-keyword">return</span> getExclusiveOwnerThread() == Thread.currentThread();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> ConditionObject <span class="hljs-title">newCondition</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ConditionObject();<br>        &#125;<br>    <br>        <span class="hljs-function"><span class="hljs-keyword">final</span> Thread <span class="hljs-title">getOwner</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState() == <span class="hljs-number">0</span> ? <span class="hljs-keyword">null</span> : getExclusiveOwnerThread();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getHoldCount</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> isHeldExclusively() ? getState() : <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLocked</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> getState() != <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">readObject</span><span class="hljs-params">(java.io.ObjectInputStream s)</span></span><br><span class="hljs-function">            <span class="hljs-keyword">throws</span> java.io.IOException, ClassNotFoundException </span>&#123;<br>            s.defaultReadObject();<br>            setState(<span class="hljs-number">0</span>); <span class="hljs-comment">// reset to unlocked state</span><br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="NonfairSync-与-FairSync"><a href="#NonfairSync-与-FairSync" class="headerlink" title="NonfairSync 与 FairSync"></a>NonfairSync 与 FairSync</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NonfairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">7316153563782823691L</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//第一次尝试插队</span><br>        <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>))<br>            setExclusiveOwnerThread(Thread.currentThread());<br>        <span class="hljs-keyword">else</span><br>            <span class="hljs-comment">//内部调用AQS的，会先尝试tryAcquire,第二次尝试插队</span><br>            acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> nonfairTryAcquire(acquires);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Sync object for fair locks</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FairSync</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Sync</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = -<span class="hljs-number">3000897897090466540L</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        acquire(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> acquires)</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> Thread current = Thread.currentThread();<br>        <span class="hljs-keyword">int</span> c = getState();<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;<br>                compareAndSetState(<span class="hljs-number">0</span>, acquires)) &#123;<br>                setExclusiveOwnerThread(current);<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (current == getExclusiveOwnerThread()) &#123;<br>            <span class="hljs-keyword">int</span> nextc = c + acquires;<br>            <span class="hljs-keyword">if</span> (nextc &lt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&quot;Maximum lock count exceeded&quot;</span>);<br>            setState(nextc);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="公平与非公平"><a href="#公平与非公平" class="headerlink" title="公平与非公平"></a>公平与非公平</h2><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221030200540053.png" alt="image-20221030200540053"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221030200550275.png" alt="image-20221030200550275"></p>
<p>无论定义为公平锁还是非公平锁，<strong>tryLock</strong>都是非公平的，都会尝试插队，这也是nonfairTryAcquire方法定义在Sync类的原因。</p>
<p>但是lock()就如同上边所说，他们的过程如下</p>
<h3 id="FairSync-lock"><a href="#FairSync-lock" class="headerlink" title="FairSync.lock()"></a>FairSync.lock()</h3><p>1、lock() -&gt; accquire(1)</p>
<p>2、tryAcquire(1) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), 1)</p>
<p>3、tryAcquire(arg)：<strong>如果state=0 且队列中无等节点</strong>，CAS获取锁，否则正常排队</p>
<h3 id="NonFairSync-lock"><a href="#NonFairSync-lock" class="headerlink" title="NonFairSync.lock()"></a>NonFairSync.lock()</h3><p>1、compareAndSetState(0, 1)<strong>第一次先尝试插队</strong></p>
<p>2、否则 acquire(1)，tryAcquire(1) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)</p>
<p>3、tryAcquire(1) -&gt; nonfairTryAcquire(1) -&gt; <strong>如果state=0,不管队列中有无等待节点</strong>，CAS获取锁</p>
<p>4、获取失败再和公平锁一样乖乖排队</p>
<h2 id="可重入与不可重入"><a href="#可重入与不可重入" class="headerlink" title="可重入与不可重入"></a>可重入与不可重入</h2><p>可重入：即获取锁时，如果当前线程已经是锁的持有者，允许当前线程再进入锁，state累加1</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221030200921906.png" alt="image-20221030200921906"></p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B03AQS&ReentrantLock/image-20221030200930372.png" alt="image-20221030200930372"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS&amp;ReentrantLock</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程05-Atomic&amp;Unsafe魔法类详解</title>
    <url>/2021/11/02/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05-Atomic&amp;Unsafe%E9%AD%94%E6%B3%95%E7%B1%BB%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Atomic-amp-Unsafe魔法类详解"><a href="#Atomic-amp-Unsafe魔法类详解" class="headerlink" title="Atomic&amp;Unsafe魔法类详解"></a>Atomic&amp;Unsafe魔法类详解</h1><h2 id="什么是原子操作？"><a href="#什么是原子操作？" class="headerlink" title="什么是原子操作？"></a>什么是原子操作？</h2><p>​    原子（atom）本意是“不能被进一步分割的最小粒子”，而<strong>原子操作（atomic operation）意为”不可被中断的一个或一系列操作</strong>” 。</p>
<p><strong>相关术语</strong></p>
<table>
<thead>
<tr>
<th><strong>术语名称</strong></th>
<th><strong>英文</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>缓存行</td>
<td>Cache line</td>
<td>缓存的最小操作单位</td>
</tr>
<tr>
<td>比较并交换</td>
<td>Compare and Swap</td>
<td>CAS操作需要输入两个数值，一个旧值（期望操作前的值）和一个新值，在操作期间先<strong>比较</strong>下在旧值有没有发生变化，如果没有发生变化，才<strong>交换</strong>成新值，发生了变化则不交换。</td>
</tr>
<tr>
<td>CPU流水线</td>
<td>CPU pipeline</td>
<td>CPU流水线的工作方式就象工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条X86指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运算速度。</td>
</tr>
<tr>
<td>内存顺序冲突</td>
<td><strong>Memory order violation</strong></td>
<td>内存顺序冲突一般是由假共享引起，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</td>
</tr>
</tbody></table>
<h2 id="多CPU原子操作的实现方式"><a href="#多CPU原子操作的实现方式" class="headerlink" title="多CPU原子操作的实现方式"></a>多CPU原子操作的实现方式</h2><p>​    <strong>前提</strong>：<strong>处理器自动保证基本内存操作的原子性</strong>，处理器保证从系统内存中读取或者写入一个字节是原子的，意思是当一个处理器读取一个字节时，其他处理器不能访问这个字节的内存地址。Pentium6和最新的处理器能自动保证单处理器对同一个缓存行里进行16/32/64位的操作时原子的，但是复杂的内存操作处理器是不能自动保证其原子性的，比如跨总线宽度、跨多个缓存行和跨页表的访问。但是，处理器提供<strong>总线锁定</strong>和<strong>缓存锁定</strong>两个机制来保证复杂内存操作的原子性。</p>
<p>​    <strong>实现：2种加锁机制</strong></p>
<p>1、缓存行加锁（基于缓存加锁，基于MESI协议）<br>2、总线加锁（锁住cpu和内存之间的通信）</p>
<p>缓存行加锁失效的场景：</p>
<p>1、CPU不支持缓存锁定</p>
<p>2、缓存数据过大，一个缓存行放不下</p>
<h2 id="JAVA原子操作的实现"><a href="#JAVA原子操作的实现" class="headerlink" title="JAVA原子操作的实现"></a>JAVA原子操作的实现</h2><p>​    1、锁（对象锁）<br>​    2、CAS操作（利用处理器提供的指令实现原子操作，x86架构:<strong>CMPXCHG</strong>，ARM：<strong>LL/SC</strong>）。</p>
<h2 id="Atomic"><a href="#Atomic" class="headerlink" title="Atomic"></a>Atomic</h2><p>​    在Atomic包里一共有12个类，四种原子更新方式，分别是原子更新基本类型，原子更新数组，原子更新引用和原子更新字段。Atomic包里的类基本都是使用Unsafe实现的包装类</p>
<p><strong>基本类：</strong>AtomicInteger、AtomicLong、AtomicBoolean；</p>
<p><strong>引用类型：</strong>AtomicReference、AtomicReference的ABA实例、 AtomicStampedRerence、AtomicMarkableReference； </p>
<p><strong>数组类型：</strong>AtomicIntegerArray、AtomicLongArray、AtomicReferenceArray </p>
<p><strong>属性原子修改器（Updater）</strong>：AtomicIntegerFieldUpdater、 AtomicLongFieldUpdater、AtomicReferenceFieldUpdater </p>
<p><strong>1、原子更新基本类型类</strong> </p>
<p>用于通过原子的方式更新基本类型，Atomic包提供了以下三个类： </p>
<ul>
<li>AtomicBoolean：原子更新布尔类型。 </li>
<li>AtomicInteger：原子更新整型。 </li>
<li>AtomicLong：原子更新长整型。 </li>
</ul>
<p>AtomicInteger的常用方法如下： </p>
<ul>
<li>int addAndGet(int delta) ：以原子方式将输入的数值与实例中的值 （AtomicInteger里的value）相加，并返回结果 </li>
<li>boolean compareAndSet(int expect, int update) ：如果输入的数值等于预期值，则以原子方式将该值设置为输入的值。 </li>
<li>int getAndIncrement()：以原子方式将当前值加1，注意：这里返回的是自增前的值。</li>
<li>void lazySet(int newValue)：最终会设置成newValue，使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 </li>
<li>int getAndSet(int newValue)：以原子方式设置为newValue的值，并返回旧值。 </li>
</ul>
<p>Atomic包提供了三种基本类型的原子更新，但是Java的基本类型里还有char，float和double等。那么问题来了，如何原子的更新其他的基本类型呢？Atomic包里的类基本都是使用Unsafe实现的，Unsafe只提供了三种CAS方法，compareAndSwapObject， compareAndSwapInt和compareAndSwapLong，再看AtomicBoolean源码，发现其是先把Boolean转换成整型，再使用compareAndSwapInt进行CAS，所以原子更新double也可以用类似的思路来实现。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i&lt;<span class="hljs-number">10</span>; i++)&#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>                    atomicInteger.incrementAndGet();<br>                &#125;<br>            &#125;).start();<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;自加10次数值：---&gt;&quot;</span>+atomicInteger.get());<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、原子更新数组类</strong></p>
<p>通过原子的方式更新数组里的某个元素，Atomic包提供了以下三个类： </p>
<p>​    AtomicIntegerArray：原子更新整型数组里的元素。</p>
<p>​    AtomicLongArray：原子更新长整型数组里的元素。 </p>
<p>​    AtomicReferenceArray：原子更新引用类型数组里的元素。 </p>
<p>AtomicIntegerArray类主要是提供原子的方式更新数组里的整型，其常用方法如下 </p>
<p>​    int addAndGet(int i, int delta)：</p>
<p>​    以原子方式将输入值与数组中索引i的元素相加。</p>
<p>​    boolean compareAndSet(int i, int expect, int update)：</p>
<p>​    如果当前值等于预期值，则以原子方式将数组位置i的元素设置成update值。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicIntegerArrayTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span>[] value = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>&#125;;<br>    <span class="hljs-keyword">static</span> AtomicIntegerArray aiArray = <span class="hljs-keyword">new</span> AtomicIntegerArray(value);<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        aiArray.getAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>);<br>        <span class="hljs-keyword">if</span>(!aiArray.compareAndSet(<span class="hljs-number">0</span>,<span class="hljs-number">3</span>,<span class="hljs-number">5</span>))&#123;<br>            System.out.println(<span class="hljs-string">&quot;更新失败&quot;</span>);<br>        &#125;<br>        System.out.println(aiArray.get(<span class="hljs-number">0</span>));<br>        System.out.println(value[<span class="hljs-number">0</span>]);<br>        <span class="hljs-keyword">if</span>(aiArray.get(<span class="hljs-number">0</span>) != value[<span class="hljs-number">0</span>])&#123;<br>            System.out.println(<span class="hljs-string">&quot;不相等&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br>不相等<br></code></pre></td></tr></table></figure>

<p><strong>3、原子更新引用类型</strong> </p>
<p>​    原子更新基本类型的AtomicInteger，只能更新一个变量，如果要原子的更新多个变 </p>
<p>量，就需要使用这个原子更新引用类型提供的类。Atomic包提供了以下三个类： </p>
<p>​    AtomicReference：原子更新引用类型。 </p>
<p>​    AtomicReferenceFieldUpdater：原子更新引用类型里的字段。 </p>
<p>​    AtomicMarkableReference：原子更新带有标记位的引用类型。可以原子的更新一个布尔类型的标记位和引用类型。构造方法是AtomicMarkableReference(VinitialRef, boolean initialMark) </p>
<p><strong>4、原子更新字段类</strong> </p>
<p>如果我们只需要某个类里的某个字段，那么就需要使用原子更新字段类，Atomic包提供了以下三个类： </p>
<p>​    AtomicIntegerFieldUpdater：原子更新整型的字段的更新器。 </p>
<p>​    AtomicLongFieldUpdater：原子更新长整型字段的更新器。 </p>
<p>​    AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值 </p>
<p>与引用关联起来，可用于原子的更数据和数据的版本号，可以解决使用CAS进行原子更新时，可能出现的ABA问题。 原子更新字段类都是抽象类，每次使用都时候必须使用静态方法newUpdater创建一个 </p>
<p>更新器。原子更新类的字段的必须使用public volatile修饰符</p>
<h4 id="5、AtomicInteger存在ABA问题"><a href="#5、AtomicInteger存在ABA问题" class="headerlink" title="5、AtomicInteger存在ABA问题"></a>5、AtomicInteger存在ABA问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicAbaProblemTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">1</span>);<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Thread main = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> a = atomicInteger.get();<br>                System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--修改前操作数值:&quot;</span>+a);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    Thread.sleep(<span class="hljs-number">1000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>                <span class="hljs-keyword">boolean</span> isCasSuccess = atomicInteger.compareAndSet(a,<span class="hljs-number">2</span>);<br>                <span class="hljs-keyword">if</span>(isCasSuccess)&#123;<br>                    System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--Cas修改后操作数值:&quot;</span>+atomicInteger.get());<br>                &#125;<span class="hljs-keyword">else</span>&#123;<br>                    System.out.println(<span class="hljs-string">&quot;CAS修改失败&quot;</span>);<br>                &#125;<br><br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;主线程&quot;</span>);<br><br>        Thread other = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                atomicInteger.incrementAndGet();<span class="hljs-comment">// 1+1 = 2;</span><br>                System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--increase后值:&quot;</span>+atomicInteger.get());<br>                atomicInteger.decrementAndGet();<span class="hljs-comment">// atomic-1 = 2-1;</span><br>                System.out.println(<span class="hljs-string">&quot;操作线程&quot;</span>+Thread.currentThread().getName()+<span class="hljs-string">&quot;--decrease后值:&quot;</span>+atomicInteger.get());<br>            &#125;<br>        &#125;,<span class="hljs-string">&quot;干扰线程&quot;</span>);<br><br>        main.start();<br>        other.start();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="自定义原子更新字段类"><a href="#自定义原子更新字段类" class="headerlink" title="自定义原子更新字段类"></a>自定义原子更新字段类</h4><p>利用Unsafe类 + 字段偏移量定位应用类型</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AtomicStudentAgeUpdater</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name ;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> age;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe unsafe = UnsafeInstance.reflectGetUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> valueOffset;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            valueOffset = unsafe.objectFieldOffset(AtomicStudentAgeUpdater.class.getDeclaredField(<span class="hljs-string">&quot;age&quot;</span>));<br>            System.out.println(<span class="hljs-string">&quot;valueOffset:---&gt;&quot;</span>+valueOffset);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(e);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">compareAndSwapAge</span><span class="hljs-params">(<span class="hljs-keyword">int</span> old,<span class="hljs-keyword">int</span> target)</span></span>&#123;<br>        unsafe.compareAndSwapInt(<span class="hljs-keyword">this</span>,valueOffset,old,target);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AtomicStudentAgeUpdater</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> age)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.age = age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAge</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.age;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AtomicStudentAgeUpdater updater = <span class="hljs-keyword">new</span> AtomicStudentAgeUpdater(<span class="hljs-string">&quot;杨过&quot;</span>,<span class="hljs-number">18</span>);<br>        updater.compareAndSwapAge(<span class="hljs-number">18</span>,<span class="hljs-number">56</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;真实的杨过年龄---&quot;</span>+updater.getAge());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="Unsafe魔法类"><a href="#Unsafe魔法类" class="headerlink" title="Unsafe魔法类"></a>Unsafe魔法类</h2><p>​    Unsafe是位于sun.misc包下的一个类，主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。<br>​    Unsafe类为一单例实现，提供静态方法getUnsafe获取Unsafe实例，当且仅当调用getUnsafe方法的类为引导类加载器所加载时才合法，否则抛出SecurityException异常</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Unsafe</span> </span>&#123; <br>    <span class="hljs-comment">// 单例对象 </span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Unsafe theUnsafe;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Unsafe</span><span class="hljs-params">()</span> </span>&#123; &#125;<br>    <span class="hljs-meta">@CallerSensitive</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">getUnsafe</span><span class="hljs-params">()</span> </span>&#123; <br>        Class var0 = Reflection.getCallerClass(); <br>            <span class="hljs-comment">// 仅在引导类加载器`BootstrapClassLoader`加载时才合法 </span><br>        <span class="hljs-keyword">if</span>(!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; <br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SecurityException(<span class="hljs-string">&quot;Unsafe&quot;</span>); <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-keyword">return</span> theUnsafe; <br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="获取Unsafe实例"><a href="#获取Unsafe实例" class="headerlink" title="获取Unsafe实例"></a>获取Unsafe实例</h3><p>1、把调用Unsafe相关方法的类Demo所在jar包路径追加到默认的bootstrap路径中，使得A被引导类加载器加载<br>    java -Xbootclasspath/Demo:${path} // 其中path为调用Unsafe相关方法的类所在jar包路径<br>2、通过反射获取单例对象theUnsafe</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UnsafeInstance</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Unsafe <span class="hljs-title">reflectGetUnsafe</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Field field = Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>            field.setAccessible(<span class="hljs-keyword">true</span>);<br>            <span class="hljs-keyword">return</span> (Unsafe) field.get(<span class="hljs-keyword">null</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="Unsafe功能介绍"><a href="#Unsafe功能介绍" class="headerlink" title="Unsafe功能介绍"></a>Unsafe功能介绍</h3><p>Unsafe可以绕过JVM做一些操作，所以称之为魔法类。直接操作提供的API大致可分为</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B05-Atomic&Unsafe%E9%AD%94%E6%B3%95%E7%B1%BB%E8%AF%A6%E8%A7%A3/image-20221031231159929.png" alt="image-20221031231159929"></p>
<h4 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h4><p>​    这部分主要包含堆外内存的分配、拷贝、释放、给定地址值操作等方法。 </p>
<h4 id="CAS-原子操作"><a href="#CAS-原子操作" class="headerlink" title="CAS 原子操作"></a>CAS 原子操作</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapObject</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, Object var4, Object var5)</span>; </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapInt</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">int</span> var4, <span class="hljs-keyword">int</span> var5)</span>; </span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">compareAndSwapLong</span><span class="hljs-params">(Object var1, <span class="hljs-keyword">long</span> var2, <span class="hljs-keyword">long</span> var4, <span class="hljs-keyword">long</span> var6)</span></span><br><span class="hljs-function">    </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">long</span> <span class="hljs-title">objectFieldOffset</span><span class="hljs-params">(Field var1)</span></span>;<br></code></pre></td></tr></table></figure>

<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>包括线程挂起、恢复、锁机制等方法。<br>**//取消阻塞线程 **</p>
<p>public native void unpark(Object thread); </p>
<p>**//阻塞线程 **</p>
<p>public native void park(boolean isAbsolute, long time);</p>
<p>**//获得对象锁（类似可重入锁ReentrantLock或者Synchronized） **</p>
<p>public native void monitorEnter(Object o); </p>
<p>**//释放对象锁 **</p>
<p>public native void monitorExit(Object o);</p>
<p><strong>//尝试获取对象锁</strong></p>
<p>public native boolean tryMonitorEnter(Object o);</p>
<p>​    方法park、unpark即可实现线程的挂起与恢复，将一个线程进行挂起是通过park方 法实现的，调用park方法后，线程将一直阻塞直到超时或者中断等条件出现； unpark可以终止一个挂起的线程，使其恢复正常</p>
<p><strong>典型应用</strong>：Java锁和同步器框架的核心类AbstractQueuedSynchronizer，就是通过调用 LockSupport.park()和LockSupport.unpark()实现线程的阻塞和唤醒的，而 LockSupport的park、unpark方法实际是调用Unsafe的park、unpark方式来实现。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>​    在Java 8中引入，用于定义内存屏障（也称内存栅栏，内存栅障，屏障指令等，是一类 同步屏障指令，是CPU或编译器在对内存随机访问的操作中的一个同步点，使得此点之前的 所有读写操作都执行后才可以开始执行此点之后的操作），避免代码重排序。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//内存屏障前后，禁止load操作重排序。屏障前的load操作不能被重排序到屏障后，屏障后的load操作不能被重排序到屏障前 </span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadFence</span><span class="hljs-params">()</span>; 相当于loadload屏障</span><br><span class="hljs-function"><span class="hljs-comment">//内存屏障前后，禁止store操作重排序。屏障前的store操作不能被重排序到屏障后， 屏障后的store操作不能被重排序到屏障前</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">storeFence</span><span class="hljs-params">()</span>; 相当于storestore屏障</span><br><span class="hljs-function"><span class="hljs-comment">//内存屏障前后，禁止load、store操作重排序 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fullFence</span><span class="hljs-params">()</span>; 相当于 <span class="hljs-title">loadFence</span><span class="hljs-params">()</span> + <span class="hljs-title">storeFence</span><span class="hljs-params">()</span> ;使所有Full Barrier之前发生的操作，对所有Full Barrier之后的操作都是可见的</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span> :利用内存屏障手动防止指令</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FenceTest</span> </span>&#123;<br><br><br><span class="hljs-comment">//    public static void main(String[] args) &#123;</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        UnsafeInstance.reflectGetUnsafe().loadFence();//读屏障</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        UnsafeInstance.reflectGetUnsafe().storeFence();//写屏障</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//        UnsafeInstance.reflectGetUnsafe().fullFence();//读写屏障</span><br><span class="hljs-comment">//</span><br><span class="hljs-comment">//    &#125;</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> a = <span class="hljs-number">0</span>, b =<span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">for</span> (;;)&#123;<br>            i++;<br>            x = <span class="hljs-number">0</span>; y = <span class="hljs-number">0</span>;<br>            a = <span class="hljs-number">0</span>; b = <span class="hljs-number">0</span>;<br>            Thread t1 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    <span class="hljs-comment">//由于线程one先启动，下面这句话让它等一等线程two. 读着可根据自己电脑的实际性能适当调整等待时间.</span><br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">100</span>));<br>                    a = <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//不允许2次store操作发生重排</span><br>                    <span class="hljs-comment">//手动加内存屏障</span><br>                    UnsafeInstance.reflectGetUnsafe().storeFence();<br>                    x = b; <span class="hljs-comment">// read-load、assign、store-write</span><br>                    <span class="hljs-comment">//分两步进行，第一步先volatile读，第二步再普通写</span><br>                &#125;<br>            &#125;);<br>            Thread t2 = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                    shortWait((<span class="hljs-keyword">long</span>) (Math.random() * <span class="hljs-number">100</span>));<br>                    b = <span class="hljs-number">1</span>;<br>                    <span class="hljs-comment">//不允许2次store操作发生重排</span><br>                    UnsafeInstance.reflectGetUnsafe().storeFence();<br>                    y = a;<br>                &#125;<br>            &#125;);<br>            t1.start();<br>            t2.start();<br>            t1.join();<br>            t2.join();<br><br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * cpu或者jit对我们的代码进行了指令重排？</span><br><span class="hljs-comment">             * 1,1</span><br><span class="hljs-comment">             * 0,1</span><br><span class="hljs-comment">             * 1,0</span><br><span class="hljs-comment">             * 0,0</span><br><span class="hljs-comment">             */</span><br>            String result = <span class="hljs-string">&quot;第&quot;</span> + i + <span class="hljs-string">&quot;次 (&quot;</span> + x + <span class="hljs-string">&quot;,&quot;</span> + y + <span class="hljs-string">&quot;）&quot;</span>;<br>            <span class="hljs-keyword">if</span>(x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>                System.err.println(result);<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(result);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shortWait</span><span class="hljs-params">(<span class="hljs-keyword">long</span> interval)</span></span>&#123;<br>        <span class="hljs-keyword">long</span> start = System.nanoTime();<br>        <span class="hljs-keyword">long</span> end;<br>        <span class="hljs-keyword">do</span>&#123;<br>            end = System.nanoTime();<br>        &#125;<span class="hljs-keyword">while</span>(start + interval &gt;= end);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>Class相关</li>
<li>对象操作</li>
<li>系统信息获取</li>
<li>数组操做</li>
</ul>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程06-List&amp;Queue体系分析</title>
    <url>/2021/11/07/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&amp;Queue/</url>
    <content><![CDATA[<h1 id="并发编程之List-amp-Queue体系分析"><a href="#并发编程之List-amp-Queue体系分析" class="headerlink" title="并发编程之List&amp;Queue体系分析"></a>并发编程之List&amp;Queue体系分析</h1><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h4 id="ArrayList线程不安全"><a href="#ArrayList线程不安全" class="headerlink" title="ArrayList线程不安全"></a>ArrayList线程不安全</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayListSample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">final</span> List&lt;Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br><br>        <span class="hljs-comment">// 线程A将0-1000添加到list</span><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span> ; i++) &#123;<br>                    list.add(i);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-comment">// 线程B将1000-2000添加到列表</span><br>        <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">10000</span>; i &lt; <span class="hljs-number">20000</span> ; i++) &#123;<br>                    list.add(i);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        Thread.sleep(<span class="hljs-number">1000</span>);<br><br>        <span class="hljs-comment">// 打印所有结果</span><br>        System.out.println(list.size());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            System.out.println(<span class="hljs-string">&quot;第&quot;</span> + (i + <span class="hljs-number">1</span>) + <span class="hljs-string">&quot;个元素为：&quot;</span> + list.get(i));<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList线程安全"><a href="#CopyOnWriteArrayList线程安全" class="headerlink" title="CopyOnWriteArrayList线程安全"></a>CopyOnWriteArrayList线程安全</h4><p>写时复制List,增删操作时，加锁并且复制另一个数组来进行修改，修改后再替换原来的数组，读操作不做控制</p>
<p>优点：适用于读多写少，数据量较小的场景，支持在遍历迭代式增删元素</p>
<p>缺点：数据量大时占用内存大，易引发GC。</p>
<h2 id="BlockingQueue阻塞队列"><a href="#BlockingQueue阻塞队列" class="headerlink" title="BlockingQueue阻塞队列"></a>BlockingQueue阻塞队列</h2><blockquote>
<p><a href="https://blog.csdn.net/qq_45105530/article/details/122490152">https://blog.csdn.net/qq_45105530/article/details/122490152</a></p>
</blockquote>
<p>实质就是一种存储数据的结构</p>
<p>通常用链表或者数组实现</p>
<p>一般而言队列具备FIFO先进先出的特性，当然也有双端队列（Deque）优先级队列</p>
<p>主要操作：入队（EnQueue）与出队（Dequeue）</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211107225144445.png" alt="image-20211107225144445"></p>
<h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><p>1、ArrayBlockingQueue 由数组支持的有界队列</p>
<p>2、LinkedBlockingQueue 由链接节点支持的可选有界队列</p>
<p>3、PriorityBlockingQueue 由优先级堆支持的无界优先级队列</p>
<p>4、DelayQueue 由优先级堆支持的、基于时间的调度队列</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211107225819914.png" alt="image-20211107225819914"></p>
<h3 id="ArrayBlockingQueue数据结构"><a href="#ArrayBlockingQueue数据结构" class="headerlink" title="ArrayBlockingQueue数据结构"></a>ArrayBlockingQueue数据结构</h3><p>队列基于数组实现,容量大小在创建ArrayBlockingQueue对象时已定义好<br><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211107230224968.png" alt="image-20211107230224968"></p>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ball</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 编号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String number ;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 颜色</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String color ;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getNumber</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNumber</span><span class="hljs-params">(String number)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.number = number;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getColor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> color;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setColor</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.color = color;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">ArrayBlockingQueueTest</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 创建容量大小为1的有界队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BlockingQueue&lt;Ball&gt; blockingQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Ball&gt;(<span class="hljs-number">5</span>);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列大小</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">queueSize</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> blockingQueue.size();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将球放入队列当中,生产者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ball</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> InterruptedException</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">produce</span><span class="hljs-params">(Ball ball)</span> <span class="hljs-keyword">throws</span> InterruptedException</span>&#123;<br>        blockingQueue.put(ball);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 将球从队列当中拿出去，消费者</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Ball <span class="hljs-title">consume</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>       <span class="hljs-keyword">return</span> blockingQueue.take();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        <span class="hljs-keyword">final</span> ArrayBlockingQueueTest box = <span class="hljs-keyword">new</span> ArrayBlockingQueueTest();<br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 往箱子里面放入乒乓球</span><br><span class="hljs-comment">         */</span><br>        executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                    Ball ball = <span class="hljs-keyword">new</span> Ball();<br>                    ball.setNumber(<span class="hljs-string">&quot;乒乓球编号:&quot;</span>+i);<br>                    ball.setColor(<span class="hljs-string">&quot;yellow&quot;</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;:准备往箱子里放入乒乓球:---&gt;&quot;</span>+ball.getNumber());<br>                        box.produce(ball);<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;:往箱子里放入乒乓球:---&gt;&quot;</span>+ball.getNumber());<br>                        System.out.println(<span class="hljs-string">&quot;put操作后，当前箱子中共有乒乓球:---&gt;&quot;</span><br>                                + box.queueSize() + <span class="hljs-string">&quot;个&quot;</span>);<br>                        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>) * <span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                    i++;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * consumer，负责从箱子里面拿球出来</span><br><span class="hljs-comment">         */</span><br>        executorService.submit(<span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>)&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;准备到箱子中拿乒乓球:---&gt;&quot;</span>);<br>                        Ball ball = box.consume();<br>                        System.out.println(System.currentTimeMillis()+<br>                                <span class="hljs-string">&quot;拿到箱子中的乒乓球:---&gt;&quot;</span>+ball.getNumber());<br>                        System.out.println(<span class="hljs-string">&quot;take操作后，当前箱子中共有乒乓球:---&gt;&quot;</span><br>                                + box.queueSize() + <span class="hljs-string">&quot;个&quot;</span>);<br>                        Thread.sleep(<span class="hljs-keyword">new</span> Random().nextInt(<span class="hljs-number">3</span>) * <span class="hljs-number">1000</span>);<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="条件等待队列"><a href="#条件等待队列" class="headerlink" title="条件等待队列"></a>条件等待队列</h3><p>put方法中，使用了AQS的条件等待队列</p>
<p><strong>条件队列中的结点是不会被唤醒去争夺锁的，只能通过转移至CLH同步等待队列才能参与争夺锁</strong></p>
<p>在ArrayBlockingQueue中，维护了 2个条件等待队列，具体实现是AQS的ConditionObject</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211108000253258.png" alt="image-20211108000253258"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/** Condition for waiting takes */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notEmpty;<br><br><span class="hljs-comment">/** Condition for waiting puts */</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Condition notFull;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(E e)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    checkNotNull(e);<br>    <span class="hljs-comment">//获取独占锁</span><br>    <span class="hljs-keyword">final</span> ReentrantLock lock = <span class="hljs-keyword">this</span>.lock;<br>    lock.lockInterruptibly();<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">while</span> (count == items.length)<br>            <span class="hljs-comment">//如果容量不足，则进度条件等待队列</span><br>            notFull.await();<br>        <span class="hljs-comment">//占用对象数组容量</span><br>        enqueue(e);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        lock.unlock();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 加入条件队列等待，条件队列入口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    <span class="hljs-comment">//如果当前线程被中断则直接抛出异常</span><br>    <span class="hljs-keyword">if</span> (Thread.interrupted())<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InterruptedException();<br>    <span class="hljs-comment">//把当前节点加入条件队列</span><br>    Node node = addConditionWaiter();<br>    <span class="hljs-comment">//释放掉已经获取的独占锁资源</span><br>    <span class="hljs-keyword">int</span> savedState = fullyRelease(node);<br>    <span class="hljs-keyword">int</span> interruptMode = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">//如果不在同步队列中则不断挂起</span><br>    <span class="hljs-keyword">while</span> (!isOnSyncQueue(node)) &#123;<br>        LockSupport.park(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-comment">//自选把结点从条件队列移动到同步等待队列（在等待队列中才可能获取独占锁从而获取独占锁）</span><br>        <span class="hljs-comment">//这里被唤醒可能是正常的signal操作也可能是中断</span><br>        <span class="hljs-keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * 走到这里说明节点已经条件满足被加入到了同步队列中或者中断了</span><br><span class="hljs-comment">             * 这个方法很熟悉吧？就跟独占锁调用同样的获取锁方法，从这里可以看出条件队列只能用于独占锁</span><br><span class="hljs-comment">             * 在处理中断之前首先要做的是从同步队列中成功获取锁资源</span><br><span class="hljs-comment">             */</span><br>    <span class="hljs-keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)<br>        interruptMode = REINTERRUPT;<br>    <span class="hljs-comment">//走到这里说明已经成功获取到了独占锁，接下来就做些收尾工作</span><br>    <span class="hljs-comment">//删除条件队列中被取消的节点</span><br>    <span class="hljs-keyword">if</span> (node.nextWaiter != <span class="hljs-keyword">null</span>) <span class="hljs-comment">// clean up if cancelled</span><br>        unlinkCancelledWaiters();<br>    <span class="hljs-comment">//根据不同模式处理中断</span><br>    <span class="hljs-keyword">if</span> (interruptMode != <span class="hljs-number">0</span>)<br>        reportInterruptAfterWait(interruptMode);<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1.与同步队列不同，条件队列头尾指针是firstWaiter跟lastWaiter</span><br><span class="hljs-comment"> * 2.条件队列是在获取锁之后，也就是临界区进行操作，因此很多地方不用考虑并发</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> Node <span class="hljs-title">addConditionWaiter</span><span class="hljs-params">()</span> </span>&#123;<br>    Node t = lastWaiter;<br>    <span class="hljs-comment">//如果最后一个节点被取消，则删除队列中被取消的节点</span><br>    <span class="hljs-comment">//至于为啥是最后一个节点后面会分析</span><br>    <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;<br>        <span class="hljs-comment">//删除所有被取消的节点</span><br>        unlinkCancelledWaiters();<br>        t = lastWaiter;<br>    &#125;<br>    <span class="hljs-comment">//创建一个类型为CONDITION的节点并加入队列，由于在临界区，所以这里不用并发控制</span><br>    Node node = <span class="hljs-keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);<br>    <span class="hljs-keyword">if</span> (t == <span class="hljs-keyword">null</span>)<br>        firstWaiter = node;<br>    <span class="hljs-keyword">else</span><br>        t.nextWaiter = node;<br>    lastWaiter = node;<br>    <span class="hljs-keyword">return</span> node;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>实质是小顶堆，小的在前，大的在后</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PriorityQueueTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        PriorityBlockingQueue&lt;Integer&gt; priorityQueue = <span class="hljs-keyword">new</span> PriorityBlockingQueue&lt;&gt;(<span class="hljs-number">5</span>);<br><br>        add(priorityQueue,<span class="hljs-number">2</span>);<br>        add(priorityQueue,<span class="hljs-number">3</span>);<br>        add(priorityQueue,<span class="hljs-number">4</span>);<br>        add(priorityQueue,<span class="hljs-number">5</span>);<br>        add(priorityQueue,<span class="hljs-number">6</span>);<br>        add(priorityQueue,<span class="hljs-number">7</span>);<br>        add(priorityQueue,<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            Integer peek = priorityQueue.take();<br>            System.out.println(peek);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(PriorityBlockingQueue&lt;Integer&gt; priorityQueue,Integer num)</span></span>&#123;<br>        priorityQueue.add(num);<br>        <span class="hljs-keyword">if</span>(priorityQueue.size() &gt; <span class="hljs-number">5</span> )&#123;<br>            priorityQueue.remove();<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-number">3</span><br><span class="hljs-number">4</span><br><span class="hljs-number">5</span><br><span class="hljs-number">6</span><br><span class="hljs-number">7</span><br>线程阻塞<br></code></pre></td></tr></table></figure>

<h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>​    由优先级堆支持的、基于时间的调度队列，内部基于无界队列PriorityQueue实现，而无界队列基于数组的扩容实现。<br>​    应用场景:电影票<br>​    要求入队的对象必须要实现Delayed接口,而Delayed集成自Comparable接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MovieTiket</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Delayed</span> </span>&#123;<br>    <span class="hljs-comment">//延迟时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> delay;<br>    <span class="hljs-comment">//到期时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> expire;<br>    <span class="hljs-comment">//数据</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String msg;<br>    <span class="hljs-comment">//创建时间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> now;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> delay;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getExpire</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> expire;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMsg</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getNow</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> now;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delay 延期时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieTiket</span><span class="hljs-params">(String msg , <span class="hljs-keyword">long</span> delay)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.delay = delay;<br>        <span class="hljs-keyword">this</span>.msg = msg;<br>        expire = System.currentTimeMillis() + delay;    <span class="hljs-comment">//到期时间 = 当前时间+延迟时间</span><br>        now = System.currentTimeMillis();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieTiket</span><span class="hljs-params">(String msg)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(msg,<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MovieTiket</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(<span class="hljs-keyword">null</span>,<span class="hljs-number">1000</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得延迟时间   用过期时间-当前时间,时间单位毫秒</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> unit</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getDelay</span><span class="hljs-params">(TimeUnit unit)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> unit.convert(<span class="hljs-keyword">this</span>.expire<br>                - System.currentTimeMillis() , TimeUnit.MILLISECONDS);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 用于延迟队列内部比较排序  当前时间的延迟时间 - 比较对象的延迟时间</span><br><span class="hljs-comment">     * 越早过期的时间在队列中越靠前</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> delayed</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compareTo</span><span class="hljs-params">(Delayed delayed)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) (<span class="hljs-keyword">this</span>.getDelay(TimeUnit.MILLISECONDS)<br>                - delayed.getDelay(TimeUnit.MILLISECONDS));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;MovieTiket&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;delay=&quot;</span> + delay +<br>                <span class="hljs-string">&quot;, expire=&quot;</span> + expire +<br>                <span class="hljs-string">&quot;, msg=&#x27;&quot;</span> + msg + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, now=&quot;</span> + now +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelayedQueueTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        DelayQueue&lt;MovieTiket&gt; delayQueue = <span class="hljs-keyword">new</span> DelayQueue&lt;MovieTiket&gt;();<br>        MovieTiket tiket = <span class="hljs-keyword">new</span> MovieTiket(<span class="hljs-string">&quot;电影票0&quot;</span>,<span class="hljs-number">10000</span>);<br>        delayQueue.put(tiket);<br>        MovieTiket tiket1 = <span class="hljs-keyword">new</span> MovieTiket(<span class="hljs-string">&quot;电影票1&quot;</span>,<span class="hljs-number">5000</span>);<br>        delayQueue.put(tiket1);<br>        MovieTiket tiket2 = <span class="hljs-keyword">new</span> MovieTiket(<span class="hljs-string">&quot;电影票2&quot;</span>,<span class="hljs-number">8000</span>);<br>        delayQueue.put(tiket2);<br>        System.out.println(<span class="hljs-string">&quot;message:---&gt;入队完毕&quot;</span>);<br><br>        <span class="hljs-keyword">while</span>( delayQueue.size() &gt; <span class="hljs-number">0</span> )&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                tiket = delayQueue.take();<br>                System.out.println(<span class="hljs-string">&quot;电影票出队:&quot;</span>+tiket.getMsg());<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>&#125;<br><br>message:---&gt;入队完毕<br>电影票出队:电影票<span class="hljs-number">1</span><br>电影票出队:电影票<span class="hljs-number">2</span><br>电影票出队:电影票<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h3><h4 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h4><p>HashMap存储的是存在映射关系的键值对，存储在被称为哈希表（数组+链表或红黑树（JDK&gt;7后））的数据结构中。通过计算key的hashCode值来确定键值对在数组中的位置，假如产生碰撞，则使用链表或红黑树。</p>
<p>而为了避免hashcode碰撞，就涉及了元素的<strong>分布策略</strong>和<strong>动态扩容</strong></p>
<h4 id="分布策略"><a href="#分布策略" class="headerlink" title="分布策略"></a>分布策略</h4><p>分布策略的体现主要有3个点</p>
<p>1、HashMap的底层数组长度始终保存为2的次幂</p>
<p>2、hash算法使用了key哈希值的高位</p>
<p>3、通过与操作对数组长度取模</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20221105213545239.png" alt="image-20221105213545239"></p>
<h4 id="动态扩容"><a href="#动态扩容" class="headerlink" title="动态扩容"></a>动态扩容</h4><p>HashMap长度默认为16</p>
<p>loadFactor负载因子默认为0.75</p>
<p>threshold容量=loadFactor * length，每当hashmap的数组长度超过threshold时，hashmap就会进行扩容一倍，避免因为数组太满导致过多的<strong>hash碰撞</strong></p>
<p>动态扩容方面，由于底层数组的长度始终为2的次幂，也就是说每次扩容，长度值都会扩大一倍，数组长度length的二进制表示在高位会多出1bit。而扩容时，该length值将会参与位于操作来确定元素所在数组中的新位置。所以，原数组中的元素所在位置要么保持不动，要么就是移动2次幂个位置。但是，HashMap美中不足的是∶它不是线程安全的。主要体现在两个方面∶</p>
<p>扩容时出现著名的环形链表异常，此问题在JDK1.8版本被解决。·</p>
<p>并发下脏读脏写</p>
<h3 id="Java7HashMap"><a href="#Java7HashMap" class="headerlink" title="Java7HashMap"></a>Java7HashMap</h3><p>Hash表 = 数组 + 链表</p>
<h4 id="扩容闭环导致死锁"><a href="#扩容闭环导致死锁" class="headerlink" title="扩容闭环导致死锁"></a>扩容闭环导致死锁</h4><p>扩容时可能会产生死锁，多线程扩容时链表<strong>头插法</strong>并发扩容时，可能产生闭环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapResizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer, Integer&gt;(<span class="hljs-number">2</span>);<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> AtomicInteger atomicInteger = <span class="hljs-keyword">new</span> AtomicInteger();<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">while</span>(atomicInteger.get() &lt; <span class="hljs-number">100000</span>)&#123;<br>            map.put(atomicInteger.get(),atomicInteger.get());<br>            atomicInteger.incrementAndGet();<br>        &#125;<br>        System.out.println( Thread.currentThread().getName() + <span class="hljs-string">&quot;线程结束&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MapTest</span> </span>&#123;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">30</span>;i++)&#123;<br>         <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> MapResizer()).start();<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="产生闭环的原因"><a href="#产生闭环的原因" class="headerlink" title="产生闭环的原因"></a>产生闭环的原因</h4><blockquote>
<p><a href="https://blog.csdn.net/Krone_/article/details/125101531">https://blog.csdn.net/Krone_/article/details/125101531</a></p>
</blockquote>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20221106172105380.png" alt="image-20221106172105380"></p>
<p>A线程：e0 -&gt; e1，切换时间片</p>
<p>B线程：e0 -&gt; e1,扩容完成后，e1-&gt;e0</p>
<p>A线程：e1 -&gt; e0 -&gt; e1，无法跳出循环 </p>
<p>jdk8后，改用了尾插法，避免了这个问题，但还是存在其他并发问题</p>
<h3 id="Java8HashMap"><a href="#Java8HashMap" class="headerlink" title="Java8HashMap"></a>Java8HashMap</h3><p><strong>Hash表 = 数组 + 链表 + 红黑树</strong></p>
<p><strong>数组扩容时，高低位搭配，不可能形成闭环</strong></p>
<p>扩容时不会形成闭环，而是采用高低位插入，<strong>if((e.hash &amp; oldCap) == 0) 判断是否需要移动元素</strong>，hash值在oldCap的最高位=1则扩容后下标=扩容前大小+原下标，否则=原下标。</p>
<p>扩容后原链表大概会被拆成2段，一段在原下标，一段在（扩容前长度+原下标）的位置</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>    <span class="hljs-keyword">if</span> (loTail == <span class="hljs-keyword">null</span>)<br>        loHead = e;<br>    <span class="hljs-keyword">else</span><br>        loTail.next = e;<br>    loTail = e;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-keyword">null</span>)<br>        hiHead = e;<br>    <span class="hljs-keyword">else</span><br>        hiTail.next = e;<br>    hiTail = e;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (loTail != <span class="hljs-keyword">null</span>) &#123;<br>    loTail.next = <span class="hljs-keyword">null</span>;<br>    newTab[j] = loHead;<br>&#125;<br><span class="hljs-keyword">if</span> (hiTail != <span class="hljs-keyword">null</span>) &#123;<br>    hiTail.next = <span class="hljs-keyword">null</span>;<br>    newTab[j + oldCap] = hiHead;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>链表长度大于8并且数组的长度大于64，会把链表转换成红黑树，当链表长度小于等于6时恢复为链表</strong></p>
<p>​    1、TreeNodes占用空间是普通Nodes的两倍，所以只有当Entry链包含足够多的节点且数组长度足够大时才会转成TreeNodes以追求查询速度log2N。</p>
<p>​    2、且正常来说如果hashcode的离散性好的话，value会均匀分布在数组中而很难达到长度为8的地步。</p>
<p>​    3、所以当出现了碰撞度比较高的离散算法时，才会使用到红黑树</p>
<p>理想情况下我们可以看到，一个bin中链表长度达到8个元素的概率为0.00000006，几乎是不可能事件，</p>
<p>​    0:    0.60653066<br>​    1:    0.30326533<br>​    2:    0.07581633<br>​    3:    0.01263606<br>​    4:    0.00157952<br>​    5:    0.00015795<br>​    6:    0.00001316<br>​    7:    0.00000094<br>​    8:    0.00000006</p>
<h4 id="扩容过程"><a href="#扩容过程" class="headerlink" title="扩容过程"></a><strong>扩容过程</strong></h4><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/HashMap%E7%9A%84put%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B.jpg" alt="image-20211110000041790"></p>
<p>基本步骤如下:</p>
<p>1、数组[i]对象是否存在，不存在则直接插入</p>
<p>2、存在，判断链表或者红黑树中key是否存在，不存在则直接插入</p>
<p>3、存在则直接覆盖</p>
<p>4、插入后更具size++ &gt; threshold？判断是否需要扩容</p>
<h4 id="数据丢失问题"><a href="#数据丢失问题" class="headerlink" title="数据丢失问题"></a>数据丢失问题</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HashMapDataLost</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">//线程一</span><br>        <span class="hljs-keyword">new</span> Thread() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br>                    map.put(String.valueOf(i), String.valueOf(i));<br>                &#125;<br>            &#125;<br>        &#125;.start();<br>        <span class="hljs-comment">//线程二</span><br>        <span class="hljs-keyword">new</span> Thread()&#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j=<span class="hljs-number">1000</span>;j&lt;<span class="hljs-number">2000</span>;j++)&#123;<br>                    map.put(String.valueOf(j), String.valueOf(j));<br>                &#125;<br>            &#125;<br>        &#125;.start();<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.currentThread().sleep(<span class="hljs-number">3000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        System.out.println(<span class="hljs-string">&quot;map.size&quot;</span>+map.size());<br>        <span class="hljs-comment">//输出</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">2000</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(Objects.isNull(map.get(String.valueOf(i))))&#123;<br>                System.out.println(<span class="hljs-string">&quot;_________________________________________________________________&quot;</span>);<br>            &#125;<br>            System.out.println(<span class="hljs-string">&quot;第：&quot;</span>+i+<span class="hljs-string">&quot;元素，值：&quot;</span>+map.get(String.valueOf(i)));<br>        &#125;<br>    &#125;<br>&#125;<br><br>map.size1978<br>...<br>第：<span class="hljs-number">53</span>元素，值：<span class="hljs-number">53</span><br>_________________________________________________________________<br>第：<span class="hljs-number">54</span>元素，值：<span class="hljs-keyword">null</span><br>...<br></code></pre></td></tr></table></figure>

<h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><p>​    既然HashMap是线程不安全的，那我每次put/get操作时都用锁进行控制不就好了？HashTable确实是这么做的，给get/put操作加上了synchronized关键字。</p>
<p>​    但是这样会导致效率低下，在多线程环境下进行读写操作时，其他操作都会被阻塞。</p>
<p>​    所以基本上不推荐使用HashTable。</p>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><p><strong>ConcurrentHashMap是线程安全</strong></p>
<h3 id="1-7分段锁"><a href="#1-7分段锁" class="headerlink" title="1.7分段锁"></a>1.7分段锁</h3><p>​    ConcurrentHashMap 1.7 = Segment数组（继承ReentrantLock） + HashEntry数组 + 链表,从而实现分段锁，支持并发。</p>
<p>​    HashTable是用一把锁锁住了所有数据，而ConcurrentHashMap是将数组分为多个段，每把锁只锁数组中的一段数据，就能大大减少锁的竞争。</p>
<h4 id="JDK7组成结构"><a href="#JDK7组成结构" class="headerlink" title="JDK7组成结构"></a>JDK7组成结构</h4><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20211109233748646.png" alt="image-20211109233748646"></p>
<h4 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h4><p>​    1、扩容仅仅针对HashEntry数组，Segement数组在初始化后就无法扩容</p>
<h3 id="1-8桶锁"><a href="#1-8桶锁" class="headerlink" title="1.8桶锁"></a>1.8桶锁</h3><p>ConcurrentHashMap 1.8 = Node数组 +  链表/红黑树，区别在于每次插入，都<strong>synchronized第一个节点</strong>，相同于锁一条链表，锁的粒度变小，并且通过CAS的算法插入每个链表的第一个阶段，从而达到并发，锁的粒度较小，灵活</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B06-Collection&Queue/image-20221106233921455.png" alt="image-20221106233921455"></p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>AQS等待队列</tag>
        <tag>ConcurrentHashMap</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程08-ForkJoin原理与应用</title>
    <url>/2021/11/22/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    <content><![CDATA[<h1 id="任务的性质"><a href="#任务的性质" class="headerlink" title="任务的性质"></a>任务的性质</h1><h2 id="CPU密集型（CPU-bound）"><a href="#CPU密集型（CPU-bound）" class="headerlink" title="CPU密集型（CPU-bound）"></a>CPU密集型（CPU-bound）</h2><p>​        CPU密集型也叫计算密集型，指的是系统的硬盘、内存性能相对CPU要好很多，此时，系统运作大部分的状况是CPULoading100%，CPU要读/写I/O(硬盘/内存)，I/O在很短的时间就可以完成，而CPU还有许多运算要处理，CPULoading很高。在多重程序系统中，大部份时间用来做计算、逻辑判断等CPU动作的程序称之CPUbound。例如一个计算圆周率至小数点一千位以下的程序，在执行的过程当中绝大部份时间用在三角函数和开根号的计算，便是属于CPUbound的程序。CPUbound的程序一般而言CPU占用率相当高。这可能是因为任务本身不太需要访问I/O设备，也可能是因为程序是多线程实现因此屏蔽掉了等待I/O的时间。</p>
<p>​        线程数一般设置为：<strong>线程数=CPU核数+1(现代CPU支持超线程)</strong></p>
<h2 id="IO密集型（I-Obound）"><a href="#IO密集型（I-Obound）" class="headerlink" title="IO密集型（I/Obound）"></a>IO密集型（I/Obound）</h2><p>​        IO密集型指的是系统的CPU性能相对硬盘、内存要好很多，此时，系统运作，大部分的状况是CPU在等I/O(硬盘/内存)的读/写操作，此时CPULoading并不高。I/Obound的程序一般在达到性能极限时，CPU占用率仍然较低。这可能是因为任务本身需要大量I/O操作，而pipeline做得不是很好，没有充分利用处理器能力。</p>
<p>​        线程数一般设置为：<strong>线程数=（（线程等待时间+线程CPU时间）/线程CPU时间）*CPU数目</strong></p>
<h2 id="CPU密集型vsIO密集型"><a href="#CPU密集型vsIO密集型" class="headerlink" title="CPU密集型vsIO密集型"></a>CPU密集型vsIO密集型</h2><p>​    我们可以把任务分为计算密集型和IO密集型。</p>
<p>​    计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。</p>
<p>​    第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。</p>
<p>一般而言、一般的web后台系统都大多做IO密集类操作，毕竟存在大量的sql或者存在导出操作</p>
<h1 id="一个问题"><a href="#一个问题" class="headerlink" title="一个问题"></a>一个问题</h1><p>​        如何充分利用多核CPU，计算很大数组中所有整数的和？</p>
<p>1、单线程累加</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumSequential</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> SumUtils.sumRange(arr, <span class="hljs-number">0</span>, arr.length);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br><br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> result = sum(arr);<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br>        System.out.println(<span class="hljs-string">&quot;单线程:&quot;</span>+ (end - begin));<br>    &#125;<br>&#125;<br>The array length is: <span class="hljs-number">200000</span><br>The result is: <span class="hljs-number">9905876</span><br>单线程:<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>2、多线程拆分（定义步长，1为2,2分为4,4分为8）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumRecursiveMT</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecursiveSumTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEQUENTIAL_CUTOFF = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> lo;<br>        <span class="hljs-keyword">int</span> hi;<br>        <span class="hljs-keyword">int</span>[] arr; <span class="hljs-comment">// arguments</span><br>        ExecutorService executorService;<br><br>        RecursiveSumTask( ExecutorService executorService, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h) &#123;<br>            <span class="hljs-keyword">this</span>.executorService = executorService;<br>            <span class="hljs-keyword">this</span>.arr = a;<br>            <span class="hljs-keyword">this</span>.lo = l;<br>            <span class="hljs-keyword">this</span>.hi = h;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// override</span><br>            System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] begin to compute %n&quot;</span>,<br>                    Thread.currentThread().getName(), lo, hi);<br>            <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (hi - lo &lt;= SEQUENTIAL_CUTOFF) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt; hi; i++)<br>                    result += arr[i];<br><br>                System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] begin to finished %n&quot;</span>,<br>                        Thread.currentThread().getName(), lo, hi);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                RecursiveSumTask left = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, lo, (hi + lo) / <span class="hljs-number">2</span>);<br>                RecursiveSumTask right = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, (hi + lo) / <span class="hljs-number">2</span>, hi);<br>                Future&lt;Long&gt; lr = executorService.submit(left);<br>                Future&lt;Long&gt; rr = executorService.submit(right);<br><br>                result = lr.get() + rr.get();<br>                System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] finished to compute %n&quot;</span>,<br>                        Thread.currentThread().getName(), lo, hi);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> nofProcessors = Runtime.getRuntime().availableProcessors();<br>        ExecutorService executorService = Executors.newFixedThreadPool(<span class="hljs-number">4</span>);<br>        <span class="hljs-comment">//ExecutorService executorService = Executors.newCachedThreadPool();</span><br><br>        RecursiveSumTask task = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, <span class="hljs-number">0</span>, arr.length);<br>        <span class="hljs-keyword">long</span> result =  executorService.submit(task).get();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br><br>        <span class="hljs-keyword">long</span> result = sum(arr);<br><br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br><br>    &#125;<br>&#125;<br><span class="hljs-comment">//无法正常运行 4个线程无法完成递归</span><br>The array length is: <span class="hljs-number">200000</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span> range [<span class="hljs-number">0</span>-<span class="hljs-number">200000</span>] begin to compute <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span> range [<span class="hljs-number">0</span>-<span class="hljs-number">100000</span>] begin to compute <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span> range [<span class="hljs-number">100000</span>-<span class="hljs-number">200000</span>] begin to compute <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span> range [<span class="hljs-number">0</span>-<span class="hljs-number">50000</span>] begin to compute <br></code></pre></td></tr></table></figure>

<p>3、多线程拆分（定义步长，拆分为 数组长度/步长  个线程去计算对应段的素组长度）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumMultiThreads</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM = <span class="hljs-number">1000</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr, ExecutorService executor)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> numThreads = arr.length / NUM &gt; <span class="hljs-number">0</span> ? arr.length / NUM : <span class="hljs-number">1</span>;<br><br>        SumTask[] tasks = <span class="hljs-keyword">new</span> SumTask[numThreads];<br>        Future&lt;Long&gt;[] sums = <span class="hljs-keyword">new</span> Future[numThreads];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++) &#123;<br>            tasks[i] = <span class="hljs-keyword">new</span> SumTask(arr, (i * NUM), ((i + <span class="hljs-number">1</span>) * NUM));<br>            sums[i] = executor.submit(tasks[i]);<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numThreads; i++) &#123;<br>            result += sums[i].get();<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br><br>        <span class="hljs-keyword">int</span> numThreads = arr.length / NUM &gt; <span class="hljs-number">0</span> ? arr.length / NUM : <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br><br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br>        ExecutorService executor = Executors.newFixedThreadPool(numThreads);<br><br>        <span class="hljs-keyword">long</span> result = sum(arr, executor);<br><br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br>        System.out.println(<span class="hljs-string">&quot;多线程:&quot;</span>+ (end - begin));<br>    &#125;<br>&#125;<br>The array length is: <span class="hljs-number">200000</span><br>The result is: <span class="hljs-number">9904260</span><br>多线程:<span class="hljs-number">177</span><br></code></pre></td></tr></table></figure>

<h2 id="分治法"><a href="#分治法" class="headerlink" title="分治法"></a>分治法</h2><p>基本思想：把一个规模大的问题划分为规模较小的子问题，然后分而治之，最后合并子问题的解得到原问题的解。<br>步骤：<br>1、分割原问题：<br>2、求解子问题：<br>3、合并子问题的解为原问题的解。<br>在分治法中，子问题一般是相互独立的，因此，经常通过递归调用算法来求解子问题。</p>
<h3 id="拆分任务"><a href="#拆分任务" class="headerlink" title="拆分任务"></a>拆分任务</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211124220037943.png" alt="image-20211124220037943"></p>
<h3 id="递归分解"><a href="#递归分解" class="headerlink" title="递归分解"></a>递归分解</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211124220208261.png" alt="image-20211124220208261"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SumRecursiveMT</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RecursiveSumTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEQUENTIAL_CUTOFF = <span class="hljs-number">1000</span>;<br>        <span class="hljs-keyword">int</span> lo;<br>        <span class="hljs-keyword">int</span> hi;<br>        <span class="hljs-keyword">int</span>[] arr; <span class="hljs-comment">// arguments</span><br>        ExecutorService executorService;<br><br>        RecursiveSumTask( ExecutorService executorService, <span class="hljs-keyword">int</span>[] a, <span class="hljs-keyword">int</span> l, <span class="hljs-keyword">int</span> h) &#123;<br>            <span class="hljs-keyword">this</span>.executorService = executorService;<br>            <span class="hljs-keyword">this</span>.arr = a;<br>            <span class="hljs-keyword">this</span>.lo = l;<br>            <span class="hljs-keyword">this</span>.hi = h;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123; <span class="hljs-comment">// override</span><br>            System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] begin to compute %n&quot;</span>,<br>                    Thread.currentThread().getName(), lo, hi);<br>            <span class="hljs-keyword">long</span> result = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">if</span> (hi - lo &lt;= SEQUENTIAL_CUTOFF) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = lo; i &lt; hi; i++)<br>                    result += arr[i];<br><br>                System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] begin to finished %n&quot;</span>,<br>                        Thread.currentThread().getName(), lo, hi);<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                RecursiveSumTask left = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, lo, (hi + lo) / <span class="hljs-number">2</span>);<br>                RecursiveSumTask right = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, (hi + lo) / <span class="hljs-number">2</span>, hi);<br>                Future&lt;Long&gt; lr = executorService.submit(left);<br>                Future&lt;Long&gt; rr = executorService.submit(right);<br><br>                result = lr.get() + rr.get();<br>                System.out.format(<span class="hljs-string">&quot;%s range [%d-%d] finished to compute %n&quot;</span>,<br>                        Thread.currentThread().getName(), lo, hi);<br>            &#125;<br><br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">sum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> nofProcessors = Runtime.getRuntime().availableProcessors();<br>        <span class="hljs-comment">//ExecutorService executorService = Executors.newFixedThreadPool(nofProcessors);</span><br>        ExecutorService executorService = Executors.newCachedThreadPool();<br><br>        RecursiveSumTask task = <span class="hljs-keyword">new</span> RecursiveSumTask(executorService, arr, <span class="hljs-number">0</span>, arr.length);<br>        <span class="hljs-keyword">long</span> result =  executorService.submit(task).get();<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span>[] arr = Utils.buildRandomIntArray(<span class="hljs-number">200000</span>);<br>        System.out.printf(<span class="hljs-string">&quot;The array length is: %d\n&quot;</span>, arr.length);<br>        <span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br>        <span class="hljs-keyword">long</span> result = sum(arr);<br>        <span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>        System.out.printf(<span class="hljs-string">&quot;The result is: %d\n&quot;</span>, result);<br>        System.out.println(<span class="hljs-string">&quot;递归:&quot;</span>+ (end - begin));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="什么是Fork-Join框架？"><a href="#什么是Fork-Join框架？" class="headerlink" title="什么是Fork/Join框架？"></a>什么是Fork/Join框架？</h1><p>​        Fork/Join框架是Java7提供了的一个用于<strong>并行执行</strong>任务的框架，是一个把大任务分割成若干个小任务（互不依赖），最终汇总每个小任务结果后得到大任务结果的框架。</p>
<blockquote>
<p>​    对Java而言，对支持Concurrency(并发)/Parallelism(并行)的不断完善，明显地体现在优化并发与并行<br>Java 1 支持threads, locks, condition queues<br>Java 5 引入了 thread pools, blocking queues, concurrent collections<br>Java 7 加入了fork-join库<br>Java 8 加入了 parallel streams</p>
</blockquote>
<p>​        Fork就是把一个大任务切分为若干子任务并行的执行，Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。比如计算1+2+…..＋10000，可以分割成10个子任务，每个子任务分别对1000个数进行求和，最终汇总这10个子任务的结果。如下图所示：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211124203343127.png" alt="image-20211124203343127"></p>
<h2 id="Fork-Jion特性："><a href="#Fork-Jion特性：" class="headerlink" title="Fork/Jion特性："></a>Fork/Jion特性：</h2><p>1、ForkJoinPool不是为了替代ExecutorService，而是它的补充，在某些应用场景下性能比ExecutorService更好。（见JavaTip:When to use ForkJoinPool vs ExecutorService ）</p>
<p>2、ForkJoinPool 主要用于实现“分而治之”的算法，特别是分治之后递归调用的函数，例如quicksort等。</p>
<p>3、ForkJoinPool最适合的是计算密集型的任务，如果存在I/O，线程间同步，sleep()等会造成线程长时间阻塞的情况时，最好配合使用ManagedBlocker。</p>
<h2 id="ForkJoinPool框架主要类"><a href="#ForkJoinPool框架主要类" class="headerlink" title="ForkJoinPool框架主要类"></a>ForkJoinPool框架主要类</h2><p>​    <strong>ForkJoinPool</strong> 实现ForkJoin的线程池——对应ThreadPool<br>​        ForkJoinWorkerThread  实现ForkJoin的线程</p>
<p>   <strong>ForkJoinTask</strong><V>一个描述ForkJoin的抽象类——对应Runnable/Callable<br>        <strong>RecursiveAction</strong> 无返回结果的ForkJoinTask类似Runnable<br>        <strong>RecursiveTask<V></V></strong> 有返回结果的ForkJoinTask类似Callable<br>        <strong>CountedCompleter<T></T></strong> 在任务完成执行后会触发执行一个自定义的钩子函数    </V></p>
<h2 id="ForkJoinPool-提交任务"><a href="#ForkJoinPool-提交任务" class="headerlink" title="ForkJoinPool 提交任务"></a><strong>ForkJoinPool</strong> 提交任务</h2><table>
<thead>
<tr>
<th><strong>返回值</strong></th>
<th><strong>方法名</strong></th>
</tr>
</thead>
<tbody><tr>
<td>void</td>
<td><strong>execute(ForkJoinTask&lt;?&gt; task)<br>execute(Runnable task)</strong></td>
</tr>
<tr>
<td>T</td>
<td><strong>invoke(ForkJoinTask<T> task)</T></strong></td>
</tr>
<tr>
<td>List<T></T></td>
<td><strong>invokeAll(Collection&lt;? extends Callable<T>&gt; tasks)</T></strong></td>
</tr>
<tr>
<td>ForkJoinTask</td>
<td><strong>submit(ForkJoinTask<T> task)<br>submit(Callable<T> task)<br>submit(Runnable task)<br>submit(Runnable task, T result)</T></T></strong></td>
</tr>
</tbody></table>
<h2 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h2><p><strong>ForkJoinTask主要包括两个方法分别实现任务的分拆与合并：</strong></p>
<p>1、fork()类似于Thread.start()，但是它并不立即执行任务，而是将任务放入工作队列中<br>2、跟Thread.join()不同，ForkJoinTask的join()方法并不简单的阻塞线程<br>        利用工作线程运行其他任务<br>        当一个工作线程中调用join()，它将处理其他任务，直到注意到目标子任务已经完成 </p>
<table>
<thead>
<tr>
<th>ForkJoinTask<T></T></th>
<th>fork()–Arranges to asynchronously execute this task in the appropriate pool</th>
</tr>
</thead>
<tbody><tr>
<td><strong>V</strong></td>
<td><strong>join()–Returns the result of the computation when itis done</strong></td>
</tr>
</tbody></table>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125213137146.png"></p>
<h4 id="1、ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue"><a href="#1、ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue" class="headerlink" title="1、ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue"></a>1、<strong>ForkJoinPool中的所有的工作线程均有一个自己的工作队列WorkQueue</strong></h4><ul>
<li>双端队列（Deque) </li>
<li>从队头取任务</li>
<li>线程私有，不共享<br><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125223853349.png" alt="image-20211125223853349"></li>
</ul>
<h4 id="2、ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头"><a href="#2、ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头" class="headerlink" title="2、ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头"></a>2、<strong>ForkJoinTask中fork的子任务，将放入运行该任务的工作线程的队头</strong></h4><ul>
<li><p>工作线程以<strong>LIFO（LAST IN FIRST OUT）</strong>的顺序来处理它队列中的任务</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125223923062.png" alt="image-20211125223923062"></p>
</li>
</ul>
<h4 id="3、为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行"><a href="#3、为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行" class="headerlink" title="3、为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行"></a>3、<strong>为了最大化CPU利用率，空闲的线程将从其他线程的队列中“窃取”任务来执行</strong></h4><ul>
<li><p>从工作队列的队尾“窃取”任务，以减少竞争</p>
</li>
<li><p>任务的“窃取”是以**FIFO(FIRST IN FIRST OUT)**顺序进行的，因为先放入的任务往往表示更大的工作量</p>
</li>
</ul>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211125224015897.png" alt="image-20211125224015897"></p>
<h4 id="4、WorkQueue双端队列最小化任务“窃取”的竞争"><a href="#4、WorkQueue双端队列最小化任务“窃取”的竞争" class="headerlink" title="4、WorkQueue双端队列最小化任务“窃取”的竞争"></a>4、<strong>WorkQueue双端队列最小化任务“窃取”的竞争</strong></h4><ul>
<li>push()/pop()仅在其所有者工作线程中调用<ul>
<li>这些操作都是通过CAS来实现的，是Wait-free的</li>
</ul>
</li>
<li>poll() 则由其他工作线程来调用“窃取”任务<ul>
<li>可能不是wait-free</li>
</ul>
</li>
</ul>
<h4 id="5、异常处理"><a href="#5、异常处理" class="headerlink" title="5、异常处理"></a>5、<strong>异常处理</strong></h4><p>ForkJoinTask 在执行的时候可能会抛出异常，但是我们没办法在主线程里直接捕获异常，所以 ForkJoinTask 提供了 isCompletedAbnormally() 方法来检查任务是否已经抛出 异常或已经被取消了，并且可以通过 ForkJoinTask 的 getException 方法获取异常。示例 如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span>(task.isCompletedAbnormally())&#123; <br>	System.out.println(task.getException()); <br>&#125;<br></code></pre></td></tr></table></figure>

<p>getException 方法返回 Throwable 对象，如果任务被取消了则返回CancellationException。如果任务没有完成或者没有抛出异常则返回 null</p>
<h4 id="6、ForkJoinPool构造函数"><a href="#6、ForkJoinPool构造函数" class="headerlink" title="6、ForkJoinPool构造函数"></a>6、<strong>ForkJoinPool构造函数</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">ForkJoinPool</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parallelism,</span></span><br><span class="hljs-function"><span class="hljs-params">                     ForkJoinWorkerThreadFactory factory,</span></span><br><span class="hljs-function"><span class="hljs-params">                     UncaughtExceptionHandler handler,</span></span><br><span class="hljs-function"><span class="hljs-params">                     <span class="hljs-keyword">int</span> mode,</span></span><br><span class="hljs-function"><span class="hljs-params">                     String workerNamePrefix)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.workerNamePrefix = workerNamePrefix;<br>    <span class="hljs-keyword">this</span>.factory = factory;<br>    <span class="hljs-keyword">this</span>.ueh = handler;<br>    <span class="hljs-keyword">this</span>.config = (parallelism &amp; SMASK) | mode;<br>    <span class="hljs-keyword">long</span> np = (<span class="hljs-keyword">long</span>)(-parallelism); <span class="hljs-comment">// offset ctl counts</span><br>    <span class="hljs-keyword">this</span>.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重要参数解释<br>①parallelism：并行度（ the parallelism level），默认情况下跟我们机器的cpu个数保持 一致，使用 Runtime.getRuntime().availableProcessors()可以得到我们机器运行时可用的 CPU个数。 </p>
<p>②factory：创建新线程的工厂（ the factory for creating new threads）。默认情况下使 用ForkJoinWorkerThreadFactory defaultForkJoinWorkerThreadFactory。 </p>
<p>③handler：线程异常情况下的处理器（Thread.UncaughtExceptionHandler handler），该处理器在线程执行任务时由于某些无法预料到的错误而导致任务线程中断时 进行一些处理，默认情况为null。 </p>
<p>④asyncMode：这个参数要注意，在ForkJoinPool中，每一个工作线程都有一个独立的任 务队列，asyncMode表示工作线程内的任务队列是采用何种方式进行调度，可以是先进先 出FIFO，也可以是后进先出LIFO。如果为true，则线程池中的工作线程则使用先进先出方 式进行任务调度，默认情况下是false。</p>
<h4 id="7、ForkJoinTask-fork-方法"><a href="#7、ForkJoinTask-fork-方法" class="headerlink" title="7、ForkJoinTask fork 方法"></a><strong>7、ForkJoinTask fork 方法</strong></h4><p>fork() 做的工作只有一件事，既是把任务推入当前工作线程的工作队列里。可以参看以下的 源代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> ForkJoinTask&lt;V&gt; <span class="hljs-title">fork</span><span class="hljs-params">()</span> </span>&#123;<br>    Thread t;<br>    <span class="hljs-keyword">if</span> ((t = Thread.currentThread()) <span class="hljs-keyword">instanceof</span> ForkJoinWorkerThread)<br>        ((ForkJoinWorkerThread)t).workQueue.push(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">else</span><br>        ForkJoinPool.common.externalPush(<span class="hljs-keyword">this</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="8、ForkJoinTask-join-方法"><a href="#8、ForkJoinTask-join-方法" class="headerlink" title="8、ForkJoinTask join 方法"></a><strong>8、ForkJoinTask join 方法</strong></h4><p>join() 的工作则复杂得多，也是 join() 可以使得线程免于被阻塞的原因——不像同名 的 Thread.join()。</p>
<ol>
<li>检查调用 join() 的线程是否是 ForkJoinThread 线程。如果不是（例如 main 线 程），则阻塞当前线程，等待任务完成。如果是，则不阻塞。 </li>
<li> 查看任务的完成状态，如果已经完成，直接返回结果。</li>
<li>如果任务尚未完成，但处于自己的工作队列内，则完成它。 </li>
<li>如果任务已经被其他的工作线程偷走，则窃取这个小偷的工作队列内的任务 （以 FIFO 方式），执行，以期帮助它早日完成欲 join 的任务。 </li>
<li>如果偷走任务的小偷也已经把自己的任务全部做完，正在等待需要 join 的任务 时，则找到小偷的小偷，帮助它完成它的任务。</li>
<li>递归地执行第5步</li>
</ol>
<p><img src="images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127132444426.png" alt="image-20211127132444426"></p>
<h4 id="9、ForkJoinPool-submit-方法"><a href="#9、ForkJoinPool-submit-方法" class="headerlink" title="9、ForkJoinPool.submit 方法"></a>9、<strong>ForkJoinPool.submit 方法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">ForkJoinTask&lt;T&gt; <span class="hljs-title">submit</span><span class="hljs-params">(ForkJoinTask&lt;T&gt; task)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (task == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    externalPush(task);<br>    <span class="hljs-keyword">return</span> task;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>ForkJoinPool 自身拥有工作队列，这些工作队列的作用是用来接收由外部线程 （非 ForkJoinThread 线程）提交过来的任务，而这些工作队列被称 为 submitting queue 。 submit() 和 fork() 其实没有本质区别，只是提交对象变成了 submitting queue 而已（还有一些同步，初始化的操作）。</p>
<p>submitting queue 和其他 work queue 一样，是工作线程”窃取“的对象，因此当其中的任务被一个工作线程 成功窃取时，就意味着提交的任务真正开始进入执行阶段。</p>
<h4 id="10、Fork-Join框架执行流程"><a href="#10、Fork-Join框架执行流程" class="headerlink" title="10、Fork/Join框架执行流程"></a>10、Fork/Join框架执行流程</h4><p><img src="images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B08-ForkJoin%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/image-20211127132530364.png" alt="image-20211127132530364"></p>
<h2 id="RecursiveTask使用实例"><a href="#RecursiveTask使用实例" class="headerlink" title="RecursiveTask使用实例"></a>RecursiveTask使用实例</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongSumMain</span> </span>&#123;<br>	<span class="hljs-comment">/** for time conversion */</span><br><span class="hljs-comment">//获取逻辑处理器数量</span><br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> NCPU = Runtime.getRuntime().availableProcessors();<br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> calcSum;<br><br>	<span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> reportSteals = <span class="hljs-keyword">true</span>;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>		<span class="hljs-keyword">int</span>[] array = Utils.buildRandomIntArray(<span class="hljs-number">200000000</span>);<br>		System.out.println(<span class="hljs-string">&quot;cpu-num:&quot;</span>+NCPU);<br>		<span class="hljs-comment">//单线程下计算数组数据总和</span><br>		<span class="hljs-keyword">long</span> begin = System.currentTimeMillis();<br> 		calcSum = seqSum(array);<br>		<span class="hljs-keyword">long</span> end = System.currentTimeMillis();<br>		System.out.println(<span class="hljs-string">&quot;seq sum=&quot;</span> + calcSum);<br>		System.out.println(<span class="hljs-string">&quot;单线程:&quot;</span>+ (end - begin));<br><br>		<span class="hljs-comment">//采用fork/join方式将数组求和任务进行拆分执行，最后合并结果</span><br>		LongSum ls = <span class="hljs-keyword">new</span> LongSum(array, <span class="hljs-number">0</span>, array.length);<br>  		ForkJoinPool fjp  = <span class="hljs-keyword">new</span> ForkJoinPool(NCPU); <span class="hljs-comment">//使用的线程数</span><br>		begin = System.currentTimeMillis();<br>		ForkJoinTask&lt;Long&gt; task = fjp.submit(ls);<br>		System.out.println(<span class="hljs-string">&quot;forkjoin sum=&quot;</span> + task.get());<br>		end = System.currentTimeMillis();<br>		System.out.println(<span class="hljs-string">&quot;forkjoin:&quot;</span>+ (end - begin));<br>		<span class="hljs-keyword">if</span>(task.isCompletedAbnormally())&#123;<br>			System.out.println(task.getException());<br>		&#125;<br><br>		fjp.shutdown();<br><br>	&#125;<br><br><br>	<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> <span class="hljs-title">seqSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] array)</span> </span>&#123;<br>		<span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; array.length; ++i)<br>			sum += array[i];<br>		<span class="hljs-keyword">return</span> sum;<br>	&#125;<br>    <br><span class="hljs-comment">/**</span><br><span class="hljs-comment">RecursiveTask 并行计算，同步有返回值</span><br><span class="hljs-comment">ForkJoin框架处理的任务基本都能使用递归处理，比如求斐波那契数列等，但递归算法的缺陷是：</span><br><span class="hljs-comment">一只会只用单线程处理，</span><br><span class="hljs-comment">二是递归次数过多时会导致堆栈溢出；</span><br><span class="hljs-comment">ForkJoin解决了这两个问题，使用多线程并发处理，充分利用计算资源来提高效率，同时避免堆栈溢出发生。</span><br><span class="hljs-comment">当然像求斐波那契数列这种小问题直接使用线性算法搞定可能更简单，实际应用中完全没必要使用ForkJoin框架，</span><br><span class="hljs-comment">所以ForkJoin是核弹，是用来对付大家伙的，比如超大数组排序。</span><br><span class="hljs-comment">最佳应用场景：多核、多内存、可以分割计算再合并的计算密集型任务</span><br><span class="hljs-comment">*/</span><br>cpu-num:<span class="hljs-number">12</span><br>seq sum=<span class="hljs-number">9899269760</span><br>单线程:<span class="hljs-number">132</span><br>forkjoin sum=<span class="hljs-number">9899269760</span><br>forkjoin:<span class="hljs-number">106</span><br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LongSum</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RecursiveTask</span>&lt;<span class="hljs-title">Long</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> SEQUENTIAL_THRESHOLD = <span class="hljs-number">1000</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> NPS = (<span class="hljs-number">1000L</span> * <span class="hljs-number">1000</span> * <span class="hljs-number">1000</span>);<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> extraWork = <span class="hljs-keyword">true</span>; <span class="hljs-comment">// change to add more than just a sum</span><br><br><br>    <span class="hljs-keyword">int</span> low;<br>    <span class="hljs-keyword">int</span> high;<br>    <span class="hljs-keyword">int</span>[] array;<br><br>    LongSum(<span class="hljs-keyword">int</span>[] arr, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi) &#123;<br>        array = arr;<br>        low = lo;<br>        high = hi;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * fork()方法：将任务放入队列并安排异步执行，一个任务应该只调用一次fork()函数，除非已经执行完毕并重新初始化。</span><br><span class="hljs-comment">     * tryUnfork()方法：尝试把任务从队列中拿出单独处理，但不一定成功。</span><br><span class="hljs-comment">     * join()方法：等待计算完成并返回计算结果。</span><br><span class="hljs-comment">     * isCompletedAbnormally()方法：用于判断任务计算是否发生异常。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Long <span class="hljs-title">compute</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (high - low &lt;= SEQUENTIAL_THRESHOLD) &#123;<br>            <span class="hljs-keyword">long</span> sum = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = low; i &lt; high; ++i) &#123;<br>                sum += array[i];<br>            &#125;<br>            <span class="hljs-keyword">return</span> sum;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">int</span> mid = low + (high - low) / <span class="hljs-number">2</span>;<br>            LongSum left = <span class="hljs-keyword">new</span> LongSum(array, low, mid);<br>            LongSum right = <span class="hljs-keyword">new</span> LongSum(array, mid, high);<br>            left.fork();<br>            right.fork();<br>            <span class="hljs-keyword">long</span> rightAns = right.join();<br>            <span class="hljs-keyword">long</span> leftAns = left.join();<br>            <span class="hljs-keyword">return</span> leftAns + rightAns;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="ForkJoinPool-VS-ExecutorService"><a href="#ForkJoinPool-VS-ExecutorService" class="headerlink" title="ForkJoinPool VS ExecutorService"></a>ForkJoinPool VS ExecutorService</h2><p>1、<strong>ForkJoinPool 最适合的是计算密集型的任务</strong>，如果存在I/O，线程间同步，sleep() 等会造成线程长时间阻塞的情况时，最好配合使用ManagedBlocker;</p>
<p>2、<strong>Work-Stealing 的适用场景是不同的任务的耗时相差比较大</strong>，即某些任务需要运行较长时间，而某些任务会很快的运行完成，这种情况下用 Work-Stealing 很合适；</p>
<p>3、ForkJoinPool是<strong>分而治之</strong>的思想的体现</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>ForkJoi</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优02-Explain详解与索引最佳实践</title>
    <url>/2021/12/11/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</url>
    <content><![CDATA[<h1 id="Explain详解与索引最佳实践"><a href="#Explain详解与索引最佳实践" class="headerlink" title="Explain详解与索引最佳实践"></a>Explain详解与索引最佳实践</h1><h2 id="Explain工具介绍"><a href="#Explain工具介绍" class="headerlink" title="Explain工具介绍"></a>Explain工具介绍</h2><p>​    使用EXPLAIN关键字可以<strong>模拟优化器执行SQL语句</strong>，分析你的查询语句或是结构的性能瓶颈，在 select语句之前增加explain关键字，MySQL会在查询上设置一个标记，<strong>执行查询会返回执行计划的信息，而不是执行这条SQL</strong></p>
<p>​    注意：如果 from 中包含子查询，仍会执行该子查询，将结果放入临时表中</p>
<h2 id="Explain分析示例"><a href="#Explain分析示例" class="headerlink" title="Explain分析示例"></a>Explain分析示例</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">-- 示例表：</span><br><span class="hljs-comment">-- actor表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `actor`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `actor` (<br>    `id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">45</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY ( `id` )<br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `actor` ( `id`, `name`, `update_time` )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;2021-12-11 21:08:31&#x27;</span> ),<br>	( <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;2021-12-11 21:08:31&#x27;</span> ),<br>	( <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;2021-12-11 21:08:31&#x27;</span> );<br>	<br><span class="hljs-comment">-- film表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `film`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `film` (<br>    `id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>    `name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">10</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>    KEY `idx_name` ( `name` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `film` ( `id`, `name` )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-number">3</span>, <span class="hljs-string">&#x27;film0&#x27;</span> ),<br>	( <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;film1&#x27;</span> ),<br>	( <span class="hljs-number">2</span>, <span class="hljs-string">&#x27;film 2&#x27;</span> );<br><br><span class="hljs-comment">-- flim_actor表</span><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `film_actor`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `film_actor` (<br>    `id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `film_id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `actor_id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>    `remark` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">255</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>    <span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>    KEY `idx_film_actor_id` ( `film_id`, `actor_id` )<br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `film_actor` (`id`, `film_id`, `actor_id`) <span class="hljs-keyword">VALUES</span> (<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>), (<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>),(<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p><strong>explain select * from actor;</strong><br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211213633437.png" alt="image-20211211213633437"></p>
<p>在查询中的每个表会输出一行，如果有两个表通过 join 连接查询，那么会输出两行</p>
<h3 id="explain-两个变种"><a href="#explain-两个变种" class="headerlink" title="explain 两个变种"></a>explain 两个变种</h3><p>1）<strong>explain extended</strong>：会在 explain 的基础上额外提供一些查询优化的信息。紧随其后通 过 show warnings 命令可以得到优化后的查询语句，从而看出优化器优化了什么。额外还有 filtered 列，是一个半分比的值，rows * filtered/100 可以估算出将要和 explain 中前一个表 进行连接的行数（前一个表指 explain 中的id值比当前表id值小的表）。</p>
<p><strong>explain extended select * from film where id = 1;</strong> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211214335940.png" alt="image-20211211214335940"></p>
<p><strong>show warnings;</strong> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211214428788.png" alt="image-20211211214428788"></p>
<p>2）<strong>explain partitions</strong>：相比 explain 多了个 partitions 字段，如果查询是基于分区表的话，会显示查询将访问的分区。</p>
<h2 id="explain中的列"><a href="#explain中的列" class="headerlink" title="explain中的列"></a>explain中的列</h2><p>接下来我们将展示 explain 中每个列的信息。</p>
<h3 id="1、id列"><a href="#1、id列" class="headerlink" title="1、id列"></a>1、id列</h3><p>id列的编号是 select 的序列号，有几个 select 就有几个id，并且id的顺序是按 select 出现的顺序增长的。</p>
<p><strong>id列越大执行优先级越高，id相同则从上往下执行，id为NULL最后执行。</strong></p>
<h3 id="2、select-type列"><a href="#2、select-type列" class="headerlink" title="2、select_type列"></a>2、select_type列</h3><p>select_type 表示对应行是简单还是复杂的查询。 </p>
<p>1）<strong>simple</strong>：简单查询。查询不包含子查询和union </p>
<p>explain select * from film where id = 2; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211215053062.png" alt="image-20211211215053062"></p>
<p>2）<strong>primary</strong>：复杂查询中最外层的 select</p>
<p>3）<strong>subquery</strong>：包含在 select 中的子查询（不在 from 子句中） </p>
<p>4）<strong>derived</strong>：包含在 from 子句中的子查询。MySQL会将结果存放在一个临时表中，也称为 </p>
<p>派生表（derived的英文含义） 用这个例子来了解 primary、subquery 和 derived 类型 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">#关闭mysql5<span class="hljs-number">.7</span>新特性对衍生表的合并优化 <br><span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=off&#x27;</span>; <br>explain <span class="hljs-keyword">select</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> actor <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">from</span> (<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> film <span class="hljs-keyword">where</span> id <span class="hljs-operator">=</span> <span class="hljs-number">1</span>) der; <br>#还原默认配置 <br><span class="hljs-keyword">set</span> session optimizer_switch<span class="hljs-operator">=</span><span class="hljs-string">&#x27;derived_merge=on&#x27;</span>; <br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211215525618.png" alt="image-20211211215525618"></p>
<p>5）union：在 union 中的第二个和随后的 select </p>
<p>explain select 1 union all select 1</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211215544724.png" alt="image-20211211215544724"></p>
<h3 id="3、table列"><a href="#3、table列" class="headerlink" title="3、table列"></a>3、table列</h3><p>这一列表示 explain 的一行正在访问哪个表。 </p>
<p>当 from 子句中有子查询时，table列是 <derivenN> 格式，表示当前查询依赖 id=N 的查询，于是先执行 id=N 的查询。 </derivenN></p>
<p>当有 union 时，UNION RESULT 的 table 列的值为&lt;union1,2&gt;，1和2表示参与 union 的select 行id。 </p>
<h3 id="4、type列"><a href="#4、type列" class="headerlink" title="4、type列"></a>4、type列</h3><p>这一列表示关联类型或访问类型，即MySQL决定如何查找表中的行，查找数据行记录的大概 </p>
<p>范围。 </p>
<p>依次从最优到最差分别为：<strong>system &gt; const &gt; eq_ref &gt; ref &gt; range &gt; index &gt; ALL</strong> </p>
<p>一般来说，得保证查询达到range级别，最好达到ref </p>
<p><strong>NULL</strong>：mysql能够在优化阶段分解查询语句，在执行阶段用不着再访问表或索引。例如：在 </p>
<p>索引列中选取最小值，可以单独查找索引来完成，不需要在执行时访问表 </p>
<p>explain select min(id) from film;（id列刚好再索引列内）</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221009216.png" alt="image-20211211221009216"></p>
<p><strong>const, system</strong>：mysql能对查询的某部分进行优化并将其转化成一个常量（可以看show warnings 的结果。<br>用于 <strong>primary key 或 unique key</strong> 的所有列与常数比较时，<strong>所以表最多有一个匹配行</strong>，读取1次，速度比较快。system是const的特例，查询范围里表里只有一条元组匹配时为 system</p>
<p>explain extended select * from film where id = 1;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221743242.png" alt="image-20211211221743242">explain extended select * from (select * from film where id = 1) tmp; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221228877.png" alt="image-20211211221228877">show warnings;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211221246720.png" alt="image-20211211221246720"></p>
<p><strong>eq_ref</strong>：primary key 或 unique key 索引的所有部分<strong>被连接使用</strong> ，最多只会返回一条符合条件的记录。这可能是在 const 之外最好的联接类型了，简单的 select 查询不会出现这种type。<br>explain select * from film_actor left join film on film_actor.film_id = film.id;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211222109808.png" alt="image-20211211222109808"></p>
<p>ref：相比 eq_ref，不使用唯一索引，而是<strong>使用普通索引或者唯一性索引的部分前缀</strong>，索引要和某个值相比较，可能会找到多个符合条件的行。 </p>
<p><strong>1、简单 select 查询，name是普通索引（非唯一索引）</strong> </p>
<p>explain select * from film where name = ‘film1’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223431263.png" alt="image-20211211223431263"></p>
<p><strong>2、关联表查询，idx_film_actor_id是film_id和actor_id的联合索引，这里使用到了film_actor的左边前缀film_id部分。</strong> </p>
<p>explain select film_id from film left join film_actor on film.id = film_actor.film_id;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223453739.png" alt="image-20211211223453739"></p>
<p><strong>range</strong>：范围扫描通常出现在 in(), between ,&gt; ,&lt;, &gt;= 等操作中。使用一个索引来检索给定范围的行。 </p>
<p>explain select * from actor where id &gt; 1;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223553807.png" alt="image-20211211223553807"></p>
<p><strong>index</strong>：扫描全表索引，这通常比ALL快一<strong>（所有字段都在索引范围内）</strong></p>
<p>explain select * from film; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223615906.png" alt="image-20211211223615906"></p>
<p><strong>ALL</strong>：即全表扫描，意味着mysql需要从头到尾去查找所需要的行。通常情况下这需要增加索引来进行优化了 </p>
<p>explain select * from actor;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211223639660.png" alt="image-20211211223639660"></p>
<h3 id="5、possible-keys列"><a href="#5、possible-keys列" class="headerlink" title="5、possible_keys列"></a>5、possible_keys列</h3><p>这一列显示查询可能使用哪些索引来查找。 </p>
<p>explain 时可能出现 possible_keys 有列，而 key 显示 NULL 的情况，这种情况是因为表中数据不多，mysql认为索引对此查询帮助不大，选择了全表查询。如果该列是NULL，则没有相关的索引。在这种情况下，可以通过检查 where 子句看是否可以创造一个适当的索引来提高查询性能，然后用 explain 查看效果。 </p>
<h3 id="6、key列"><a href="#6、key列" class="headerlink" title="6、key列"></a>6、key列</h3><p>这一列显示mysql实际采用哪个索引来优化对该表的访问。 </p>
<p>如果没有使用索引，则该列是 NULL。如果想强制mysql使用或忽视possible_keys列中的索 </p>
<p>引，在查询中使用 force index、ignore index。<br><strong>explain select * from actor ignore index(PRIMARY) where id &gt; 1</strong><br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211224827205.png" alt="image-20211211224827205"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">explain <span class="hljs-keyword">select</span> f.<span class="hljs-operator">*</span>,fa.<span class="hljs-operator">*</span><br><span class="hljs-keyword">from</span> film f ignore index(<span class="hljs-keyword">PRIMARY</span>,idx_name) <br><span class="hljs-keyword">left</span> <span class="hljs-keyword">join</span> film_actor fa ignore index(idx_film_actor_id) <span class="hljs-keyword">on</span> fa.film_id <span class="hljs-operator">=</span> f.id<br><span class="hljs-keyword">where</span> f.id <span class="hljs-operator">&gt;</span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20221008230527859.png" alt="image-20221008230527859"></p>
<h3 id="7、key-len列"><a href="#7、key-len列" class="headerlink" title="7、key_len列"></a>7、key_len列</h3><p>这一列显示了mysql在索引里使用的字节数，通过这个值可以算出具体使用了索引中的哪些列。</p>
<p>举例来说，film_actor的联合索引 idx_film_actor_id 由 film_id 和 actor_id 两个int列组成， </p>
<p>并且每个int是4字节。通过结果中的key_len=4可推断出查询使用了第一个列：film_id列来执 </p>
<p>行索引查找。 </p>
<p>explain select * from film_actor where film_id = 2<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211224908363.png" alt="image-20211211224908363"></p>
<p>key_len计算规则如下： </p>
<ul>
<li>字符串 <ul>
<li>char(n)：n字节长度 </li>
<li>varchar(n)：2字节存储字符串长度，如果是utf-8，则长度 3n + 2</li>
</ul>
</li>
<li>数值类型<ul>
<li>tinyint：1字节 </li>
<li>smallint：2字节 </li>
<li>int：4字节 </li>
<li>bigint：8字节 </li>
</ul>
</li>
<li>时间类型<ul>
<li>date：3字节 </li>
<li>timestamp：4字节 </li>
<li>datetime：8字节 </li>
</ul>
</li>
<li>如果字段允许为 NULL，需要1字节记录是否为 NULL </li>
</ul>
<p>索引最大长度是768字节，当字符串过长时，mysql会做一个类似左前缀索引的处理，将前半部分的字符提取出来做索引。</p>
<p>explain select * from film_actor where film_id = 1<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230231364.png" alt="image-20211211230231364"></p>
<p>explain select * from film_actor where film_id = 1 and actor_id = 1<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230247482.png" alt="image-20211211230247482"></p>
<h3 id="8、ref列"><a href="#8、ref列" class="headerlink" title="8、ref列"></a>8、ref列</h3><p>这一列显示了在key列记录的索引中，表查找值所用到的列或常量，常见的有：const（常量），字段名（例：film.id） </p>
<h3 id="9、rows列"><a href="#9、rows列" class="headerlink" title="9、rows列"></a>9、rows列</h3><p>这一列是mysql估计要读取并检测的行数，注意这个不是结果集里的行数。 </p>
<h3 id="10、-Extra列"><a href="#10、-Extra列" class="headerlink" title="10、 Extra列"></a>10、 Extra列</h3><p>这一列展示的是额外信息。常见的重要值如下： </p>
<p>1）Using index：使用覆盖索引 </p>
<p>explain select film_id from film_actor where film_id = 1; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230656337.png" alt="image-20211211230656337"></p>
<p>2）Using where：使用 where 语句来处理结果，<strong>查询的列未被索引覆盖</strong> </p>
<p>explain select * from actor where name = ‘a’;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230707631.png" alt="image-20211211230707631"></p>
<p>3）Using index condition：<strong>查询的列不完全被索引覆盖</strong>，where条件中是一个前导列的范围；</p>
<p>explain select * from film_actor where film_id &gt; 1;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230818309.png" alt="image-20211211230818309"></p>
<p>4）Using temporary：mysql需要创建一张临时表来处理查询。出现这种情况一般是要进行 </p>
<p>优化的，首先是想到用索引来优化。 </p>
<p>1、actor.name没有索引，此时创建了张临时表来distinct </p>
<p>explain select distinct name from actor; </p>
<p>2、film.name建立了idx_name索引，此时查询时extra是using index,没有用临时表 </p>
<p>explain select distinct name from film; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211230955403.png" alt="image-20211211230955403"></p>
<p>5）Using filesort：将用外部排序而不是索引排序，数据较小时从内存排序，否则需要在磁盘完成排序。这种情况下一般也是要考虑使用索引来优化的。 </p>
<p>1、actor.name未创建索引，会浏览actor整个表，保存排序关键字name和对应的id，然后排序name并检索行记录 </p>
<p>explain select * from actor order by name; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211231636847.png" alt="image-20211211231636847"></p>
<p>2、film.name建立了idx_name索引,此时查询时extra是using index </p>
<p>explain select * from film order by name; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211231657103.png" alt="image-20211211231657103"></p>
<p>6）Select tables optimized away：<strong>使用某些聚合函数（比如 max、min）来访问存在索引的某个字段</strong></p>
<p>explain select min(id) from film; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211211231723599.png" alt="image-20211211231723599"></p>
<h2 id="索引最佳实践"><a href="#索引最佳实践" class="headerlink" title="索引最佳实践"></a>索引最佳实践</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">24</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`age` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`position` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>`hire_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_name_age_position` ( `name`, `age`, `position` ) <span class="hljs-keyword">USING</span> BTREE <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees ( NAME, age, position, hire_time )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-string">&#x27;LiLei&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;mana ger&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) );<br></code></pre></td></tr></table></figure>

<h3 id="1-全值匹配"><a href="#1-全值匹配" class="headerlink" title="1.全值匹配"></a>1.全值匹配</h3><p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212132754065.png" alt="image-20211212132754065"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212132810459.png" alt="image-20211212132810459"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212132821885.png" alt="image-20211212132821885"></p>
<h3 id="2-最左前缀法则"><a href="#2-最左前缀法则" class="headerlink" title="2.最左前缀法则"></a>2.最左前缀法则</h3><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列</p>
<p>EXPLAIN SELECT * FROM employees WHERE age = 22 AND position =’manager’;<br>EXPLAIN SELECT * FROM employees WHERE position = ‘manager’;<br>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212133112471.png" alt="image-20211212133112471"></p>
<h3 id="3-不在索引列上做任何操作"><a href="#3-不在索引列上做任何操作" class="headerlink" title="3.不在索引列上做任何操作"></a>3.不在索引列上做任何操作</h3><p>（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描</p>
<p>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’;<br>EXPLAIN SELECT * FROM employees WHERE left(name,3) = ‘LiLei’;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212133313784.png" alt="image-20211212133313784"></p>
<p>给hire_time增加一个普通索引： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">ADD</span> INDEX `idx_hire_time` (`hire_time`) <span class="hljs-keyword">USING</span> BTREE;<br></code></pre></td></tr></table></figure>

<p>EXPLAIN select * from employees where date(hire_time) =’2018-09-30’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212134448828.png" alt="image-20211212134448828"></p>
<p>转化为日期范围查询，会走索引,再还原最初索引状态 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">ADD</span> INDEX `idx_hire_time` (`hire_time`) <span class="hljs-keyword">USING</span> BTREE;<br>EXPLAIN <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> hire_time <span class="hljs-operator">&gt;=</span><span class="hljs-string">&#x27;2018-09-30 00:00:00&#x27;</span> <span class="hljs-keyword">and</span> hire_time <span class="hljs-operator">&lt;=</span><span class="hljs-string">&#x27;2018-09-30 23:59:59&#x27;</span>;<br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <span class="hljs-keyword">DROP</span> INDEX `idx_hire_time`;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212134848499.png" alt="image-20211212134848499"></p>
<h3 id="4-存储引擎不能使用索引中范围条件右边的列"><a href="#4-存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="4.存储引擎不能使用索引中范围条件右边的列"></a>4.存储引擎不能使用索引中范围条件右边的列</h3><p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 22 AND position =’manager’;</p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age &gt; 22 AND position =’manager’;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212135038639.png" alt="image-20211212135038639"></p>
<h3 id="5-尽量使用覆盖索引"><a href="#5-尽量使用覆盖索引" class="headerlink" title="5.尽量使用覆盖索引"></a>5.尽量使用覆盖索引</h3><p>（只访问索引的查询（索引列包含查询列）），减少select *语句 </p>
<p>EXPLAIN SELECT name,age FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212140701049.png" alt="image-20211212140701049"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name= ‘LiLei’ AND age = 23 AND position =’manager’;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212140533870.png" alt="image-20211212140533870"></p>
<h3 id="6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描"><a href="#6-mysql在使用不等于（！-或者-lt-gt-）的时候无法使用索引会导致全表扫描" class="headerlink" title="6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描"></a>6.mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</h3><p>EXPLAIN SELECT * FROM employees WHERE name != ‘LiLei’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212140732839.png" alt="image-20211212140732839"></p>
<p>走索引覆盖优化<br>EXPLAIN SELECT name  FROM employees WHERE name != ‘LiLei’;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141216350.png" alt="image-20211212141216350"></p>
<h3 id="7-is-null-is-not-null-也无法使用索引"><a href="#7-is-null-is-not-null-也无法使用索引" class="headerlink" title="7.is null,is not null 也无法使用索引"></a>7.is null,is not null 也无法使用索引</h3><p>EXPLAIN SELECT * FROM employees WHERE name is null </p>
<p>优化方案:字段定义not null且设置默认值</p>
<h3 id="8-like以通配符开头（’-abc…’）"><a href="#8-like以通配符开头（’-abc…’）" class="headerlink" title="8.like以通配符开头（’%abc…’）"></a>8.like以通配符开头（’%abc…’）</h3><p>​    mysql索引失效会变成全表扫描操作 </p>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘%Lei’<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141604151.png" alt="image-20211212141604151"></p>
<p>EXPLAIN SELECT * FROM employees WHERE name like ‘Lei%’<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141623205.png" alt="image-20211212141623205"></p>
<p>问题：解决like’%字符串%’索引不被使用的方法？ </p>
<p>a）使用覆盖索引，查询字段必须是建立覆盖索引字段 </p>
<p>EXPLAIN SELECT name,age,position FROM employees WHERE name like ‘%Lei%’;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141653284.png" alt="image-20211212141653284"></p>
<p>b）如果不能使用覆盖索引则可能需要借助搜索引擎 如：ES</p>
<h3 id="9-字符串不加单引号索引失效"><a href="#9-字符串不加单引号索引失效" class="headerlink" title="9.字符串不加单引号索引失效"></a>9.字符串不加单引号索引失效</h3><p>EXPLAIN SELECT * FROM employees WHERE name = ‘1000’;<br>EXPLAIN SELECT * FROM employees WHERE name = 1000;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212141729418.png" alt="image-20211212141729418"></p>
<h3 id="10-少用or或in"><a href="#10-少用or或in" class="headerlink" title="10.少用or或in"></a>10.少用or或in</h3><p>​    用它查询时，mysql不一定使用索引，mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引，详见范围查询优化 </p>
<p>EXPLAIN SELECT * FROM employees WHERE name = ‘LiLei’ or name = ‘HanMeimei’; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212142110215.png" alt="image-20211212142110215"></p>
<h3 id="11-范围查询优化"><a href="#11-范围查询优化" class="headerlink" title="11.范围查询优化"></a>11.范围查询优化</h3><p>给年龄添加单值索引 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">ADD</span> INDEX `idx_age` (`age`) <span class="hljs-keyword">USING</span> BTREE ; <br></code></pre></td></tr></table></figure>

<p>explain select * from employees where age &gt;=1 and age &lt;=2000;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212142353972.png" alt="image-20211212142353972"></p>
<p>没走索引原因：mysql内部优化器会根据检索比例、表大小等多个因素整体评估是否使用索引。比如这个例子，可能是由于单次数据量查询过大导致优化器最终选择不走索引<br>优化方法：可以讲大的范围拆分成多个小范围 </p>
<p>explain select * from employees where age &gt;=0 and age &lt;=10;<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212142511643.png" alt="image-20211212142511643"></p>
<p>还原最初索引状态 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">TABLE</span> `employees` <br><span class="hljs-keyword">DROP</span> INDEX `idx_age`; <br></code></pre></td></tr></table></figure>

<h2 id="索引使用总结："><a href="#索引使用总结：" class="headerlink" title="索引使用总结："></a>索引使用总结：</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9802-Explain%E8%AF%A6%E8%A7%A3%E4%B8%8E%E7%B4%A2%E5%BC%95%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/image-20211212212248730.png" alt="image-20211212212248730"></p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能调优</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优03-Mysql索引优化实战</title>
    <url>/2021/12/12/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h2 id="Mysql如何选择合适的索引"><a href="#Mysql如何选择合适的索引" class="headerlink" title="Mysql如何选择合适的索引"></a>Mysql如何选择合适的索引</h2><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">24</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`age` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`position` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>`hire_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时 间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_name_age_position` ( `name`, `age`, `position` ) <span class="hljs-keyword">USING</span> BTREE <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">4</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees ( NAME, age, position, hire_time )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-string">&#x27;LiLei&#x27;</span>, <span class="hljs-number">22</span>, <span class="hljs-string">&#x27;mana ger&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;HanMeimei&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) ),<br>	( <span class="hljs-string">&#x27;Lucy&#x27;</span>, <span class="hljs-number">23</span>, <span class="hljs-string">&#x27;dev&#x27;</span>, NOW( ) );<br></code></pre></td></tr></table></figure>

<p><strong>mysql&gt; EXPLAIN select * from employees where name &gt; ‘a’;</strong><br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212213552032.png" alt="image-20211212213552032"></p>
<p>如果用name索引需要遍历name字段联合索引树，然后还需要根据遍历出来的主键值去主键索引树里再去查出最终数据，成本比全表扫描还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下： </p>
<p>还高，可以用覆盖索引优化，这样只需要遍历name字段的联合索引树就能拿到所有结果，如下： </p>
<p><strong>mysql&gt; EXPLAIN select name,age,position from employees where name &gt; ‘a’ ;</strong> </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212213730591.png" alt="image-20211212213730591"></p>
<p><strong>mysql&gt; EXPLAIN select * from employees where name &gt; ‘zzz’ ;</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212214147100.png" alt="image-20211212214147100"></p>
<p>select * from employees where name &gt; ‘a’;<br>select * from employees where name &gt; ‘zzz’；</p>
<p>对于上面这两种 name&gt;’a’ 和 name&gt;’zzz’ 的执行结果，mysql最终是否选择走索引或者一张表涉及多个索引，mysql最终如何选择索引，我们可以用trace工具来一查究竟，开启trace工具会影响mysql性能，所以只能临时分析sql使用，用完之后立即关闭</p>
<h3 id="trace工具用法"><a href="#trace工具用法" class="headerlink" title="trace工具用法"></a>trace工具用法</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>; <span class="hljs-comment">-- 开启trace</span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;a&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE;<br><span class="hljs-comment">-- 结论：全表扫描的成本低于索引扫描，所以mysql最终选择全表扫描 </span><br>查看trace字段：<br>&#123;<br>  &quot;steps&quot;: [<br>    &#123;<br>      &quot;join_preparation&quot;: &#123;  -- 第一阶段：SQL准备阶段 10<br>        &quot;select#&quot;: <span class="hljs-number">1</span>,<br>        &quot;steps&quot;: [<br>          &#123;<br>            &quot;expanded_query&quot;: &quot;/* select#1 */ select `employees`.`id` AS `id`,`employees`.`name` AS `name`,`employees`.`age` AS `age`,`employees`.`position` AS `position`,`employees`.`hire_time` AS `hire_time` from `employees` where (`employees`.`name` &gt; &#x27;a&#x27;) order by `employees`.`position`&quot;<br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; /* join_preparation */<br>    &#125;,<br>    &#123;<br>      &quot;join_optimization&quot;: &#123;  -- 第二阶段：SQL优化阶段<br>        &quot;select#&quot;: <span class="hljs-number">1</span>,<br>        &quot;steps&quot;: [<br>          &#123;<br>            &quot;condition_processing&quot;: &#123; -- 条件处理<br>              &quot;condition&quot;: &quot;WHERE&quot;,<br>              &quot;original_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;,<br>              &quot;steps&quot;: [<br>                &#123;<br>                  &quot;transformation&quot;: &quot;equality_propagation&quot;,<br>                  &quot;resulting_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;,<br>                &#123;<br>                  &quot;transformation&quot;: &quot;constant_propagation&quot;,<br>                  &quot;resulting_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;,<br>                &#123;<br>                  &quot;transformation&quot;: &quot;trivial_condition_removal&quot;,<br>                  &quot;resulting_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;<br>              ] <span class="hljs-comment">/* steps */</span><br>            &#125; /* condition_processing */<br>          &#125;,<br>          &#123;<br>            &quot;substitute_generated_columns&quot;: &#123;<br>            &#125; /* substitute_generated_columns */<br>          &#125;,<br>          &#123;<br>            &quot;table_dependencies&quot;: [ <span class="hljs-comment">-- 表依赖详情</span><br>              &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;row_may_be_null&quot;: <span class="hljs-literal">false</span>,<br>                &quot;map_bit&quot;: <span class="hljs-number">0</span>,<br>                &quot;depends_on_map_bits&quot;: [<br>                ] <span class="hljs-comment">/* depends_on_map_bits */</span><br>              &#125;<br>            ] <span class="hljs-comment">/* table_dependencies */</span><br>          &#125;,<br>          &#123;<br>            &quot;ref_optimizer_key_uses&quot;: [<br>            ] <span class="hljs-comment">/* ref_optimizer_key_uses */</span><br>          &#125;,<br>          &#123;<br>            &quot;rows_estimation&quot;: [ <span class="hljs-comment">-- 预估表的访问成本</span><br>              &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;range_analysis&quot;: &#123;<br>                  &quot;table_scan&quot;: &#123; -- 全表扫描情况<br>                    &quot;rows&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">-- 扫描行数</span><br>                    &quot;cost&quot;: <span class="hljs-number">3.7</span> <span class="hljs-comment">-- 查询成本(相对值，同一个trace内部比较才有意义)</span><br>                  &#125; /* table_scan */,<br>                  &quot;potential_range_indexes&quot;: [ <span class="hljs-comment">-- 查询可能使用的索引</span><br>                    &#123;<br>                      &quot;index&quot;: &quot;PRIMARY&quot;, <span class="hljs-comment">-- 主键索引</span><br>                      &quot;usable&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 不采用</span><br>                      &quot;cause&quot;: &quot;not_applicable&quot;<br>                    &#125;,<br>                    &#123;<br>                      &quot;index&quot;: &quot;idx_name_age_position&quot;, <span class="hljs-comment">-- 其他辅助索引</span><br>                      &quot;usable&quot;: <span class="hljs-literal">true</span>, <span class="hljs-comment">-- 采用</span><br>                      &quot;key_parts&quot;: [<br>                        &quot;name&quot;,<br>                        &quot;age&quot;,<br>                        &quot;position&quot;,<br>                        &quot;id&quot;<br>                      ] <span class="hljs-comment">/* key_parts */</span><br>                    &#125;,<br>                    &#123;<br>                      &quot;index&quot;: &quot;idx_age&quot;,<br>                      &quot;usable&quot;: <span class="hljs-literal">false</span>,<br>                      &quot;cause&quot;: &quot;not_applicable&quot;<br>                    &#125;<br>                  ] <span class="hljs-comment">/* potential_range_indexes */</span>, <br>                  &quot;setup_range_conditions&quot;: [<br>                  ] <span class="hljs-comment">/* setup_range_conditions */</span>,<br>                  &quot;group_index_range&quot;: &#123;<br>                    &quot;chosen&quot;: <span class="hljs-literal">false</span>,<br>                    &quot;cause&quot;: &quot;not_group_by_or_distinct&quot;<br>                  &#125; /* group_index_range */,<br>                  &quot;analyzing_range_alternatives&quot;: &#123; -- 分析各个索引使用成本<br>                    &quot;range_scan_alternatives&quot;: [<br>                      &#123;<br>                        &quot;index&quot;: &quot;idx_name_age_position&quot;,<br>                        &quot;ranges&quot;: [<br>                          &quot;a &lt; name&quot;<br>                        ] <span class="hljs-comment">/* ranges */</span>,<br>                        &quot;index_dives_for_eq_ranges&quot;: <span class="hljs-literal">true</span>,<br>                        &quot;rowid_ordered&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 使用该索引获取的记录是否按照主键排序</span><br>                        &quot;using_mrr&quot;: <span class="hljs-literal">false</span>,<br>                        &quot;index_only&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 是否使用覆盖索引</span><br>                        &quot;rows&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">-- 索引扫描行数</span><br>                        &quot;cost&quot;: <span class="hljs-number">4.61</span>,<span class="hljs-comment">-- 索引使用成本</span><br>                        &quot;chosen&quot;: <span class="hljs-literal">false</span>, <span class="hljs-comment">-- 是否选择该索引</span><br>                        &quot;cause&quot;: &quot;cost&quot; <span class="hljs-comment">-- 原因：耗时成本</span><br>                      &#125;<br>                    ] <span class="hljs-comment">/* range_scan_alternatives */</span>,<br>                    &quot;analyzing_roworder_intersect&quot;: &#123;<br>                      &quot;usable&quot;: <span class="hljs-literal">false</span>,<br>                      &quot;cause&quot;: &quot;too_few_roworder_scans&quot;<br>                    &#125; /* analyzing_roworder_intersect */<br>                  &#125; /* analyzing_range_alternatives */<br>                &#125; /* range_analysis */<br>              &#125;<br>            ] <span class="hljs-comment">/* rows_estimation */</span><br>          &#125;,<br>          &#123;<br>            &quot;considered_execution_plans&quot;: [<br>              &#123;<br>                &quot;plan_prefix&quot;: [<br>                ] <span class="hljs-comment">/* plan_prefix */</span>,<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;best_access_path&quot;: &#123; -- 最优访问路径<br>                  &quot;considered_access_paths&quot;: [ <span class="hljs-comment">-- 最终选择的访问路径 </span><br>                    &#123;<br>                      &quot;rows_to_scan&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">-- 访问类型：为scan，全表扫描</span><br>                      &quot;access_type&quot;: &quot;scan&quot;,<br>                      &quot;resulting_rows&quot;: <span class="hljs-number">3</span>,<br>                      &quot;cost&quot;: <span class="hljs-number">1.6</span>,<br>                      &quot;chosen&quot;: <span class="hljs-literal">true</span>,  <span class="hljs-comment">-- 确定选择</span><br>                      &quot;use_tmp_table&quot;: <span class="hljs-literal">true</span><br>                    &#125;<br>                  ] <span class="hljs-comment">/* considered_access_paths */</span><br>                &#125; /* best_access_path */,<br>                &quot;condition_filtering_pct&quot;: <span class="hljs-number">100</span>,<br>                &quot;rows_for_plan&quot;: <span class="hljs-number">3</span>,<br>                &quot;cost_for_plan&quot;: <span class="hljs-number">1.6</span>,<br>                &quot;sort_cost&quot;: <span class="hljs-number">3</span>,<br>                &quot;new_cost_for_plan&quot;: <span class="hljs-number">4.6</span>,<br>                &quot;chosen&quot;: <span class="hljs-literal">true</span><br>              &#125;<br>            ] <span class="hljs-comment">/* considered_execution_plans */</span><br>          &#125;,<br>          &#123;<br>            &quot;attaching_conditions_to_tables&quot;: &#123;<br>              &quot;original_condition&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;,<br>              &quot;attached_conditions_computation&quot;: [<br>              ] <span class="hljs-comment">/* attached_conditions_computation */</span>,<br>              &quot;attached_conditions_summary&quot;: [<br>                &#123;<br>                  &quot;table&quot;: &quot;`employees`&quot;,<br>                  &quot;attached&quot;: &quot;(`employees`.`name` &gt; &#x27;a&#x27;)&quot;<br>                &#125;<br>              ] <span class="hljs-comment">/* attached_conditions_summary */</span><br>            &#125; /* attaching_conditions_to_tables */<br>          &#125;,<br>          &#123;<br>            &quot;clause_processing&quot;: &#123;<br>              &quot;clause&quot;: &quot;ORDER BY&quot;,<br>              &quot;original_clause&quot;: &quot;`employees`.`position`&quot;,<br>              &quot;items&quot;: [<br>                &#123;<br>                  &quot;item&quot;: &quot;`employees`.`position`&quot;<br>                &#125;<br>              ] <span class="hljs-comment">/* items */</span>,<br>              &quot;resulting_clause_is_simple&quot;: <span class="hljs-literal">true</span>,<br>              &quot;resulting_clause&quot;: &quot;`employees`.`position`&quot;<br>            &#125; /* clause_processing */<br>          &#125;,<br>          &#123;<br>            &quot;reconsidering_access_paths_for_index_ordering&quot;: &#123;<br>              &quot;clause&quot;: &quot;ORDER BY&quot;,<br>              &quot;index_order_summary&quot;: &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;index_provides_order&quot;: <span class="hljs-literal">false</span>,<br>                &quot;order_direction&quot;: &quot;undefined&quot;,<br>                &quot;index&quot;: &quot;unknown&quot;,<br>                &quot;plan_changed&quot;: <span class="hljs-literal">false</span><br>              &#125; /* index_order_summary */<br>            &#125; /* reconsidering_access_paths_for_index_ordering */<br>          &#125;,<br>          &#123;<br>            &quot;refine_plan&quot;: [<br>              &#123;<br>                &quot;table&quot;: &quot;`employees`&quot;<br>              &#125;<br>            ] <span class="hljs-comment">/* refine_plan */</span><br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; /* join_optimization */<br>    &#125;,<br>    &#123;<br>      &quot;join_execution&quot;: &#123;<br>        &quot;select#&quot;: <span class="hljs-number">1</span>,<br>        &quot;steps&quot;: [<br>          &#123;<br>            &quot;filesort_information&quot;: [<br>              &#123;<br>                &quot;direction&quot;: &quot;asc&quot;,<br>                &quot;table&quot;: &quot;`employees`&quot;,<br>                &quot;field&quot;: &quot;position&quot;<br>              &#125;<br>            ] <span class="hljs-comment">/* filesort_information */</span>,<br>            &quot;filesort_priority_queue_optimization&quot;: &#123;<br>              &quot;usable&quot;: <span class="hljs-literal">false</span>,<br>              &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot;<br>            &#125; /* filesort_priority_queue_optimization */,<br>            &quot;filesort_execution&quot;: [<br>            ] <span class="hljs-comment">/* filesort_execution */</span>,<br>            &quot;filesort_summary&quot;: &#123;<br>              &quot;rows&quot;: <span class="hljs-number">3</span>,<br>              &quot;examined_rows&quot;: <span class="hljs-number">3</span>,<br>              &quot;number_of_tmp_files&quot;: <span class="hljs-number">0</span>,<br>              &quot;sort_buffer_size&quot;: <span class="hljs-number">200704</span>,<br>              &quot;sort_mode&quot;: &quot;&lt;sort_key, packed_additional_fields&gt;&quot;<br>            &#125; /* filesort_summary */<br>          &#125;<br>        ] <span class="hljs-comment">/* steps */</span><br>      &#125; /* join_execution */<br>    &#125;<br>  ] <span class="hljs-comment">/* steps */</span><br>&#125;<br><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">&gt;</span> <span class="hljs-string">&#x27;zzz&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> information_schema.OPTIMIZER_TRACE; <br><span class="hljs-comment">-- 查看trace字段可知索引扫描的成本低于全表扫描，所以mysql最终选择索引扫描 </span><br><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=off&quot;; <span class="hljs-comment">-- 关闭trace</span><br><br></code></pre></td></tr></table></figure>

<h2 id="常见sql深入优化"><a href="#常见sql深入优化" class="headerlink" title="常见sql深入优化"></a>常见sql深入优化</h2><h3 id="Order-by与Group-by优化"><a href="#Order-by与Group-by优化" class="headerlink" title="Order by与Group by优化"></a>Order by与Group by优化</h3><h4 id="Case1："><a href="#Case1：" class="headerlink" title="Case1："></a>Case1：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221238882.png" alt="image-20211212221238882"></p>
<p>分析：利用最左前缀法则：中间字段不能断，因此查询用到了name索引，从key_len=74也能看出，age索引列用 </p>
<p>在排序过程中，因为Extra字段里没有using filesort </p>
<h4 id="Case-2："><a href="#Case-2：" class="headerlink" title="Case 2："></a>Case 2：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221451865.png" alt="image-20211212221451865"> </p>
<p>分析： 从explain的执行结果来看：key_len=74，查询使用了name索引，由于用了position进行排序，跳过了 </p>
<p>age，出现了<strong>Using filesort</strong>。 </p>
<h4 id="Case-3："><a href="#Case-3：" class="headerlink" title="Case 3："></a>Case 3：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221554635.png"></p>
<p>分析： 查找只用到索引name，age和position用于排序，无Using filesort。 </p>
<h4 id="Case-4："><a href="#Case-4：" class="headerlink" title="Case 4："></a>Case 4：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212221654266.png"></p>
<p>分析： 和Case 3中explain的执行结果一样，但是出现了Using filesort，因为索引的创建顺序为 name,age,position，但是排序的时候age和position颠倒位置了。 </p>
<h4 id="Case-5："><a href="#Case-5：" class="headerlink" title="Case 5："></a>Case 5：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212222142762.png" alt="image-20211212222142762"></p>
<p>分析： <strong>与Case 4对比，在Extra中并未出现Using filesort，因为age为常量，在排序中被优化，所以索引未颠倒，不会出现Using filesort。</strong> </p>
<h4 id="Case-6："><a href="#Case-6：" class="headerlink" title="Case 6："></a>Case 6：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212222333327.png" alt="image-20211212222333327"></p>
<p>分析： 虽然排序的字段列与索引顺序一样，且order by默认升序，这里position desc变成了降序，<strong>导致与索引的</strong> </p>
<p><strong>排序方式不同</strong>，从而产生Using filesort。Mysql8以上版本有降序索引可以支持该种查询方式。 </p>
<h4 id="Case-7："><a href="#Case-7：" class="headerlink" title="Case 7："></a>Case 7：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212222622724.png" alt="image-20211212222622724"></p>
<p>分析：对于排序来说，多个相等条件也是范围查询 </p>
<h4 id="Case-8："><a href="#Case-8：" class="headerlink" title="Case 8："></a>Case 8：</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212223349317.png" alt="image-20211212223349317"> </p>
<p>可以用覆盖索引优化 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212223626651.png" alt="image-20211212223626651"></p>
<p>也可以用 force index 强制使用索引</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211212223536584.png" alt="image-20211212223536584"></p>
<h3 id="优化总结"><a href="#优化总结" class="headerlink" title="优化总结"></a>优化总结</h3><p>1、MySQL支持两种方式的排序<strong>filesort</strong>和<strong>index</strong>，Using index是指MySQL扫描索引本身完成排序。index 效率高，filesort效率低。</p>
<p>2、order by满足两种情况会使用Using index。 </p>
<p>​    1) order by语句使用索引<strong>最左前列</strong>。 </p>
<p>​    2) 使用where子句与order by子句条件列<strong>组合满足索引最左前列</strong></p>
<p>3、尽量在索引列上完成排序，遵循索引建立（索引创建的顺序）时的最左前缀法则。 </p>
<p>4、如果order by的条件不在索引列上，就会产生Using filesort。 </p>
<p>5、能用覆盖索引尽量用覆盖索引 （即查询的所有列被组合索引的字段包含）</p>
<p>6、group by与order by很类似，其实质是<strong>先排序后分组</strong>，遵照索引创建顺序的最左前缀法则。对于group by的优化如果不需要排序的可以加上<strong>order by null禁止排序</strong>。注意，where高于having，能写在where中 的限定条件就不要去having限定了。</p>
<h3 id="1、Using-filesort文件排序原理详解"><a href="#1、Using-filesort文件排序原理详解" class="headerlink" title="1、Using filesort文件排序原理详解"></a>1、Using filesort文件排序原理详解</h3><h4 id="filesort文件排序方式"><a href="#filesort文件排序方式" class="headerlink" title="filesort文件排序方式"></a>filesort文件排序方式</h4><h5 id="单路排序"><a href="#单路排序" class="headerlink" title="单路排序"></a>单路排序</h5><p>​    是一次性取出满足条件行的所有字段，然后在sort buffer中进行排序；用trace工具可 以看到sort_mode信息里显示&lt; sort_key, additional_fields &gt;或者&lt; sort_key, packed_additional_fields &gt;</p>
<h5 id="双路排序（又叫回表排序模式）"><a href="#双路排序（又叫回表排序模式）" class="headerlink" title="双路排序（又叫回表排序模式）"></a>双路排序（又叫<strong>回表</strong>排序模式）</h5><p>​    是首先根据相应的条件取出相应的<strong>排序字段</strong>和<strong>可以直接定位行数据的行ID</strong>，然后在 sort buffer 中进行排序，排序完后需要再次取回其它需要的字段；用trace工具 </p>
<p>可以看到sort_mode信息里显示&lt; sort_key, rowid &gt; </p>
<h5 id="max-length-for-sort-data"><a href="#max-length-for-sort-data" class="headerlink" title="max_length_for_sort_data"></a>max_length_for_sort_data</h5><p>​    MySQL 通过比较系统变量 max_length_for_sort_data(<strong>默认1024字节</strong>) 的大小和需要查询的字段总大小来判断使用哪种排序模式。<br>​    如果 max_length_for_sort_data 比查询字段的总长度大，那么使用 单路排序模式；<br>​    如果 max_length_for_sort_data 比查询字段的总长度小，那么使用 双路排序模式。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=on&quot;,end_markers_in_json<span class="hljs-operator">=</span><span class="hljs-keyword">on</span>; <span class="hljs-comment">-- 开启trace </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhuge&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.OPTIMIZER_TRACE;<br>trace排序部分结果： <br><br>&quot;join_execution&quot;: &#123; --Sql执行阶段 <br>&quot;select#&quot;: <span class="hljs-number">1</span>, <br>&quot;steps&quot;: [ <br>&#123; <br> &quot;filesort_information&quot;: [ <br> &#123; <br> &quot;direction&quot;: &quot;asc&quot;, <br> &quot;table&quot;: &quot;`employees`&quot;, <br> &quot;field&quot;: &quot;position&quot; <br> &#125; <br> ] <span class="hljs-comment">/* filesort_information */</span>, <br> &quot;filesort_priority_queue_optimization&quot;: &#123; <br> &quot;usable&quot;: <span class="hljs-literal">false</span>, <br> &quot;cause&quot;: &quot;not applicable (no LIMIT)&quot; <br> &#125; /* filesort_priority_queue_optimization */, <br> &quot;filesort_execution&quot;: [ <br> ] <span class="hljs-comment">/* filesort_execution */</span>, <br> &quot;filesort_summary&quot;: &#123; --文件排序信息 <br> &quot;rows&quot;: <span class="hljs-number">10000</span>, <span class="hljs-comment">--预计扫描行数 </span><br> &quot;examined_rows&quot;: <span class="hljs-number">10000</span>, <span class="hljs-comment">--参数排序的行 </span><br> &quot;number_of_tmp_files&quot;: <span class="hljs-number">3</span>, <span class="hljs-comment">--使用临时文件的个数，这个值如果为0代表全部使用的sort_buffer内存排序，否则使用的 磁盘文件排序 </span><br> &quot;sort_buffer_size&quot;: <span class="hljs-number">262056</span>, <span class="hljs-comment">--排序缓存的大小 </span><br> &quot;sort_mode&quot;: &quot;&lt;sort_key, packed_additional_fields&gt;&quot; <span class="hljs-comment">--排序方式，这里用的单路排序 </span><br>&#125; /* filesort_summary */ <br> &#125; <br>] <span class="hljs-comment">/* steps */</span> <br>&#125; /* join_execution */ <br><br><br><span class="hljs-keyword">set</span> max_length_for_sort_data <span class="hljs-operator">=</span> <span class="hljs-number">10</span>; <span class="hljs-comment">--employees表所有字段长度总和肯定大于10字节 </span><br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> employees <span class="hljs-keyword">where</span> name <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;zhuge&#x27;</span> <span class="hljs-keyword">order</span> <span class="hljs-keyword">by</span> position; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> information_schema.OPTIMIZER_TRACE;<br><br>trace排序部分结果： <br>&quot;join_execution&quot;: &#123; <br>&quot;select#&quot;: <span class="hljs-number">1</span>,<br>&quot;steps&quot;: [ <br>&#123; <br>&quot;filesort_information&quot;: [ <br>&#123; <br>&quot;direction&quot;: &quot;asc&quot;, <br>&quot;table&quot;: &quot;`employees`&quot;, <br>&quot;field&quot;: &quot;position&quot; <br>&#125; <br>] <span class="hljs-comment">/* filesort_information */</span>, <br>&quot;filesort_priority_queue_optimization&quot;: &#123; <br>&quot;usable&quot;: <span class="hljs-literal">false</span>, <br>&quot;cause&quot;: &quot;not applicable (no LIMIT)&quot; <br>&#125; /* filesort_priority_queue_optimization */, <br>&quot;filesort_execution&quot;: [ <br>] <span class="hljs-comment">/* filesort_execution */</span>, <br>&quot;filesort_summary&quot;: &#123; <br>&quot;rows&quot;: <span class="hljs-number">10000</span>, <br>&quot;examined_rows&quot;: <span class="hljs-number">10000</span>, <br>&quot;number_of_tmp_files&quot;: <span class="hljs-number">2</span>, <br>&quot;sort_buffer_size&quot;: <span class="hljs-number">262136</span>, <br>&quot;sort_mode&quot;: &quot;&lt;sort_key, rowid&gt;&quot; <span class="hljs-comment">--排序方式，这里用的双路排序 </span><br>&#125; /* filesort_summary */ <br>&#125; <br>] <span class="hljs-comment">/* steps */</span> <br>&#125; /* join_execution */ <br><br><br><span class="hljs-keyword">set</span> session optimizer_trace<span class="hljs-operator">=</span>&quot;enabled=off&quot;; <span class="hljs-comment">--关闭trace</span><br></code></pre></td></tr></table></figure>

<h3 id="2、分页查询优化"><a href="#2、分页查询优化" class="headerlink" title="2、分页查询优化"></a>2、分页查询优化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> employees;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `employees` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`name` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">24</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;姓名&#x27;</span>,<br>`age` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;0&#x27;</span> COMMENT <span class="hljs-string">&#x27;年龄&#x27;</span>,<br>`position` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-string">&#x27;&#x27;</span> COMMENT <span class="hljs-string">&#x27;职位&#x27;</span>,<br>`hire_time` <span class="hljs-type">TIMESTAMP</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <span class="hljs-keyword">DEFAULT</span> <span class="hljs-built_in">CURRENT_TIMESTAMP</span> COMMENT <span class="hljs-string">&#x27;入职时间&#x27;</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_name_age_position` ( `name`, `age`, `position` ) <span class="hljs-keyword">USING</span> BTREE <br>) ENGINE <span class="hljs-operator">=</span> INNODB AUTO_INCREMENT <span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8 COMMENT <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;员工记录表&#x27;</span>;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> insert_emp;<br>delimiter;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp ( ) <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span><br>		i <span class="hljs-type">INT</span>;	<br>	<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	WHILE<br>			( i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100000</span> ) DO<br>			<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> employees ( NAME, age, position )<br>		<span class="hljs-keyword">VALUES</span><br>			( CONCAT( <span class="hljs-string">&#x27;zhuge&#x27;</span>, i ), i, <span class="hljs-string">&#x27;dev&#x27;</span> );	<br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;		<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">END</span>;;<br>delimiter;<br><span class="hljs-keyword">CALL</span> insert_emp ( );<br></code></pre></td></tr></table></figure>

<p>很多时候我们业务系统实现分页功能可能会用如下sql实现<br>    select * from employees limit 10000,10;<br>表示从表 employees 中取出从 10001 行开始的 10 行记录。看似只查询了 10 条记录，实际这条 SQL 是先读取 10010 条记录，然后抛弃前 10000 条记录，然后读到后面 10 条想要的数据。因此要查询一张大表比较靠后的数据，执行效率 是非常低的。</p>
<h4 id="1、根据自增且连续的主键排序的分页查询"><a href="#1、根据自增且连续的主键排序的分页查询" class="headerlink" title="1、根据自增且连续的主键排序的分页查询"></a>1、根据自增且连续的主键排序的分页查询</h4><p>select * from employees limit 90000,5;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216224501539.png" alt="image-20211216224501539"></p>
<p>select * from employees where id &gt; 90000 limit 5;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216231835906.png" alt="image-20211216231835906"></p>
<p>显然改写后的 SQL 走了索引，而且扫描的行数大大减少，执行效率更高。 但是，这条改写的SQL 在很多场景并<strong>不实用</strong>，因为表中可能某些记录被删后，主键空缺，导致结果不一致，如下图试验 所示（先删除一条前面的记录，然后再测试原 SQL 和优化后的 SQL）：</p>
<p>​    两条 SQL 的结果并不一样，因此，如果主键不连续，不能使用上面描述的优化方法。 另外如果原 SQL 是 order by 非主键的字段，按照上面说的方法改写会导致两条 SQL 的结果不一致。所以这种改写得满 足以下两个条件：</p>
<p>​    1、主键自增且连续 </p>
<p>​    2、结果是按照主键排序的</p>
<h4 id="2、根据非主键字段排序的分页查询"><a href="#2、根据非主键字段排序的分页查询" class="headerlink" title="2、根据非主键字段排序的分页查询"></a>2、根据非主键字段排序的分页查询</h4><p>EXPLAIN select * from employees ORDER BY name limit 90000,5; </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216232215527.png" alt="image-20211216232215527"><br>Explain select * from employees e inner join (select id from employees order by name limit 90000,5) ed on e.id = ed.id;<br>    发现并没有使用 name 字段的索引（key 字段对应的值为 null），具体原因上文讲过：扫描整个索引并查找到没索引的行(可能要遍历多个索引树)的成本比扫描全表的成本更高，所以优化器放弃使用索引。 知道不走索引的原因，那么怎么优化呢？ 其实关键是<strong>让排序时返回的字段尽可能少（索引覆盖）</strong>，所以可以让排序和分页操作先查出主键，然后根据主键查到对应的记录</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211216232245214.png" alt="image-20211216232245214"></p>
<p>原SQL 使用的是 filesort 排序，而优化后的 SQL 使用的是索引排序。 </p>
<h3 id="3、Join关联查询优化"><a href="#3、Join关联查询优化" class="headerlink" title="3、Join关联查询优化"></a>3、Join关联查询优化</h3><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `t1` (<br>`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>`a` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>`b` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br><span class="hljs-keyword">PRIMARY</span> KEY ( `id` ),<br>KEY `idx_a` ( `a` ) <br>) ENGINE <span class="hljs-operator">=</span> INNODB <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> t2 <span class="hljs-keyword">LIKE</span> t1;<br><span class="hljs-comment">-- 往t2表插入100行记录</span><br><span class="hljs-keyword">truncate</span> t2;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> insert_emp;<br>delimiter;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp ( ) <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span><br>		i <span class="hljs-type">INT</span>;	<br>	<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	WHILE<br>			( i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span> ) DO<br>			<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t2 ( a, b )<br>		<span class="hljs-keyword">VALUES</span><br>			( i, i<span class="hljs-operator">*</span>i );	<br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;		<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">END</span>;;<br>delimiter;<br><span class="hljs-keyword">CALL</span> insert_emp ( );<br><span class="hljs-comment">-- 往t1表插入1万行记录</span><br><span class="hljs-keyword">truncate</span> t1;<br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">PROCEDURE</span><br>IF<br>	<span class="hljs-keyword">EXISTS</span> insert_emp;<br>delimiter;;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">PROCEDURE</span> insert_emp ( ) <span class="hljs-keyword">BEGIN</span><br><span class="hljs-keyword">DECLARE</span><br>		i <span class="hljs-type">INT</span>;	<br>	<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;<br>	WHILE<br>			( i <span class="hljs-operator">&lt;=</span> <span class="hljs-number">100</span> ) DO<br>			<span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> t1 ( a, b )<br>		<span class="hljs-keyword">VALUES</span><br>			( i, i<span class="hljs-operator">*</span>i );	<br>		<span class="hljs-keyword">SET</span> i <span class="hljs-operator">=</span> i <span class="hljs-operator">+</span> <span class="hljs-number">1</span>;		<br>	<span class="hljs-keyword">END</span> WHILE;<br>	<span class="hljs-keyword">END</span>;;<br>delimiter;<br><span class="hljs-keyword">CALL</span> insert_emp ( );<br></code></pre></td></tr></table></figure>

<h4 id="1、mysql的表关联常见有两种算法"><a href="#1、mysql的表关联常见有两种算法" class="headerlink" title="1、mysql的表关联常见有两种算法"></a>1、mysql的表关联常见有两种算法</h4><p>1、Nested-Loop Join 算法 </p>
<p>2、Block Nested-Loop Join 算法 </p>
<h5 id="1、-嵌套循环连接-Nested-Loop-Join-NLJ-算法"><a href="#1、-嵌套循环连接-Nested-Loop-Join-NLJ-算法" class="headerlink" title="1、 嵌套循环连接 Nested-Loop Join(NLJ) 算法"></a>1、 嵌套循环连接 Nested-Loop Join(NLJ) 算法</h5><p>​    一次一行循环地从第一张表（称为驱动表）中读取行，在这行数据中取到关联字段，根据关联字段在另一张表（被驱动表）里取出满足条件的行<strong>（走索引所以很快，再从磁盘中读取目标行，所以当做只做一次磁盘IO）</strong>，然后取出两张表的结果合集。</p>
<p>EXPLAIN select * from t1 inner join t2 on t1.a= t2.a;</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218203442806.png" alt="image-20211218203442806"></p>
<p>​    从执行计划中可以看到这些信息： 驱动表是t2，被驱动表是t1。先执行的就是驱动表(执行计划结果的id如果一样则按从上到下顺序执行sql)；优 化器一般会优先选择小表做驱动表。<strong>所以使用 inner join时，排在前面的表并不一定就是驱动表</strong>。 使用了 NLJ算法。一般 join 语句中，如果执行计划 Extra 中未出现 Using join buffer 则表示使用的 join 算 法是 NLJ。</p>
<p>上面sql的大致流程如下： </p>
<p>1、从表 t2 中读取一行数据； </p>
<p>2、从第1步的数据中，取出关联字段 a，到表 t1中查找； </p>
<p>3、取出表t1中满足条件的行，跟t2中获取到的结果合并，作为结果返回给客户端； </p>
<p>4、重复上面 3 步</p>
<p>​    整个过程会读取t2 表的所有数据(扫描100行)，然后遍历这每行数据中字段 a 的值，根据 t2 表中 a 的值索引扫描 t1 表 中的对应行(扫描100次 t1 表的索引，1次扫描可以认为最终只扫描 t1 表一行完整数据，也就是总共 t1 表也扫描了100 行)。因此整个过程扫描了<strong>200</strong>行。 如果被驱动表的关联字段没索引，使用NLJ算法性能会比较低(下面有详细解释)，mysql会选择Block Nested-Loop Join 算法。</p>
<h5 id="2、基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法"><a href="#2、基于块的嵌套循环连接-Block-Nested-Loop-Join-BNL-算法" class="headerlink" title="2、基于块的嵌套循环连接 Block Nested-Loop Join(BNL)算法"></a><strong>2、基于块的嵌套循环连接</strong> Block Nested-Loop Join(BNL)算法</h5><p>把<strong>驱动表</strong>的数据读入到 join_buffer 中，然后扫描<strong>被驱动表</strong>，把<strong>被驱动表</strong>每一行取出来跟 join_buffer 中的数据做对比。 </p>
<p><strong>EXPLAIN select*from t1 inner join t2 on t1.b= t2.b;</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218205149807.png" alt="image-20211218205149807"></p>
<p>Extra 中 的Using join buffer (Block Nested Loop)说明该关联查询使用的是 BNL 算法。 </p>
<p>上面sql的大致流程如下： </p>
<p>1、 把 t2 的所有数据放入到 join_buffer 中 </p>
<p>2、把表 t1 中每一行取出来，跟 join_buffer 中的数据做对比 </p>
<p>3、返回满足 join 条件的数据 </p>
<p>整个过程对表 t1 和 t2 都做了一次全表扫描，因此扫描的总行数为10000(表 t1 的数据总量) + 100(表 t2 的数据总量) = 10100。并且 join_buffer 里的数据是无序的，因此对表 t1 中的每一行，都要做 100 次判断，所以内存中的判断次数是 100 * 10000= <strong>100 万次</strong>。 <strong>被驱动表的关联字段没索引为什么要选择使用 BNL 算法而不使用 Nested-Loop Join呢？</strong> </p>
<p>​    如果上面第二条sql使用 Nested-Loop Join，那么扫描行数为 100 * 10000 = <strong>100万</strong>次，这个是<strong>磁盘扫描</strong>。很显然，用BNL磁盘扫描次数少很多，相比于磁盘扫描，BNL的内存计算会快得多。 </p>
<p>​    <strong>因此MySQL对于被驱动表的关联字段没索引的关联查询，一般都会使用 BNL 算法。如果有索引一般选择 NLJ 算法，有索引的情况下NLJ 算法比 BNL算法性能更高</strong> </p>
<h4 id="2、对于关联sql的优化"><a href="#2、对于关联sql的优化" class="headerlink" title="2、对于关联sql的优化"></a>2、对于关联sql的优化</h4><p>1、<strong>关联字段加索引</strong>，让mysql做join操作时尽量选择NLJ算法 </p>
<p>2、<strong>小标驱动大表</strong>，写多表连接sql时如果明确知道哪张表是小表可以用straight_join写法固定连接驱动方式，省去mysql优化器自己判断的时间（<strong>注意left join 已经决定了驱动表是左边，同理right join,使用inner join时myslq优化器才能自动优化</strong>）</p>
<p>​    <strong>straight_join</strong>：straight_join功能同join类似，但能让左边的表来驱动右边的表，能改表优化器对于联表查询的执行顺序。 </p>
<p>比如：select * from t2 straight_join t1 on t2.a = t1.a; 代表制定mysql选着 t2 表作为驱动表。 </p>
<p>​    <strong>straight_join只适用于inner join</strong>，并不适用于left join，right join。（因为left join，right join已经代表指 </p>
<p>定了表的执行顺序） </p>
<p>​    <strong>尽可能让优化器去判断</strong>，因为大部分情况下mysql优化器是比人要聪明的。使用<strong>straight_join</strong>一定要慎重，因 </p>
<p>为部分情况下人为指定的执行顺序并不一定会比优化引擎要靠谱。</p>
<h3 id="4、in和exsits优化"><a href="#4、in和exsits优化" class="headerlink" title="4、in和exsits优化"></a>4、in和exsits优化</h3><p>原则：<strong>小表驱动大表，即小的数据集驱动大的数据集</strong></p>
<p><strong>in：</strong>当B表的数据集小于A表的数据集时，in优于exists </p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> id <span class="hljs-keyword">in</span> (<span class="hljs-keyword">select</span> id <span class="hljs-keyword">from</span> B) <br># 等价于：<br>for(select id from B)&#123; <br>	<span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> A.id <span class="hljs-operator">=</span> B.id <br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>exists：</strong>当A表的数据集小于B表的数据集时，exists优于in </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> A <span class="hljs-keyword">where</span> <span class="hljs-keyword">exists</span> (<span class="hljs-keyword">select</span> <span class="hljs-number">1</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id) <br>#等价于: <br>for(select * from A)&#123; <br> <span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> B <span class="hljs-keyword">where</span> B.id <span class="hljs-operator">=</span> A.id <br>&#125; <br>#A表与B表的ID字段应建立索引<br></code></pre></td></tr></table></figure>

<p>1、EXISTS (subquery)只返回TRUE或FALSE,因此子查询中的SELECT * 也可以用SELECT 1替换,官方说法是实际执行时会 忽略SELECT清单,因此没有区别 </p>
<p>2、EXISTS子查询的实际执行过程可能经过了优化而不是我们理解上的逐条对比 </p>
<p>3、EXISTS子查询往往也可以用JOIN来代替，何种最优需要具体问题具体分析</p>
<h3 id="5、count-查询优化"><a href="#5、count-查询优化" class="headerlink" title="5、count(*)查询优化"></a>5、count(*)查询优化</h3><p><strong>EXPLAIN select count(1) from employees;</strong><br><strong>EXPLAIN select count(id) from employees;</strong><br><strong>EXPLAIN select count(name) from employees;</strong><br><strong>EXPLAIN select count(*) from employees;</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218224055599.png" alt="image-20211218224055599"></p>
<p>​    四个sql的执行计划一样，说明这四个sql执行效率应该差不多，区别在于根据某个字段count不会统计字段为null值的数 据行为什么mysql最终选择辅助索引而不是主键聚集索引？<strong>因为二级索引相对主键索引存储数据更少，检索性能应该更高</strong></p>
<h4 id="常见优化方法"><a href="#常见优化方法" class="headerlink" title="常见优化方法"></a>常见优化方法</h4><h5 id="1、查询mysql自己维护的总行数"><a href="#1、查询mysql自己维护的总行数" class="headerlink" title="1、查询mysql自己维护的总行数"></a>1、查询mysql自己维护的总行数</h5><p>​    对于<strong>myisam存储引擎</strong>的表做不带where条件的count查询性能是很高的，因为myisam存储引擎的表的总行数会被mysql存储在磁盘上，查询不需要计算 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218224321258.png" alt="image-20211218224321258"></p>
<p>对于innodb存储引擎的表mysql不会存储表的总记录行数，查询count需要实时计算</p>
<h5 id="2、show-table-status"><a href="#2、show-table-status" class="headerlink" title="2、show table status"></a>2、show table status</h5><p>​    如果只需要知道表总行数的<strong>估计值</strong>可以用如下sql查询，性能很高 </p>
<p><strong>1、ANALYZE  table employees;</strong><br><strong>2、show table status where name = “employees”</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9803-Mysql%E7%B4%A2%E5%BC%95%E4%BC%98%E5%8C%96%E5%AE%9E%E6%88%98/image-20211218224401104.png" alt="image-20211218224401104"></p>
<h5 id="3、将总数维护到Redis里"><a href="#3、将总数维护到Redis里" class="headerlink" title="3、将总数维护到Redis里"></a>3、将总数维护到Redis里</h5><p>​    插入或删除表数据行的时候同时维护redis里的表总行数key的计数值(用incr或decr命令)，但是这种方式可能不准，很难 保证表操作和redis操作的事务一致性</p>
<h5 id="4、增加计数表"><a href="#4、增加计数表" class="headerlink" title="4、增加计数表"></a>4、增加计数表</h5><p>​    插入或删除表数据行的时候同时维护计数表，让他们在同一个事务里操作</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能调优</tag>
        <tag>索引</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优04-Mysql锁与事务隔离级别与MVCC</title>
    <url>/2021/12/19/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="Mysql锁与事务隔离级别"><a href="#Mysql锁与事务隔离级别" class="headerlink" title="Mysql锁与事务隔离级别"></a>Mysql锁与事务隔离级别</h1><h2 id="1、锁定义"><a href="#1、锁定义" class="headerlink" title="1、锁定义"></a>1、锁定义</h2><p>​        锁是计算机协调多个进程或线程并发访问某一资源的机制。 在数据库中，除了传统的计算资源（如CPU、RAM、I/O等）的争用以外， 数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性 是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个 重要因素。</p>
<h2 id="2、锁分类"><a href="#2、锁分类" class="headerlink" title="2、锁分类"></a>2、锁分类</h2><p>1、从性能上分为<strong>悲观锁</strong> 和<strong>乐观锁</strong>(用版本对比来实现)</p>
<p>2、从对数据库操作的类型分，分为<strong>读锁</strong>和<strong>写锁</strong>(<font style="background:yellow;font-weight:bold">都属于悲观锁</font>) </p>
<p>​        1、读锁（共享锁）：针对同一份数据，<strong>多个读操作可以同时进行而不会互相影响</strong> </p>
<p>​        2、写锁（排它锁）：当前写操作没有完成前，它<strong>会阻断其他写锁和读锁</strong> </p>
<p>3、从对数据操作的粒度分，分为表锁和行锁</p>
<h3 id="2-1-表锁"><a href="#2-1-表锁" class="headerlink" title="2.1 表锁"></a>2.1 表锁</h3><p>​        每次操作锁住整张表。</p>
<p>​        开销小，加锁快；不会出现死锁；</p>
<p>​        锁定粒度大，发生锁冲突的概率最高，并发度最低</p>
<h4 id="2-1-1-基本操作"><a href="#2-1-1-基本操作" class="headerlink" title="2.1.1 基本操作"></a>2.1.1 基本操作</h4><figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `mylock` (<br>	`id` <span class="hljs-type">INT</span> ( <span class="hljs-number">11</span> ) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT, <br>	`NAME` <span class="hljs-type">VARCHAR</span> ( <span class="hljs-number">20</span> ) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>, <br>	<span class="hljs-keyword">PRIMARY</span> KEY ( `id` ) <br>) ENGINE <span class="hljs-operator">=</span> MyISAM <span class="hljs-keyword">DEFAULT</span> CHARSET <span class="hljs-operator">=</span> utf8;<br><span class="hljs-comment">-- 插入数据 </span><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `mylock` ( `id`, `NAME` )<br><span class="hljs-keyword">VALUES</span><br>	( <span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;a&#x27;</span> )，<br>	( <span class="hljs-string">&#x27;2&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span> )，<br>	( <span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span> )，<br>	( <span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span> );<br>	<br>	<br>session <span class="hljs-number">1</span>	<br><span class="hljs-comment">-- 手动增加表锁</span><br>lock <span class="hljs-keyword">table</span> mylock read<br><span class="hljs-comment">-- 查看表上加过的锁</span><br><span class="hljs-keyword">show</span> <span class="hljs-keyword">open</span> tables;<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> mylock<br><span class="hljs-comment">-- 删除表锁</span><br>unlock tables<br><br></code></pre></td></tr></table></figure>

<p>存在锁<br><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211220212824765.png" alt="image-20211220212824765"></p>
<h4 id="2-1-2-案例分析-加读锁）"><a href="#2-1-2-案例分析-加读锁）" class="headerlink" title="2.1.2 案例分析(加读锁）"></a>2.1.2 案例分析(加读锁）</h4><p>​    当前session和其他session都可以读该表 </p>
<p>​    当前session中插入或者更新锁定的表都会报错，其他session插入或更新则会等待</p>
<h4 id="2-1-3-案例分析-加写锁）"><a href="#2-1-3-案例分析-加写锁）" class="headerlink" title="2.1.3 案例分析(加写锁）"></a>2.1.3 案例分析(加写锁）</h4><p>​    当前session对该表的增删改查都没有问题，其他session对该表的所有操作被阻塞</p>
<h4 id="2-1-4-案例结论"><a href="#2-1-4-案例结论" class="headerlink" title="2.1.4 案例结论"></a>2.1.4 案例结论</h4><p>​        MyISAM在执行查询语句(SELECT)前,会自动给涉及的所有表加读锁,在执行增删改操作前,会自动给涉及的表加写锁。 </p>
<p>​    1、对MyISAM表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。 </p>
<p>​    2、对MylSAM表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作 </p>
<p><strong>总结：</strong> <strong>读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞</strong>。</p>
<h3 id="2-2-行锁"><a href="#2-2-行锁" class="headerlink" title="2.2 行锁"></a>2.2 行锁</h3><p>​    每次操作锁住一行数据。开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度最高。</p>
<p> InnoDB与MYISAM的最大不同有两点：</p>
<p>​    <strong>支持事务（TRANSACTION）</strong> </p>
<p>​    <strong>支持行级锁</strong> </p>
<h4 id="2-2-1行锁支持事务"><a href="#2-2-1行锁支持事务" class="headerlink" title="2.2.1行锁支持事务"></a>2.2.1行锁支持事务</h4><h5 id="事务（Transaction）及其ACID属性"><a href="#事务（Transaction）及其ACID属性" class="headerlink" title="事务（Transaction）及其ACID属性"></a>事务（Transaction）及其ACID属性</h5><p>​        1、<strong>原子性(Atomicity)</strong> ：事务是一个原子操作单元,其对数据的修改,要么全都执 行,要么全都不执行。</p>
<p>​        2、<strong>一致性(Consistent)</strong> ：在事务开始和完成时,数据都必须保持一致状态。这意 味着所有相关的数据规则都必须应用于事务的修改,以保持数据的完整性;事务结束 时,所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。 </p>
<p>​        3、<strong>隔离性(Isolation)</strong> ：数据库系统提供一定的隔离机制,保证事务在不受外部并 发操作影响的“独立”环境执行。这意味着事务处理过程中的中间状态对外部是 不可见的,反之亦然。</p>
<p>​        4、<strong>持久性(Durable)</strong> ：事务完成之后,它对于数据的修改是永久性的,即使出现系 统故障也能够保持</p>
<h5 id="并发事务处理带来的问题"><a href="#并发事务处理带来的问题" class="headerlink" title="并发事务处理带来的问题"></a>并发事务处理带来的问题</h5><p>​        1、**更新丢失（Lost Update）(脏写)**当两个或多个事务选择同一行，然后基于最初选定的值更新该行时，由于每 个事务都不知道其他事务的存在，就会发生丢失更新问题–最后的更新覆盖了由其他事务所做的更新。</p>
<p>​        就是两个事务都更新一个数据，结果有一个人回滚了把另外一个人更新的数据也回滚没了        </p>
<p>​        解决办法：乐观锁加版本号或者悲观锁加行锁</p>
<p>​        2、<strong>脏读（Dirty Reads）</strong>一个事务正在对一条记录做修改，在这个事务完成并提交前，这条记录的数 据就处于不一致的状态；这时，另一个事务也来读取同一条记录，如果不加控 制，第二个事务读取了这些“脏”数据，并据此作进一步的处理，就会产生未提 交的数据依赖关系。这种现象被形象的叫做“脏读”。 一句话：事务A读取到了事务B已经修改但尚未提交的数据，还在这个数据基 础上做了操作。此时，如果B事务回滚，A读取的数据无效，不符合一致性要求。</p>
<p>​        3、<strong>不可重读（Non-Repeatable Reads）</strong>一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现 其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不 可重复读”。 一句话：事务A读取到了事务B已经提交的修改数据，不符合隔离性</p>
<p>​        4、<strong>幻读（Phantom Reads）</strong> 一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插 入了满足其查询条件的新数据，这种现象就称为“幻读”。 一句话：事务A读取到了事务B提交的新增数据，不符合隔离性</p>
<h5 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h5><p>​    脏读”、“不可重复读”和“幻读”,其实都是数据库读一致性问题,必须由数 据库提供一定的事务隔离机制来解决。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211220223800568.png" alt="image-20211220223800568"></p>
<p>​    数据库的事务隔离越严格,并发副作用越小,但付出的代价也就越大,因为事务隔 离实质上就是使事务在一定程度上“串行化”进行,这显然与“并发”是矛盾的。 </p>
<p>​    同时,不同的应用对读一致性和事务隔离程度的要求也是不同的,比如许多应用 对“不可重复读”和“幻读”并不敏感,可能更关心数据并发访问的能力。 </p>
<p>​    <strong>常看当前数据库的事务隔离级别: show variables like ‘tx_isolation’;</strong> </p>
<p>​    <strong>设置事务隔离级别：set tx_isolation=’REPEATABLE-READ’;</strong></p>
<p>​    set [ global | session ] transaction isolation level Read uncommitted | Read committed | Repeatable Read | Serializable;</p>
<p>Mysql5.8：</p>
<p>​    show variables like ‘%transaction_isolation%’</p>
<p>​    set session transaction isolation level read committed ;</p>
<p>​    set globaltransaction isolation level read committed ;</p>
<h4 id="2-2-2-行锁与隔离级别案例分析"><a href="#2-2-2-行锁与隔离级别案例分析" class="headerlink" title="2.2.2 行锁与隔离级别案例分析"></a>2.2.2 行锁与隔离级别案例分析</h4><h5 id="1、行锁演示"><a href="#1、行锁演示" class="headerlink" title="1、行锁演示"></a>1、行锁演示</h5><p>​    一个session开启事务更新不提交，另一个session更新同一条记录会阻塞，更新不同记录不会阻塞 </p>
<h5 id="2、读未提交"><a href="#2、读未提交" class="headerlink" title="2、读未提交"></a>2、读未提交</h5><p>（1）打开一个客户端A，并设置当前事务模式为read uncommitted（未提交 读），查询表account的初始值： set tx_isolation=’read-uncommitted’; </p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>
<p>（3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p>
<p>（4）一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那 客户端A查询到的数据其实就是脏数据： </p>
<p>（5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不 一致啊，如果你这么想就太天真 了，在应用程序中，并 不知道其他会话回滚了，要想解决这个问题可以采用<strong>读已提交</strong>的隔离级别</p>
<h5 id="3、读已提交"><a href="#3、读已提交" class="headerlink" title="3、读已提交"></a>3、读已提交</h5><p>（1）打开一个客户端A，并设置当前事务模式为read committed（读已提交 ），查询表account的所有记录： set tx_isolation=’read-committed’; </p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account： </p>
<p>（3）这时，客户端B的事务还没提交，客户端A不能查询到B已经更新的数据，解决了脏读问题：</p>
<p>（4）客户端B的事务提交 </p>
<p>（5）客户端A执行与上一步相同的查询，结果 与上一步不一致，即产生了不可重复读的问题</p>
<h5 id="4、可重复读"><a href="#4、可重复读" class="headerlink" title="4、可重复读"></a>4、可重复读</h5><p>（1）打开一个客户端A，并设置当前事务模式为repeatable read，查询表 account的所有记录 </p>
<p>​        set tx_isolation=’repeatable-read’; </p>
<p>（2）在客户端A的事务提交之前，打开另一个客户端B，更新表account并提 交</p>
<p>（3）在客户端A查询表account的所有记录，与步骤（1）查询结果一致，没 有出现不可重复读的问题 </p>
<p>（4）在客户端A，接着执行update account set balance = balance - 50 where id = 1，balance没有变成400-50=350，balance值用的是步骤 （2）中的350来算的，所以是300，数据的一致性倒是没有被破坏。可重复读的 隔离级别下使用了MVCC(multi-version concurrency control)机制，</p>
<p>​    select操作不会更新版本号，是快照读（历史版本）；insert、update和delete会更新版本 号，是当前读（当前版本）。</p>
<h5 id="5、串行化"><a href="#5、串行化" class="headerlink" title="5、串行化"></a>5、串行化</h5><p>（1）打开一个客户端A，并设置当前事务模式为serializable，查询表account 的初始值： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level serializable; <br><span class="hljs-keyword">start</span> transaction; <br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account; <br><span class="hljs-operator">|</span> id <span class="hljs-operator">|</span> name <span class="hljs-operator">|</span> balance <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">1</span> <span class="hljs-operator">|</span> lilei <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">2</span> <span class="hljs-operator">|</span> hanmei <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">3</span> <span class="hljs-operator">|</span> lucy <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br><span class="hljs-operator">|</span> <span class="hljs-number">4</span> <span class="hljs-operator">|</span> lily <span class="hljs-operator">|</span> <span class="hljs-number">10000</span> <span class="hljs-operator">|</span> <br></code></pre></td></tr></table></figure>

<p>（2）打开一个客户端B，并设置当前事务模式为serializable，插入一条记录 报错，表被锁了插入失败，mysql中事务隔离级别为serializable时会锁表，因此不会出现幻读的情况，<strong>这种隔离级别并发性极低</strong>，开发中很少会用到。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">set</span> session transaction isolation level serializable;<br><span class="hljs-keyword">start</span> transaction;<br><span class="hljs-keyword">insert</span> <span class="hljs-keyword">into</span> account <span class="hljs-keyword">values</span>(<span class="hljs-number">5</span>,<span class="hljs-string">&#x27;tom&#x27;</span>,<span class="hljs-number">0</span>); <br>Lock wait timeout exceeded; <br>try restarting transaction<br></code></pre></td></tr></table></figure>

<h5 id="Mysql默认级别是repeatable-read，有办法解决幻读问题吗？"><a href="#Mysql默认级别是repeatable-read，有办法解决幻读问题吗？" class="headerlink" title="Mysql默认级别是repeatable-read，有办法解决幻读问题吗？"></a>Mysql默认级别是repeatable-read，有办法解决幻读问题吗？</h5><p>​    <strong>间隙锁在某些情况下可以解决幻读问题</strong></p>
<p>​    要避免幻读可以用间隙锁在Session_1下面执行update account set name = ‘zhuge’ where id &gt; 10 and id &lt;=20;，则其他Session没法在这个范围所包含的 间隙里插入或修改任何数据</p>
<h5 id="无索引行锁会升级为表锁"><a href="#无索引行锁会升级为表锁" class="headerlink" title="无索引行锁会升级为表锁"></a>无索引行锁会升级为表锁</h5><p>​    锁主要是加在索引上，如果对非索引字段更新, 行锁可能会变表锁 ，**==且InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则都会从行锁升级为表锁。==**</p>
<h5 id="其他加锁方式"><a href="#其他加锁方式" class="headerlink" title="其他加锁方式"></a>其他加锁方式</h5><p>​    SELECT … LOCK IN SHARE MODE走的是IS锁(意向共享锁)</p>
<blockquote>
<p>​    一个表是child表，一个是parent表，假设child表的某一列child_id映射到parent表的c_child_id列，那么从业务角度讲，此时我直接insert一条child_id=100记录到child表是存在风险的，因为刚insert的时候可能在parent表里删除了这条c_child_id=100的记录，那么业务数据就存在不一致的风险。正确的方法是再插入时执行select * from parent where c_child_id=100 lock in share mode,锁定了parent表的这条记录，然后执行insert into child(child_id) values (100)就ok了。</p>
</blockquote>
<p>​    SELECT … FOR UPDATE 走的是IX锁(意向排它锁)</p>
<h4 id="2-2-3-案例结论"><a href="#2-2-3-案例结论" class="headerlink" title="2.2.3 案例结论"></a>2.2.3 案例结论</h4><p>​    Innodb存储引擎由于实现了<strong>行级锁</strong>定，虽然在锁定机制的实现方面所带来的性能损耗可能比表级锁定会要更高一下，但是在整体<strong>并发处理能力</strong>方面要远远优 于MYISAM的表级锁定的。当系统并发量高的时候，Innodb的整体性能和 MYISAM相比就会有比较明显的优势了。</p>
<p>​    相对来说，Innodb的风险更高，容易锁死锁</p>
<h4 id="2-2-4-行锁分析"><a href="#2-2-4-行锁分析" class="headerlink" title="2.2.4 行锁分析"></a>2.2.4 行锁分析</h4><p>通过检查InnoDB_row_lock状态变量来分析系统上的行锁的争夺情况 </p>
<p>show status like’innodb_row_lock%’; </p>
<p>对各个状态量的说明如下： </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql">Innodb_row_lock_current_waits: 当前正在等待锁定的数量 <br>Innodb_row_lock_time: 从系统启动到现在锁定总时间长度 <br>Innodb_row_lock_time_avg: 每次等待所花平均时间 <br>Innodb_row_lock_time_max：从系统启动到现在等待最长的一次所花时间 <br>Innodb_row_lock_waits:系统启动后到现在总共等待的次数 <br>对于这<span class="hljs-number">5</span>个状态变量，比较重要的主要是： <br>Innodb_row_lock_time_avg （等待平均时长） <br>Innodb_row_lock_waits （等待总次数） <br>Innodb_row_lock_time（等待总时长）<br></code></pre></td></tr></table></figure>

<p>尤其是当等待次数很高，而且每次等待时长也不小的时候，我们就需要分析系统 中为什么会有如此多的等待，然后根据分析结果着手制定优化计划。</p>
<h4 id="2-2-5-死锁"><a href="#2-2-5-死锁" class="headerlink" title="2.2.5 死锁"></a>2.2.5 死锁</h4><p><strong>set tx_isolation=’<strong>repeatable-read</strong>‘;</strong> </p>
<p>Session_1执行：select * from account where id=1 for update; </p>
<p>Session_2执行：select * from account where id=2 for update; </p>
<p>Session_1执行：select * from account where id=2 for update; </p>
<p>Session_2执行：select * from account where id=1 for update;</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs SQL"><span class="hljs-comment">-- 查看近期死锁日志信息：show engine innodb status</span><br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">24</span> <span class="hljs-number">0x750c</span> INNODB MONITOR OUTPUT<br><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span><br><span class="hljs-keyword">Per</span> <span class="hljs-keyword">second</span> averages calculated <span class="hljs-keyword">from</span> the <span class="hljs-keyword">last</span> <span class="hljs-number">39</span> seconds<br><span class="hljs-comment">-----------------</span><br>BACKGROUND THREAD<br><span class="hljs-comment">-----------------</span><br>srv_master_thread loops: <span class="hljs-number">698</span> srv_active, <span class="hljs-number">0</span> srv_shutdown, <span class="hljs-number">695589</span> srv_idle<br>srv_master_thread log flush <span class="hljs-keyword">and</span> writes: <span class="hljs-number">696287</span><br><span class="hljs-comment">----------</span><br>SEMAPHORES<br><span class="hljs-comment">----------</span><br>OS WAIT <span class="hljs-keyword">ARRAY</span> INFO: reservation count <span class="hljs-number">585</span><br>OS WAIT <span class="hljs-keyword">ARRAY</span> INFO: signal count <span class="hljs-number">545</span><br>RW<span class="hljs-operator">-</span>shared spins <span class="hljs-number">548</span>, rounds <span class="hljs-number">960</span>, OS waits <span class="hljs-number">417</span><br>RW<span class="hljs-operator">-</span>excl spins <span class="hljs-number">25</span>, rounds <span class="hljs-number">595</span>, OS waits <span class="hljs-number">27</span><br>RW<span class="hljs-operator">-</span>sx spins <span class="hljs-number">3</span>, rounds <span class="hljs-number">61</span>, OS waits <span class="hljs-number">2</span><br>Spin rounds <span class="hljs-keyword">per</span> wait: <span class="hljs-number">1.75</span> RW<span class="hljs-operator">-</span>shared, <span class="hljs-number">23.80</span> RW<span class="hljs-operator">-</span>excl, <span class="hljs-number">20.33</span> RW<span class="hljs-operator">-</span>sx<br><span class="hljs-comment">------------------------</span><br>LATEST DETECTED DEADLOCK<br><span class="hljs-comment">------------------------</span><br><span class="hljs-number">2021</span><span class="hljs-number">-12</span><span class="hljs-number">-21</span> <span class="hljs-number">23</span>:<span class="hljs-number">27</span>:<span class="hljs-number">01</span> <span class="hljs-number">0xe360</span><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">1</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">399250</span>, ACTIVE <span class="hljs-number">30</span> sec starting index read<br>mysql tables <span class="hljs-keyword">in</span> use <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br>LOCK WAIT <span class="hljs-number">3</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">2</span> <span class="hljs-type">row</span> lock(s)<br>MySQL thread id <span class="hljs-number">33</span>, OS thread handle <span class="hljs-number">23912</span>, query id <span class="hljs-number">802533</span> localhost ::<span class="hljs-number">1</span> root statistics<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> <span class="hljs-number">2</span> <span class="hljs-keyword">for</span> update<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">1</span>) WAITING <span class="hljs-keyword">FOR</span> THIS LOCK <span class="hljs-keyword">TO</span> BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">2822</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">5</span> n bits <span class="hljs-number">80</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `study_imysql_ndex`.`account` trx id <span class="hljs-number">399250</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> PHYSICAL RECORD: n_fields <span class="hljs-number">5</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000002</span>; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000061775</span>; <span class="hljs-keyword">asc</span>      u;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex a90000011e0110; <span class="hljs-keyword">asc</span>        ;;<br> <span class="hljs-number">3</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">6e616</span>d65; <span class="hljs-keyword">asc</span> name;;<br> <span class="hljs-number">4</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80003e80</span>; <span class="hljs-keyword">asc</span>   <span class="hljs-operator">&gt;</span> ;;<br><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">2</span>) TRANSACTION:<br>TRANSACTION <span class="hljs-number">399251</span>, ACTIVE <span class="hljs-number">15</span> sec starting index read, thread declared inside InnoDB <span class="hljs-number">5000</span><br>mysql tables <span class="hljs-keyword">in</span> use <span class="hljs-number">1</span>, locked <span class="hljs-number">1</span><br><span class="hljs-number">3</span> lock struct(s), heap size <span class="hljs-number">1136</span>, <span class="hljs-number">2</span> <span class="hljs-type">row</span> lock(s)<br>MySQL thread id <span class="hljs-number">34</span>, OS thread handle <span class="hljs-number">58208</span>, query id <span class="hljs-number">802537</span> localhost ::<span class="hljs-number">1</span> root statistics<br><span class="hljs-keyword">select</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">from</span> account <span class="hljs-keyword">where</span> id<span class="hljs-operator">=</span> <span class="hljs-number">1</span> <span class="hljs-keyword">for</span> update<br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">2</span>) HOLDS THE LOCK(S):<br>RECORD LOCKS space id <span class="hljs-number">2822</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">5</span> n bits <span class="hljs-number">80</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `study_imysql_ndex`.`account` trx id <span class="hljs-number">399251</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">2</span> PHYSICAL RECORD: n_fields <span class="hljs-number">5</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000002</span>; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000061775</span>; <span class="hljs-keyword">asc</span>      u;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex a90000011e0110; <span class="hljs-keyword">asc</span>        ;;<br> <span class="hljs-number">3</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">6e616</span>d65; <span class="hljs-keyword">asc</span> name;;<br> <span class="hljs-number">4</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80003e80</span>; <span class="hljs-keyword">asc</span>   <span class="hljs-operator">&gt;</span> ;;<br><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> (<span class="hljs-number">2</span>) WAITING <span class="hljs-keyword">FOR</span> THIS LOCK <span class="hljs-keyword">TO</span> BE GRANTED:<br>RECORD LOCKS space id <span class="hljs-number">2822</span> page <span class="hljs-keyword">no</span> <span class="hljs-number">5</span> n bits <span class="hljs-number">80</span> index <span class="hljs-keyword">PRIMARY</span> <span class="hljs-keyword">of</span> <span class="hljs-keyword">table</span> `study_imysql_ndex`.`account` trx id <span class="hljs-number">399251</span> lock_mode X locks rec but <span class="hljs-keyword">not</span> gap waiting<br>Record lock, heap <span class="hljs-keyword">no</span> <span class="hljs-number">6</span> PHYSICAL RECORD: n_fields <span class="hljs-number">5</span>; compact format; info bits <span class="hljs-number">0</span><br> <span class="hljs-number">0</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">80000001</span>; <span class="hljs-keyword">asc</span>     ;;<br> <span class="hljs-number">1</span>: len <span class="hljs-number">6</span>; hex <span class="hljs-number">000000061771</span>; <span class="hljs-keyword">asc</span>      q;;<br> <span class="hljs-number">2</span>: len <span class="hljs-number">7</span>; hex a7000001df0110; <span class="hljs-keyword">asc</span>        ;;<br> <span class="hljs-number">3</span>: len <span class="hljs-number">5</span>; hex <span class="hljs-number">6</span>c696c6569; <span class="hljs-keyword">asc</span> lilei;;<br> <span class="hljs-number">4</span>: len <span class="hljs-number">4</span>; hex <span class="hljs-number">800001</span>c2; <span class="hljs-keyword">asc</span>     ;;<br><br><span class="hljs-operator">*</span><span class="hljs-operator">*</span><span class="hljs-operator">*</span> WE ROLL BACK TRANSACTION (<span class="hljs-number">2</span>)<br><span class="hljs-comment">------------</span><br>TRANSACTIONS<br><span class="hljs-comment">------------</span><br>Trx id counter <span class="hljs-number">399252</span><br>Purge done <span class="hljs-keyword">for</span> trx<span class="hljs-string">&#x27;s n:o &lt; 399236 undo n:o &lt; 0 state: running but idle</span><br><span class="hljs-string">History list length 540</span><br><span class="hljs-string">LIST OF TRANSACTIONS FOR EACH SESSION:</span><br><span class="hljs-string">---TRANSACTION 283720369143296, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">---TRANSACTION 283720369145040, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">---TRANSACTION 283720369141552, not started</span><br><span class="hljs-string">0 lock struct(s), heap size 1136, 0 row lock(s)</span><br><span class="hljs-string">---TRANSACTION 399250, ACTIVE 53 sec</span><br><span class="hljs-string">3 lock struct(s), heap size 1136, 2 row lock(s)</span><br><span class="hljs-string">MySQL thread id 33, OS thread handle 23912, query id 802544 localhost ::1 root</span><br><span class="hljs-string">--------</span><br><span class="hljs-string">FILE I/O</span><br><span class="hljs-string">--------</span><br><span class="hljs-string">I/O thread 0 state: wait Windows aio (insert buffer thread)</span><br><span class="hljs-string">I/O thread 1 state: wait Windows aio (log thread)</span><br><span class="hljs-string">I/O thread 2 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 3 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 4 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 5 state: wait Windows aio (read thread)</span><br><span class="hljs-string">I/O thread 6 state: wait Windows aio (write thread)</span><br><span class="hljs-string">I/O thread 7 state: wait Windows aio (write thread)</span><br><span class="hljs-string">I/O thread 8 state: wait Windows aio (write thread)</span><br><span class="hljs-string">I/O thread 9 state: wait Windows aio (write thread)</span><br><span class="hljs-string">Pending normal aio reads: [0, 0, 0, 0] , aio writes: [0, 0, 0, 0] ,</span><br><span class="hljs-string"> ibuf aio reads:, log i/o&#x27;</span>s:, sync i<span class="hljs-operator">/</span>o<span class="hljs-string">&#x27;s:</span><br><span class="hljs-string">Pending flushes (fsync) log: 0; buffer pool: 0</span><br><span class="hljs-string">11388 OS file reads, 275231 OS file writes, 268926 OS fsyncs</span><br><span class="hljs-string">0.00 reads/s, 0 avg bytes/read, 0.15 writes/s, 0.00 fsyncs/s</span><br><span class="hljs-string">-------------------------------------</span><br><span class="hljs-string">INSERT BUFFER AND ADAPTIVE HASH INDEX</span><br><span class="hljs-string">-------------------------------------</span><br><span class="hljs-string">Ibuf: size 1, free list len 113, seg size 115, 51 merges</span><br><span class="hljs-string">merged operations:</span><br><span class="hljs-string"> insert 76, delete mark 78, delete 42</span><br><span class="hljs-string">discarded operations:</span><br><span class="hljs-string"> insert 0, delete mark 0, delete 0</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 3 buffer(s)</span><br><span class="hljs-string">Hash table size 2267, node heap has 1 buffer(s)</span><br><span class="hljs-string">0.36 hash searches/s, 0.38 non-hash searches/s</span><br><span class="hljs-string">---</span><br><span class="hljs-string">LOG</span><br><span class="hljs-string">---</span><br><span class="hljs-string">Log sequence number 3913168090</span><br><span class="hljs-string">Log flushed up to   3913168090</span><br><span class="hljs-string">Pages flushed up to 3913168090</span><br><span class="hljs-string">Last checkpoint at  3913168081</span><br><span class="hljs-string">0 pending log flushes, 0 pending chkp writes</span><br><span class="hljs-string">267248 log i/o&#x27;</span>s done, <span class="hljs-number">0.00</span> log i<span class="hljs-operator">/</span>o<span class="hljs-string">&#x27;s/second</span><br><span class="hljs-string">----------------------</span><br><span class="hljs-string">BUFFER POOL AND MEMORY</span><br><span class="hljs-string">----------------------</span><br><span class="hljs-string">Total large memory allocated 8585216</span><br><span class="hljs-string">Dictionary memory allocated 3494975</span><br><span class="hljs-string">Buffer pool size   512</span><br><span class="hljs-string">Free buffers       246</span><br><span class="hljs-string">Database pages     256</span><br><span class="hljs-string">Old database pages 0</span><br><span class="hljs-string">Modified db pages  0</span><br><span class="hljs-string">Pending reads      0</span><br><span class="hljs-string">Pending writes: LRU 0, flush list 0, single page 0</span><br><span class="hljs-string">Pages made young 0, not young 0</span><br><span class="hljs-string">0.00 youngs/s, 0.00 non-youngs/s</span><br><span class="hljs-string">Pages read 10815, created 2268, written 6967</span><br><span class="hljs-string">0.00 reads/s, 0.00 creates/s, 0.15 writes/s</span><br><span class="hljs-string">Buffer pool hit rate 1000 / 1000, young-making rate 0 / 1000 not 0 / 1000</span><br><span class="hljs-string">Pages read ahead 0.00/s, evicted without access 0.00/s, Random read ahead 0.00/s</span><br><span class="hljs-string">LRU len: 256, unzip_LRU len: 0</span><br><span class="hljs-string">I/O sum[9]:cur[0], unzip sum[0]:cur[0]</span><br><span class="hljs-string">--------------</span><br><span class="hljs-string">ROW OPERATIONS</span><br><span class="hljs-string">--------------</span><br><span class="hljs-string">0 queries inside InnoDB, 0 queries in queue</span><br><span class="hljs-string">0 read views open inside InnoDB</span><br><span class="hljs-string">Process ID=5632, Main thread ID=0000000000000B1C , state=sleeping</span><br><span class="hljs-string">Number of rows inserted 279451, updated 682, deleted 187, read 1383947</span><br><span class="hljs-string">0.15 inserts/s, 0.00 updates/s, 0.00 deletes/s, 0.97 reads/s</span><br><span class="hljs-string">----------------------------</span><br><span class="hljs-string">END OF INNODB MONITOR OUTPUT</span><br><span class="hljs-string">============================</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure>

<h4 id="2-2-6-优化建议"><a href="#2-2-6-优化建议" class="headerlink" title="2.2.6 优化建议"></a>2.2.6 优化建议</h4><p>尽可能让所有数据检索都通过索引来完成，避免无索引行锁升级为表锁 </p>
<p>合理设计索引，尽量缩小锁的范围 </p>
<p>尽可能减少检索条件范围，避免间隙锁 </p>
<p>尽量控制事务大小，减少锁定资源量和时间长度，涉及事务加锁的sql </p>
<p>尽量放在事务最后执行 </p>
<p>尽可能低级别事务隔离</p>
<h1 id="MVCC机制详解"><a href="#MVCC机制详解" class="headerlink" title="MVCC机制详解"></a>MVCC机制详解</h1><p>多个事务并发运行的时候，同时读写一个数据，可能会出现脏写、脏读、不可重复读、幻读几个问题</p>
<p>​    脏写，就是两个事务都更新一个数据，结果有一个人回滚了把另外一个人更新的数据也回滚没了；<br>​    脏读，就是一个事务读到了另外一个还没提交的时候修改的数据，结果另外一个事务回滚了，下次读就读不到了；<br>​    不可重复读，就是多次读同一条数据，别的事务修改数据值还提交了，多次读到的值不同；<br>​    幻读，就是范围查询，每次查询的的数据不同，有时候别的事务插入了新的值，就会读到的值不同</p>
<p>针对这些问题,<strong>才有了 RU（读未提交）、RC（读已提交）、RR（可重复读） 和串行四个隔离级别</strong></p>
<p>​    <strong>RU 隔离级别，就是可以读到别人还没提交的事务修改过的数据；</strong><br>​    <strong>RC 隔离级别，可以读到人家提交的事务修改过的数据，可以避免脏读问题；</strong><br>​    <strong>RR 是不会读到别的事务已经提交事务修改的数据，可以避免脏读和不可重复读的问题；</strong><br>​    <strong>串行是让事务都串行执行，可以避免所有问题，包括脏读、不可重复读、幻读</strong></p>
<p>MySQL 实现 MVCC 机制的时候，是基于 <strong>undo log 多版本链条</strong> + <strong>ReadView</strong> 机制来做的，默认的 RR 隔离级别，就是基于这套机制实现了 RR 级别，除了避免脏写、脏读、不可重复读，还能避免幻读问题。因此我们一般来说我们都用默认的 RR 隔离级别就可以了</p>
<h2 id="undo-log版本链"><a href="#undo-log版本链" class="headerlink" title="undo log版本链"></a>undo log版本链</h2><p>​    总起起来，就是多个事务串行执行的时候，每个人修改了一行数据，都会更新隐藏字段 trx_id 和 roll_pointer，同时之前多个数据快照对应的 undo log，会通过roll_pointer 指针串联起来，形成一个重要的版本链</p>
<p>我们每条数据其实都有两个子段，一个是 trx_id，一个是 roll_pointer。</p>
<p>trx_id 就是最近一次更新这条数据的事务id</p>
<p>roll_pointer 就是指向你更新这个事务之前生成的 undo log</p>
<p>简单来说：<strong>mysql中每行记录根据先后事务更新提交顺序用roll_pointer串起来的链条</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211222230309957.png" alt="image-20211222230309957"></p>
<h2 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h2><p>​    ReadView简单来说就是你执行一个事务的时候就给你生成一个 ReadView，里面比较关键的东西有 4个</p>
<p>m_ids，这个就是说此时有哪些事务在 MySQL 里执行还没提交的<br>min_trx_id，就是 m_ids 里面最小的值<br>max_trx_id，就是说 MySQL 下一个要生成的事务 id，就是最大事务 id<br>creator_trx_id，就是你这个事务的 id</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9804-Mysql%E9%94%81%E4%B8%8E%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/image-20211222230650385.png" alt="image-20211222230650385"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>1、Review 其实就是查询时根据事务id，去查询数据中<strong>事务id &lt;= 当前事务id</strong>的记录，如果发现记录事务id大于当前事务id，则沿着undo log链找到 &lt;= 当前事务id的记录。</p>
<p>2、在<strong>读已提交</strong>的事务隔离级别下，每次执行select拍快照ReadView，从而达到每次读都是读到别的事务已提交的内容</p>
<p>3、在<strong>可重复读</strong>的事务隔离级别下，事务后首次查询时拍快照ReadView，从而达到可重复度的效果</p>
]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>Mysql</tag>
        <tag>性能调优</tag>
        <tag>事务</tag>
        <tag>MVCC</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优06Nginx核心模块与实战</title>
    <url>/2021/10/03/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h1><h2 id="1、Nginx-简介"><a href="#1、Nginx-简介" class="headerlink" title="1、Nginx 简介"></a>1、Nginx 简介</h2><p>​    Nginx是一个高性能<strong>WEB服务器</strong>，除它之外<strong>Apache</strong>、<strong>Tomcat</strong>、<strong>Jetty</strong>、<strong>IIS</strong>，它们都是Web服务器，或者叫做WWW（World Wide Web）服务器，相应地也都具备Web服务器的基本功能。Nginx  相对基它WEB服务有什么优势呢？</p>
<ol>
<li>Tomcat、Jetty 面向java语言，先天就是重量级的WEB服务器，其性能与Nginx没有可比性。</li>
<li>IIS只能在Windows操作系统上运行。Windows作为服务器在稳定性与其他一些性能上都不如类UNIX操作系统，因此，在需要高性能Web服务器的场合下IIS并不占优。</li>
<li>Apache(一个线程处理一个请求)的发展时期很长，而且是目前毫无争议的世界第一大Web服务器，其有许多优点，如稳定、开源、跨平台等，但它出现的时间太长了，在它兴起的年代，互联网的产业规模远远比不上今天，所以它被设计成了一个<strong>重量级的、不支持高并发的Web</strong>服务器。在Apache服务器上，如果有数以万计的并发HTTP请求同时访问，就会导致服务器上消耗大量内存，操作系统内核对成百上千的Apache进程做进程间切换也会消耗大量CPU资源，并导致HTTP请求的平均响应速度降低，这些都决定了Apache不可能成为高性能Web服务器，这也促使了Lighttpd和Nginx的出现。</li>
</ol>
<h2 id="2、编译安装与基本命令"><a href="#2、编译安装与基本命令" class="headerlink" title="2、编译安装与基本命令"></a>2、编译安装与基本命令</h2><p>​    略</p>
<p>控制命令：</p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">#查看命令帮助<br>./sbin/nginx -?<br>#默认方式启动：<br>./sbin/nginx <br>#指定配置文件启动 <br>./sbing/nginx -c /tmp/nginx.conf <br>#指定nginx程序目录启动<br>./sbin/nginx -p /usr/local/nginx/<br><br>#快速停止<br>./sbin/nginx -s stop<br>#优雅停止<br>./sbin/nginx -s quit<br><br># 热装载配置文件 <br>./sbin/nginx -s reload<br># 重新打开日志文件<br>./sbin/nginx -s reopen<br># 设置全局命令，如下表示设置启动用户为root<br>./sbin/nginx -g &quot;user root;&quot;<br></code></pre></td></tr></table></figure>



<h2 id="3、Nginx-架构说明"><a href="#3、Nginx-架构说明" class="headerlink" title="3、Nginx 架构说明"></a>3、Nginx 架构说明</h2><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211004150428318.png" alt="image-20211004150428318"></p>
<p><strong>架构说明：</strong></p>
<p>1）nginx启动时，master进程启动，不处理网络请求，主要负责调度工作进程，也就是图示的三项：<strong>加载配置、启动工作进程及非停升级</strong>。所以，nginx启动以后，查看操作系统的进程列表，我们就能看到至少有两个nginx进程。<br>2）服务器实际处理网络请求及响应的是工作进程（worker），在类unix系统上，<strong>nginx可以配置多个worker，而每个worker进程都可以同时处理数以千计的网络请求。</strong><br>3）<strong>模块化设计</strong>。nginx的worker，包括核心和功能性模块，核心模块负责维持一个运行循环（run-loop），执行网络请求处理的不同阶段的模块功能，如网络读写、存储读写、内容传输、外出过滤，以及将请求发往上游服务器等。而其代码的模块化设计，也使得我们可以根据需要对功能模块进行适当的选择和修改，编译成具有特定功能的服务器。<br>4）<strong>事件驱动、异步及非阻塞，可以说是nginx得以获得高并发、高性能的关键因素</strong>，同时也得益于对Linux、Solaris及类BSD等操作系统内核中事件通知及I/O性能增强功能的采用，如kqueue、<strong>epoll</strong>及event ports。</p>
<h3 id="nginx核心模块"><a href="#nginx核心模块" class="headerlink" title="nginx核心模块"></a>nginx核心模块</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20221016095857685.png" alt="image-20221016095857685"></p>
<h2 id="4、Nginx-配置与使用"><a href="#4、Nginx-配置与使用" class="headerlink" title="4、Nginx 配置与使用"></a>4、Nginx 配置与使用</h2><h3 id="1、配置文件语法格式"><a href="#1、配置文件语法格式" class="headerlink" title="1、配置文件语法格式"></a>1、配置文件语法格式</h3><p>先来看一个简单的nginx 配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs conf">worker_processes  1;<br>events &#123;<br>    worker_connections  1024;<br>&#125;<br>http &#123;<br>    include       mime.types;<br>    default_type  application&#x2F;octet-stream;<br>    sendfile        on;<br>    keepalive_timeout  65;<br>    server &#123;<br>        listen       80;<br>        server_name  localhost;<br>        location &#x2F; &#123;<br>            root   html;<br>            index  index.html index.htm;<br>        &#125;<br>        location &#x2F;nginx_status &#123;<br>    	   stub_status on;<br>    	   access_log   off;<br>  	    &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    上述配置中的events、http、server、location、upstream等属于配置项块。而worker_processes 、worker_connections、include、listen  属于配置项块中的属性。   /nginx_status   属于配置块的特定参数参数。其中server块嵌套于http块，其可以直接继承访问Http块当中的参数。</p>
<table>
<thead>
<tr>
<th align="left">**配置块 **</th>
<th align="left">名称开头用大括号包裹其对应属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>属性</strong></td>
<td align="left">基于空格切分属性名与属性值，属性值可能有多个项 都以空格进行切分 如：  access_log logs/host.access.log main</td>
</tr>
<tr>
<td align="left"><strong>参数</strong></td>
<td align="left">其配置在块名称与大括号间，其值如果有多个也是通过空格进行拆</td>
</tr>
</tbody></table>
<p>​    注意 如果配置项值中包括语法符号，比如空格符，那么需要使用单引号或双引号括住配置项值，否则Nginx会报语法错误。例如：<br>​    log_format  main  ‘$remote_addr - $remote_user [$time_local] “$request” ‘<br>​                     ‘$status $body_bytes_sent “$http_referer” ‘<br>​                     ‘“$http_user_agent” “$http_x_forwarded_for”‘;</p>
<h3 id="2、配置第一个静态WEB服务"><a href="#2、配置第一个静态WEB服务" class="headerlink" title="2、配置第一个静态WEB服务"></a>2、配置第一个静态WEB服务</h3><ul>
<li>基础站点演示：</li>
<li>创建站点目录 mkdir -p /usr/www/luban </li>
<li>编写静态文件</li>
<li>配置 nginx.conf<ul>
<li>配置server</li>
<li>配置location</li>
</ul>
</li>
</ul>
<p>基本配置介绍说明：<br>（1）监听端口</p>
<p>​    语法：listen address：<br>​    默认：listen 80;<br>​    配置块：server</p>
<p>（2）主机名称</p>
<p>​    语法：server_name name[……];<br>​    默认：server_name “”;<br>​    配置块：server<br>​    server_name后可以跟多个主机名称，如server_name <a href="http://www.testweb.com/">www.testweb.com</a>、download.testweb.com;。 支持通配符与正则</p>
<p>（3）location</p>
<p>​    语法：location[=|～|～*|^～|@]/uri/{……}<br>​    配置块：server</p>
<ol>
<li>=表示把URI作为字符串，以便与参数中的uri做完全匹配。</li>
<li>/ 基于uri目录匹配</li>
<li>～表示正则匹配URI时是字母大小写敏感的。</li>
<li>～*表示正则匹配URI时忽略字母大小写问题。</li>
<li>～^表示正则匹配URI时只需要其前半部分与uri参数匹配即可。</li>
</ol>
<h3 id="3、匹配优先规则："><a href="#3、匹配优先规则：" class="headerlink" title="3、匹配优先规则："></a><strong>3、匹配优先规则：</strong></h3><ol>
<li>    精确匹配优先 =</li>
<li>    正则匹配优先 ^~</li>
<li>    前缀最大匹配优先。</li>
<li>    配置靠前优先</li>
</ol>
<p>（4）root 指定站点根目录</p>
<p>​    <strong>可配置在 server与location中，基于ROOT路径+URL中路径去寻找指定文件。</strong></p>
<p>（5）alias 指定站点别名</p>
<p>​    <strong>只能配置location 中。基于alias 路径+ URL移除location  前缀后的路径来寻找文件。</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211004160702044.png" alt="image-20211004160702044"></p>
<p><strong>如下示例：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">location /V1 &#123;<br>      alias  <span class="hljs-regexp">/www/</span>old_site;<br>      index  index.html index.htm;<br>&#125;<br><span class="hljs-comment">#访问规则如下</span><br>URL：http:<span class="hljs-regexp">//</span>xxx:xx<span class="hljs-regexp">/V1/</span>a.html<br>最终寻址：<span class="hljs-regexp">/www/</span>old_site/a.thml<br></code></pre></td></tr></table></figure>



<h3 id="4、动静分离演示："><a href="#4、动静分离演示：" class="headerlink" title="4、动静分离演示："></a><strong>4、动静分离演示：</strong></h3><p>​    创建静态站点</p>
<p>​    配置 location /static</p>
<p>​    配置 ~* .(gif|png|css|js)$ </p>
<p><strong>分离2种方式可以实现资源动静分离</strong></p>
<p>1、基于目录动静资源分离</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx">   <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span> <span class="hljs-regexp">*.luban.com</span>;<br>        <span class="hljs-attribute">root</span> /usr/www/luban;<br>        <span class="hljs-attribute">location</span> / &#123;<br>                <span class="hljs-attribute">index</span> luban.html;<br>        &#125;<br>        <span class="hljs-attribute">location</span> /static &#123;<br>         <span class="hljs-attribute">alias</span> /usr/www/static;<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<p><strong>2、基于正则动静分离</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs conf">location ~* \.(gif|jpg|png|css|js)$ &#123;  <br>      root &#x2F;usr&#x2F;www&#x2F;static;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5、防盗链配置演示："><a href="#5、防盗链配置演示：" class="headerlink" title="5、防盗链配置演示："></a><strong>5、防盗链配置演示：</strong></h3><figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment"># 加入至指定location 即可实现</span><br><span class="hljs-attribute">valid_referers</span> <span class="hljs-literal">none</span> <span class="hljs-literal">blocked</span> <span class="hljs-regexp">*.luban.com</span>;<br> <span class="hljs-attribute">if</span> ($invalid_referer) &#123;<br>       <span class="hljs-attribute">return</span> <span class="hljs-number">403</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6、下载限速："><a href="#6、下载限速：" class="headerlink" title="6、下载限速："></a><strong>6、下载限速：</strong></h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">location /download &#123;<br>    limit_rate <span class="hljs-number">1</span>m; <span class="hljs-regexp">//</span>限制每S下载速度<br>    limit_rate_after <span class="hljs-number">30</span>m; <span class="hljs-regexp">//</span> 超过<span class="hljs-number">30</span>m之后再限速<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h3 id="7、创建IP黑名单"><a href="#7、创建IP黑名单" class="headerlink" title="7、创建IP黑名单"></a><strong>7、创建IP黑名单</strong></h3><figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-comment">#封禁指定IP</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span> <span class="hljs-number">192.168.0.1</span>;<br><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-number">192.168.0.1</span>;<br><span class="hljs-comment">#开放指定IP 段</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span> <span class="hljs-number">192.168.0.0</span>/<span class="hljs-number">24</span>;<br><span class="hljs-comment">#封禁所有</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">deny</span></span>    <span class="hljs-literal">all</span>;<br><span class="hljs-comment">#开放所有</span><br><span class="hljs-attribute"><span class="hljs-nomarkup">allow</span></span>    <span class="hljs-literal">all</span>;<br><span class="hljs-comment"># 创建黑名单文件</span><br><span class="hljs-attribute">echo</span> &#x27;<span class="hljs-literal">deny</span> <span class="hljs-number">192.168.0.132</span>;&#x27; &gt;&gt; balck.ip<br><span class="hljs-comment">#http 配置块中引入 黑名单文件</span><br><span class="hljs-attribute">include</span>       black.ip;<br></code></pre></td></tr></table></figure>

<h2 id="5、日志配置"><a href="#5、日志配置" class="headerlink" title="5、日志配置"></a>5、日志配置</h2><p><strong>日志格式：</strong></p>
<figure class="highlight nsis"><table><tr><td class="code"><pre><code class="hljs nsis">log_format  main  <span class="hljs-string">&#x27;<span class="hljs-variable">$remote_addr</span> - <span class="hljs-variable">$remote_user</span> [<span class="hljs-variable">$time_local</span>]   &quot;<span class="hljs-variable">$request</span>&quot; &#x27;</span><br>                     <span class="hljs-string">&#x27;<span class="hljs-variable">$status</span> <span class="hljs-variable">$body_bytes_sent</span> &quot;<span class="hljs-variable">$http_referer</span>&quot; &#x27;</span><br>                  <span class="hljs-string">&#x27;&quot;<span class="hljs-variable">$http_user_agent</span>&quot; &quot;<span class="hljs-variable">$http_x_forwarded_for</span>&quot;&#x27;</span><span class="hljs-comment">;</span><br>access_log  logs/access.log  main<span class="hljs-comment">;</span><br><span class="hljs-comment">#基于域名打印日志</span><br>access_log logs/<span class="hljs-variable">$host</span>.access.log main<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p><strong>error日志的设置</strong><br>语法：error_log /path/file level;<br>默认：error_log logs/error.log error;<br>level是日志的输出级别，取值范围是debug、info、notice、warn、error、crit、alert、emerg，<br><strong>针对指定的客户端输出debug级别的日志</strong><br>语法：debug_connection[IP|CIDR]<br>events {<br>debug_connection 192.168.0.147; <br>debug_connection 10.224.57.0/200;<br>}<br>注意：debug 日志开启 必须在安装时 添加  –with-debug (允许debug)</p>
<h2 id="6、正向代理与反向代理"><a href="#6、正向代理与反向代理" class="headerlink" title="6、正向代理与反向代理"></a>6、正向代理与反向代理</h2><h3 id="正向代理"><a href="#正向代理" class="headerlink" title="正向代理"></a>正向代理</h3><p>​    正向代理是指客户端与目标服务器之间增加一个代理服务器，客户端直接访问代理服务器，在由代理服务器访问目标服务器并返回客户端并返回 。这个过程当中客户端需要知道代理服务器地址，并配置连接。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211227222908381.png" alt="image-20211227222908381"></p>
<h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>​    反向代理是指客户端访问目标服务器，在目标服务内部有一个统一接入网关将请求转发至后端真正处理的服务器并返回结果。这个过程当中客户端不需要知道代理服务器地址，代理对客户端而言是透明的。</p>
<p>​    技术实现与正向代理没有区别，最大的区别是应用场景，主要目的是屏蔽服务端的内部实现 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211227223047489.png" alt="image-20211227223047489"></p>
<p>反向代理：技术实现与正向代理没有区别，最大的区别是应用场景，主要目的是屏蔽服务端的内部实现</p>
<p>正向代理：</p>
<table>
<thead>
<tr>
<th align="left"></th>
<th align="left"><strong>正向代理</strong></th>
<th align="left"><strong>反向代理</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">代理服务器位置</td>
<td align="left">客户端与服务都能连接的们位置</td>
<td align="left">目标服务器内部</td>
</tr>
<tr>
<td align="left">主要作用</td>
<td align="left">屏蔽客户端IP、集中式缓存、解决客户端不能直连服务端的问题。</td>
<td align="left">屏蔽服务端内部实现、负载均衡、缓存。</td>
</tr>
<tr>
<td align="left">应用场景</td>
<td align="left">爬虫、翻墙、maven 的nexus 服务</td>
<td align="left">Nginx 、Apache负载均衡应用</td>
</tr>
</tbody></table>
<h3 id="Nginx代理基本配置"><a href="#Nginx代理基本配置" class="headerlink" title="Nginx代理基本配置"></a>Nginx代理基本配置</h3><p>​    Nginx 代理只需要配置 location 中配置proxy_pass 属性即可。其指向代理的服务器地址。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 正向代理到baidu 服务</span><br><span class="hljs-attr">location</span> = <span class="hljs-string">/baidu.html &#123;</span><br><span class="hljs-meta"> </span> <span class="hljs-string">       proxy_pass http://www.baidu.com;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"># 反向代理至 本机的8010服务</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/luban/ &#123;</span><br><span class="hljs-meta"> </span> <span class="hljs-string">   proxy_pass http://127.0.0.1:8010;  </span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-comment"># 代理相关参数：</span><br><span class="hljs-meta">proxy_pass          </span> <span class="hljs-string"># 代理服务</span><br><span class="hljs-attr">proxy_redirect</span> <span class="hljs-string">off;   # 是否允许重定向</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">Host $host; # 传 header 参数至后端服务</span><br><span class="hljs-attr">proxy_set_header</span> <span class="hljs-string">X-Forwarded-For $remote_addr; # 设置request header 即客户端IP 地址</span><br><span class="hljs-attr">proxy_connect_timeout</span> <span class="hljs-string">90; # 连接代理服务超时时间</span><br><span class="hljs-attr">proxy_send_timeout</span> <span class="hljs-string">90; # 请求发送最大时间</span><br><span class="hljs-attr">proxy_read_timeout</span> <span class="hljs-string">90;  # 读取最大时间</span><br><span class="hljs-attr">proxy_buffer_size</span> <span class="hljs-string">4k; </span><br><span class="hljs-attr">proxy_buffers</span> <span class="hljs-string">4 32k;</span><br><span class="hljs-attr">proxy_busy_buffers_size</span> <span class="hljs-string">64k; </span><br><span class="hljs-attr">proxy_temp_file_write_size</span> <span class="hljs-string">64k;</span><br></code></pre></td></tr></table></figure>

<h2 id="7、负载均衡"><a href="#7、负载均衡" class="headerlink" title="7、负载均衡"></a>7、负载均衡</h2><p>​    通过proxy_pass 可以把请求代理至后端服务，但是为了实现更高的负载及性能， 我们的后端服务通常是多个， 这个是时候可以通过upstream 模块实现负载均衡。</p>
<h4 id="upstream示例"><a href="#upstream示例" class="headerlink" title="upstream示例"></a>upstream示例</h4><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">upstream</span> <span class="hljs-string">backend &#123;     </span><br>   <span class="hljs-attr">server</span> <span class="hljs-string">127.0.0.1:8010 weight=1;</span><br><span class="hljs-meta"> </span> <span class="hljs-string"> server 127.0.0.1:8080 weight=2;</span><br><br>  <span class="hljs-attr">server</span> <span class="hljs-string">127.0.0.1:8030 weight=1 backup;</span><br><span class="hljs-attr">&#125;</span><br><span class="hljs-attr">location</span> <span class="hljs-string">/ &#123;</span><br><span class="hljs-meta"> </span> <span class="hljs-string">  proxy_pass http://backend;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-comment"># upstream 相关参数:</span><br><span class="hljs-attr">server</span>	<span class="hljs-string">反向服务地址 加端口</span><br><span class="hljs-attr">weight</span>	 <span class="hljs-string">权重</span><br><span class="hljs-attr">max_fails</span>	<span class="hljs-string">失败多少次 认为主机已挂掉则，踢出</span><br><span class="hljs-attr">fail_timeout</span>	<span class="hljs-string">踢出后重新探测时间</span><br><span class="hljs-attr">backup</span>	<span class="hljs-string">备用服务</span><br><span class="hljs-attr">max_conns</span>	<span class="hljs-string">允许最大连接数</span><br><span class="hljs-attr">slow_start</span>	<span class="hljs-string">当节点恢复，不立即加入,而是等待 slow_start	后加入服务对列。</span><br></code></pre></td></tr></table></figure>

<h4 id="upstream-负载均衡算法介绍"><a href="#upstream-负载均衡算法介绍" class="headerlink" title="upstream 负载均衡算法介绍"></a>upstream 负载均衡算法介绍</h4><ul>
<li>**ll+weight： **轮询加权重 (默认)</li>
<li>**ip_hash : **基于Hash 计算 ,用于保持session 一至性</li>
<li><strong>url_hash:</strong> 静态资源缓存,节约存储，加快速度（第三方）</li>
<li>**least_conn **：最少链接（第三方）</li>
<li>**least_time  **：最小的响应时间,计算节点平均响应时间，然后取响应最快的那个，分配更高权重（第三方）</li>
</ul>
<h2 id="8、Nginx-高速缓存"><a href="#8、Nginx-高速缓存" class="headerlink" title="8、Nginx 高速缓存"></a>8、Nginx 高速缓存</h2><p><strong>1、案例分析</strong></p>
<p>​    某电商平台商品详情页需要实现 700+ QPS，如何着手去做？</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211228205614945.png" alt="image-20211228205614945"></p>
<p>⾸先为分析⼀下⼀个商品详情⻚有哪些信息</p>
<p>**对于商品详情页涉及了如下主要服务： **</p>
<ul>
<li><p>商品详情页HTML页面渲染</p>
</li>
<li><p>价格服务</p>
</li>
<li><p>促销服务</p>
</li>
<li><p>库存状态/配送至服务</p>
</li>
<li><p>广告词服务</p>
</li>
<li><p>预售/秒杀服务</p>
</li>
<li><p>评价服务</p>
</li>
<li><p>试用服务</p>
</li>
<li><p>推荐服务</p>
</li>
<li><p>商品介绍服务</p>
</li>
<li><p>各品类相关的一些特殊服务</p>
</li>
<li><p><em>解决方案：</em>*</p>
</li>
</ul>
<ol>
<li>采用Ajax 动态加载 价格、广告、库存等服务</li>
<li>采用key value 缓存详情页主体html。</li>
</ol>
<h3 id="1、后台采用缓存"><a href="#1、后台采用缓存" class="headerlink" title="1、后台采用缓存"></a>1、后台采用缓存</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211228210221149.png" alt="image-20211228210221149"></p>
<p><strong>问题：</strong><br>    当达到500QPS 的时候很难继续压测上去。<br><strong>分析原因</strong>：</p>
<p>​    一个详情页html  主体达平均150 kb  那么在500QPS 已接近千M局域网宽带极限。必须减少内网通信。</p>
<h3 id="2、基于Nginx-静态缓存"><a href="#2、基于Nginx-静态缓存" class="headerlink" title="2、基于Nginx 静态缓存"></a>2、基于Nginx 静态缓存</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9806Nginx%E6%A0%B8%E5%BF%83%E6%A8%A1%E5%9D%97%E4%B8%8E%E5%AE%9E%E6%88%98/image-20211228210706401.png" alt="image-20211228210706401"></p>
<p><strong>Nginx 静态缓存基本配置</strong></p>
<p>一、在http元素下添加缓存区声明</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#proxy_cache_path 缓存路径</span><br><span class="hljs-comment">#levels 缓存层级及目录位数</span><br><span class="hljs-comment">#keys_zone 缓存区内存大小</span><br><span class="hljs-comment">#inactive 有效期</span><br><span class="hljs-comment">#max_size 硬盘大小</span><br><span class="hljs-attr">proxy_cache_path</span> <span class="hljs-string">/data/nginx/cache_luban levels=1:2 keys_zone=cache_luban:500m inactive=20d max_size=1g;</span><br></code></pre></td></tr></table></figure>

<p>⼆、为指定location设定缓存策略</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 指定缓存区</span><br><span class="hljs-attr">proxy_cache</span> <span class="hljs-string">cache_luban;</span><br><span class="hljs-comment">#以全路径md5值做做为Key </span><br><span class="hljs-attr">proxy_cache_key</span> <span class="hljs-string">$host$uri$is_args$args;</span><br><span class="hljs-comment">#对不同的HTTP状态码设置不同的缓存时间</span><br><span class="hljs-attr">proxy_cache_valid</span> <span class="hljs-string">200 304 12h;</span><br></code></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">父元素</th>
<th align="left">名称</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">http</td>
<td align="left">proxy_cache_path</td>
<td align="left">指定缓存区的根路径</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">levels</td>
<td align="left">缓存目录层级最高三层，每层1~2个字符表示。如1:1:2 表示三层。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">keys_zone</td>
<td align="left">缓存块名称 及内存块大小。如 cache_item:500m 。表示声明一个名为cache_item 大小为500m。超出大小后最早的数据将会被清除。</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">inactive</td>
<td align="left">最长闲置时间 如:10d 如果一个数据被闲置10天将会被清除</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">max_size</td>
<td align="left">缓存区硬盘最大值。超出闲置数据将会被清除</td>
</tr>
<tr>
<td align="left">location</td>
<td align="left">proxy_cache</td>
<td align="left">指定缓存区，对应keys_zone 中设置的值</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">proxy_cache_key</td>
<td align="left">通过参数拼装缓存key 如：$host$uri$is_args$args 则会以全路径md5值做做为Key</td>
</tr>
<tr>
<td align="left"></td>
<td align="left">proxy_cache_valid</td>
<td align="left">为不同的状态码设置缓存有效期</td>
</tr>
</tbody></table>
<p>三、缓存的清除</p>
<p>该功能可以采用第三方模块 ngx_cache_purge 实现。</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">location</span> <span class="hljs-string">~ /clear(/.*) &#123;</span><br><span class="hljs-comment">  #允许访问的IP</span><br><span class="hljs-meta">  </span> <span class="hljs-string">allow           127.0.0.1;</span><br><span class="hljs-comment">   #禁止访问的IP</span><br><span class="hljs-meta">  </span> <span class="hljs-string">deny            all;</span><br><span class="hljs-comment">   #配置清除指定缓存区和路径(与proxy_cache_key一至)</span><br><span class="hljs-meta">  </span> <span class="hljs-string">proxy_cache_purge    cache_luban $host$1$is_args$args;</span><br><span class="hljs-attr">&#125;</span><br><br><span class="hljs-comment"># 访问生成缓存文件</span><br><span class="hljs-attr">http</span>:<span class="hljs-string">//www.luban.com/?a=1</span><br><span class="hljs-comment"># 清除生成的缓存,如果指定缓存不存在 则会报404 错误。</span><br><span class="hljs-attr">http</span>:<span class="hljs-string">//www.luban.com/clear/?a=1</span><br></code></pre></td></tr></table></figure>

<h2 id="9、Nginx-性能参数调优"><a href="#9、Nginx-性能参数调优" class="headerlink" title="9、Nginx 性能参数调优"></a>9、Nginx 性能参数调优</h2><p><strong>worker_processes number;</strong></p>
<blockquote>
<p>每个worker进程都是单线程的进程<br>它们会调用各个模块以实现多种多样的功能。如果这些模块确认不会出现阻塞式的调用，那么，有多少CPU内核就应该配置多少个进程；反之，如果有可能出现阻塞式调用，那么需要配置稍多一些的worker进程。例如，如果业务方面会致使用户请求大量读取本地磁盘上的静态资源文件，而且服务器上的内存较小，以至于大部分的请求访问静态资源文件时都必须读取磁盘（磁头的寻址是缓慢的），而不是内存中的磁盘缓存，那么磁盘I/O调用可能会阻塞住worker进程少量时间，进而导致服务整体性能下降。</p>
</blockquote>
<p><strong>worker_connections number;</strong></p>
<blockquote>
<p>每个worker 进程的最大连接数<br>语法：worker_connections number;<br>默认：worker_connections 1024</p>
</blockquote>
<p><strong>worker_cpu_affinity cpumask[cpumask……]</strong></p>
<blockquote>
<p>绑定Nginx worker进程到指定的CPU内核<br>为什么要绑定worker进程到指定的CPU内核呢？假定每一个worker进程都是非常繁忙的，如果多个worker进程都在抢同一个CPU，那么这就会出现同步问题。反之，如果每一个worker进程都独享一个CPU，就在内核的调度策略上实现了完全的并发。<br>例如，如果有4颗CPU内核，就可以进行如下配置：<br>worker_processes 4;<br>worker_cpu_affinity 1000 0100 0010 0001;<br>注意 worker_cpu_affinity配置仅对Linux操作系统有效。</p>
</blockquote>
<p><strong>Nginx worker 进程优先级设置</strong></p>
<blockquote>
<p>语法：worker_priority nice;<br>默认：worker_priority 0;<br>优先级由静态优先级和内核根据进程执行情况所做的动态调整（目前只有±5的调整）共同决定。nice值是进程的静态优先级，它的取值范围是–20～+19，–20是最高优先级，+19是最低优先级。因此，如果用户希望Nginx占有更多的系统资源，那么可以把nice值配置得更小一些，但不建议比内核进程的nice值（通常为–5）还要小</p>
</blockquote>
<p><strong>Nginx worker进程可以打开的最大句柄描述符个数</strong></p>
<blockquote>
<p>语法： worker_rlimit_nofile limit;<br>默认：空<br>更改worker进程的最大打开文件数限制。如果没设置的话，这个值为操作系统的限制。设置后你的操作系统和Nginx可以处理比“ulimit -a”更多的文件，所以把这个值设高，这样nginx就不会有“too many open files”问题了。</p>
</blockquote>
<p><strong>是否打开accept锁</strong></p>
<blockquote>
<p>语法：accept_mutex[on|off]<br>默认：accept_mutext on;<br>accept_mutex是Nginx的负载均衡锁，当某一个worker进程建立的连接数量达到worker_connections配置的最大连接数的7/8时，会大大地减小该worker进程试图建立新TCP连接的机会，accept锁默认是打开的，如果关闭它，那么建立TCP连接的耗时会更短，但worker进程之间的负载会非常不均衡，因此不建议关闭它。</p>
</blockquote>
<p><strong>使用accept锁后到真正建立连接之间的延迟时间</strong></p>
<blockquote>
<p>语法：accept_mutex_delay Nms; <br>默认：accept_mutex_delay 500ms; <br>在使用accept锁后，同一时间只有一个worker进程能够取到accept锁。这个accept锁不是堵塞锁，如果取不到会立刻返回。如果只有一个worker进程试图取锁而没有取到，他至少要等待accept_mutex_delay定义的时间才能再次试图取锁。</p>
</blockquote>
]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优07-Tomcat网络通信模型与应用解析</title>
    <url>/2022/01/27/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="一、Tomcat组件介绍"><a href="#一、Tomcat组件介绍" class="headerlink" title="一、Tomcat组件介绍"></a>一、Tomcat组件介绍</h1><h2 id="1、简介"><a href="#1、简介" class="headerlink" title="1、简介"></a>1、简介</h2><p>​    Tomcat是一个基于JAVA的WEB容器，其实现了JAVA EE中的 Servlet 与 jsp 规范，与Nginx（一般用于反向代理、负载均衡，屏蔽内部细节）、apache 服务器不同在于一般用于<strong>动态请求处理</strong>。在架构设计上采用面向组件的方式设计。即整体功能是通过组件的方式拼装完成。另外每个组件都可以被替换以保证灵活性。</p>
<p>​    那么是哪些组件组成了Tomcat呢？</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/tomcat-startup.gif" alt="图片"></p>
<h2 id="2、Tomcat-各组件及关系"><a href="#2、Tomcat-各组件及关系" class="headerlink" title="2、Tomcat 各组件及关系"></a>2、Tomcat 各组件及关系</h2><ul>
<li>Server<ul>
<li>Service<ul>
<li>Connector   连接器<ul>
<li>HTTP 1.1</li>
<li>SSL  https</li>
<li>AJP（ Apache JServ Protocol） apache 私有协议，用于apache 反向代理Tomcat</li>
</ul>
</li>
</ul>
</li>
<li>Container <ul>
<li>Engine  引擎 catalina<ul>
<li>Host   虚拟机 基于域名 分发请求<ul>
<li>Context 隔离各个WEB应用 每个Context的  ClassLoader独立</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Component <ul>
<li>Manager （管理器）</li>
<li>logger （日志管理）</li>
<li>loader （载入器）</li>
<li>pipeline (管道)</li>
<li>valve （管道中的阀）</li>
</ul>
</li>
</ul>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20211229224310865.png" alt="image-20211229224310865"></p>
<h2 id="3、Tomcat-server-xml-配置"><a href="#3、Tomcat-server-xml-配置" class="headerlink" title="3、Tomcat server.xml 配置"></a>3、Tomcat server.xml 配置</h2><h3 id="server"><a href="#server" class="headerlink" title="**server  **"></a>**server  **</h3><p>​    root元素——server 的顶级配置<br>主要属性:</p>
<ul>
<li>port：执行关闭命令的端口号</li>
<li>shutdown：关闭命令</li>
</ul>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">#基于telent执行SHUTDOWN 命令即可关闭(必须大写)<br>telent 127.0.0.1 8005<br>SHUTDOWN<br></code></pre></td></tr></table></figure>

<h3 id="service"><a href="#service" class="headerlink" title="service"></a>service</h3><p>​    服务：将多个connector 与一个Engine组合成一个服务，可以配置多个服务。</p>
<h3 id="Connector"><a href="#Connector" class="headerlink" title="Connector"></a>Connector</h3><p>​    连接器：用于接收指定协议下的连接 并指定给唯一的Engine 进行处理。</p>
<p>主要属性：</p>
<ul>
<li>protocol 监听的协议，默认是http/1.1(可以指定特性的)</li>
<li>port 指定服务器端要创建的端口号</li>
<li>minThread    服务器启动时创建的处理请求的线程数</li>
<li>maxThread    最大可以创建的处理请求的线程数</li>
<li>enableLookups    如果为true，则可以通过调用request.getRemoteHost()进行DNS查询来得到远程客户端的实际主机名，若为false则不进行DNS查询，而是返回其ip地址</li>
<li>redirectPort    指定服务器正在处理http请求时收到了一个SSL传输请求后重定向的端口号</li>
<li>acceptCount    指定当所有可以使用的处理请求的线程数都被使用时，可以放到处理队列中的请求数，超过这个数的请求将不予处理</li>
<li>connectionTimeout    指定超时的时间数(以毫秒为单位)</li>
<li>SSLEnabled 是否开启 sll 验证，在Https 访问时需要开启。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-comment">&lt;!-- 演示配置Connector --&gt;</span><br> <span class="hljs-tag">&lt;<span class="hljs-name">Connector</span> <span class="hljs-attr">port</span>=<span class="hljs-string">&quot;8860&quot;</span> <span class="hljs-attr">protocol</span>=<span class="hljs-string">&quot;org.apache.coyote.http11.Http11NioProtocol&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">connectionTimeout</span>=<span class="hljs-string">&quot;20000&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">redirectPort</span>=<span class="hljs-string">&quot;8862&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">URIEncoding</span>=<span class="hljs-string">&quot;UTF-8&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">useBodyEncodingForURI</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">compression</span>=<span class="hljs-string">&quot;on&quot;</span> <span class="hljs-attr">compressionMinSize</span>=<span class="hljs-string">&quot;2048&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">compressableMimeType</span>=<span class="hljs-string">&quot;text/html,text/xml,text/plain,text/javascript,text/css,application/x-json,application/json,application/x-javascript&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">maxThreads</span>=<span class="hljs-string">&quot;1024&quot;</span> <span class="hljs-attr">minSpareThreads</span>=<span class="hljs-string">&quot;200&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">acceptCount</span>=<span class="hljs-string">&quot;800&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">enableLookups</span>=<span class="hljs-string">&quot;false&quot;</span></span><br><span class="hljs-tag">        /&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a><strong>Engine</strong></h3><p>​    引擎：用于处理连接的执行器，默认的引擎是catalina。<strong>一个service 中只能配置一个Engine</strong>。<br>主要属性：</p>
<ul>
<li>name 引擎名称 </li>
<li>defaultHost 默认host</li>
</ul>
<h3 id="Host"><a href="#Host" class="headerlink" title="Host"></a><strong>Host</strong></h3><p>​    虚拟机：基于域名匹配至指定虚拟机。类似于nginx 当中的server,默认的虚拟机是localhost<br>主要属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Host</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;www.luban.com&quot;</span>  <span class="hljs-attr">appBase</span>=<span class="hljs-string">&quot;/usr/www/luban&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">unpackWARs</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">autoDeploy</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">&quot;logs&quot;</span>               <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;www.luban.com.access_log&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;.txt&quot;</span></span><br><span class="hljs-tag">               <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">Host</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a><strong>Context</strong></h3><p>应用上下文：一个host 下可以配置多个Context ，每个Context 都有其独立的classPath。相互隔离，以免造成ClassPath 冲突。<br>主要属性：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Context</span> <span class="hljs-attr">docBase</span>=<span class="hljs-string">&quot;hello&quot;</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/h&quot;</span> <span class="hljs-attr">reloadable</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>Valve</strong><br>阀门：可以理解成过滤器，具体配置要基于具体的Valve 接口的子类。以下即为一个访问日志的Valve.</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">Valve</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;org.apache.catalina.valves.AccessLogValve&quot;</span> <span class="hljs-attr">directory</span>=<span class="hljs-string">&quot;logs&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;www.luban.com.access_log&quot;</span> <span class="hljs-attr">suffix</span>=<span class="hljs-string">&quot;.txt&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%h %l %u %t <span class="hljs-symbol">&amp;quot;</span>%r<span class="hljs-symbol">&amp;quot;</span> %s %b&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure>

<h2 id="4、Tomcat-自动部署脚本编写"><a href="#4、Tomcat-自动部署脚本编写" class="headerlink" title="4、Tomcat 自动部署脚本编写"></a>4、Tomcat 自动部署脚本编写</h2><hr>
<h3 id="Tomcat启动参数说明"><a href="#Tomcat启动参数说明" class="headerlink" title="Tomcat启动参数说明"></a>Tomcat启动参数说明</h3><p>我们平时启动Tomcat过程是怎么样的？ </p>
<ol>
<li>复制WAR包至Tomcat webapp 目录。</li>
<li>执行starut.bat 脚本启动。</li>
<li>启动过程中war 包会被自动解压装载。</li>
</ol>
<p>但是我们在Eclipse 或idea 中启动WEB项目的时候 也是把War包复杂至webapps 目录解压吗？显然不是，其真正做法是在Tomcat程序文件之外创建了一个部署目录，在一般生产环境中也是这么做的 即：Tomcat 程序目录和部署目录分开 。<br> 我们只需要在启动时指定CATALINA_HOME 与  CATALINA_BASE 参数即可实现。</p>
<table>
<thead>
<tr>
<th align="left"><strong>启动参数</strong></th>
<th align="left"><strong>描述说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left">JAVA_OPTS</td>
<td align="left">jvm 启动参数 , 设置内存  编码等 -Xms100m -Xmx200m -Dfile.encoding=UTF-8</td>
</tr>
<tr>
<td align="left">JAVA_HOME</td>
<td align="left">指定jdk 目录，如果未设置从java 环境变量当中去找。</td>
</tr>
<tr>
<td align="left">CATALINA_HOME</td>
<td align="left">Tomcat 程序根目录</td>
</tr>
<tr>
<td align="left">CATALINA_BASE</td>
<td align="left">应用部署目录，默认为$CATALINA_HOME</td>
</tr>
<tr>
<td align="left">CATALINA_OUT</td>
<td align="left">应用日志输出目录：默认$CATALINA_BASE/log</td>
</tr>
<tr>
<td align="left">CATALINA_TMPDIR</td>
<td align="left">应用临时目录：默认：$CATALINA_BASE/temp</td>
</tr>
</tbody></table>
<h3 id="可以编写一个脚本-来实现自定义配置："><a href="#可以编写一个脚本-来实现自定义配置：" class="headerlink" title="可以编写一个脚本 来实现自定义配置："></a>可以编写一个脚本 来实现自定义配置：</h3><h3 id="更新-启动-脚本"><a href="#更新-启动-脚本" class="headerlink" title="更新 启动 脚本"></a>更新 启动 脚本</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-comment">#!/bin/bash </span><br>export JAVA_OPTS=<span class="hljs-string">&quot;-Xms100m -Xmx200m&quot;</span><br>export JAVA_HOME=<span class="hljs-regexp">/root/</span>svr<span class="hljs-regexp">/jdk/</span><br>export CATALINA_HOME=<span class="hljs-regexp">/root/</span>svr/apache-tomcat-<span class="hljs-number">7.0</span>.<span class="hljs-number">81</span><br>export CATALINA_BASE=<span class="hljs-string">&quot;`pwd`&quot;</span><br><br>case <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br>        start)<br>        <span class="hljs-variable">$CATALINA_HOME</span><span class="hljs-regexp">/bin/</span>catalina.sh start<br>                echo start success!!<br>        ;;<br>        stop)<br>                <span class="hljs-variable">$CATALINA_HOME</span><span class="hljs-regexp">/bin/</span>catalina.sh stop<br>                echo stop success!!<br>        ;;<br>        restart)<br>        <span class="hljs-variable">$CATALINA_HOME</span><span class="hljs-regexp">/bin/</span>catalina.sh stop<br>                echo stop success!!<br>                sleep <span class="hljs-number">3</span><br>        <span class="hljs-variable">$CATALINA_HOME</span><span class="hljs-regexp">/bin/</span>catalina.sh start<br>        echo start success!!<br>        ;;<br>        version)<br>        <span class="hljs-variable">$CATALINA_HOME</span><span class="hljs-regexp">/bin/</span>catalina.sh version<br>        ;;<br>        configtest)<br>        <span class="hljs-variable">$CATALINA_HOME</span><span class="hljs-regexp">/bin/</span>catalina.sh configtest<br>        ;;<br>        esac<br><span class="hljs-keyword">exit</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>


<h3 id="自动部署脚本："><a href="#自动部署脚本：" class="headerlink" title="自动部署脚本："></a>自动部署脚本：</h3><figure class="highlight sh"><table><tr><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br><span class="hljs-built_in">export</span> now_time=$(date +%Y-%m-%d_%H-%M-%S)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deploy time:<span class="hljs-variable">$now_time</span>&quot;</span><br><br>app=<span class="hljs-variable">$1</span><br>version=<span class="hljs-variable">$2</span><br>mkdir -p war/<br><span class="hljs-comment">#从svn下载程序至 war目录</span><br>war=war/<span class="hljs-variable">$&#123;app&#125;</span>_<span class="hljs-variable">$&#123;version&#125;</span>.war<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;<span class="hljs-variable">$war</span>&quot;</span><br>svn <span class="hljs-built_in">export</span> svn://192.168.0.147/release/<span class="hljs-variable">$&#123;app&#125;</span>_<span class="hljs-variable">$&#123;version&#125;</span>.war <span class="hljs-variable">$war</span><br><br><span class="hljs-function"><span class="hljs-title">deploy_war</span></span>() &#123;<br><span class="hljs-comment">#解压版本至当前目录</span><br>target_dir=war/<span class="hljs-variable">$&#123;app&#125;</span>_<span class="hljs-variable">$&#123;version&#125;</span>_<span class="hljs-variable">$&#123;now_time&#125;</span><br>unzip -q <span class="hljs-variable">$war</span> -d <span class="hljs-variable">$target_dir</span><br>rm -f appwar<br>ln -sf <span class="hljs-variable">$target_dir</span> appwar<br>target_ln=`<span class="hljs-built_in">pwd</span>`/appwar<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-string">&lt;Context docBase=&quot;&#x27;</span><span class="hljs-variable">$target_ln</span><span class="hljs-string">&#x27;&quot; allowLinking=&quot;false&quot;&gt;</span><br><span class="hljs-string">&lt;/Context&gt;&#x27;</span> &gt; conf/Catalina/localhost/ROOT.xml<br><span class="hljs-comment">#重启Tomcat服务</span><br>./tomcat.sh restart<br>&#125;<br>deploy_war<br></code></pre></td></tr></table></figure>

<h1 id="二、Tomcat通信模型原理与源码"><a href="#二、Tomcat通信模型原理与源码" class="headerlink" title="二、Tomcat通信模型原理与源码"></a>二、Tomcat通信模型原理与源码</h1><h2 id="2-1、tomcat支持的4种IO模型"><a href="#2-1、tomcat支持的4种IO模型" class="headerlink" title="2.1、tomcat支持的4种IO模型"></a>2.1、tomcat支持的4种IO模型</h2><h3 id="1、什么是IO"><a href="#1、什么是IO" class="headerlink" title="1、什么是IO?"></a>1、什么是IO?</h3><p>​    IO是指为数据传输所提供的输入输出流，其输入输出对象可以是：文件、网络服务、内存等。</p>
<h3 id="2、什么是IO模型"><a href="#2、什么是IO模型" class="headerlink" title="2、什么是IO模型"></a>2、什么是IO模型</h3><p>​    通常情况下IO操作是比较耗时的，所以为了高效的使用硬件，应用程序可以用一个专门线程进行IO操作，而另外一个线程则利用CPU的空闲去做其它计算。这种为提高应用执行效率而采用的IO操作方法即为IO模型。</p>
<h3 id="3、各IO简单说明"><a href="#3、各IO简单说明" class="headerlink" title="3、各IO简单说明"></a>3、各IO简单说明</h3><table>
<thead>
<tr>
<th>IO模型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BIO</td>
<td>同步阻塞式IO，即Tomcat使用传统的java.io进行操作。该模式下每个请求都会创建一个线程，对性能开销大，不适合高并发场景。<strong>优点是稳定，适合连接数目小且固定架构。</strong></td>
</tr>
<tr>
<td>NIO</td>
<td>同步非阻塞式IO，jdk1.4 之后实现的新IO。该模式基于<strong>多路复用选择器</strong>监测连接状态在同步通知线程处理，从而达到非阻塞的目的。比传统BIO能更好的支持并发性能。Tomcat 8.0之后默认采用该模式。<strong>优点是适合连接数目大且连接时间较短的场景</strong></td>
</tr>
<tr>
<td>APR</td>
<td>全称是 Apache Portable Runtime/Apache可移植运行库)，是Apache HTTP服务器的支持库。可以简单地理解为，Tomcat将以JNI的形式调用Apache HTTP服务器的核心动态链接库来处理文件读取或网络传输操作。使用需要编译安装APR库</td>
</tr>
<tr>
<td>AIO(asynchronous  I/O)</td>
<td>异步非阻塞式IO，jdk1.7后之支持 。与nio不同在于<strong>不需要多路复用选择器</strong>，而是请求处理线程执行完程进行回调调知，以继续执行后续操作。Tomcat 8之后支持。<strong>优点是适合连接数目大且连接时间较短的场景</strong></td>
</tr>
</tbody></table>
<h3 id="4、Tomcat使用指定IO模型的配置方式"><a href="#4、Tomcat使用指定IO模型的配置方式" class="headerlink" title="4、Tomcat使用指定IO模型的配置方式"></a>4、Tomcat使用指定IO模型的配置方式</h3><p>配置 server.xml 文件当中的 <Connector protocol="HTTP/1.1">  修改即可。</Connector></p>
<p>默认配置 8.0 protocol=“HTTP/1.1” 8.0 之前是 BIO 8.0 之后是NIO</p>
<p><strong>BIO</strong></p>
<p>protocol=“org.apache.coyote.http11.Http11Protocol“ </p>
<p><strong>NIO</strong></p>
<p>protocol=”org.apache.coyote.http11.Http11NioProtocol“</p>
<p><strong>AIO</strong></p>
<p>protocol=”org.apache.coyote.http11.Http11Nio2Protocol“</p>
<p><strong>APR</strong></p>
<p>protocol=”org.apache.coyote.http11.Http11AprProtocol“</p>
<h2 id="2-2、Tomcat-BIO、NIO实现过程源码解析"><a href="#2-2、Tomcat-BIO、NIO实现过程源码解析" class="headerlink" title="2.2、Tomcat BIO、NIO实现过程源码解析"></a>2.2、Tomcat BIO、NIO实现过程源码解析</h2><h3 id="BIO-JioEndPoint"><a href="#BIO-JioEndPoint" class="headerlink" title="BIO(JioEndPoint)"></a>BIO(JioEndPoint)</h3><p>3个组成成分都实现了runnable</p>
<h4 id="Acceptor：接受所有连接，分配给SocketProcessor处理"><a href="#Acceptor：接受所有连接，分配给SocketProcessor处理" class="headerlink" title="Acceptor：接受所有连接，分配给SocketProcessor处理"></a>Acceptor：接受所有连接，分配给SocketProcessor处理</h4><h4 id="SocketProcessor：接受连接，分配线程池线程"><a href="#SocketProcessor：接受连接，分配线程池线程" class="headerlink" title="SocketProcessor：接受连接，分配线程池线程"></a>SocketProcessor：接受连接，分配线程池线程</h4><p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220128233200081.png" alt="image-20220128233200081"></p>
<p>NIO(NioEndPoint)</p>
<p>3个组成成分都实现了runnable</p>
<h4 id="Acceptor：接受所有连接，注册给Poller处理"><a href="#Acceptor：接受所有连接，注册给Poller处理" class="headerlink" title="Acceptor：接受所有连接，注册给Poller处理"></a>Acceptor：接受所有连接，注册给Poller处理</h4><h4 id="Poller：监听、分配任务给SocketProcessor"><a href="#Poller：监听、分配任务给SocketProcessor" class="headerlink" title="Poller：监听、分配任务给SocketProcessor"></a>Poller：监听、分配任务给SocketProcessor</h4><h4 id="SocketProcessor：接受连接，分配线程池线程-1"><a href="#SocketProcessor：接受连接，分配线程池线程-1" class="headerlink" title="SocketProcessor：接受连接，分配线程池线程"></a>SocketProcessor：接受连接，分配线程池线程</h4><p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220128233207289.png" alt="image-20220128233207289"></p>
<h2 id="2-3、Tomcat-connector-并发参数解读"><a href="#2-3、Tomcat-connector-并发参数解读" class="headerlink" title="2.3、Tomcat connector 并发参数解读"></a>2.3、Tomcat connector 并发参数解读</h2><table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>acceptCount</td>
<td>等待最大队列</td>
</tr>
<tr>
<td>address</td>
<td>绑定客户端特定地址，127.0.0.1</td>
</tr>
<tr>
<td>bufferSize</td>
<td>每个请求的缓冲区大小。bufferSize * maxThreads</td>
</tr>
<tr>
<td>compression</td>
<td>是否启用文档压缩</td>
</tr>
<tr>
<td>compressableMimeTypes</td>
<td>text/html,text/xml,text/plain</td>
</tr>
<tr>
<td>connectionTimeout</td>
<td>客户发起链接 到 服务端接收为止，中间最大的等待时间</td>
</tr>
<tr>
<td>connectionUploadTimeout</td>
<td>upload 情况下连接超时时间</td>
</tr>
<tr>
<td>disableUploadTimeout</td>
<td>true 则使用connectionTimeout</td>
</tr>
<tr>
<td>enableLookups</td>
<td>禁用DNS查询 true</td>
</tr>
<tr>
<td>keepAliveTimeout</td>
<td>当长链接闲置 指定时间主动关闭 链接 ，前提是客户端请求头 带上这个 head”connection” “ keep-alive”</td>
</tr>
<tr>
<td>maxKeepAliveRequests</td>
<td>最大的 长连接数</td>
</tr>
<tr>
<td>maxHttpHeaderSize</td>
<td></td>
</tr>
<tr>
<td>maxSpareThreads</td>
<td>BIO 模式下 最多线闲置线程数</td>
</tr>
<tr>
<td>maxThreads（执行线程）</td>
<td>最大执行线程数</td>
</tr>
<tr>
<td>minSpareThreads(初始线业务线程 10)</td>
<td>BIO 模式下 最小线闲置线程数</td>
</tr>
</tbody></table>
<h2 id="2-4、类加载"><a href="#2-4、类加载" class="headerlink" title="2.4、类加载"></a>2.4、类加载</h2><h3 id="1、什么是类加载"><a href="#1、什么是类加载" class="headerlink" title="1、什么是类加载"></a>1、什么是类加载</h3><p>​    类加载是加载Class文件进入JVM。它负责将 Class 的字节码形式转换成内存形式的 Class 对象。字节码可以来自于磁盘文件 *.class，也可以是 jar 包里的 *.class，也可以来自远程服务器提供的字节流，字节码的本质就是一个字节数组 []byte，它有特定的复杂的内部格式。</p>
<h3 id="2、JVM的类加载器"><a href="#2、JVM的类加载器" class="headerlink" title="2、JVM的类加载器"></a>2、JVM的类加载器</h3><p>​    JVM 运行实例中会存在多个 ClassLoader，不同的 ClassLoader 会从不同的地方加载字节码文件。它可以从不同的文件目录加载，也可以从不同的 jar 文件中加载，也可以从网络上不同的静态文件服务器来下载字节码再加载。JVM中类加载器层次结构如下</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/20211118110505327.png" alt="img"></p>
<p>1、启动类加载器：Bootstrap ClassLoader，用于加载JVM提供的基础运行类，即位于**%JAVA_HOME%/jre/lib目录下的核心类库**；</p>
<p>2、扩展类加载器：Extension ClassLoader， Java提供的一个标准的扩展机制用于加载除核心类库外的Jar包，即只要复制到指定的扩展目录（可以多个）下的Jar, JVM会自动加载（不需要通过-classpath指定）。默认的扩展目录是<strong>％JAVA_HOME%/jre/lib/ext</strong>。典型的应用场景就是，Java使用该类加载器加载JVM默认提供的但是不属于核心类库的Jar。不推荐将应用程序依赖的类库放置到扩展目录下，因为该目录下的类库对所有基于该JVM运行的应用程序可见；</p>
<p>3、应用程序类加载器：Application ClassLoader ，用于加载环境变量CLASSPATH （不推荐使用）指定目录下的或者-classpath运行参数指定的Jar包。System类加载器通常用于加载应用程序Jar包及其启动入口类（Tomcat 的Bootstrap类即由System类加载器加载）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>  <span class="hljs-comment">//  每个类加载器都有一个父加载器</span><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ClassLoader parent;<br>  <span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>        <span class="hljs-keyword">return</span> loadClass(name, <span class="hljs-keyword">false</span>);<br>    &#125;<br>     <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>        <span class="hljs-keyword">throws</span> ClassNotFoundException<br>    &#123;<br>            <span class="hljs-comment">// First, check if the class has already been loaded</span><br>            Class&lt;?&gt; c = findLoadedClass(name);<br>           <span class="hljs-comment">// 如果没有加载过</span><br>            <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>                  <span class="hljs-comment">//  先委托给父加载器去加载，注意这是个递归调用</span><br>                 c = parent.loadClass(name, <span class="hljs-keyword">false</span>);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                 <span class="hljs-comment">// 如果父加载器为空，查找 Bootstrap 加载器是不是加载过了</span><br>                   c = findBootstrapClassOrNull(name);<br>                &#125;<br>              <br>            <span class="hljs-comment">// 如果父加载器没加载成功，调用自己的 findClass 去加载</span><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;        <br>                    c = findClass(name);<br>                &#125;<br>            &#125; <br>        <br>            <span class="hljs-keyword">return</span> c;<br>        &#125;<br>        <br>    &#125;<br>    <span class="hljs-comment">//ClassLoader 中findClass方式需要被子类覆盖，下面这段代码就是对应代码</span><br>      <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name)&#123;<br>       <span class="hljs-comment">//1. 根据传入的类名 name，到在特定目录下去寻找类文件，把.class 文件读入内存</span><br>          ...<br>       <span class="hljs-comment">//2. 调用 defineClass 将字节数组转成 Class 对象</span><br>       <span class="hljs-keyword">return</span> defineClass(buf, off, len)；<br>    &#125;<br>      <span class="hljs-comment">// 将字节码数组解析成一个 Class 对象，用 native 方法实现</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Class&lt;?&gt; defineClass(<span class="hljs-keyword">byte</span>[] b, <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)&#123;<br>    <br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3、Tomcat-的类加载器"><a href="#3、Tomcat-的类加载器" class="headerlink" title="3、Tomcat 的类加载器"></a>3、Tomcat 的类加载器</h3><p>​    <strong>下图不表示类加载顺序，只代表结构</strong></p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/v2-726bd459a1e157cd6ad85d806ef69c82_720w.jpg" alt="img"></p>
<ul>
<li><p>引导类加载器 和 扩展类加载器 的作⽤不变</p>
</li>
<li><p>系统类加载器正常情况下加载的是 CLASSPATH 下的类，但是 Tomcat 的启动脚本并未使⽤该变量，⽽是加载tomcat启动的类，⽐如bootstrap.jar，通常在catalina.bat或者catalina.sh中指定。位于CATALINA_HOME/bin下</p>
</li>
<li><p>Common 通⽤类加载器加载Tomcat使⽤以及应⽤通⽤的⼀些类，位于CATALINA_HOME/lib下，⽐如servlet-api.jar</p>
</li>
<li><p>Catalina ClassLoader ⽤于加载服务器内部可⻅类，这些类应⽤程序不能访问</p>
</li>
<li><p>Shared ClassLoader ⽤于加载应⽤程序共享类，这些类服务器不会依赖</p>
</li>
<li><p>Webapp ClassLoader，每个应⽤程序都会有⼀个独⼀⽆⼆的Webapp ClassLoader，他⽤来加载本应⽤程序 /WEB-INF/classes 和 /WEB-INF/lib 下的类。</p>
</li>
</ul>
<h2 id="2-5、Tomcat如何双亲委派机制"><a href="#2-5、Tomcat如何双亲委派机制" class="headerlink" title="2.5、Tomcat如何双亲委派机制"></a>2.5、Tomcat如何双亲委派机制</h2><h3 id="1、什么是双亲委派机制"><a href="#1、什么是双亲委派机制" class="headerlink" title="1、什么是双亲委派机制"></a>1、什么是双亲委派机制</h3><p>​    当某个类加载器需要加载某个.class⽂件时，它⾸先把这个任务委托给他的上级类加载器，递归这个操作，如果上级的类加载器没有加载，⾃⼰才会去加载这个类。JVM的类加载就是严格按照该机制进行的</p>
<h3 id="2、双亲委派机制的作用"><a href="#2、双亲委派机制的作用" class="headerlink" title="2、双亲委派机制的作用"></a>2、双亲委派机制的作用</h3><p>1、<strong>防⽌重复加载同⼀个.class</strong>。通过委托去向上⾯问⼀问，加载过了，就不⽤再加载⼀遍。保证数据安全。<br>2、<strong>保证核⼼.class不能被篡改</strong>。通过委托⽅式，不会去篡改核⼼.class，即使篡改也不会去加载，即使加载也不会是同⼀个.class对象了。这样保证了class执⾏安全（如果⼦类加载器先加载，那么我们可以写⼀些与java.lang包中基础类同名的类， 然后再定义⼀个⼦类加载器，这样整个应⽤使⽤的基础类就都变成我们⾃⼰定义的类了。）如</p>
<h3 id="3、何打破双亲委派"><a href="#3、何打破双亲委派" class="headerlink" title="3、何打破双亲委派"></a>3、何打破双亲委派</h3><p>WebappClassLoaderBase重写loadClass()，delegate默认为false，因此打破了双亲委派机制<br>可以通过配置<Loader delegate="true"> 不打破双亲委托</Loader></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>      <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>          <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>              log.debug(<span class="hljs-string">&quot;loadClass(&quot;</span> + name + <span class="hljs-string">&quot;, &quot;</span> + resolve + <span class="hljs-string">&quot;)&quot;</span>);<br>          Class&lt;?&gt; clazz = <span class="hljs-keyword">null</span>;<br>          <span class="hljs-comment">// Log access to stopped class loader</span><br>          checkStateForClassLoading(name);    <br>          <span class="hljs-comment">//从当前ClassLoader的本地缓存中加载类，如果找到则返回</span><br>          clazz = findLoadedClass0(name);<br>          <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                  log.debug(<span class="hljs-string">&quot;  Returning class from cache&quot;</span>);<br>              <span class="hljs-keyword">if</span> (resolve)<br>                  resolveClass(clazz);<br>              <span class="hljs-keyword">return</span> clazz;<br>          &#125;<br>          <span class="hljs-comment">// 本地缓存没有的情况下，调用ClassLoader的findLoadedClass方法查看jvm是否已经加载过此类，如果已经加载则直接返回。</span><br>          clazz = findLoadedClass(name);<br>          <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                  log.debug(<span class="hljs-string">&quot;  Returning class from cache&quot;</span>);<br>              <span class="hljs-keyword">if</span> (resolve)<br>                  resolveClass(clazz);<br>              <span class="hljs-keyword">return</span> clazz;<br>          &#125;<br>          String resourceName = binaryNameToPath(name, <span class="hljs-keyword">false</span>);<br>          <span class="hljs-comment">//此时的javaseClassLoader是扩展类加载器  是把扩展类加载器赋值给了javaseClassLoader</span><br>          ClassLoader javaseLoader = getJavaseClassLoader();<br>          <span class="hljs-keyword">boolean</span> tryLoadingFromJavaseLoader;<br>          <span class="hljs-keyword">try</span> &#123;<br>            .....<br>          <span class="hljs-comment">//如果可以用getResource得到</span><br>          <span class="hljs-comment">//如果能用扩展类加载器的getResource得到就证明可以被扩展类加载器加载到接下来安排扩展类加载器加载</span><br>          <span class="hljs-keyword">if</span> (tryLoadingFromJavaseLoader) &#123;<br>              <span class="hljs-keyword">try</span> &#123;<br>                  <span class="hljs-comment">//使用扩展类加载器进行加载</span><br>                  clazz = javaseLoader.loadClass(name);<br>                  <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;<br>                      <span class="hljs-keyword">if</span> (resolve)<br>                          resolveClass(clazz);<br>                      <span class="hljs-keyword">return</span> clazz;<br>                  &#125;<br>              &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                  <span class="hljs-comment">// Ignore</span><br>              &#125;<br>          &#125;<br>          <span class="hljs-comment">// (0.5) Permission to access this class when using a SecurityManager</span><br>          <span class="hljs-keyword">if</span> (securityManager != <span class="hljs-keyword">null</span>) &#123;<br>              <span class="hljs-keyword">int</span> i = name.lastIndexOf(<span class="hljs-string">&#x27;.&#x27;</span>);<br>              <span class="hljs-keyword">if</span> (i &gt;= <span class="hljs-number">0</span>) &#123;<br>                  <span class="hljs-keyword">try</span> &#123;<br>                      securityManager.checkPackageAccess(name.substring(<span class="hljs-number">0</span>,i));<br>                  &#125; <span class="hljs-keyword">catch</span> (SecurityException se) &#123;<br>                      String error = <span class="hljs-string">&quot;Security Violation, attempt to use &quot;</span> +<br>                          <span class="hljs-string">&quot;Restricted Class: &quot;</span> + name;<br>                      log.info(error, se);<br>                      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(error, se);<br>                  &#125;<br>              &#125;<br>          &#125;<br>          <span class="hljs-keyword">boolean</span> delegateLoad = delegate || filter(name, <span class="hljs-keyword">true</span>);<br>          <span class="hljs-comment">// (1) Delegate to our parent if requested</span><br>          <span class="hljs-comment">//如果是true就是用父类加载器进行加载</span><br>          <span class="hljs-keyword">if</span> (delegateLoad) &#123;<br>              <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                  log.debug(<span class="hljs-string">&quot;  Delegating to parent classloader1 &quot;</span> + parent);<br>              <span class="hljs-keyword">try</span> &#123;<br>                  clazz = Class.forName(name, <span class="hljs-keyword">false</span>, parent);<br>                  <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;<br>                      <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                          log.debug(<span class="hljs-string">&quot;  Loading class from parent&quot;</span>);<br>                      <span class="hljs-keyword">if</span> (resolve)<br>                          resolveClass(clazz);<br>                      <span class="hljs-keyword">return</span> clazz;<br>                  &#125;<br>              &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                  <span class="hljs-comment">// Ignore</span><br>              &#125;<br>          &#125;<br>          <span class="hljs-comment">// (2) Search local repositories</span><br>          <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>              log.debug(<span class="hljs-string">&quot;  Searching local repositories&quot;</span>);<br>          <span class="hljs-keyword">try</span> &#123;<br>              <span class="hljs-comment">// 本地进行加载</span><br>              clazz = findClass(name);<br>              <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;<br>                  <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                      log.debug(<span class="hljs-string">&quot;  Loading class from local repository&quot;</span>);<br>                  <span class="hljs-keyword">if</span> (resolve)<br>                      resolveClass(clazz);<br>                  <span class="hljs-keyword">return</span> clazz;<br>              &#125;<br>          &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>              <span class="hljs-comment">// Ignore</span><br>          &#125;<br>          <span class="hljs-comment">// (3) Delegate to parent unconditionally</span><br>          <span class="hljs-comment">//到这里还是没有加载上再次尝试使用父类加载器进行加载</span><br>          <span class="hljs-keyword">if</span> (!delegateLoad) &#123;<br>                  <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                  log.debug(<span class="hljs-string">&quot;  Delegating to parent classloader at end: &quot;</span> + parent);<br>              <span class="hljs-keyword">try</span> &#123;<br>                  clazz = Class.forName(name, <span class="hljs-keyword">false</span>, parent);<br>                  <span class="hljs-keyword">if</span> (clazz != <span class="hljs-keyword">null</span>) &#123;<br>                      <span class="hljs-keyword">if</span> (log.isDebugEnabled())<br>                          log.debug(<span class="hljs-string">&quot;  Loading class from parent&quot;</span>);<br>                      <span class="hljs-keyword">if</span> (resolve)<br>                          resolveClass(clazz);<br>                      <span class="hljs-keyword">return</span> clazz;<br>                  &#125;<br>              &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;<br>                  <span class="hljs-comment">// Ignore</span><br>              &#125;<br>          &#125;<br>      &#125;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException(name);<br>  &#125;<br></code></pre></td></tr></table></figure>

<p>4、Tomcat类加载顺序</p>
<p>默认情况下（打破双亲委派）</p>
<ul>
<li>JVM 的 Bootstrap 类</li>
<li>Web 应用的 /WEB-INF/classes 类</li>
<li>Web 应用的 /WEB-INF/lib/*.jar 类</li>
<li>System 类加载器的类</li>
<li>Common 类加载器的类</li>
</ul>
<p>遵循双亲委托<Loader delegate="true"></Loader></p>
<ul>
<li>JVM 的 Bootstrap 类</li>
<li>System 类加载器的类</li>
<li>Common 类加载器的类</li>
<li>Web 应用的 /WEB-INF/classes 类</li>
<li>Web 应用的 /WEB-INF/lib/*.jar 类</li>
</ul>
<h3 id="4、为何打破后依旧先加载Bootstrap的类"><a href="#4、为何打破后依旧先加载Bootstrap的类" class="headerlink" title="4、为何打破后依旧先加载Bootstrap的类"></a>4、为何打破后依旧先加载Bootstrap的类</h3><p>​    jvm的一些基础类不允许重写，所以bootstrapClassLoader始终是最先加载的</p>
<h3 id="5、不同的加载器加载同一个class的到的class对象也是不同的"><a href="#5、不同的加载器加载同一个class的到的class对象也是不同的" class="headerlink" title="5、不同的加载器加载同一个class的到的class对象也是不同的"></a>5、不同的加载器加载同一个class的到的class对象也是不同的</h3><h1 id="三、Tomcat处理HTTP原理"><a href="#三、Tomcat处理HTTP原理" class="headerlink" title="三、Tomcat处理HTTP原理"></a>三、Tomcat处理HTTP原理</h1><h2 id="1、请求的流程"><a href="#1、请求的流程" class="headerlink" title="1、请求的流程"></a>1、请求的流程</h2><p>HTTP请求 -&gt; Ip + Port -&gt; 操作系统 -&gt; Tomcat(1) -&gt;根据Http协议解析成Request-&gt; Engine(1) -&gt; Host(n) -&gt; Context(n) -&gt; Wrapper(n) -&gt;doFilter -&gt; service() -&gt; doGet()/doPost()</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220126235959710.png" alt="image-20220126235959710"></p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220126220257506.png" alt="image-20220126220257506"></p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220126220403696.png" alt="image-20220126220403696"></p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220126224337153.png" alt="image-20220126224337153"></p>
<h2 id="2、Http请求字节流如何解析成HttpServletRequest"><a href="#2、Http请求字节流如何解析成HttpServletRequest" class="headerlink" title="2、Http请求字节流如何解析成HttpServletRequest"></a>2、Http请求字节流如何解析成HttpServletRequest</h2><p>1、Http请求头格式</p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220126225059436.png" alt="image-20220126225059436"></p>
<p><img src="images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9807-Tomcat%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%BA%94%E7%94%A8%E8%A7%A3%E6%9E%90/image-20220126225922494.png" alt="image-20220126225922494"></p>
<p>​    JIoEndPoint（InternalInputBuffer）就是按照Http协议请求头的格式去解析字节流，从而解析成HttpServletRequest对象（一般而言通过请求头的Content-Length表示请求体长度，或者分块传输——Transfer-Encoding为chunk）</p>
]]></content>
      <categories>
        <category>Tomcat</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>Tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优10JVM01类加载机制深度解析</title>
    <url>/2022/03/01/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="类加载机制深度解析"><a href="#类加载机制深度解析" class="headerlink" title="类加载机制深度解析"></a>类加载机制深度解析</h1><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2><p>​    多个java文件经过编译打包生成可运行jar包，最终由java命令运行某个主类的main函数启 动程序，这里首先需要通过类加载器把主类加载到JVM。 主类在运行过程中如果使用到其它类，会逐步加载这些类。 </p>
<p>​    类加载到使用整个过程有如下几步：<strong>加载 &gt;&gt; 验证 &gt;&gt; 准备 &gt;&gt; 解析 &gt;&gt; 初始化 &gt;&gt;</strong> 使用 &gt;&gt; 卸载 </p>
<p><strong>加载</strong>：在硬盘上找到Java字节码文件加载到JVM</p>
<p><strong>验证</strong>：校验字节码文件的正确性</p>
<p><strong>准备</strong>：给类的静态变量分配内存并赋予默认值</p>
<p><strong>解析</strong>：将符号引用直接替换成直接引用，该阶段会把一些静态方法(符号引用，比如 main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接 引用，下节课会讲到动态链接</p>
<p><strong>初始</strong>化：对类的静态成员变量初始化为指定的值，执行静态代码块</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20220227124358606.png" alt="image-20220227124358606"></p>
<p>注意，jar包里的类不是一次性全部加载的，是使用到时才加载。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDynamicLoad</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*************load TestDynamicLoad************&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> A();<br>        System.out.println(<span class="hljs-string">&quot;*************load test************&quot;</span>);<br>        B b = <span class="hljs-keyword">null</span>;  <span class="hljs-comment">//B不会加载，除非这里执行 new B()</span><br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*************load A************&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">A</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;*************initial A************&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;*************load B************&quot;</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">B</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;*************initial B************&quot;</span>);<br>    &#125;<br>&#125;<br>运行结果：<br>*************load TestDynamicLoad************<br>*************load A************<br>*************initial A************<br>*************load test************<br></code></pre></td></tr></table></figure>



<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><p>​    Java里有如下几种类加载器</p>
<ul>
<li>启动类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如 rt.jar、charsets.jar等 </li>
<li>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包 </li>
<li>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li>
<li>自定义加载器：负责加载用户自定义路径下的类包</li>
</ul>
<h3 id="自定义类加载器"><a href="#自定义类加载器" class="headerlink" title="自定义类加载器"></a>自定义类加载器</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestJDKClassLoader</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(String.class.getClassLoader());<br>        System.out.println(com.sun.crypto.provider.DESKeyFactory.class.getClassLoader().getClass().getName());<br>        System.out.println(TestJDKClassLoader.class.getClassLoader().getClass().getName());<br><br>        System.out.println();<br>        ClassLoader appClassLoader = ClassLoader.getSystemClassLoader();<br>        ClassLoader extClassloader = appClassLoader.getParent();<br>        ClassLoader bootstrapLoader = extClassloader.getParent();<br>        System.out.println(<span class="hljs-string">&quot;the bootstrapLoader : &quot;</span> + bootstrapLoader);<br>        System.out.println(<span class="hljs-string">&quot;the extClassloader : &quot;</span> + extClassloader);<br>        System.out.println(<span class="hljs-string">&quot;the appClassLoader : &quot;</span> + appClassLoader);<br><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;bootstrapLoader加载以下文件：&quot;</span>);<br>        URL[] urls = Launcher.getBootstrapClassPath().getURLs();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; urls.length; i++) &#123;<br>            System.out.println(urls[i]);<br>        &#125;<br><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;extClassloader加载以下文件：&quot;</span>);<br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;java.ext.dirs&quot;</span>));<br><br>        System.out.println();<br>        System.out.println(<span class="hljs-string">&quot;appClassLoader加载以下文件：&quot;</span>);<br>        System.out.println(System.getProperty(<span class="hljs-string">&quot;java.class.path&quot;</span>));<br>    &#125;<br>&#125;<br>运行结果<br><span class="hljs-keyword">null</span><br>sun.misc.Launcher$ExtClassLoader<br>sun.misc.Launcher$AppClassLoader<br><br>the bootstrapLoader : <span class="hljs-keyword">null</span><br>the extClassloader : sun.misc.Launcher$ExtClassLoader@7ea987ac<br>the appClassLoader : sun.misc.Launcher$AppClassLoader@18b4aac2<br><br>bootstrapLoader加载以下文件：<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/resources.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/rt.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/sunrsasign.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/jsse.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/jce.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/charsets.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/lib/jfr.jar<br>file:/D:/software/JDK/jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>/jre/classes<br><br>extClassloader加载以下文件：<br>D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext;C:\WINDOWS\Sun\Java\lib\ext<br><br>appClassLoader加载以下文件：<br>D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\charsets.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\deploy.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\access-bridge-<span class="hljs-number">64.</span>jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\cldrdata.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\dnsns.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\jaccess.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\jfxrt.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\localedata.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\nashorn.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\sunec.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\sunjce_provider.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\sunmscapi.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\sunpkcs11.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\ext\zipfs.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\javaws.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\jce.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\jfr.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\jfxswt.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\jsse.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\management-agent.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\plugin.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\resources.jar;D:\software\JDK\jdk1<span class="hljs-number">.8</span><span class="hljs-number">.0_171</span>\jre\lib\rt.jar;D:\git\code\study\jvm-study\target\classes;D:\software\IDEA\idea20203pj_186103\lib\idea_rt.jar<br><br></code></pre></td></tr></table></figure>

<h3 id="自定义一个类加载器示例"><a href="#自定义一个类加载器示例" class="headerlink" title="自定义一个类加载器示例"></a>自定义一个类加载器示例</h3><p>自定义类加载器只需要继承 java.lang.ClassLoader 类，该类有两个核心方法。</p>
<p>一个是 loadClass(String, boolean)，实现了双亲委派机制，大体逻辑 </p>
<ol>
<li><p>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载， 直接返回。</p>
<ol start="2">
<li> 如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由 父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加 载器来加载。 </li>
<li>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器 的findClass方法来完成类加载。</li>
</ol>
</li>
</ol>
<p>另一个方法是findClass，默认实现是抛出异常，<strong>所以我们自定义类加载器主要是重写 findClass方法</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sout</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;=======自己的加载器加载类调用方法=======&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">private</span> Integer id;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//User类需要重写finalize方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        FinalizeTest.LIST.add(<span class="hljs-keyword">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;关闭资源，userid=&quot;</span> + id + <span class="hljs-string">&quot;即将被回收&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoaderTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String classPath;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String classPath)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.classPath = classPath;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] loadByte(String name) <span class="hljs-keyword">throws</span> Exception &#123;<br>            name = name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(classPath + <span class="hljs-string">&quot;/&quot;</span> + name<br>                    + <span class="hljs-string">&quot;.class&quot;</span>);<br>            <span class="hljs-keyword">int</span> len = fis.available();<br>            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[len];<br>            fis.read(data);<br>            fis.close();<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">byte</span>[] data = loadByte(name);<br>                <span class="hljs-comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span><br>                <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span><br>        MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader(<span class="hljs-string">&quot;D:/test&quot;</span>);<br>        <span class="hljs-comment">//D盘创建 test/com/tuling/jvm 几级目录，将User类的复制类User1.class丢入该目录</span><br>        Class clazz = classLoader.loadClass(<span class="hljs-string">&quot;classload.User1&quot;</span>);<br>        Object obj = clazz.newInstance();<br>        Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;sout&quot;</span>, <span class="hljs-keyword">null</span>);<br>        method.invoke(obj, <span class="hljs-keyword">null</span>);<br>        System.out.println(clazz.getClassLoader().getClass().getName());<br>    &#125;<br>&#125;<br><br>运行结果：<br>=======自己的加载器加载类调用方法=======<br>classload.MyClassLoaderTest$MyClassLoader<br></code></pre></td></tr></table></figure>



<h2 id="双亲委派机制"><a href="#双亲委派机制" class="headerlink" title="双亲委派机制"></a>双亲委派机制</h2><p>​    加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。 </p>
<p>JVM类加载器是有亲子层级结构的，如下图</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20211006160302834.png" alt="image-20211006160302834"></p>
<p>​    这里类加载其实就有一个<strong>双亲委派机制</strong>，比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器，应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。。</p>
<p><strong><font color="red">    双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</font></strong></p>
<h3 id="为什么要设计双亲委派机制？"><a href="#为什么要设计双亲委派机制？" class="headerlink" title="为什么要设计双亲委派机制？"></a>为什么要设计双亲委派机制？</h3><ol>
<li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改 </li>
<li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证<strong>被加载类的唯一性</strong> </li>
</ol>
<p>举例说明第1点</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20220228001234177.png" alt="image-20220228001234177"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoaderTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String classPath;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String classPath)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.classPath = classPath;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] loadByte(String name) <span class="hljs-keyword">throws</span> Exception &#123;<br>            name = name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(classPath + <span class="hljs-string">&quot;/&quot;</span> + name<br>                    + <span class="hljs-string">&quot;.class&quot;</span>);<br>            <span class="hljs-keyword">int</span> len = fis.available();<br>            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[len];<br>            fis.read(data);<br>            fis.close();<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">byte</span>[] data = loadByte(name);<br>                <span class="hljs-comment">//defineClass将一个字节数组转为Class对象，这个字节数组是class文件读取后最终的字节数组。</span><br>                <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> resolve</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>                <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>                <span class="hljs-comment">// First, check if the class has already been loaded</span><br>                Class&lt;?&gt; c = findLoadedClass(name);<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                    <span class="hljs-comment">// to find the class.</span><br>                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br>                    c = findClass(name);<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (resolve) &#123;<br>                    resolveClass(c);<br>                &#125;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//初始化自定义类加载器，会先初始化父类ClassLoader，其中会把自定义类加载器的父加载器设置为应用程序类加载器AppClassLoader</span><br>        MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader(<span class="hljs-string">&quot;D:/test&quot;</span>);<br>        <span class="hljs-comment">//D盘创建 test/com/tuling/jvm 几级目录，将User类的复制类User1.class丢入该目录</span><br>        Class clazz = classLoader.loadClass(<span class="hljs-string">&quot;java.lang.String&quot;</span>);<br>        Object obj = clazz.newInstance();<br>        Method method = clazz.getDeclaredMethod(<span class="hljs-string">&quot;sout&quot;</span>, <span class="hljs-keyword">null</span>);<br>        method.invoke(obj, <span class="hljs-keyword">null</span>);<br>        System.out.println(clazz.getClassLoader().getClass().getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>举例说明第2点</p>
<p>​    因为String已经被父类加载过，所以父类加载的String是不包含main方法的，应用加载器加载不到也加载不了我们自己定义的String类</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20220227225314682.png" alt="image-20220227225314682"></p>
<h2 id="打破双亲委派机制"><a href="#打破双亲委派机制" class="headerlink" title="打破双亲委派机制"></a>打破双亲委派机制</h2><h3 id="Tomcat打破双亲委派机制"><a href="#Tomcat打破双亲委派机制" class="headerlink" title="Tomcat打破双亲委派机制"></a>Tomcat打破双亲委派机制</h3><p>以Tomcat类加载为例，Tomcat 如果使用默认的双亲委派类加载机制行不行？</p>
<p>我们思考一下：Tomcat是个web容器， 那么它要解决什么问题： </p>
<p>1、 一个web容器可能需要部署两个应用程序，不同的应用程序可能会<strong>依赖同一个第三方类库的不同版本</strong>，不能要求同一个类库在同一个服务器只有一份，因此要保证每个应用程序的类库都是独立的，保证相互隔离。 </p>
<p>2、部署在同一个web容器中<strong>相同的类库相同的版本可以共享</strong>。否则，如果服务器有10个应用程序，那么要有10份相同的类库加载进虚拟机。 </p>
<p>3、 <strong>web容器也有自己依赖的类库，不能与应用程序的类库混淆</strong>。基于安全考虑，应该让容器的类库和程序的类库隔离开来。 </p>
<p>4、web容器要支持jsp的修改，我们知道，jsp 文件最终也是要编译成class文件才能在虚拟机中运行，但程序运行后修改jsp已经是司空见惯的事情， web容器需要支持 jsp 修改后不用重启。</p>
<p><strong>Tomcat 如果使用默认的双亲委派类加载机制行不行？</strong></p>
<p>答案是不行的。为什么？</p>
<p>第一个问题，如果使用默认的类加载器机制，那么是无法加载两个相同类库的不同版本的，默认的类加器是不管你是什么版本的，只在乎你的全限定类名，并且只有一份。</p>
<p>第二个问题，默认的类加载器是能够实现的，因为他的职责就是保证<strong>唯一性</strong>。</p>
<p>第三个问题和第一个问题一样。</p>
<p>我们再看第四个问题，我们想我们要怎么实现jsp文件的热加载，jsp 文件其实也就是class文件，那么如果修改了，但类名还是一样，类加载器会直接取方法区中已经存在的，修改后的jsp是不会重新加载的。那么怎么办呢？我们可以直接卸载掉这jsp文件的类加载器，所以你应该想到了，每个jsp文件对应一个唯一的类加载器，当一个jsp文件修改了，就直接卸载这个jsp类加载器。重新创建类加载器，重新加载jsp文件。</p>
<h3 id="Tomcat自定义加载器详解"><a href="#Tomcat自定义加载器详解" class="headerlink" title="Tomcat自定义加载器详解"></a>Tomcat自定义加载器详解</h3><p>​    <img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9810JVM01%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/image-20220228231621243.png" alt="0"></p>
<p>tomcat的几个主要类加载器：</p>
<ul>
<li>commonLoader：Tomcat最基本的类加载器，加载路径中的class可以被Tomcat容器本身以及各个Webapp访问；</li>
<li>catalinaLoader：Tomcat容器私有的类加载器，加载路径中的class对于Webapp不可见；</li>
<li>sharedLoader：各个Webapp共享的类加载器，加载路径中的class对于所有Webapp可见，但是对于Tomcat容器不可见；</li>
<li>WebappClassLoader：各个Webapp私有的类加载器，加载路径中的class只对当前Webapp可见，比如加载war包里相关的类，每个war包应用都有自己的WebappClassLoader，实现相互隔离，比如不同war包应用引入了不同的spring版本，这样实现就能加载各自的spring版本；</li>
</ul>
<p>从图中的委派关系中可以看出：</p>
<p>​    CommonClassLoader能加载的类都可以被CatalinaClassLoader和SharedClassLoader使用，从而实现了公有类库的共用，CatalinaClassLoader和SharedClassLoader自己能加载的类则与对方相互隔离。WebAppClassLoader可以使用SharedClassLoader加载到的类，但各个WebAppClassLoader实例之间相互隔离。而JasperLoader的加载范围仅仅是这个JSP文件所编译出来的那一个.Class文件，它出现的目的就是为了被丢弃：当Web容器检测到JSP文件被修改时，会替换掉目前的JasperLoader的实例，并通过再建立一个新的Jsp类加载器来实现JSP文件的热加载功能。</p>
<p>tomcat 这种类加载机制违背了java 推荐的双亲委派模型，<strong>每个webappClassLoader加载自己的目录下的class文件，不会默认传递给父类加载器（先尝试自己加载，再从父类那找），打破了双亲委派机制</strong>。</p>
<h3 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h3><p>1、模拟实现Tomcat的webappClassLoader加载自己war包应用内不同版本类实现相互共存与隔离</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoaderTest</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyClassLoader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ClassLoader</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String classPath;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyClassLoader</span><span class="hljs-params">(String classPath)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.classPath = classPath;<br>        &#125;<br><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">byte</span>[] loadByte(String name) <span class="hljs-keyword">throws</span> Exception &#123;<br>            name = name.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>);<br>            FileInputStream fis = <span class="hljs-keyword">new</span> FileInputStream(classPath + <span class="hljs-string">&quot;/&quot;</span> + name<br>                    + <span class="hljs-string">&quot;.class&quot;</span>);<br>            <span class="hljs-keyword">int</span> len = fis.available();<br>            <span class="hljs-keyword">byte</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[len];<br>            fis.read(data);<br>            fis.close();<br>            <span class="hljs-keyword">return</span> data;<br><br>        &#125;<br><br>        <span class="hljs-keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">byte</span>[] data = loadByte(name);<br>                <span class="hljs-keyword">return</span> defineClass(name, data, <span class="hljs-number">0</span>, data.length);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ClassNotFoundException();<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 重写类加载方法，实现自己的加载逻辑，不委派给双亲加载</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> name</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@param</span> resolve</span><br><span class="hljs-comment">         * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">         * <span class="hljs-doctag">@throws</span> ClassNotFoundException</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="hljs-keyword">boolean</span> resolve)<br>                <span class="hljs-keyword">throws</span> ClassNotFoundException &#123;<br>            <span class="hljs-keyword">synchronized</span> (getClassLoadingLock(name)) &#123;<br>                <span class="hljs-comment">// First, check if the class has already been loaded</span><br>                Class&lt;?&gt; c = findLoadedClass(name);<br><br>                <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// If still not found, then invoke findClass in order</span><br>                    <span class="hljs-comment">// to find the class.</span><br>                    <span class="hljs-keyword">long</span> t1 = System.nanoTime();<br><br>                    <span class="hljs-comment">//非自定义的类还是走双亲委派加载</span><br>                    <span class="hljs-keyword">if</span> (!name.startsWith(<span class="hljs-string">&quot;com.jvm&quot;</span>))&#123;<br>                        c = <span class="hljs-keyword">this</span>.getParent().loadClass(name);<br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        c = findClass(name);<br>                    &#125;<br><br>                    <span class="hljs-comment">// this is the defining class loader; record the stats</span><br>                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);<br>                    sun.misc.PerfCounter.getFindClasses().increment();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (resolve) &#123;<br>                    resolveClass(c);<br>                &#125;<br>                <span class="hljs-keyword">return</span> c;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MyClassLoader classLoader = <span class="hljs-keyword">new</span> MyClassLoader(<span class="hljs-string">&quot;D:/test&quot;</span>);<br>        Class clazz = classLoader.loadClass(<span class="hljs-string">&quot;com.jvm.User1&quot;</span>);<br>        Object obj = clazz.newInstance();<br>        Method method= clazz.getDeclaredMethod(<span class="hljs-string">&quot;sout&quot;</span>, <span class="hljs-keyword">null</span>);<br>        method.invoke(obj, <span class="hljs-keyword">null</span>);<br>        System.out.println(clazz.getClassLoader());<br>        <br>        System.out.println();<br>        MyClassLoader classLoader1 = <span class="hljs-keyword">new</span> MyClassLoader(<span class="hljs-string">&quot;D:/test1&quot;</span>);<br>        Class clazz1 = classLoader1.loadClass(<span class="hljs-string">&quot;com.jvm.User1&quot;</span>);<br>        Object obj1 = clazz1.newInstance();<br>        Method method1= clazz1.getDeclaredMethod(<span class="hljs-string">&quot;sout&quot;</span>, <span class="hljs-keyword">null</span>);<br>        method1.invoke(obj1, <span class="hljs-keyword">null</span>);<br>        System.out.println(clazz1.getClassLoader());<br>    &#125;<br>&#125;<br><br>运行结果：<br>=======自己的加载器加载类调用方法=======<br>comjvm.MyClassLoaderTest$MyClassLoader@266474c2<br><br>=======另外一个User1版本：自己的加载器加载类调用方法=======<br>com.jvm.MyClassLoaderTest$MyClassLoader@66d3c617<br></code></pre></td></tr></table></figure>

<p>注意：同一个JVM内，两个相同包名和类名的类对象可以共存，因为他们的类加载器可以不一样，所以看两个类对象是否是同一个，除了看类的包名和类名是否都相同之外，还需要他们的类加载器也是同一个才能认为他们是同一个。</p>
<p>2、模拟实现Tomcat的JasperLoader热加载</p>
<p>​    原理：后台启动线程监听jsp文件变化，如果变化了找到该jsp对应的servlet类的加载器引用(gcroot)，重新生成新的<strong>JasperLoader</strong>加载器赋值给引用，然后加载新的jsp对应的servlet类，之前的那个加载器因为没有gcroot引用了，下一次gc的时候会被销毁。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优12-JVM内存分配与垃圾收集机制</title>
    <url>/2022/03/06/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h1 id="JVM内存分配与垃圾收集机制"><a href="#JVM内存分配与垃圾收集机制" class="headerlink" title="JVM内存分配与垃圾收集机制"></a>JVM内存分配与垃圾收集机制</h1><p><a href="https://note.youdao.com/s/1n6qJL8A">参考笔记</a></p>
<h2 id="JVM内存分配"><a href="#JVM内存分配" class="headerlink" title="JVM内存分配"></a>JVM内存分配</h2><h3 id="对象内存分配"><a href="#对象内存分配" class="headerlink" title="对象内存分配"></a>对象内存分配</h3><h4 id="对象内存分配流程图"><a href="#对象内存分配流程图" class="headerlink" title="对象内存分配流程图"></a>对象内存分配流程图</h4><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/327202027172.png"></p>
<h4 id="对象栈上分配"><a href="#对象栈上分配" class="headerlink" title="对象栈上分配"></a>对象栈上分配</h4><p>​    我们通过JVM内存分配可以知道JAVA中的对象都是在堆上进行分配，当对象没有被引用的时候，需要依靠GC进行回收内存，如果对象数量较多的时候，会给GC带来较大压力，也间接影响了应用的性能。为了减少临时对象在堆内分配的数量，JVM通过<strong>逃逸分析</strong>确定该对象不会被外部访问。如果不会逃逸可以将该对象在<strong>栈上分配</strong>内存，这样该对象所占用的内存空间就可以随栈帧出栈而销毁，就减轻了垃圾回收的压力。</p>
<p><strong>对象逃逸分析</strong>：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。</p>
<h3 id="对象优先在Eden区分配"><a href="#对象优先在Eden区分配" class="headerlink" title="对象优先在Eden区分配"></a>对象优先在Eden区分配</h3><p>​    大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。我们来进行实际测试一下。</p>
<p>在测试之前我们先来看看 <strong>Minor GC和Full GC 有什么不同呢？</strong></p>
<ul>
<li><strong>Minor GC/Young GC</strong>：指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li>
<li><strong>Major GC/Full GC</strong>：一般会回收老年代 ，年轻代，方法区的垃圾，Major GC的速度一般会比Minor GC的慢10倍以上。</li>
</ul>
<p><strong>Eden与Survivor区默认8:1:1</strong></p>
<p>​    大量的对象被分配在eden区，eden区满了后会触发minor gc，可能会有99%以上的对象成为垃圾被回收掉，剩余存活的对象会被挪到为空的那块survivor区，下一次eden区满了后又会触发minor gc，把eden区和survivor区垃圾对象回收，把剩余存活的对象一次性挪动到另外一块为空的survivor区，因为新生代的对象都是朝生夕死的，存活时间很短，所以JVM默认的8:1:1的比例是很合适的，**<font color="red">让eden区尽量的大，survivor区够用即可</font>**</p>
<p>​    JVM默认有这个参数-XX:+UseAdaptiveSizePolicy(默认开启)，会导致这个8:1:1比例自动变化，如果不想这个比例有变化可以设置参数-XX:-UseAdaptiveSizePolicy<br><strong>示例：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加运行JVM参数： -XX:+PrintGCDetails</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] allocation1, allocation2;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">59000</span>*<span class="hljs-number">1024</span>];<br>    &#125;<br>&#125;<br><br>Heap<br> PSYoungGen      total 75776K, used 65024K [<span class="hljs-number">0x000000076b900000</span>, <span class="hljs-number">0x0000000770d80000</span>, <span class="hljs-number">0x00000007c0000000</span>)<br>  eden space 65024K, <span class="hljs-number">100</span>% used [<span class="hljs-number">0x000000076b900000</span>,<span class="hljs-number">0x000000076f880000</span>,<span class="hljs-number">0x000000076f880000</span>)<br>  from space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000770300000</span>,<span class="hljs-number">0x0000000770300000</span>,<span class="hljs-number">0x0000000770d80000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x000000076f880000</span>,<span class="hljs-number">0x000000076f880000</span>,<span class="hljs-number">0x0000000770300000</span>)<br> ParOldGen       total 173568K, used 0K [<span class="hljs-number">0x00000006c2a00000</span>, <span class="hljs-number">0x00000006cd380000</span>, <span class="hljs-number">0x000000076b900000</span>)<br>  object space 173568K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x00000006c2a00000</span>,<span class="hljs-number">0x00000006c2a00000</span>,<span class="hljs-number">0x00000006cd380000</span>)<br> Metaspace       used 3436K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 374<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br></code></pre></td></tr></table></figure>

<p>​    我们可以看出eden区内存几乎已经被分配完全（即使程序什么也不做，新生代也会使用至少几M内存）。假如我们再为allocation2分配内存会出现什么情况呢？</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加运行JVM参数： -XX:+PrintGCDetails</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] allocation1, allocation2;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">59000</span>*<span class="hljs-number">1024</span>];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>*<span class="hljs-number">1024</span>];<br>    &#125;<br>&#125;<br>[GC (Allocation Failure) [PSYoungGen: 64210K-&gt;888K(75776K)] 64210K-&gt;59896K(249344K), <span class="hljs-number">0.0358277</span> secs] [Times: user=<span class="hljs-number">0.14</span> sys=<span class="hljs-number">0.03</span>, real=<span class="hljs-number">0.04</span> secs] <br>Heap<br> PSYoungGen      total 75776K, used 11538K [<span class="hljs-number">0x000000076b900000</span>, <span class="hljs-number">0x0000000774d00000</span>, <span class="hljs-number">0x00000007c0000000</span>)<br>  eden space 65024K, <span class="hljs-number">16</span>% used [<span class="hljs-number">0x000000076b900000</span>,<span class="hljs-number">0x000000076c366a78</span>,<span class="hljs-number">0x000000076f880000</span>)<br>  from space 10752K, <span class="hljs-number">8</span>% used [<span class="hljs-number">0x000000076f880000</span>,<span class="hljs-number">0x000000076f95e030</span>,<span class="hljs-number">0x0000000770300000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000774280000</span>,<span class="hljs-number">0x0000000774280000</span>,<span class="hljs-number">0x0000000774d00000</span>)<br> ParOldGen       total 173568K, used 59008K [<span class="hljs-number">0x00000006c2a00000</span>, <span class="hljs-number">0x00000006cd380000</span>, <span class="hljs-number">0x000000076b900000</span>)<br>  object space 173568K, <span class="hljs-number">33</span>% used [<span class="hljs-number">0x00000006c2a00000</span>,<span class="hljs-number">0x00000006c63a0010</span>,<span class="hljs-number">0x00000006cd380000</span>)<br> Metaspace       used 3436K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 374<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br></code></pre></td></tr></table></figure>

<pre><code> 因为给allocation2分配内存的时候eden区内存几乎已经被分配完了，我们刚刚讲了当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC，GC期间虚拟机又发现allocation1无法存入Survior空间，所以只好把新生代的对象**提前转移到老年代**中去，老年代上的空间足够存放allocation1，所以不会出现Full GC。执行Minor GC后，后面分配的对象如果能够存在eden区的话，还是会在eden区分配内存。
</code></pre>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//添加运行JVM参数： -XX:+PrintGCDetails</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GCTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] allocation1, allocation2, allocation3, allocation4, allocation5, allocation6;<br>        allocation1 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">59000</span>*<span class="hljs-number">1024</span>];<br>        allocation2 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>*<span class="hljs-number">1024</span>];<br>        allocation3 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>*<span class="hljs-number">1024</span>];<br>        allocation4 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>*<span class="hljs-number">1024</span>];<br>        allocation5 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>*<span class="hljs-number">1024</span>];<br>        allocation6 = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">10000</span>*<span class="hljs-number">1024</span>];<br>    &#125;<br>&#125;<br>[GC (Allocation Failure) [PSYoungGen: 64210K-&gt;888K(75776K)] 64210K-&gt;59896K(249344K), <span class="hljs-number">0.0308868</span> secs] [Times: user=<span class="hljs-number">0.25</span> sys=<span class="hljs-number">0.00</span>, real=<span class="hljs-number">0.03</span> secs] <br>Heap<br> PSYoungGen      total 75776K, used 52799K [<span class="hljs-number">0x000000076b900000</span>, <span class="hljs-number">0x0000000774d00000</span>, <span class="hljs-number">0x00000007c0000000</span>)<br>  eden space 65024K, <span class="hljs-number">79</span>% used [<span class="hljs-number">0x000000076b900000</span>,<span class="hljs-number">0x000000076ebb1e08</span>,<span class="hljs-number">0x000000076f880000</span>)<br>  from space 10752K, <span class="hljs-number">8</span>% used [<span class="hljs-number">0x000000076f880000</span>,<span class="hljs-number">0x000000076f95e010</span>,<span class="hljs-number">0x0000000770300000</span>)<br>  to   space 10752K, <span class="hljs-number">0</span>% used [<span class="hljs-number">0x0000000774280000</span>,<span class="hljs-number">0x0000000774280000</span>,<span class="hljs-number">0x0000000774d00000</span>)<br> ParOldGen       total 173568K, used 59008K [<span class="hljs-number">0x00000006c2a00000</span>, <span class="hljs-number">0x00000006cd380000</span>, <span class="hljs-number">0x000000076b900000</span>)<br>  object space 173568K, <span class="hljs-number">33</span>% used [<span class="hljs-number">0x00000006c2a00000</span>,<span class="hljs-number">0x00000006c63a0010</span>,<span class="hljs-number">0x00000006cd380000</span>)<br> Metaspace       used 3436K, capacity 4496K, committed 4864K, reserved 1056768K<br>  <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">space</span>    <span class="hljs-title">used</span> 374<span class="hljs-title">K</span>, <span class="hljs-title">capacity</span> 388<span class="hljs-title">K</span>, <span class="hljs-title">committed</span> 512<span class="hljs-title">K</span>, <span class="hljs-title">reserved</span> 1048576<span class="hljs-title">K</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">Process</span> <span class="hljs-title">finished</span> <span class="hljs-title">with</span> <span class="hljs-title">exit</span> <span class="hljs-title">code</span> 0</span><br><span class="hljs-class"></span><br></code></pre></td></tr></table></figure>

<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>​    大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。JVM参数 -XX:PretenureSizeThreshold 可以设置大对象的大小，如果对象超过设置大小会直接进入老年代，不会进入年轻代，这个参数只在 Serial 和ParNew两个收集器下有效。</p>
<p>​    比如设置JVM参数：-XX:PretenureSizeThreshold=1000000 (单位是字节)  -XX:+UseSerialGC  ，再执行下上面的第一个程序会发现大对象直接进了老年代</p>
<p><strong>为什么要这样呢？</strong></p>
<p>​    为了避免为大对象分配内存时的复制操作而降低效率。</p>
<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>​    既然虚拟机采用了<strong>分代收集</strong>的思想来管理内存，那么内存回收时就必须能识别哪些对象应放在新生代，哪些对象应放在老年代中。为了做到这一点，虚拟机给每个对象一个对象年龄（Age）计数器。<br>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为1。对象在 Survivor 中每熬过一次 MinorGC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁，CMS收集器默认6岁，不同的垃圾收集器会略微有点不同），就会被晋升到老年代中。对象晋升到老年代的年龄阈值。</p>
<p>​    可以通过参数 <strong>-XX:MaxTenuringThreshold</strong> 来设置。</p>
<h3 id="对象动态年龄判断"><a href="#对象动态年龄判断" class="headerlink" title="对象动态年龄判断"></a>对象动态年龄判断</h3><p>​    当前放对象的Survivor区域里(其中一块区域，放对象的那块s区)，一批对象的总大小大于这块Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了，例如Survivor区域里现在有一批对象，年龄1+年龄2+年龄n的多个年龄对象总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对象都放入老年代。这个规则其实是<strong>希望那些可能是长期存活的对象，尽早进入老年代</strong>。<strong>对象动态年龄判断机制一般是在minor gc之后触发的</strong></p>
<h3 id="老年代空间分配担保机制"><a href="#老年代空间分配担保机制" class="headerlink" title="老年代空间分配担保机制"></a>老年代空间分配担保机制</h3><p>​    年轻代每次minor gc之前JVM都会计算下老年代剩余可用空间，如果这个可用空间小于年轻代里现有的所有对象大小之和(包括垃圾对象)就会看一个“-XX:-HandlePromotionFailure”(<strong>jdk1.8默认就设置了</strong>)的参数是否设置了<br>如果有这个参数，就会看看老年代的可用内存大小，是否大于之前每一次minor gc后进入老年代的对象的平均大小。如果上一步结果是小于或者之前说的参数没有设置，那么就会触发一次Full gc，对老年代和年轻代一起回收一次垃圾，如果回收完还是没有足够空间存放新的对象就会发生”OOM”。当然，如果minor gc之后剩余存活的需要挪动到老年代的对象大小还是大于老年代可用空间，那么也会触发full gc，full gc完之后如果还是没有空间放minor gc之后的存活对象，则也会发生“OOM”。</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/clipboard.png"></p>
<h3 id="对象内存回收"><a href="#对象内存回收" class="headerlink" title="对象内存回收"></a>对象内存回收</h3><p>​    堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象），那么如何判断对象是否可回收。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>​    给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ReferenceCountingGc</span> </span>&#123;<br>   Object instance = <span class="hljs-keyword">null</span>;<br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>      ReferenceCountingGc objA = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>      ReferenceCountingGc objB = <span class="hljs-keyword">new</span> ReferenceCountingGc();<br>      objA.instance = objB;<br>      objB.instance = objA;<br>      objA = <span class="hljs-keyword">null</span>;<br>      objB = <span class="hljs-keyword">null</span>;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>​    将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象</p>
<p>​    <strong>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</strong></p>
<p>​    <img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/6E72848C54E84BB7A76F0FF89ED5010D.jpeg"></p>
<h4 id="常见引用类型"><a href="#常见引用类型" class="headerlink" title="常见引用类型"></a>常见引用类型</h4><p>java的引用类型一般分为四种：<strong>强引用</strong>、<strong>软引用</strong>、弱引用、虚引用</p>
<p><strong>强引用</strong>：普通的变量引用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User user = <span class="hljs-keyword">new</span> User();<br></code></pre></td></tr></table></figure>

<p> <strong>软引用</strong>：将对象用SoftReference软引用类型的对象包裹，正常情况不会被回收，但是GC做完后发现释放不出空间存放新的对象，则会把这些软引用的对象回收掉。<strong>软引用可用来实现内存敏感的高速缓存。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SoftReference&lt;User&gt; user = <span class="hljs-keyword">new</span> SoftReference&lt;User&gt;(<span class="hljs-keyword">new</span> User());  <br></code></pre></td></tr></table></figure>

<p>​    软引用在实际中有重要的应用，假如有一个应用需要读取大量的本地图片，如果每次读取图片都从硬盘读取，则会严重影响性能，但是如果全部加载到内存当中，又有可能造成内存溢出，此时使用软引用可以解决这个问题。</p>
<p>​    设计思路是：用一个HashMap来保存图片的路径 和 相应图片对象关联的软引用之间的映射关系，在内存不足时，JVM会自动回收这些缓存图片对象所占用的空间，从而有效地避免了OOM的问题。在Android开发中对于大量图片下载会经常用到</p>
<p><strong>弱引用</strong>：将对象用WeakReference软引用类型的对象包裹，弱引用跟没引用差不多，<strong>一旦触发GC会直接回收掉只有弱引用引用的变量或空间</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> WeakReference&lt;User&gt; user = <span class="hljs-keyword">new</span> WeakReference&lt;User&gt;(<span class="hljs-keyword">new</span> User());<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/12211b97837395685e42052bb9026aa1.png" alt="在这里插入图片描述"></p>
<h5 id="ThreadLocal的原理"><a href="#ThreadLocal的原理" class="headerlink" title="ThreadLocal的原理"></a>ThreadLocal的原理</h5><p>​    ThreadLocal就是用的弱引用，首先，ThreadLocal是多线程中用于解决线程安全的一个线程内部存储类，它为每一个线程分配一个独立的线程副本，实现线程内的资源共享。每个Thread中维护着一个Map，就是ThreadLocal.ThreadLocalMap，他的key是ThreadLocal实例的弱引用，value是变量值。</p>
<h5 id="ThreadLocal的Key为什么使用弱引用"><a href="#ThreadLocal的Key为什么使用弱引用" class="headerlink" title="ThreadLocal的Key为什么使用弱引用"></a>ThreadLocal的Key为什么使用弱引用</h5><p>​    如果key使用强引用，当threadlocal变量不再使用后（比如某些切面逻辑使用完毕），threadlocal不再被程序引用，由于线程还存活着且存在着对threadlocal的强引用导致无法回收（实际上threadlocal没用了，可以回收了），使用弱引用可以解决这个问题，顺利回收threadlocal。</p>
<h5 id="ThreadLocal的内存泄漏问题"><a href="#ThreadLocal的内存泄漏问题" class="headerlink" title="ThreadLocal的内存泄漏问题"></a>ThreadLocal的内存泄漏问题</h5><p>​    虽然key使用了弱引用，threadlocal被回收后，只要线程没结束，value依然被强引用着，，若果线程生命周期很长就会导致value一直占用内存，所以可以在使用结束后手动调用ThreadLocal.remove()方法来清除整个Entry</p>
<p><strong>虚引用：</strong>虚引用也称为幽灵引用或者幻影引用，它是最弱的一种引用关系，几乎不用</p>
<h4 id="finalize-方法最终判定对象是否存活"><a href="#finalize-方法最终判定对象是否存活" class="headerlink" title="finalize()方法最终判定对象是否存活"></a>finalize()方法最终判定对象是否存活</h4><p>​    即使在可达性分析算法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历再次标记过程。</p>
<p>​    <strong>标记的前提是对象在进行可达性分析后发现没有与GC Roots相连接的引用链</strong></p>
<p><strong>1. 第一次标记并进行一次筛选。</strong></p>
<p>​    筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize方法，对象将直接被回收。</p>
<p><strong>2. 第二次标记</strong></p>
<p>​    如果这个对象覆盖了finalize方法，finalize方法是对象脱逃死亡命运的最后一次机会，如果对象要在finalize()中成功拯救自己，只要重新与引用链上的任何的一个对象建立关联即可，譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。</p>
<p>​    注意：一个对象的finalize()方法只会被执行一次，也就是说通过调用finalize方法自我救命的机会就一次。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FinalizeTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Object&gt; LIST = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                LIST.add(<span class="hljs-keyword">new</span> User(i++, UUID.randomUUID().toString()));<br>            <span class="hljs-keyword">new</span> User(j--, UUID.randomUUID().toString());<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(Integer id, String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-comment">//User类需要重写finalize方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finalize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        FinalizeTest.LIST.add(<span class="hljs-keyword">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;关闭资源，userid=&quot;</span> + id + <span class="hljs-string">&quot;即将被回收&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h3><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类呢？</p>
<ul>
<li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 ClassLoader 已经被回收。</li>
<li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><h3 id="标记清除算法"><a href="#标记清除算法" class="headerlink" title="标记清除算法"></a>标记清除算法</h3><p>​    算法分为“标记”和“清除”阶段：标记存活的对象， 统一回收所有未被标记的对象(一般选择这种)；也可以反过来，标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象 。它是最基础的收集算法，比较简单，但是会带来两个明显的问题：</p>
<p><strong>1、效率问题（若标记的对象太多，则效率不高）</strong></p>
<p><strong>2、空间问题（标记清楚后会产生大量不连续的碎片空间，不利于空间利用及大对象的分配）</strong></p>
<h3 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h3><p>​    根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/image-20220308220129146.png" alt="image-20220308220129146"></p>
<h3 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h3><p>​    为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p>​    新生代中Eden区和2个Survivor区就是复制算法的变形，复制回收时，Eden+S1复制存活对象到S2，反正Eden + S2 -&gt; S1</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9812-JVM%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E6%9C%BA%E5%88%B6/image-20220308215328308.png" alt="image-20220308215328308"></p>
<h3 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h3><p>​    当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>​    比如在新生代中，每次收集都会有大量对象(近99%)死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。注意，“标记-清除”或“标记-整理”算法会比复制算法慢10倍以上。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优13-JVM垃圾收集器详解</title>
    <url>/2022/03/08/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="JVM垃圾收集器详解"><a href="#JVM垃圾收集器详解" class="headerlink" title="JVM垃圾收集器详解"></a>JVM垃圾收集器详解</h1><h2 id="垃圾收集器有哪些？"><a href="#垃圾收集器有哪些？" class="headerlink" title="垃圾收集器有哪些？"></a>垃圾收集器有哪些？</h2><p>Serial 收集器</p>
<p>Parallel Scavenge收集器</p>
<p>ParNew收集器</p>
<p>CMS收集器</p>
<p>G1收集器</p>
<p>​    如果说收集算法是内存回收的方法论，那么<strong>垃圾收集器就是内存回收算法的具体实现</strong>。 虽然我们对各个收集器进行比较，但并非为了挑选出一个最好的收集器。因为直到现在为止还没有 最好的垃圾收集器出现，更加没有万能的垃圾收集器，我们能做的就是根据具体应用场景选择适合 自己的垃圾收集器。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么 我们的Java虚拟机就不会实现那么多不同的垃圾收集器了。</p>
<h2 id="虚拟机运行模式"><a href="#虚拟机运行模式" class="headerlink" title="虚拟机运行模式"></a>虚拟机运行模式</h2><p>​    目前java虚拟机有两种模式，分别为Client模式和Server模式。这两种模式可以使用-Client和-Server参数可以进行设置。如果没有设置的话，怎么办呢？那当然难不倒虚拟机，以它的智商当然会根据当前计算机系统环境自动选择运行模式。</p>
<p>​    那它怎么检测呢？当不指定运行模式参数时，虚拟机启动检测主机是否为服务器，如果是，则以Server模式启动，否则以Client模式启动（J2SE5.0检测的根据是至少2个CPU和最低2GB内存）</p>
<h2 id="Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC"><a href="#Serial收集器-XX-UseSerialGC-XX-UseSerialOldGC" class="headerlink" title="Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)"></a>Serial收集器(-XX:+UseSerialGC -XX:+UseSerialOldGC)</h2><p>​    <strong>可应用于年轻代和老年代，新生代采用复制算法，老年代采用标记-整理算法</strong></p>
<p>​    Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一 个单线程收集器了。它的 “单线程” 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃 圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程<strong>STW</strong>（ “Stop The World” ），直到它收集结束。</p>
<p>​    虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计 中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。 但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它简单而高效（与其他收集器的 单线程相比）。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。 Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器。它主要有两大用 途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案</p>
<p><strong>特点</strong>：<br><strong>1、单线程，简单而高效</strong><br><strong>2、作为CMS的后备方案</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220308231007320.png" alt="image-20220308231007320"></p>
<h2 id="Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代"><a href="#Parallel-Scavenge收集器-XX-UseParallelGC-年轻代-XX-UseParallelOldGC-老年代" class="headerlink" title="Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))"></a>Parallel Scavenge收集器(-XX:+UseParallelGC(年轻代),-XX:+UseParallelOldGC(老年代))</h2><p>​    就是Serial的多线程版本，<strong>新生代采用复制算法，老年代采用标记-整理算法</strong>。Parallel收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器类似。默认的收集线程数跟cpu核数相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改</p>
<p>​    Parallel Scavenge收集器<strong>关注点是吞吐量（高效率的利用CPU）</strong>。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。 Parallel Scavenge收集器提供了很多参数供用户找到<strong>最合适的停顿时间</strong>或最大吞吐量，如果对于收集器运作不太了解的话，可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>特点</strong></p>
<p>1、注重吞吐量（并发收集、调整合适的停顿时间）</p>
<p>2、JDK8默认的新生代和老年代收集器（Parallel Scavenge收集器和Parallel Old）</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220309220252386.png" alt="image-20220309220252386"></p>
<h2 id="ParNew收集器-XX-UseParNewGC"><a href="#ParNew收集器-XX-UseParNewGC" class="headerlink" title="ParNew收集器(-XX:+UseParNewGC)"></a>ParNew收集器(-XX:+UseParNewGC)</h2><p>​    类似Parallel Scavenge ，一般用于<strong>年轻代</strong>垃圾收集，配合CMS使用。<strong>新生代采用复制算法，老年代采用标记-整理算法</strong><br>起多个线程去并发进行垃圾回收，默认的收集线程数跟cpu核数 相同，当然也可以用参数(-XX:ParallelGCThreads)指定收集线程数，但是一般不推荐修改。</p>
<p>​    它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器 （真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<ul>
<li>“-XX:+UseConcMarkSweepGC”：指定使用CMS后，会默认使用ParNew作为新生代收集器；</li>
<li>“-XX:+UseParNewGC”：强制指定使用ParNew；</li>
<li>“-XX:ParallelGCThreads”：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同；</li>
</ul>
<p><strong>特点：</strong></p>
<p><strong>1、一般用户年轻代配合CMS老年代使用主流使用</strong><br><strong>2、性能好于Searial</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220308232555436.png" alt="image-20220308232555436"></p>
<h2 id="CMS收集器（-XX-UseConcMarkSweepGC）"><a href="#CMS收集器（-XX-UseConcMarkSweepGC）" class="headerlink" title="CMS收集器（-XX:+UseConcMarkSweepGC）"></a>CMS收集器（-XX:+UseConcMarkSweepGC）</h2><p>​    <strong>CMS(Concurrent Mark Sweep 并发标记清除)是一种以获取最短停顿时间为目标的收集器，注重用户停用时间（STW）,实现了垃圾收集线程与用户线程并行执行</strong>，它是HotSpot虚拟机第一款真正意义上的并发收集器</p>
<p>​    采用标记清除算法，垃圾收集过程分的4个重要步骤</p>
<p>1、初始标记：STW暂停用户线程，记录GC Roots的直接应用对象，速度很快</p>
<p>2、并发标记：同事开启GC线程和用户线程，用一个闭包结构去记录可达对象，并发标记过程中会产生的新的引用变跟，所以GC线程无法保证可达性分析的实时性。</p>
<p>（预处理、可中断的预处理）</p>
<p>3、重新标记：STW,修正并发标记过程中产生的变动，时间大于初始标记且远远小于并发标记的时间</p>
<p>4、并发清理：开启用户线程，并清理未标记的做清除工作</p>
<p>（并发重置）</p>
<p><strong>特点</strong>：</p>
<p>1、并发收集、低停顿（获取最短停顿时间）</p>
<p>2、对CPU资源敏感，和用户服务线程抢资源</p>
<p>3、使用标记清除算法，会遗留大量碎片化空间；通过参数-XX:+UseCMSCompactAtFullCollection 可以让jvm在执行完标记清除后再做整理 </p>
<p>4、执行过程的不确定性，可能上一次还没执行完成，又在触发fullGC,也就是”concurrent mode failure”，此时会进入STW，用serial old垃圾收集器来回收</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310081843874.png" alt="image-20220310081843874"></p>
<h3 id="CMS相关参数"><a href="#CMS相关参数" class="headerlink" title="CMS相关参数"></a>CMS相关参数</h3><p>1、-XX:+UseConcMarkSweepGC：启动CMS</p>
<p>2、-XX:ConcGCThreads：并发GC线程数</p>
<p>3、-XX:UserCMSCompactAtFullCollection：FullGC后做压缩整理（减少碎片）</p>
<p>4、-XX:CMSFullGCsBeforeCompaction：多少次FullGC才触发一次压缩，默认0，一次FullGC压缩一次</p>
<p>5、-XX:CMSInitiatingOccupancyFraction：当老年代使用比例达到该比例是会触发FullGC,默认百分之92</p>
<p>6、-XX:+UseCMSInitiatingOccupancyOnly：只使用-XX:CMSInitiatingOccupancyFraction设置的值来设置比例，不然只有第一次使用设定值，后面会自动调整</p>
<p>7、-XX:CMSScavengeBeforeRemark：在CMSGC启动前先触发一次YougGC，目的是为了减少老年代对年轻代的引用，减低CMS GC标记阶段的开销，，一般CMS的GC耗时 80%都在 remark阶段</p>
<h3 id="亿级流量电商系统如何优化JVM参数设置-ParNew-CMS"><a href="#亿级流量电商系统如何优化JVM参数设置-ParNew-CMS" class="headerlink" title="亿级流量电商系统如何优化JVM参数设置(ParNew+CMS)"></a>亿级流量电商系统如何优化JVM参数设置(ParNew+CMS)</h3><p>​    大型电商系统后端现在一般都是拆分为多个子系统部署的，比如，商品系统，库存系统，订单系统，促销系统，会员系统等等。 </p>
<p>​    我们这里以比较核心的订单系统为例对于8G内存，我们一般是分配4G内存给JVM，正常的JVM参数配置如下：</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310083615638.png" alt="image-20220310083615638"></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">‐Xms3072M</span> <span class="hljs-string">‐Xmx3072M ‐Xmn1536M ‐Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M ‐XX:SurvivorRatio=8</span><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310084300444.png" alt="image-20220310084300444">    </p>
<p>​    系统按每秒生成60MB的速度来生成对象，大概运行20秒就会撑满eden区，会出发minor gc，大概会有95%以上对象成为垃圾被回收，可能最后一两秒生成的对象还被引用着，我们暂估为100MB左右，那么这100M会被挪到S0区，回忆下<strong>动态对象年龄判断原则</strong>，这100MB对象同龄而且总和大于S0区的50%，那么这些对象都会被挪到老年代，到了老年代不到一秒又变成了垃圾对象，很明显，survivor区大小设置有点小</p>
<p>​    我们分析下系统业务就知道，明显大部分对象都是短生存周期的，根本不应该频繁进入老年代，也没必要给老年代维持过大的内存空间，得让对象尽量留在新生代里。于是我们可以更新下JVM参数设置： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">-Xms3072M</span> <span class="hljs-string">‐Xmx3072M ‐Xmn2048M ‐Xss1M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  ‐XX:SurvivorRatio=8 </span><br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310084312004.png" alt="image-20220310084312004">    </p>
<p>这样就降低了因为对象动态年龄判断原则导致的对象频繁进入老年代的问题，其实<strong>很多优化无非就是让短期存活的对象尽量都留在survivor里，不要进入老年代，这样在minor gc的时候这些对象都会被回收，不会进到老年代从而导致full gc</strong>。 </p>
<p>​    对于对象年龄应该为多少才移动到老年代比较合适，本例中一次minor gc要间隔二三十秒，大多数对象一般在几秒内就会变为垃圾，完全可以将默认的15岁改小一点，比如改为5，那么意味着对象要经过5次minor gc才会进入老年代，整个时间也有一两分钟了，如果对象这么长时间都没被回收，完全可以认为这些对象是会存活的比较长的对象，可以移动到老年代，而不是继续一直占用survivor区空间。对于多大的对象直接进入老年代(参数-XX:PretenureSizeThreshold)，这个一般可以结合你自己系统看下有没有什么大对象生成，预估下大对象的大小，一般来说设置为1M就差不多了，很少有超过 1M的大对象，这些对象一般就是你系统初始化分配的缓存对象，比如大的缓存List，Map之类的 对象。 可以适当调整JVM参数如下： </p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">-Xms3072M</span> <span class="hljs-string">-Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 </span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M </span><br></code></pre></td></tr></table></figure>

<p>​    对于老年代CMS的参数如何设置我们可以思考下，首先我们想下当前这个系统有哪些对象可能会长期存活躲过5次以上minor gc最终进入老年代。 无非就是那些Spring容器里的Bean，线程池对象，一些初始化缓存数据对象等，这些加起来充其 量也就几十MB。 还有就是某次minor gc完了之后还有超过200M的对象存活，那么就会直接进入老年代，比如突然某一秒瞬间要处理五六百单，那么每秒生成的对象可能有一百多M，再加上整个系统可能压力剧 增，一个订单要好几秒才能处理完，下一秒可能又有很多订单过来。我们可以估算下大概每隔五六分钟出现一次这样的情况，那么大概半小时到一小时之间就可能因为老年代满了触发一次Full GC，Full GC的触发条件还有我们之前说过的<strong>老年代空间分配担保机制</strong>，历次的minor gc挪动到老年代的对象大小肯定是非常小的，所以几乎不会在minor gc触发之前由于老年代空间分配担保失败而产生full gc，其实在半小时后发生full gc，这时候已经过了抢购的最 高峰期，后续可能几小时才做一次FullGC。 </p>
<p>​    对于碎片整理，因为都是1小时或几小时才做一次FullGC，是可以每做完一次就开始碎片整理。 综上，只要年轻代参数设置合理，老年代CMS的参数设置基本都可以用默认值，如下所示：</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">-Xms3072M</span> <span class="hljs-string">-Xmx3072M -Xmn2048M -Xss1M  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:SurvivorRatio=8 </span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">MaxTenuringThreshold=5 -XX:PretenureSizeThreshold=1M -XX:+UseParNewGC -XX:+UseConcMarkSweepGC </span><br><span class="hljs-meta">-XX</span>:<span class="hljs-string">CMSInitiatingOccupancyFraction=92 -XX:+UseCMSCompactAtFullCollection -XX:CMSFullGCsBeforeCompaction=3</span><br></code></pre></td></tr></table></figure>

<h2 id="G1收集器（-XX-UseG1GC）"><a href="#G1收集器（-XX-UseG1GC）" class="headerlink" title="G1收集器（-XX:+UseG1GC）"></a>G1收集器（-XX:+UseG1GC）</h2><p>​    <strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器，主要针对配备多颗处理器及大容量内存的机器，以极高的概率满足GC停顿时间的要求的同时，还满足高吞吐的性能要求</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310091315475.png" alt="image-20220310091315475"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310091320876.png" alt="image-20220310091320876"></p>
<p>​    G1将Java堆划分为多个大小相等的独立区域（Region），JVM最多可以有2048个Region。 一般Region大小等于堆大小除以2048，比如堆大小为4096M，则Region大小为2M，当然也可以 用参数”-XX:G1HeapRegionSize”手动指定Region大小，但是推荐默认的计算方式。 G1保留了年轻代和老年代的概念，但不再是物理隔阂了，它们都是（可以不连续）Region的集合。</p>
<p>​    默认年轻代对堆内存的占比是5%，如果堆大小为4096M，那么年轻代占据200MB左右的内存， 对应大概是100个Region，可以通过“-XX:G1NewSizePercent”设置新生代初始占比，在系统 运行中，JVM会不停的给年轻代增加更多的Region，但是最多新生代的占比不会超过60%，可以 通过“-XX:G1MaxNewSizePercent”调整。</p>
<p>​    年轻代中的Eden和Survivor对应的region也跟之前 一样，默认8:1:1，假设年轻代现在有1000个region，eden区对应800个，s0对应100个，s1对应 100个。 一个Region可能之前是年轻代，如果Region进行了垃圾回收，之后可能又会变成老年代，也就是 说Region的区域功能可能会动态变化。</p>
<p>​    G1垃圾收集器对于对象什么时候会转移到老年代跟之前讲过的原则一样，唯一不同的是对大对象 的处理，G1有专门分配大对象的Region叫<strong>Humongous</strong>区，而不是让大对象直接进入老年代的 Region中。在G1中，大对象的判定规则就是一个大对象**超过了一个Region大小的50%**，比如按 照上面算的，每个Region是2M，只要一个大对象超过了1M，就会被放入Humongous中，而且 一个大对象如果太大，可能会横跨多个Region来存放。</p>
<p>Humongous区<strong>专门存放短期巨型对象</strong>，不用直接进老年代，可以节约老年代的空间，避免因为老 年代空间不够的GC开销。 Full GC的时候除了收集年轻代和老年代之外，也会将Humongous区一并回收。</p>
<p>​    G1收集器一次GC的运作过程大致分为以下几个步骤： </p>
<p>1、初始标记，同CMS</p>
<p>2、并发标记，同CMS</p>
<p>3、最终标记，同CMS重新标记</p>
<p>4、<strong>筛选回收</strong>，筛选回收阶段首先对各个Region的回收价值和成本进行 排序，<strong>根据用户所期望的GC停顿时间(可以用JVM参数 -XX:MaxGCPauseMillis指定)来制 定回收计划</strong>，比如说老年代此时有1000个Region都满了，但是因为根据预期停顿时间，本 次垃圾回收可能只能停顿200毫秒，那么通过之前回收成本计算得知，可能回收其中800个 Region刚好需要200ms，那么就只会回收800个Region，尽量把GC导致的停顿时间控制在 我们指定的范围内。这个阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一 部分Region，时间是用户可控制的，而且停顿用户线程将大幅提高收集效率。不管是年轻代 或是老年代，回收算法主要用的是复制算法，将一个region中的存活对象复制到另一个 region中，这种不会像CMS那样回收完因为有很多内存碎片还需要整理一次，G1采用复制 算法回收几乎不会有太多内存碎片</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220310092501416.png" alt="image-20220310092501416"></p>
<p>​    G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的 Region(这也就是它的名字Garbage-First的由来)，比如一个Region花200ms能回收10M垃 圾，另外一个Region花50ms能回收20M垃圾，在回收时间有限情况下，G1当然会优先选择后面 这个Region回收。<strong>这种使用Region划分内存空间以及有优先级的区域回收方式，保证了G1收集 器在有限时间内可以尽可能高的收集效率</strong>。</p>
<p>G1被视为JDK1.7以上版本Java虚拟机的一个重要进化特征。它具备以下特点</p>
<p>1、<strong>并行与并发</strong>：存在并发标记，并发回收的过程，充分利用cpu资源</p>
<p>2、<strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留 了分代的概念</p>
<p>3、<strong>空间整理</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法 实现的收集器；从局部上来看是基于“<strong>复制”算法</strong>实现的。</p>
<p>4、<strong>可预测的停顿（适合大内存）</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同 的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指 定在一个长度为M毫秒的时间片段(通过参数”-XX:MaxGCPauseMillis”指定)内完成垃圾收 集</p>
<p>5、Humongous区存放短期大对象</p>
<p>6、除了Youg GC，Old GC，还存在Mixed GC,</p>
<h3 id="G1收集器参数设置"><a href="#G1收集器参数设置" class="headerlink" title="G1收集器参数设置"></a>G1收集器参数设置</h3><p>1、-XX:+UserG1GC:使用G1收集器</p>
<p>2、-XX:ParallelGCThreads:指定GC工作的线程数量</p>
<p>3、-XX:G1HeapReginSize:指定region分区大小（1-32M 必须是2的幂），默认将堆划分为2048个分区</p>
<p>4、-XX:MaxGCPauseMillis:目标暂停时间（默认200ms）</p>
<p>5、-XX:G1NewSizePercent:新生代内存默认初始比例（默认比例5%）</p>
<p>6、-XX:G1MaxNewSizePercent:新生代内存最大空间 </p>
<p>7、-XX:TargetSurvivorRatio:Survivor区的填充容量(默认50%)，Survivor区域里的一批对象(年龄 1+年龄2+年龄n的多个年龄对象)总和超过了Survivor区域的50%，此时就会把年龄n(含)以上的对 象都放入老年代</p>
<p>8、-XX:MaxTenuringThreshold:最大年龄阈值（默认年龄15进入老年代）</p>
<p>9、-XX:InitiatingHeapOccupancyPercent:老年代占用空间达到整堆内存阈值(默认45%)，则执行 新生代和老年代的混合收集(MixedGC)，比如我们之前说的堆默认有2048个region，如果有接近 1000个region都是老年代的region，则可能就要触发MixedGC了</p>
<p>10、-XX:G1HeapWastePercent(默认5%): gc过程中空出来的region是否充足阈值，在混合回收的时 候，对Region回收都是基于复制算法进行的，都是把要回收的Region里的存活对象放入其他 Region，然后这个Region中的垃圾对象全部清理掉，这样的话在回收过程就会不断空出来新的 Region，一旦空闲出来的Region数量达到了堆内存的5%，此时就会立即停止混合回收，意味着 本次混合回收就结束了</p>
<p>11、-XX:G1MixedGCLiveThresholdPercent(默认85%) region中的存活对象低于这个值时才会回收 该region，如果超过这个值，存活对象过多，回收的的意义不大。</p>
<p>12、-XX:G1MixedGCCountTarget:在一次回收过程中指定做几次筛选回收(默认8次)，在最后一个筛 选回收阶段可以回收一会，然后暂停回收，恢复系统运行，一会再开始回收，这样可以让系统不至 于单次停顿时间过长。</p>
<h3 id="G1垃圾收集类别"><a href="#G1垃圾收集类别" class="headerlink" title="G1垃圾收集类别"></a>G1垃圾收集类别</h3><h4 id="Youg-GC"><a href="#Youg-GC" class="headerlink" title="Youg GC"></a>Youg GC</h4><p>​    YoungGC并不是说现有的Eden区放满了就会马上触发，而且G1会计算下现在Eden区回收大 概要多久时间，如果回收时间远远小于参数 -XX:MaxGCPauseMills 设定的值，那么增加年轻代 的region，继续给新对象存放，不会马上做Young GC，直到下一次Eden区放满，G1计算回收时 间接近参数 -MaxGCPauseMillis设定的值，那么就会触发Young GC</p>
<p>​    根据 -XX:MaxGCPauseMills 设定值判断是否要进行YougGC</p>
<h4 id="Mixed-GC"><a href="#Mixed-GC" class="headerlink" title="Mixed GC"></a>Mixed GC</h4><p>​    不是FullGC，老年代的堆占有率达到参数(-XX:InitiatingHeapOccupancyPercen)设定的值则触发，<strong>回收所有的Young和部分Old(根据期望的GC停顿时间确定old区垃圾收集的优先顺序)以及大对象区</strong>，正常情况G1的垃圾收集是先做MixedGC，主要使用<strong>复制算法</strong>，需要把各个region中 存活的对象拷贝到别的region里去，拷贝过程中如果发现没有足够的空region能够承载拷贝对象就会触发一次Full GC</p>
<p>​    老年代堆占有率达到阈值触发Mixed GC</p>
<h4 id="Old-GC"><a href="#Old-GC" class="headerlink" title="Old GC"></a>Old GC</h4><p>​    停止系统程序，然后采用单线程进行标记、清理和压缩整理，好空闲出来一批Region来供下 一次MixedGC使用，这个过程是非常耗时的。</p>
<h3 id="G1垃圾收集器优化建议"><a href="#G1垃圾收集器优化建议" class="headerlink" title="G1垃圾收集器优化建议"></a>G1垃圾收集器优化建议</h3><p>​    假设参数 -XX:MaxGCPauseMills 设置的值很大，导致系统运行很久，年轻代可能都占用了堆 内存的60%了，此时才触发年轻代gc。 那么存活下来的对象可能就会很多，此时就会导致Survivor区域放不下那么多的对象，就会进 入老年代中。 或者是你年轻代gc过后，存活下来的对象过多，导致进入Survivor区域后触发了动态年龄判定 规则，达到了Survivor区域的50%，也会快速导致一些对象进入老年代中。 </p>
<p>​    <strong>所以这里核心还是在于调节 -XX:MaxGCPauseMills 这个参数的值，在保证他的年轻代gc别太频繁的同时，还得考虑每次gc过后的存活对象有多少,避免存活对象太多快速进入老年代，频繁触 发mixed gc</strong></p>
<ul>
<li>年轻代大小：避免使用 -Xmn选项或 -XX:NewRatio 等其他相关选项显示设置年轻代大小<br>固定年轻代的大小会覆盖暂停时间目标</li>
<li>暂停时间目标不要太过严苛：G1 GC 的吞吐量目标是 90% 的应用程序时间和 10%的垃圾回收时间<br>评估G1 GC的吞吐量时，暂停时间目标不要太严苛，目标太过严苛表示你愿意承受更多的垃圾回收开销，而这会直接影响到吞吐量</li>
</ul>
<h3 id="几十万并发-大内存-的系统如何优化JVM"><a href="#几十万并发-大内存-的系统如何优化JVM" class="headerlink" title="几十万并发(大内存)的系统如何优化JVM"></a>几十万并发(大内存)的系统如何优化JVM</h3><p>​    Kafka类似的支撑高并发消息系统大家肯定不陌生，对于kafka来说，每秒处理几万甚至几十万 消息时很正常的，一般来说部署kafka需要用大内存机器(比如64G)，也就是说可以给年轻代分配 个三四十G的内存用来支撑高并发处理，这里就涉及到一个问题了，我们以前常说的对于eden区 的young gc是很快的，这种情况下它的执行还会很快吗？很显然，不可能，因为内存太大，处理 还是要花不少时间的，假设三四十G内存回收可能最快也要几秒钟，按kafka这个并发量放满三四 十G的eden区可能也就一两分钟吧，那么意味着整个系统每运行一两分钟就会因为young gc卡顿 几秒钟没法处理新消息，显然是不行的。那么对于这种情况如何优化了，我们可以使用G1收集 器，设置 -XX:MaxGCPauseMills 为50ms，假设50ms能够回收三到四个G内存，然后50ms的卡顿其实完全能够接受，用户几乎无感知，那么整个系统就可以在卡顿几乎无感知的情况下一边处理 业务一边收集垃圾。 </p>
<p>​    G1天生就适合这种大内存机器的JVM运行，可以比较完美的解决大内存垃圾回收时间过长的 问题</p>
<h2 id="如何选择垃圾收集器"><a href="#如何选择垃圾收集器" class="headerlink" title="如何选择垃圾收集器"></a>如何选择垃圾收集器</h2><p>1、优先调整堆的大小让服务器自己来选择 </p>
<p>2、如果内存小于100M，使用串行收集器 </p>
<p>3、如果是单核，并且没有停顿时间的要求，串行或JVM自己选择 </p>
<p>4、如果允许停顿时间超过1秒，选择并行或者JVM自己选 </p>
<p>5、如果响应时间最重要，并且不能超过1秒，使用并发收集器 </p>
<p>下图有连线的可以搭配使用，官方推荐使用G1，因为性能高</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/image-20220311213409341.png" alt="image-20220311213409341"></p>
<h2 id="G1和ParNew-CMS孰优孰劣？"><a href="#G1和ParNew-CMS孰优孰劣？" class="headerlink" title="G1和ParNew+CMS孰优孰劣？"></a>G1和ParNew+CMS孰优孰劣？</h2><table>
<thead>
<tr>
<th align="center"><strong>场景</strong></th>
<th align="center"><strong>推荐收集器</strong></th>
<th align="center"><strong>理由</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>大堆</strong>（&gt;16GB）</td>
<td align="center">G1</td>
<td align="center">分区模型优化内存使用，避免碎片化</td>
</tr>
<tr>
<td align="center"><strong>低延迟小堆</strong>（&lt;4GB）</td>
<td align="center">ParNew + CMS</td>
<td align="center">并发清除阶段资源占用低，延迟可控</td>
</tr>
<tr>
<td align="center">吞吐量优先</td>
<td align="center">Parallel Scavenge</td>
<td align="center">G1 和 CMS 均侧重延迟，Parallel 更适合计算密集型任务</td>
</tr>
<tr>
<td align="center"><strong>兼容旧系统</strong></td>
<td align="center">ParNew + CMS</td>
<td align="center">避免参数迁移和稳定性风险</td>
</tr>
</tbody></table>
<h3 id="G1-的局限性"><a href="#G1-的局限性" class="headerlink" title="G1 的局限性"></a><strong>G1 的局限性</strong></h3><ol>
<li><strong>内存与 CPU 开销</strong><br>G1 的 Remembered Set（便于扫描Region区域的对象是否处于可达路径中，避免全堆扫描）和 Card Table（Region 在逻辑上划分为若干个固定大小（介于128到512字节之间）的连续区域，每个区域称之为卡片 Card） 机制需要额外内存（约 10%-20% 堆大小），且后台线程（如并发标记）可能占用较多 CPU，影响吞吐量</li>
<li><strong>小堆性能劣势</strong><br>在堆内存小于 4GB 时，G1 的分区管理可能带来额外开销，而 CMS 的简单分代模型更高效</li>
<li><strong>Full GC 风险</strong><br>G1 的 Full GC 退化为单线程 Serial Old，而 CMS 可通过 <code>-XX:+UseCMSInitiatingOccupancyOnly</code> 调整触发阈值。例如，内存分配过快时，G1 的 Full GC 可能导致更长的停顿。</li>
</ol>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9813-JVM%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8%E8%AF%A6%E8%A7%A3/d878a4262ab909c97e43b2ad4a463ecc.png" alt="在这里插入图片描述"></p>
<p>综上所述，在小堆场景，过度优秀的垃圾收集算法比如G1需要占用更多的内存和CPU算力，反而会拖慢垃圾回收</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优15-JVM调优实战及常量池介绍</title>
    <url>/2022/03/13/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="JVM调优实战及常量池介绍"><a href="#JVM调优实战及常量池介绍" class="headerlink" title="JVM调优实战及常量池介绍"></a>JVM调优实战及常量池介绍</h1><h2 id="GC日志详解"><a href="#GC日志详解" class="headerlink" title="GC日志详解"></a>GC日志详解</h2><p>对于java应用我们可以通过一些配置把程序运行过程中的gc日志全部打印出来，然后分析gc日志得到关键性指标，分析 </p>
<p>GC原因，调优JVM参数。 </p>
<p>打印GC日志方法，在JVM参数里增加参数 </p>
<p>1 ‐XX:+PrintGCDetails ‐XX:+PrintGCTimeStamps ‐XX:+PrintGCDateStamps ‐Xloggc:./gc.log </p>
<p>Tomcat则直接加在JAVA_OPTS变量里。 </p>
<h2 id="如何分析GC日志"><a href="#如何分析GC日志" class="headerlink" title="如何分析GC日志"></a>如何分析GC日志</h2><h3 id="普通GC日志（默认Parallel）"><a href="#普通GC日志（默认Parallel）" class="headerlink" title="普通GC日志（默认Parallel）"></a>普通GC日志（默认Parallel）</h3><p>下图中是截取的JVM刚启动的一部分GC日志 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/clipboard.png" alt="img"></p>
<p>我们可以看到图中第一行红框，是项目的配置参数。这里不仅配置了打印GC日志，还有相关的VM内存参数。 </p>
<p>第二行红框中的是在这个GC时间点发生GC之后相关GC情况。 </p>
<p>1、对于2.909：  这是从jvm启动开始计算到这次GC经过的时间，前面还有具体的发生时间日期。 </p>
<p>2、Full GC(Metadata GC Threshold)指这是一次full gc，括号里是gc的原因， PSYoungGen是年轻代的GC，ParOldGen是老年代的GC，Metaspace是元空间的GC</p>
<p>3、 6160K-&gt;0K(141824K)，这三个数字分别对应GC之前占用年轻代的大小，GC之后年轻代占用，以及整个年轻代的大小。 </p>
<p>4、112K-&gt;6056K(95744K)，这三个数字分别对应GC之前占用老年代的大小，GC之后老年代占用，以及整个老年代的大小。 </p>
<p>5、6272K-&gt;6056K(237568K)，这三个数字分别对应GC之前占用堆内存的大小，GC之后堆内存占用，以及整个堆内存的大小。 </p>
<p>6、20516K-&gt;20516K(1069056K)，这三个数字分别对应GC之前占用元空间内存的大小，GC之后元空间内存占用，以及整个元空间内存的大小。 </p>
<p>7、0.0209707是该时间点GC总耗费时间。 </p>
<p>从日志可以发现几次fullgc都是由于元空间不够导致的，所以我们可以将元空间调大点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">java -jar -Xloggc:./gc-adjust-%t.log -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -XX:+PrintGCDetails -XX:+PrintGCDateStamps  <br>-XX:+PrintGCTimeStamps -XX:+PrintGCCause  -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M <br>microservice-eureka-server.jar<br></code></pre></td></tr></table></figure>

<p>​    调整完我们再看下gc日志发现已经没有因为元空间不够导致的fullgc了</p>
<p>​    对于CMS和G1收集器的日志会有一点不一样，也可以试着打印下对应的gc日志分析下，可以发现gc日志里面的gc步骤跟我们之前讲过的步骤是类似的</p>
<h3 id="CMS-GC日志"><a href="#CMS-GC日志" class="headerlink" title="CMS-GC日志"></a>CMS-GC日志</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/image-20220314211343508.png" alt="image-20220314211343508"></p>
<h3 id="G1-GC日志"><a href="#G1-GC日志" class="headerlink" title="G1-GC日志"></a>G1-GC日志</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * -Xloggc:d:/gc-g1-%t.log -Xms10M -Xmx10M -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M</span><br><span class="hljs-comment"> * -XX:+PrintGCDetails -XX:+PrintGCDateStamps  -XX:+PrintGCTimeStamps -XX:+PrintGCCause  </span><br><span class="hljs-comment"> * -XX:+UseGCLogFileRotation -XX:NumberOfGCLogFiles=10 -XX:GCLogFileSize=100M </span><br><span class="hljs-comment"> * -XX:+UseG1GC -XX:MaxGCPauseMillis=2</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeapTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;SoftReference&lt;<span class="hljs-keyword">byte</span>[]&gt;&gt; heapTests = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            HeapTest heapTest = <span class="hljs-keyword">new</span> HeapTest();<br>            heapTest.func();<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>            heapTests.add(<span class="hljs-keyword">new</span> SoftReference&lt;&gt;(heapTest.funcA()));<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">func</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">byte</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];  <span class="hljs-comment">//100KB</span><br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">byte</span>[] funcA()&#123;<br>        <span class="hljs-keyword">byte</span>[] a = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">100</span>];  <span class="hljs-comment">//100KB</span><br>        <span class="hljs-keyword">return</span> a;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>日志太长就不放了</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/image-20220314215033980.png" alt="image-20220314215033980"></p>
<p>上面的这些参数，能够帮我们查看分析GC的垃圾收集情况。但是如果GC日志很多很多，成千上万行。就算你一目十行，看完了，脑子也是一片空白。所以我们可以借助一些功能来帮助我们分析，这里推荐一个gceasy(<a href="https://gceasy.io/">https://gceasy.io</a>)，可以上传gc文件，然后他会利用可视化的界面来展现GC情况。具体下图所示 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/clipboard-1647265871233.png" alt="clipboard-1647265871233"></p>
<p>上图我们可以看到年轻代，老年代，以及永久代的内存分配，和最大使用情况。 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/clipboard-1647265871280.png" alt="0"></p>
<p>​    上图我们可以看到堆内存在GC之前和之后的变化，以及其他信息。</p>
<p>这个工具还提供基于机器学习的JVM智能优化建议，当然现在这个功能需要付费<img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/clipboard-1647265871577.png" alt="0"></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/clipboard-1647265871348.png" alt="clipboard-1647265871348"></p>
<h2 id="JVM参数汇总查看命令"><a href="#JVM参数汇总查看命令" class="headerlink" title="JVM参数汇总查看命令"></a>JVM参数汇总查看命令</h2><p>java -XX:+PrintFlagsInitial 表示打印出所有参数选项的默认值</p>
<p>java -XX:+PrintFlagsFinal 表示打印出所有参数选项在运行程序时生效的值</p>
<h2 id="JVM调优思路"><a href="#JVM调优思路" class="headerlink" title="JVM调优思路"></a>JVM调优思路</h2><p>1、内存管理优化</p>
<p>​    1、合适的堆大小、新生代和老年代的比例（如果系统大部分对象朝生夕死，则适当增大年轻代，以减少短生命周期对象进入老年代的频率），尽量让Young GC不触发动态年龄判断，存货对象留在老年代</p>
<p>​    2、大对象直接进入老年代</p>
<p>2、选择合适的垃圾收集器</p>
<p>​    1、根据应用自身要求和特性选择合适的垃圾收集器，对响应时间要求高，选择CMS；对于大内存的应用，对停顿时间有严格限制的，选择G1或者ZGC；对于简单程序，程序默认的parallel即可</p>
<p>3、JIT编译优化+开启线程逃逸分析</p>
<p>​    1、逃逸分析有利于栈上分配对象</p>
<p>​    2、调整 JIT 编译的阈值：通过 -XX:CompileThreshold 等参数调整方法被编译为本地代码的调用次数阈值，以提高热点方法的执行效率。</p>
<p>4、合理设置线程池大小</p>
<p>​    1、根据系统性能合理的设置各类线程池的大小，比如数据库连接池，redis连接池、自定义线程池、kafka消费并发数等，如果设置过大或者过载，会导致JVM在触发垃圾回收时需要花费时间来处理处理线程上下文，消耗大量时间来完成标记过程GCroot，进而导致停顿时间边长。</p>
<p>5、完善的监测告警和分析优化</p>
<h2 id="Class常量池与运行时常量池"><a href="#Class常量池与运行时常量池" class="headerlink" title="Class常量池与运行时常量池"></a>Class常量池与运行时常量池</h2><h4 id="Class常量池"><a href="#Class常量池" class="headerlink" title="Class常量池"></a>Class常量池</h4><p>​    Class常量池可以理解为是Class文件中的资源仓库。 Class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是**常量池(constant pool table)<strong>，用于存放编译期生成的各种</strong>字面量(Literal)和符号引用(Symbolic References)**。</p>
<p>一个class文件的16进制大体结构如下图：</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/image-20220314221534785.png" alt="image-20220314221534785"></p>
<p>对应的含义如下，细节可以查下oracle官方文档</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/image-20220314221600707.png" alt="image-20220314221600707"></p>
<p>当然我们一般不会去人工解析这种16进制的字节码文件，我们一般可以通过javap命令生成更可读的JVM字节码指令文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">javap -v Math.class<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/image-20220314221951108.png" alt="image-20220314221951108"></p>
<p>常量池中主要存放两大类常量：<strong>字面量和符号引用</strong>。</p>
<h5 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h5><p>​    由字母、数字构成的字符串或者数值常量，字面量只可以右值出现，所谓右值是指等号右边的值，如：int a=1 这里的a为左值，1为右值。在这个例子中1就是字面量，如</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">int</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">int</span> b = <span class="hljs-number">2</span>;<br>String c = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br>String d = <span class="hljs-string">&quot;abcdefg&quot;</span>;<br></code></pre></td></tr></table></figure>

<h5 id="符号引用"><a href="#符号引用" class="headerlink" title="符号引用"></a>符号引用</h5><p>​    符号应用是编译原理的概念、相对于直接引用而言，主要包含以下3类常量</p>
<ul>
<li>类和接口的全限定名</li>
<li>字段名称和描述符</li>
<li>方法名和方法描述符</li>
</ul>
<p>​    上面的a，b就是字段名称，就是一种符号引用，还有Math类常量池里的 Lcom/tuling/jvm/Math 是类的全限定名，main和compute是方法名称，()是一种UTF8格式的描述符，这些都是符号引用。<br>这些常量池现在是静态信息，只有到运行时被加载到内存后，这些符号才有对应的内存地址信息，这些常量池一旦被装入内存就变成运行时常量池。</p>
<p>​    符号应用在类加载（把静态变量、静态方法、静态类变为直接引用——静态链接）或者程序运行时（其他情况——动态链接）变为动态引用。所谓引用就是具体符号应用在内存中实际的内存地址或者句柄。<strong>例如，compute()这个符号引用在运行时就会被转变为compute()方法具体代码在内存中的地址，主要通过对象头里的类型指针去转换直接引用。</strong></p>
<h3 id="字符串常量池（jdk8后字符串常量池只在堆中-运行时常量池在元空间）"><a href="#字符串常量池（jdk8后字符串常量池只在堆中-运行时常量池在元空间）" class="headerlink" title="字符串常量池（jdk8后字符串常量池只在堆中,运行时常量池在元空间）"></a>字符串常量池（jdk8后字符串常量池只在堆中,运行时常量池在元空间）</h3><h4 id="字符串常量池的设计思想"><a href="#字符串常量池的设计思想" class="headerlink" title="字符串常量池的设计思想"></a>字符串常量池的设计思想</h4><ol>
<li>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价，作为最基础的数据类型，大量频繁的创建字符串，极大程度地影响程序的性能</li>
<li>JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化</li>
</ol>
<ul>
<li>为字符串开辟一个字符串常量池，类似于缓存区</li>
<li>创建字符串常量时，首先查询字符串常量池是否存在该字符串</li>
<li>存在该字符串，返回引用实例，不存在，实例化该字符串并放入池中</li>
</ul>
<h4 id="三种字符串操作"><a href="#三种字符串操作" class="headerlink" title="三种字符串操作"></a>三种字符串操作</h4><p>1、直接复制字符串</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s = <span class="hljs-string">&quot;zhuge&quot;</span>;  <span class="hljs-comment">// s指向常量池中的引用</span><br></code></pre></td></tr></table></figure>

<p>这种方式创建的字符串对象，只会在常量池中。因为有”zhuge”这个字面量，创建对象s的时候，JVM会先去常量池中通过 equals(key) 方法，判断是否有相同的对象<br>如果有，则直接返回该对象在常量池中的引用；<br>如果没有，则会在常量池中创建一个新对象，再返回引用。</p>
<p>2、new String()</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;zhuge&quot;</span>);  <span class="hljs-comment">// s1指向内存中的对象引用</span><br></code></pre></td></tr></table></figure>

<p>这种方式会保证字符串常量池和堆中都有这个对象，没有就创建，最后返回堆内存中的对象引用</p>
<p>步骤大致如下：</p>
<p>因为有”zhuge”这个字面量，所以会先检查字符串常量池中是否存在字符串”zhuge”</p>
<p>不存在，先在字符串常量池里创建一个字符串对象；再去内存中创建一个字符串对象”zhuge”；</p>
<p>存在的话，就直接去堆内存中创建一个字符串对象”zhuge”；</p>
<p>最后，将内存中的引用返回。</p>
<p>3、intern()方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s1 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;zhuge&quot;</span>);   <br>String s2 = s1.intern();<br>System.out.println(s1 == s2);  <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<p>通过new操作符创建的字符串对象不指向字符串常量池中的任何对象，但是可以通过使用字符串的intern()方法来指向其 中的某一个。java.lang.String.intern()返回一个常量池里面的字符串，就是一个在字符串常量池中有了一个入口。如果 以前没有在字符串常量池中，那么它就会被添加到里面</p>
<h4 id="String常量池问题的几个例子"><a href="#String常量池问题的几个例子" class="headerlink" title="String常量池问题的几个例子"></a>String常量池问题的几个例子</h4><p>示例1：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s0=<span class="hljs-string">&quot;zhuge&quot;</span>;<br>String s1=<span class="hljs-string">&quot;zhuge&quot;</span>;<br>String s2=<span class="hljs-string">&quot;zhu&quot;</span> + <span class="hljs-string">&quot;ge&quot;</span>;<br>System.out.println( s0==s1 ); <span class="hljs-comment">//true</span><br>System.out.println( s0==s2 ); <span class="hljs-comment">//true    </span><br></code></pre></td></tr></table></figure>

<p>分析：因为例子中的 s0和s1中的”zhuge”都是字符串常量，它们在编译期就被确定了，所以s0s1为true；而”zhu”和”ge”也都是字符串常量，当一个字 符串由多个字符串常量连接而成时，它自己肯定也是字符串常量，所以s2也同样在编译期就被优化为一个字符串常量”zhuge”，所以s2也是常量池中” zhuge”的一个引用。所以我们得出s0 == s1 == s2；</p>
<p>示例2：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String s0=<span class="hljs-string">&quot;zhuge&quot;</span>;<br>String s1=<span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;zhuge&quot;</span>);<br>String s2=<span class="hljs-string">&quot;zhu&quot;</span> + <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;ge&quot;</span>);<br>System.out.println( s0==s1 );　　<span class="hljs-comment">// false</span><br>System.out.println( s0==s2 )；　 <span class="hljs-comment">// false</span><br>System.out.println( s1==s2 );　　<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>分析：用new String() 创建的字符串不是常量，不能在编译期就确定，所以new String() 创建的字符串不放入常量池中，它们有自己的地址空间。</p>
<p>s0还是常量池 中”zhuge”的引用，s1因为无法在编译期确定，所以是运行时创建的新对象”zhuge”的引用，s2因为有后半部分 new String(”ge”)所以也无法在编译期确定，所以也是一个新创建对象”zhuge”的引用;明白了这些也就知道为何得出此结果了。</p>
<p>示例3：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;a1&quot;</span>;<br> String b = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">1</span>;<br> System.out.println(a == b); <span class="hljs-comment">// true </span><br> <br> String a = <span class="hljs-string">&quot;atrue&quot;</span>;<br> String b = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;true&quot;</span>;<br> System.out.println(a == b); <span class="hljs-comment">// true </span><br> <br> String a = <span class="hljs-string">&quot;a3.4&quot;</span>;<br> String b = <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-number">3.4</span>;<br> System.out.println(a == b); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>分析：JVM对于字符串常量的”+”号连接，将在程序编译期，JVM就将常量字符串的”+”连接优化为连接后的值，拿”a” + 1来说，经编译器优化后在class中就已经是a1。在编译期其字符串常量的值就确定下来，故上面程序最终的结果都为true。</p>
<p>示例4：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;ab&quot;</span>;<br>String bb = <span class="hljs-string">&quot;b&quot;</span>;<br>String b = <span class="hljs-string">&quot;a&quot;</span> + bb;<br>System.out.println(a == b); <span class="hljs-comment">// false  </span><br></code></pre></td></tr></table></figure>

<p>分析：JVM对于字符串引用，由于在字符串的”+”连接中，有字符串引用存在，而引用的值在程序编译期是无法确定的，即”a” + bb无法被编译器优化，只有在程序运行期来动态分配并将连接后的新地址赋给b。所以上面程序的结果也就为false。</p>
<p>示例5：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">final</span> String bb = <span class="hljs-string">&quot;b&quot;</span>;<br>String b = <span class="hljs-string">&quot;a&quot;</span> + bb;<br><br>System.out.println(a == b); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>分析：和示例4中唯一不同的是bb字符串加了final修饰，对于final修饰的变量，它在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中。所以此时的”a” + bb和”a” + “b”效果是一样的。故上面程序的结果为true。</p>
<p>示例6：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String a = <span class="hljs-string">&quot;ab&quot;</span>;<br><span class="hljs-keyword">final</span> String bb = getBB();<br>String b = <span class="hljs-string">&quot;a&quot;</span> + bb;<br>System.out.println(a == b); <span class="hljs-comment">// false</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getBB</span><span class="hljs-params">()</span> </span><br><span class="hljs-function"></span>&#123;  <br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;b&quot;</span>;  <br> &#125;<br></code></pre></td></tr></table></figure>

<p>分析：JVM对于字符串引用bb，它的值在编译期无法确定，只有在程序运行期调用方法后，将方法的返回值和”a”来动态连接并分配地址为b，故上面 程序的结果为false。</p>
<p><strong>关于String是不可变的</strong></p>
<p>通过上面例子可以得出得知</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String  s  =  <span class="hljs-string">&quot;a&quot;</span> + <span class="hljs-string">&quot;b&quot;</span> + <span class="hljs-string">&quot;c&quot;</span>;  <span class="hljs-comment">//就等价于String s = &quot;abc&quot;;</span><br>String  a  =  <span class="hljs-string">&quot;a&quot;</span>;<br>String  b  =  <span class="hljs-string">&quot;b&quot;</span>;<br>String  c  =  <span class="hljs-string">&quot;c&quot;</span>;<br>String  s1  =   a  +  b  +  c;<br></code></pre></td></tr></table></figure>

<p>s1 这个就不一样了，可以通过观察其<strong>JVM指令码</strong>发现s1的”+”操作会变成如下操作：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">StringBuilder temp = <span class="hljs-keyword">new</span> StringBuilder();<br>temp.append(a).append(b).append(c);<br>String s = temp.toString();<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">String str1 = <span class="hljs-string">&quot;abc&quot;</span>; <br>String str2 = <span class="hljs-string">&quot;abc&quot;</span>; <br>String str3 = <span class="hljs-string">&quot;abc&quot;</span>; <br>String str4 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>String str5 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br>String str5 = <span class="hljs-keyword">new</span> String(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure>



<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9815-JVM%E8%B0%83%E4%BC%98%E5%AE%9E%E6%88%98%E5%8F%8A%E5%B8%B8%E9%87%8F%E6%B1%A0%E4%BB%8B%E7%BB%8D/image-20220315091119340.png" alt="image-20220315091119340"></p>
<p><strong>面试题：String str4 = new String(“abc”) 创建多少个对象？</strong> </p>
<ol>
<li>在常量池中查找是否有“abc”对象 </li>
</ol>
<p>有则返回对应的引用实例 </p>
<p>没有则在常量池中创建对应的实例对象 </p>
<ol start="2">
<li><p>在堆中 new 一个 String(“abc”) 对象</p>
<p>3.将对象地址赋值给str4，创建一个引用 </p>
</li>
</ol>
<p>所以，常量池中没有“abc”字面量则创建两个对象，否则创建一个对象，以及创建一个引用 </p>
<p>根据字面量，往往会提出这样的变式题： </p>
<p><strong>String str1 = new String(“A”+”B”) ; 会创建多少个对象?</strong></p>
<p><strong>String str2 = new String(“ABC”) + “ABC” ; 会创建多少个对象?</strong> </p>
<p><strong>str1：</strong> </p>
<p>字符串常量池：”A”,”B”,”AB” : 3个 </p>
<p>堆：new String(“AB”) ：1个 </p>
<p>引用： str1 ：1个 </p>
<p>总共 ： 5个 </p>
<p><strong>str2 ：</strong> </p>
<p>字符串常量池：”ABC” : 1个 </p>
<p>堆：new String(“ABC”) ：1个 </p>
<p>引用： str2 ：1个 </p>
<p>总共 ： 3个 </p>
<h3 id="八种基本类型的包装类和对象池"><a href="#八种基本类型的包装类和对象池" class="headerlink" title="八种基本类型的包装类和对象池"></a>八种基本类型的包装类和对象池</h3><p>java中基本类型的包装类的大部分都实现了常量池技术(严格来说应该叫<strong>对象池，</strong>在堆上)，这些类是Byte,Short,Integer,Long,Character,Boolean,另外两种浮点数类型的包装类则没有实现。另外Byte,Short,Integer,Long,Character这5种整型的包装类也只是在对应值-128~127时才可使用对象池，也即对象不负责创建和管理范围外的这些类的对象。因为一般这种比较小的数用到的概率相对较大。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//5种整形的包装类Byte,Short,Integer,Long,Character的对象，</span><br>        <span class="hljs-comment">//在值小于127时可以使用对象池</span><br>        Integer i1 = <span class="hljs-number">127</span>;  <span class="hljs-comment">//这种调用底层实际是执行的Integer.valueOf(127)，里面用到了IntegerCache对象池</span><br>        Integer i2 = <span class="hljs-number">127</span>;<br>        System.out.println(i1 == i2);<span class="hljs-comment">//输出true</span><br><br>        <span class="hljs-comment">//值大于127时，不会从对象池中取对象</span><br>        Integer i3 = <span class="hljs-number">128</span>;<br>        Integer i4 = <span class="hljs-number">128</span>;<br>        System.out.println(i3 == i4);<span class="hljs-comment">//输出false</span><br><br>        <span class="hljs-comment">//用new关键词新生成对象不会使用对象池</span><br>        Integer i5 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">127</span>);<br>        Integer i6 = <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">127</span>);<br>        System.out.println(i5 == i6);<span class="hljs-comment">//输出false</span><br><br>        <span class="hljs-comment">//Boolean类也实现了对象池技术</span><br>        Boolean bool1 = <span class="hljs-keyword">true</span>;<br>        Boolean bool2 = <span class="hljs-keyword">true</span>;<br>        System.out.println(bool1 == bool2);<span class="hljs-comment">//输出true</span><br><br>        <span class="hljs-comment">//浮点类型的包装类没有实现对象池技术</span><br>        Double d1 = <span class="hljs-number">1.0</span>;<br>        Double d2 = <span class="hljs-number">1.0</span>;<br>        System.out.println(d1 == d2);<span class="hljs-comment">//输出false</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="安全点与安全区域"><a href="#安全点与安全区域" class="headerlink" title="安全点与安全区域"></a>安全点与安全区域</h2><p>​    安全点就是指代码中一些特定的位置,当线程运行到这些位置时它的状态是确定的,这样JVM就可以安全的进行一些操作,比 如GC等，所以GC不是想什么时候做就立即触发的，是需要等待所有线程运行到安全点后才能触发。 这些特定的安全点位置主要有以下几种: </p>
<ol>
<li>方法返回之前 </li>
<li>调用某个方法之后</li>
<li> 抛出异常的位置 </li>
<li>循环的末尾 </li>
</ol>
<p>安全区域又是什么？ Safe Point 是对正在执行的线程设定的。 如果一个线程处于 Sleep 或中断状态，它就不能响应 JVM 的中断请求，再运行到 Safe Point 上。 因此 JVM 引入了 Safe Region。 <strong>Safe Region 是指在一段代码片段中，引用关系不会发生变化</strong>。在这个区域内的任意地方开始 GC 都是安全的。 线程在进入 Safe Region 的时候先标记自己已进入了 Safe Region，等到被唤醒时准备离开 Safe Region 时，先检查能 否离开，如果 GC 完成了，那么线程可以离开，否则它必须等待直到收到安全离开的信号为止。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>性能调优14-JVM调优工具介绍</title>
    <url>/2022/03/12/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<h1 id="JVM调优工具"><a href="#JVM调优工具" class="headerlink" title="JVM调优工具"></a>JVM调优工具</h1><p>启动测试java进程得到进程号pid</p>
<h2 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h2><p>查看各种类实例个数和占用内存大小、内存信息</p>
<h3 id="1、查看实例信息"><a href="#1、查看实例信息" class="headerlink" title="1、查看实例信息"></a>1、查看实例信息</h3><p>jmap -histo pid(进程id)</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jmap -histo 26260 &gt; ./log.txt #查看历史生成的实例<br>jmap -histo:live 26260 &gt; ./log.txt #查看当前存活的实例，执行过程中可能会触发一次full gc<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220312205152599.png" alt="image-20220312205152599"></p>
<ul>
<li>num：序号 </li>
<li>instances：实例数量 </li>
<li>bytes：占用空间大小 </li>
<li>class name：类名称，[C is a char[]，[S is a short[]，[I is a int[]，[B is a byte[]，[[I is a int[][] </li>
</ul>
<h3 id="2、查看堆信息"><a href="#2、查看堆信息" class="headerlink" title="2、查看堆信息"></a>2、查看堆信息</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jmap -heap 26260<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220312205932399.png" alt="image-20220312205932399"></p>
<h3 id="3、获取堆内存dump"><a href="#3、获取堆内存dump" class="headerlink" title="3、获取堆内存dump"></a>3、获取堆内存dump</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jmap -dump:format=b,file=mss.hprof 26260<br></code></pre></td></tr></table></figure>

<p>启动java程序时也可以设置内存溢出自动导出dump文件(内存很大的时候，可能会导不出来)</p>
<p><strong>-XX:+HeapDumpOnOutOfMemoryError</strong><br><strong>-XX:HeapDumpPath=./  （路径）</strong></p>
<p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OOMTest</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">// JVM设置</span><br>    <span class="hljs-comment">// -Xms10M -Xmx10M -XX:+PrintGCDetails -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=D:\jvm.dump</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;Object&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>            list.add(<span class="hljs-keyword">new</span> User(i++, UUID.randomUUID().toString()));<br>            <span class="hljs-keyword">new</span> User(j--, UUID.randomUUID().toString());<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>可以用jvisualvm命令工具导入该dump文件分析</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220312211624326.png" alt="image-20220312211624326"></p>
<h2 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h2><p>​    查看堆内存各部分的内存使用情况、gc回收情况等</p>
<h3 id="1、GC垃圾回收统计"><a href="#1、GC垃圾回收统计" class="headerlink" title="1、GC垃圾回收统计"></a>1、GC垃圾回收统计</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jstat -gc pid<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313143119622.png" alt="image-20220313143119622"></p>
<ul>
<li>S0C：第一个幸存区的大小，单位KB</li>
<li>S1C：第二个幸存区的大小</li>
<li>S0U：第一个幸存区的使用大小</li>
<li>S1U：第二个幸存区的使用大小</li>
<li>EC：伊甸园区的大小</li>
<li>EU：伊甸园区的使用大小</li>
<li>OC：老年代大小</li>
<li>OU：老年代使用大小</li>
<li>MC：方法区大小(元空间)</li>
<li>MU：方法区使用大小</li>
<li>CCSC:压缩类空间大小</li>
<li>CCSU:压缩类空间使用大小</li>
<li>YGC：年轻代垃圾回收次数</li>
<li>YGCT：年轻代垃圾回收消耗时间，单位s</li>
<li>FGC：老年代垃圾回收次数 </li>
<li>FGCT：老年代垃圾回收消耗时间，单位s</li>
<li>GCT：垃圾回收消耗总时间，单位s</li>
</ul>
<h3 id="2、堆内存统计"><a href="#2、堆内存统计" class="headerlink" title="2、堆内存统计"></a>2、堆内存统计</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jstat -gccapacity pid<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313143341976.png" alt="image-20220313143341976"></p>
<ul>
<li>NGCMN：新生代最小容量</li>
<li>NGCMX：新生代最大容量</li>
<li>NGC：当前新生代容量</li>
<li>S0C：第一个幸存区大小</li>
<li>S1C：第二个幸存区的大小</li>
<li>EC：伊甸园区的大小</li>
<li>OGCMN：老年代最小容量</li>
<li>OGCMX：老年代最大容量</li>
<li>OGC：当前老年代大小</li>
<li>OC:当前老年代大小</li>
<li>MCMN:最小元数据容量</li>
<li>MCMX：最大元数据容量</li>
<li>MC：当前元数据空间大小</li>
<li>CCSMN：最小压缩类空间大小</li>
<li>CCSMX：最大压缩类空间大小</li>
<li>CCSC：当前压缩类空间大小</li>
<li>YGC：年轻代gc次数</li>
<li>FGC：老年代GC次数</li>
</ul>
<h3 id="3、新生代垃圾回收统计"><a href="#3、新生代垃圾回收统计" class="headerlink" title="3、新生代垃圾回收统计"></a>3、新生代垃圾回收统计</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313144731110.png" alt="image-20220313144731110"></p>
<p>S0C：第一个幸存区的大小 </p>
<p>S1C：第二个幸存区的大小 </p>
<p>S0U：第一个幸存区的使用大小 </p>
<p>S1U：第二个幸存区的使用大小 </p>
<p>TT:对象在新生代存活的次数 </p>
<p>MTT:对象在新生代存活的最大次数 </p>
<p>DSS:期望的幸存区大小 </p>
<p>EC：伊甸园区的大小 </p>
<p>EU：伊甸园区的使用大小 </p>
<p>YGC：年轻代垃圾回收次数 </p>
<p>YGCT：年轻代垃圾回收消耗时间 </p>
<h3 id="4、新生代内存统计"><a href="#4、新生代内存统计" class="headerlink" title="4、新生代内存统计"></a>4、新生代内存统计</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313144749730.png" alt="image-20220313144749730"></p>
<p>NGCMN：新生代最小容量 </p>
<p>NGCMX：新生代最大容量 </p>
<p>NGC：当前新生代容量 </p>
<p>S0CMX：最大幸存1区大小 </p>
<p>S0C：当前幸存1区大小 </p>
<p>S1CMX：最大幸存2区大小 </p>
<p>S1C：当前幸存2区大小 </p>
<p>ECMX：最大伊甸园区大小 </p>
<p>EC：当前伊甸园区大小 </p>
<p>YGC：年轻代垃圾回收次数FGC：老年代回收次数 </p>
<h3 id="5、老年代垃圾回收统计"><a href="#5、老年代垃圾回收统计" class="headerlink" title="5、老年代垃圾回收统计"></a>5、老年代垃圾回收统计</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313144830230.png" alt="image-20220313144830230"></p>
<p>MC：方法区大小 </p>
<p>MU：方法区使用大小 </p>
<p>CCSC:压缩类空间大小 </p>
<p>CCSU:压缩类空间使用大小 </p>
<p>OC：老年代大小 </p>
<p>OU：老年代使用大小 </p>
<p>YGC：年轻代垃圾回收次数 </p>
<p>FGC：老年代垃圾回收次数 </p>
<p>FGCT：老年代垃圾回收消耗时间 </p>
<p>GCT：垃圾回收消耗总时间 </p>
<h3 id="6、老年代内存统计"><a href="#6、老年代内存统计" class="headerlink" title="6、老年代内存统计"></a>6、老年代内存统计</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313144849484.png" alt="image-20220313144849484"></p>
<p>OGCMN：老年代最小容量 </p>
<p>OGCMX：老年代最大容量 </p>
<p>OGC：当前老年代大小 </p>
<p>OC：老年代大小 </p>
<p>YGC：年轻代垃圾回收次数 </p>
<p>FGC：老年代垃圾回收次数 </p>
<p>FGCT：老年代垃圾回收消耗时间 </p>
<p>GCT：垃圾回收消耗总时间 </p>
<h3 id="7、元数据空间统计"><a href="#7、元数据空间统计" class="headerlink" title="7、元数据空间统计"></a>7、元数据空间统计</h3><p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313144928639.png" alt="image-20220313144928639"></p>
<p>MCMN:最小元数据容量 </p>
<p>MCMX：最大元数据容量 </p>
<p>MC：当前元数据空间大小 </p>
<p>CCSMN：最小压缩类空间大小 </p>
<p>CCSMX：最大压缩类空间大小 </p>
<p>CCSC：当前压缩类空间大小 </p>
<p>YGC：年轻代垃圾回收次数 </p>
<p>FGC：老年代垃圾回收次数 </p>
<p>FGCT：老年代垃圾回收消耗时间 </p>
<p>GCT：垃圾回收消耗总时间 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313144944658.png" alt="image-20220313144944658"></p>
<p>S0：幸存1区当前使用比例 </p>
<p>S1：幸存2区当前使用比例 </p>
<p>E：伊甸园区使用比例 </p>
<p>O：老年代使用比例 </p>
<p>M：元数据区使用比例 </p>
<p>CCS：压缩使用比例 </p>
<p>YGC：年轻代垃圾回收次数 </p>
<p>FGC：老年代垃圾回收次数 </p>
<p>FGCT：老年代垃圾回收消耗时间 </p>
<p>GCT：垃圾回收消耗总时间</p>
<h2 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h2><h3 id="1、查看死锁线程栈信息"><a href="#1、查看死锁线程栈信息" class="headerlink" title="1、查看死锁线程栈信息"></a>1、查看死锁线程栈信息</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DeadLockTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object lock1 = <span class="hljs-keyword">new</span> Object();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object lock2 = <span class="hljs-keyword">new</span> Object();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;thread1 begin&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;thread1 end&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">synchronized</span> (lock2) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    System.out.println(<span class="hljs-string">&quot;thread2 begin&quot;</span>);<br>                    Thread.sleep(<span class="hljs-number">5000</span>);<br>                &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                &#125;<br>                <span class="hljs-keyword">synchronized</span> (lock1) &#123;<br>                    System.out.println(<span class="hljs-string">&quot;thread2 end&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;).start();<br><br>        System.out.println(<span class="hljs-string">&quot;main thread end&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220312232141532.png" alt="image-20220312232141532"></p>
<p>“Thread-1” 线程名 </p>
<p>prio=5 优先级=5</p>
<p>tid=0x000000001fa9e000 线程id</p>
<p>nid=0x2d64 线程对应的本地线程标识nid</p>
<p>java.lang.Thread.State: BLOCKED 线程状态</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220312232241817.png" alt="image-20220312232241817"></p>
<p>还可以用jvisualvm自动检测死锁 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220312232402499.png" alt="image-20220312232402499"></p>
<h3 id="2、找出占用cpu最高的栈信息"><a href="#2、找出占用cpu最高的栈信息" class="headerlink" title="2、找出占用cpu最高的栈信息"></a>2、找出占用cpu最高的栈信息</h3><p>1，使用命令top -p <pid> ，显示你的java进程的内存情况，pid是你的java进程号，比如4977 </pid></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard.png"></p>
<p>2，按H，获取每个线程的内存情况 </p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard-1.png"></p>
<p>3，找到内存和cpu占用最高的线程tid，比如19664</p>
<p>4，转为十六进制得到 0x4cd0，此为线程id的十六进制表示</p>
<p>5，执行 jstack 19663|grep -A 10 4cd0，得到线程堆栈信息中 4cd0 这个线程所在行的后面10行，从堆栈中可以发现导致cpu飙高的调用方法</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard-2.png" alt="clipboard (2)"></p>
<p>6，查看对应的堆栈信息找出可能存在问题的代码</p>
<h2 id="jvisualvm-远程连接（少用）"><a href="#jvisualvm-远程连接（少用）" class="headerlink" title="jvisualvm(远程连接（少用）)"></a>jvisualvm(远程连接（少用）)</h2><p><strong>启动普通的jar程序JMX端口配置：</strong> </p>
<p>java -Dcom.sun.management.jmxremote.port=8899 -Dcom.sun.management.jmxremote.ssl=false - </p>
<p>Dcom.sun.management.jmxremote.authenticate=false -jar foo.jar </p>
<p><strong>tomcat的JMX配置</strong> </p>
<p>JAVA_OPTS=-Dcom.sun.management.jmxremote.port=8899 -Dcom.sun.management.jmxremote.ssl=false - </p>
<p>Dcom.sun.management.jmxremote.authenticate=false </p>
<p>jvisualvm远程连接服务需要在远程服务器上配置host(连接ip 主机名)，并且要关闭防火墙</p>
<h2 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h2><p><strong>查看正在运行的Java应用程序的扩展参数</strong> </p>
<h3 id="1、查看jvm的参数"><a href="#1、查看jvm的参数" class="headerlink" title="1、查看jvm的参数"></a>1、查看jvm的参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jinfo -flags pid<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313140211740.png" alt="image-20220313140211740"></p>
<h3 id="2、查看java系统参数"><a href="#2、查看java系统参数" class="headerlink" title="2、查看java系统参数"></a>2、查看java系统参数</h3><figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jinfo -sysprops pid<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313140549411.png" alt="image-20220313140549411"></p>
<h1 id="JVM运行情况预估"><a href="#JVM运行情况预估" class="headerlink" title="JVM运行情况预估"></a>JVM运行情况预估</h1><h2 id="如何获取GC重要评判参数"><a href="#如何获取GC重要评判参数" class="headerlink" title="如何获取GC重要评判参数"></a>如何获取GC重要评判参数</h2><p>​    用 jstat gc -pid 命令可以计算出如下一些关键数据，有了这些数据就可以采用之前介绍过的优化思路，先给自己的系统设置一些初始性的JVM参数，比如堆内存大小，年轻代大小，Eden和Survivor的比例，老年代的大小，大对象的阈值，大龄对象进入老年代的阈值等。</p>
<p><strong>年轻代对象增长的速率</strong></p>
<p>可以执行命令 jstat -gc pid 1000 10 (每隔1秒执行1次命令，共执行10次)，通过观察EU(eden区的使用)来估算每秒eden大概新增多少对象，如果系统负载不高，可以把频率1秒换成1分钟，甚至10分钟来观察整体情况。注意，一般系统可能有高峰期和日常期，所以需要在不同的时间分别估算不同情况下对象增长速率。</p>
<p><strong>Young GC的触发频率和每次耗时</strong></p>
<p>知道年轻代对象增长速率我们就能推根据eden区的大小推算出Young GC大概多久触发一次，Young GC的平均耗时可以通过 YGCT/YGC 公式算出，根据结果我们大概就能知道<strong>系统大概多久会因为Young GC的执行而卡顿多久。</strong></p>
<p><strong>每次Young GC后有多少对象存活和进入老年代</strong></p>
<p>这个因为之前已经大概知道Young GC的频率，假设是每5分钟一次，那么可以执行命令 jstat -gc pid 300000 10 ，观察每次结果eden，survivor和老年代使用的变化情况，在每次gc后eden区使用一般会大幅减少，survivor和老年代都有可能增长，这些增长的对象就是每次Young GC后存活的对象，同时还可以看出每次Young GC后进去老年代大概多少对象，从而可以推算出<strong>老年代对象增长速率。</strong></p>
<p><strong>Full GC的触发频率和每次耗时</strong></p>
<p>知道了老年代对象的增长速率就可以推算出Full GC的触发频率了，Full GC的每次耗时可以用公式 FGCT/FGC 计算得出。</p>
<h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>​    其实简单来说就是尽量让每次Young GC后的存活对象小于Survivor区域的50%，都留存在年轻代里。尽量别让对象进入老年代。尽量减少Full GC的频率，避免频繁Full GC对JVM性能的影响。</p>
<h1 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h1><h2 id="系统频繁Full-GC导致系统卡顿"><a href="#系统频繁Full-GC导致系统卡顿" class="headerlink" title="系统频繁Full GC导致系统卡顿"></a>系统频繁Full GC导致系统卡顿</h2><ul>
<li>机器配置：2核4G</li>
<li>JVM内存大小：2G</li>
<li>系统运行时间：7天</li>
<li>期间发生的Full GC次数和耗时：500多次，200多秒</li>
<li>期间发生的Young GC次数和耗时：1万多次，500多秒</li>
</ul>
<p>1、大致算下来每天会发生70多次Full GC，平均每小时3次，每次Full GC在400毫秒左右；</p>
<p>2、每天会发生1000多次Young GC，每分钟会发生1次，每次Young GC在50毫秒左右。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">-Xms1536M -Xmx1536M -Xmn512M -Xss256K -XX:SurvivorRatio=6  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M  -XX:+UseParNewGC  -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly       <br></code></pre></td></tr></table></figure>

<p>​    结合<strong>对象挪动到老年代那些规则</strong>推理下我们这个程序可能存在的一些问题经过分析感觉可能会由于对象动态年龄判断机制导致full gc较为频繁</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313154642775.png" alt="image-20220313154642775"></p>
<h2 id="模拟程序如下"><a href="#模拟程序如下" class="headerlink" title="模拟程序如下"></a>模拟程序如下</h2><p>服务器                   </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/user/process&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">processUserData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        ArrayList&lt;User&gt; users = queryUsers();<br><br>        <span class="hljs-keyword">for</span> (User user: users) &#123;<br>            <span class="hljs-comment">//TODO 业务处理</span><br>            System.out.println(<span class="hljs-string">&quot;user:&quot;</span> + user.toString());<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;end&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 模拟批量查询用户场景</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> ArrayList&lt;User&gt; <span class="hljs-title">queryUsers</span><span class="hljs-params">()</span> </span>&#123;<br>        ArrayList&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>            users.add(<span class="hljs-keyword">new</span> User(i,<span class="hljs-string">&quot;zhuge&quot;</span>));<br>        &#125;<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RunWith(SpringRunner.class)</span><br><span class="hljs-meta">@SpringBootTest(classes=&#123;Application.class&#125;)</span><span class="hljs-comment">// 指定启动类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationTests</span> </span>&#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>   &#125;<br><br>   <span class="hljs-meta">@Autowired</span><br>   <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++) &#123;<br>         String result = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/user/process&quot;</span>, String.class);<br>         Thread.sleep(<span class="hljs-number">1000</span>);<br>      &#125;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">jstat -gc 13456 2000 10000<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard-3.png"></p>
<p>对于对象动态年龄判断机制导致的full gc较为频繁可以先试着优化下JVM参数，把年轻代适当调大点：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><code class="hljs shell">-Xms1536M -Xmx1536M -Xmn1024M -Xss256K -XX:SurvivorRatio=6  -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M <br>-XX:+UseParNewGC  -XX:+UseConcMarkSweepGC  -XX:CMSInitiatingOccupancyFraction=92 -XX:+UseCMSInitiatingOccupancyOnly <br></code></pre></td></tr></table></figure>

<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard-4.png"></p>
<p>优化完发现没什么变化，<strong>full gc的次数比minor gc的次数还多了</strong></p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard-1647159739850.png"></p>
<p><strong>我们可以推测下full gc比minor gc还多的原因有哪些？</strong></p>
<p>1、元空间不够导致的多余full gc</p>
<p>2、显示调用System.gc()造成多余的full gc，这种一般线上尽量通过-XX:+DisableExplicitGC参数禁用，如果加上了这个JVM启动参数，那么代码中调用System.gc()没有任何效果</p>
<p>3、老年代空间分配担保机制</p>
<p>4、YoungGC后，老年代空间不足92%</p>
<p>最快速度分析完这些我们推测的原因以及优化后，我们发现young gc和full gc依然很频繁了，而且看到有大量的对象频繁的被挪动到老年代，这种情况我们可以借助jmap命令大概看下是什么对象</p>
<p> <img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/clipboard-1647160054918.png" alt="clipboard-1647160054918"></p>
<p>查到了有大量User对象产生，这个可能是问题所在，但不确定，还必须找到对应的代码确认，如何去找对应的代码了？</p>
<p>1、代码里全文搜索生成User对象的地方(适合只有少数几处地方的情况)</p>
<p>2、如果生成User对象的地方太多，无法定位具体代码，我们可以同时分析下占用cpu较高的线程，一般有大量对象不断产生，对应的方法代码肯定会被频繁调用，占用的cpu必然较高</p>
<p>可以用上面讲过的jstack或jvisualvm来定位cpu使用较高的代码，最终定位到的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 模拟批量查询用户场景</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> ArrayList&lt;User&gt; <span class="hljs-title">queryUsers</span><span class="hljs-params">()</span> </span>&#123;<br>    ArrayList&lt;User&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++) &#123;<br>        users.add(<span class="hljs-keyword">new</span> User(i,<span class="hljs-string">&quot;zhuge&quot;</span>));<br>    &#125;<br>    <span class="hljs-keyword">return</span> users;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>一次查询出500M的对象出来，明显不合适，要根据之前说的各种原则尽量优化到合适的值，尽量消除这种朝生夕死的对象导致的full gc</p>
<p>这是把5000 -&gt; 500后的GC情况，FullGC明显锐减</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/image-20220313163751396.png" alt="image-20220313163751396"></p>
<h1 id="其他JVM调优工具："><a href="#其他JVM调优工具：" class="headerlink" title="其他JVM调优工具："></a>其他JVM调优工具：</h1><h2 id="阿里的arthas"><a href="#阿里的arthas" class="headerlink" title="阿里的arthas"></a>阿里的arthas</h2><h4 id="火焰图"><a href="#火焰图" class="headerlink" title="火焰图"></a>火焰图</h4><h5 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h5><p>​    火焰图（Flame Graph）是一种用于可视化性能分析的图表，最初由Brendan Gregg开发。它主要用于分析<strong>CPU使用情况和函数调用堆栈</strong>。火焰图以图形的形式展示了函数调用的层次结构和时间分布，可以帮助开发人员快速定位应用程序中的性能瓶颈和热点。</p>
<p>​    在火焰图中，每个矩形代表一个函数，<strong>矩形的宽度表示该函数在采样中出现的频率或占用的CPU时间</strong>，<strong>矩形的高度表示函数的调用深度</strong>。<strong>火焰图的顶部是正在执行的函数，下方都是父函数，类似栈，从底部向上看层数越高，栈越深</strong>。通过观察火焰图的形状和颜色，开发人员可以迅速识别出CPU密集型函数和热点函数，从而进行性能优化和调试。</p>
<h5 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h5><p>1、可视化性能瓶颈和热点</p>
<p>2、协助性能优化</p>
<p>3、协助排查问题</p>
<p>4、监控和调试</p>
<h5 id="怎么用"><a href="#怎么用" class="headerlink" title="怎么用"></a>怎么用</h5><p> profiler start：开始搜集样本<br> profiler getSamples：搜集的样本数，时间越长搜集的样本数越多<br> profiler list：可搜集的event，默认为CPU<br> profiler status：搜集时间<br> profiler stop：搜集暂停，默认搜集为.svg图片文件，需要转换下文件格式和输出路径 （profiler stop –format html –file /service/app/logs/xxx.html）<br> profiler resume 恢复采样</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/edcb763af969c70ea2eb9c4ba3e8915e.png" alt="image-20240522173816416"></p>
<p>打开html文件</p>
<p><img src="/images/%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%9814-JVM%E8%B0%83%E4%BC%98%E5%B7%A5%E5%85%B7%E4%BB%8B%E7%BB%8D/a7f6215578f60a9bdceb34d4d98c44d5.png" alt="image-20240522173952757"></p>
<h5 id="颜色意义"><a href="#颜色意义" class="headerlink" title="颜色意义"></a>颜色意义</h5><ul>
<li>绿色：Java代码</li>
<li>黄色：JVM，C++代码</li>
<li>红色：用户态，C代码</li>
<li>橙色：内核态，C代码</li>
</ul>
<h5 id="图中x-y轴代表"><a href="#图中x-y轴代表" class="headerlink" title="图中x-y轴代表"></a>图中x-y轴代表</h5><ul>
<li>x轴代表函数在采样中出现的频率或占用的CPU时间（按字母顺序排列）</li>
<li>y轴代表方法的调用栈深度</li>
</ul>
<h5 id="栈宽含义（CPU时间）"><a href="#栈宽含义（CPU时间）" class="headerlink" title="栈宽含义（CPU时间）"></a>栈宽含义（CPU时间）</h5><p>宽度可以理解为CPU采样率的占比，越宽代表当前栈在采样数中占比高，其可能为三种含义<br>该函数运行时间长<br>该函数被调用次数多</p>
<h5 id="平顶现象（一定要格外注意）"><a href="#平顶现象（一定要格外注意）" class="headerlink" title="平顶现象（一定要格外注意）"></a>平顶现象（一定要格外注意）</h5><p>​    火焰图中的平顶现象是指在火焰图的顶部出现了一个较宽的平顶区域。这表示在采样期间，该函数或代码段被频繁调用，并且占用了大量的 CPU 时间。</p>
<p>平顶现象可能暗示着以下几种情况：</p>
<ul>
<li><strong>性能瓶颈</strong>：该函数可能是系统中的性能瓶颈，消耗了大量的 CPU 资源，导致其他部分的性能受到影响。</li>
<li><strong>频繁执行</strong>：函数可能在短时间内被频繁执行，可能是由于循环、递归或其他频繁的调用模式导致的。</li>
<li><strong>耗时操作</strong>：该函数可能执行了一些耗时的操作，例如文件 I/O、网络请求、复杂计算等，导致 CPU 时间被长时间占用。</li>
</ul>
<p>当在火焰图中观察到平顶现象时，可以进一步分析该函数的代码，确定是否存在性能问题，并考虑采取优化措施，如算法优化、缓存使用、异步处理等，以提高系统的整体性能。</p>
]]></content>
      <categories>
        <category>JVM</category>
      </categories>
      <tags>
        <tag>性能调优</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven学习笔记</title>
    <url>/2021/04/26/Maven%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Maven基础"><a href="#Maven基础" class="headerlink" title="Maven基础"></a>Maven基础</h1><h3 id="第1章-maven概述"><a href="#第1章-maven概述" class="headerlink" title="第1章 maven概述"></a>第1章 maven概述</h3><blockquote>
<p>maven是一个自动化构建的项目管理工具</p>
<p>1、背景</p>
<p>（1）jar包的导入需要手动</p>
<p>（2）jar包的依赖需要清楚</p>
<p>（3）jar包重复导入（jar包版本问题）</p>
<p>（4）项目划分只能使用package</p>
<p>（5）项目打包文件大小小，节省磁盘空间</p>
<p>（与传统web项目不同，maven会将所有jar包放在镜像仓库，部署上线的项目会自动到仓库下载jar包）</p>
<p>2、解决</p>
<p>（1）自动导入jar包及其依赖jar包</p>
<p>（2）可以使用mudule划分大型项目</p>
</blockquote>
<h3 id="第2章-仓库类型"><a href="#第2章-仓库类型" class="headerlink" title="第2章 仓库类型"></a>第2章 仓库类型</h3><blockquote>
<p>1、maven仓库分为3种</p>
<p>（1）本地仓库、远程仓库【企业搭建的私服、中央仓库】</p>
<p>2、maven下载jar包流程</p>
<p>（1）本地仓库 -&gt; 远程仓库 -&gt; 中央仓库-&gt;镜像仓库</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fd1730a299" alt="image.png"></p>
<h4 id="本地仓库"><a href="#本地仓库" class="headerlink" title="本地仓库"></a>本地仓库</h4><p>一般来说，在Maven项目目录下，没有诸如lib/这样用来存放依赖文件的目录。当Maven在执行编译或测试时，如果需要使用依赖文件，它总是基于坐标使用本地仓库的依赖文件。</p>
<p>默认情况下，不管在Window还是Linux下，每个用户在自己用户目录下都有一个路径名为.m2/repository/的仓库目录。 如果你想自定义本地仓库目录地址。你可以编辑文件~/.m2/settings.xml，设置localRepository元素的值为想要的仓库地址，例如:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>D:\java\repository\<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>这样，该用户的本地仓库地址就被设置成了 D:\java\repository\。 需要注意的是，默认情况下，~/.m2/settings.xml文件不存在，用户需要从Maven安装目录复制$M2_HOME/conf/settings.xml文件再进行编辑。</p>
<h4 id="远程仓库-中央仓库"><a href="#远程仓库-中央仓库" class="headerlink" title="远程仓库-中央仓库"></a>远程仓库-中央仓库</h4><p>由于最原始的本地仓库是空的，Maven必须知道至少一个可用的远程仓库，才能在执行Maven命令的时候下载到需要的构件。中央仓库就是这样一个默认的远程仓库，Maven的安装文件自带了中央仓库的配置。</p>
<p>中央仓库包含了这个世界上绝大多数流行的开源Java构件，以及源码、作者信息、SCM,信息、许可证信息等，每个月这里都会接受全世界Java程序员大概1亿次的访问，它对全世界Java开发者的贡献由此可见一斑。</p>
<h4 id="远程仓库-私服"><a href="#远程仓库-私服" class="headerlink" title="远程仓库-私服"></a>远程仓库-私服</h4><p>私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。因此，一些无法从外部仓库下载到的构件也能从本地上传到私服上供大家使用。 私服的好处：</p>
<ul>
<li>节省自己的外网速度</li>
<li>加速Maven构建</li>
<li>部署第三方构建</li>
<li>提高稳定性，增强控制</li>
<li>降低中央仓库的负荷</li>
</ul>
<h4 id="远程仓库的配置"><a href="#远程仓库的配置" class="headerlink" title="远程仓库的配置"></a>远程仓库的配置</h4><p>在平时的开发中，我们往往不会使用默认的中央仓库，默认的中央仓库访问的速度比较慢，访问的人或许很多，有时候也无法满足我们项目的需求，可能项目需要的某些构件中央仓库中是没有的，而在其他远程仓库中有，如JBoss Maven仓库。这时，可以在pom.xml中配置该仓库，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置远程仓库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jboss<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>JBoss Repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://repository.jboss.com/maven2/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">updatePolicy</span>&gt;</span>daily<span class="hljs-tag">&lt;/<span class="hljs-name">updatePolicy</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">checksumPolicy</span>&gt;</span>warn<span class="hljs-tag">&lt;/<span class="hljs-name">checksumPolicy</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">layout</span>&gt;</span>default<span class="hljs-tag">&lt;/<span class="hljs-name">layout</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>**repository:**在repositories元素下，可以使用repository子元素声明一个或者多个远程仓库。</li>
<li><strong>id：</strong>仓库声明的唯一id，尤其需要注意的是，Maven自带的中央仓库使用的id为central，如果其他仓库声明也使用该id，就会覆盖中央仓库的配置。</li>
<li><strong>name：</strong>仓库的名称，让我们直观方便的知道仓库是哪个，暂时没发现其他太大的含义。</li>
<li><strong>url：</strong>指向了仓库的地址，一般来说，该地址都基于http协议，Maven用户都可以在浏览器中打开仓库地址浏览构件。</li>
<li><strong>releases和snapshots：</strong>用来控制Maven对于发布版构件和快照版构件的下载权限。需要注意的是<strong>enabled</strong>子元素，该例中releases的enabled值为true，表示开启JBoss仓库的发布版本下载支持，而snapshots的enabled值为false，表示关闭JBoss仓库的快照版本的下载支持。根据该配置，Maven只会从JBoss仓库下载发布版的构件，而不会下载快照版的构件。</li>
<li><strong>layout：</strong>元素值default表示仓库的布局是Maven2及Maven3的默认布局，而不是Maven1的布局。基本不会用到Maven1的布局。</li>
<li><strong>其他：</strong>对于releases和snapshots来说，除了enabled，它们还包含另外两个子元素updatePolicy和checksumPolicy。<br> 1：元素<strong>updatePolicy</strong>用来配置Maven从远处仓库检查更新的频率，默认值是daily，表示Maven每天检查一次。其他可用的值包括：never-从不检查更新；always-每次构建都检查更新；interval：X-每隔X分钟检查一次更新（X为任意整数）。<br> 2：元素<strong>checksumPolicy</strong>用来配置Maven检查校验和文件的策略。当构建被部署到Maven仓库中时，会同时部署对应的检验和文件。在下载构件的时候，Maven会验证校验和文件，如果校验和验证失败，当checksumPolicy的值为默认的warn时，Maven会在执行构建时输出警告信息，其他可用的值包括：fail-Maven遇到校验和错误就让构建失败；ignore-使Maven完全忽略校验和错误。</li>
</ul>
<h4 id="远程仓库的认证"><a href="#远程仓库的认证" class="headerlink" title="远程仓库的认证"></a>远程仓库的认证</h4><p>大部分的远程仓库不需要认证，但是如果是自己内部使用，为了安全起见，还是要配置认证信息的。 配置认证信息和配置远程仓库不同，远程仓库可以直接在pom.xml中配置，但是认证信息必须配置在settings.xml文件中。这是因为pom往往是被提交到代码仓库中供所有成员访问的，而settings.xml一般只存在于本机。因此，在settings.xml中配置认证信息更为安全。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br> 2     ...<br> 3     <span class="hljs-comment">&lt;!--配置远程仓库认证信息--&gt;</span><br> 4     <span class="hljs-tag">&lt;<span class="hljs-name">servers</span>&gt;</span><br> 5         <span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br> 6             <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br> 7             <span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>admin<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br> 8             <span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>admin123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br> 9         <span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br>10     <span class="hljs-tag">&lt;/<span class="hljs-name">servers</span>&gt;</span><br>11     ...<br>12 <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>这里除了配置账号密码之外，值关键的就是id了，这个id要跟你在pom.xml里面配置的远程仓库repository的id一致，正是这个id将认证信息与仓库配置联系在了一起。</p>
<h4 id="部署构件至远程仓库"><a href="#部署构件至远程仓库" class="headerlink" title="部署构件至远程仓库"></a>部署构件至远程仓库</h4><p>我们自己搭建远程仓库的目的就是为了可以方便部署我们自己项目的构件以及一些无法从外部仓库直接获取的构件。这样才能在开发时，供其他对团队成员使用。 Maven除了能对项目进行编译、测试、打包之外，还能将项目生成的构件部署到远程仓库中。首先，需要编辑项目的pom.xml文件。配置distributionManagement元素，代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>releases<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>public<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/releases<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://59.50.95.66:8081/nexus/content/repositories/snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>看代码，从命名上就看的出来区别，repository表示表示发布版本（稳定版本）构件的仓库，snapshotRepository表示快照版本（开发测试版本）的仓库。这两个元素都需要配置id、name和url，id为远程仓库的唯一标识，name是为了方便人阅读，关键的url表示该仓库的地址。</p>
<p>配置好了就运行命令mvn clean deploy，Maven就会将项目构建输出的构件部署到配置对应的远程仓库，如果项目当前的版本是快照版本，则部署到快照版本的仓库地址，否则就部署到发布版本的仓库地址。 当前项目是快照还是发布版本是通过 true 这个来区分的。忘记的同学在看看上面的## 远程仓库的配置。</p>
<h4 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h4><p>如果仓库X可以提供仓库Y存储的所有内容，那么就可以认为X是Y的一个镜像。用过Maven的都知道，国外的中央仓库用起来太慢了，所以选择一个国内的镜像就很有必要，我推荐国内的阿里云镜像。 阿里云镜像：配置很简单，修改conf文件夹下的settings.xml文件，添加如下镜像配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mirrors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://maven.aliyun.com/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>        <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">mirrors</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>上例子中，的值为central,表示该配置为中央库的镜像，任何对于中央仓库的请求都会转至该镜像，用户也可以用同样的方法配置其他仓库的镜像</p>
<p>这里介绍下``配置的各种选项</p>
<ul>
<li><code>*</code>:匹配所有远程仓库。</li>
<li><code>external:*</code>:匹配所有远程仓库，使用localhost的除外，使用file://协议的除外。也就是说，匹配所有不在本机上的远程仓库。</li>
<li><code>repo1,repo2</code>:匹配仓库repo1h和repo2，使用逗号分隔多个远程仓库。</li>
<li><code>*,!repo1</code>:匹配所有远程仓库，repo1除外，使用感叹号将仓库从匹配中排除。</li>
</ul>
<p>需要注意的是，由于镜像仓库完全屏蔽了被镜像仓库，当镜像仓库不稳定或者停止服务的时候，Maven仍将无法访问被镜像仓库，因而将无法下载构件。</p>
<h2 id="仓库服务搜索"><a href="#仓库服务搜索" class="headerlink" title="仓库服务搜索"></a>仓库服务搜索</h2><p>这里介绍2个提供仓库服务搜索的地址：</p>
<ul>
<li>Sonatype Nexus：<a href="https://repository.sonatype.org/">repository.sonatype.org/</a></li>
<li>MVNrepository：<a href="http://mvnrepository.com/">mvnrepository.com/</a></li>
</ul>
</blockquote>
<h3 id="第3章-目录结构"><a href="#第3章-目录结构" class="headerlink" title="第3章 目录结构"></a>第3章 目录结构</h3><blockquote>
<p>maven提供了一个标准</p>
<p>1、核心代码目录：src/main/java</p>
<p>2、核心配置目录：src/main/resources</p>
<p>3、测试代码目录：src/test/java</p>
<p>4、测试配置目录：src/test/resources</p>
<p>5、其他目录：根据模板不同，会有对应的目录</p>
</blockquote>
<h3 id="第4章-常用命令"><a href="#第4章-常用命令" class="headerlink" title="第4章 常用命令"></a>第4章 常用命令</h3><blockquote>
<p>maven有一套管理项目结构的命令，每一个命令都是一个插件</p>
<ul>
<li><strong>mvn clean</strong>：表示运行清理操作（会默认把target文件夹中的数据清理）。</li>
<li><strong>mvn clean compile</strong>：表示先运行清理之后运行编译，会将代码编译到target文件夹中。</li>
<li><strong>mvn clean test</strong>：运行清理和测试。</li>
<li><strong>mvn clean package</strong>：运行清理和打包。</li>
<li><strong>mvn clean install</strong>：运行清理和安装，会将打好的包安装到本地仓库中，以便其他的项目可以调用。</li>
<li><strong>mvn clean deploy</strong>：运行清理和发布（发布到私服上面）。</li>
</ul>
</blockquote>
<p><a href="https://blog.csdn.net/lizz861109/article/details/109033157">mvn clean package 及之后的命令跳过test阶段</a></p>
<h3 id="第5章-生命周期"><a href="#第5章-生命周期" class="headerlink" title="第5章 生命周期"></a>第5章 生命周期</h3><blockquote>
<p>maven有三套生命周期</p>
<p>1、“清理生命周期”：<strong>clean</strong>【项目运行之前需要清除项目之前编译的代码】</p>
<p>2、“默认生命周期”：<strong>编译compile、测试test、打包package、安装install、发布deploy</strong>【一个项目编译到发布的过程】</p>
<p>3、“站点生命周期”：【使用较少，暂不介绍】</p>
</blockquote>
<h3 id="第6章-依赖范围"><a href="#第6章-依赖范围" class="headerlink" title="第6章 依赖范围"></a>第6章 依赖范围</h3><h4 id="1、依赖范围"><a href="#1、依赖范围" class="headerlink" title="1、依赖范围"></a>1、依赖范围</h4><p>依赖范围就是用来控制依赖和三种classpath(编译classpath，测试classpath、运行classpath)的关系，Maven有如下几种依赖范围：</p>
<ul>
<li><strong>compile:</strong> 编译依赖范围。如果没有指定，就会默认使用该依赖范围。使用此依赖范围的Maven依赖，对于编译、测试、运行三种classpath都有效。典型的例子是spring-code,在编译、测试和运行的时候都需要使用该依赖。</li>
<li><strong>test:</strong> 测试依赖范围。使用次依赖范围的Maven依赖，只对于测试classpath有效，在编译主代码或者运行项目的使用时将无法使用此依赖。典型的例子是Jnuit,它只有在编译测试代码及运行测试的时候才需要。<ul>
<li>如junit</li>
</ul>
</li>
<li><strong>provided:</strong> 已提供依赖范围。使用此依赖范围的Maven依赖，对于编译和测试classpath有效，但在运行时候无效。典型的例子是servlet-api,编译和测试项目的时候需要该依赖，但在运行项目的时候，由于容器以及提供，就不需要Maven重复地引入一遍。<ul>
<li>如servlet-api</li>
</ul>
</li>
<li>**runtime:**运行时依赖范围。使用此依赖范围的Maven依赖，对于测试和运行classpath有效，但在编译主代码时无效。典型的例子是JDBC驱动实现，项目主代码的编译只需要JDK提供的JDBC接口，只有在执行测试或者运行项目的时候才需要实现上述接口的具体JDBC驱动。<ul>
<li>JDBC驱动实现</li>
</ul>
</li>
<li>**system(一般不用):**系统依赖范围。该依赖与三种classpath的关系，和provided依赖范围完全一致，但是，使用system范围的依赖时必须通过systemPath元素显示地指定依赖文件的路径。由于此类依赖不是通过Maven仓库解析的，而且往往与本机系统绑定，可能构成构建的不可移植，因此应该谨慎使用。systemPath元素可以引用环境变量，如：</li>
</ul>
<figure class="highlight dts"><table><tr><td class="code"><pre><code class="hljs dts"><span class="hljs-params">&lt;dependency&gt;</span><br>    <span class="hljs-params">&lt;groupId&gt;</span>javax.sql<span class="hljs-params">&lt;/groupId&gt;</span><br>    <span class="hljs-params">&lt;artifactId&gt;</span>jdbc-stdext<span class="hljs-params">&lt;/artifactId&gt;</span><br>    <span class="hljs-params">&lt;Version&gt;</span><span class="hljs-number">2.0</span><span class="hljs-params">&lt;/Version&gt;</span><br>    <span class="hljs-params">&lt;scope&gt;</span>system<span class="hljs-params">&lt;/scope&gt;</span><br>    <span class="hljs-params">&lt;systemPath&gt;</span>$&#123;java.home&#125;<span class="hljs-meta-keyword">/lib/</span>rt.jar<span class="hljs-params">&lt;/systemPath&gt;</span><br><span class="hljs-params">&lt;/dependency&gt;</span><br><br></code></pre></td></tr></table></figure>

<ul>
<li>**import:**导入依赖范围。该依赖范围不会对三种classpath产生实际的影响。 上述除import以外的各种依赖范围与三种classpath的关系如下:</li>
</ul>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fceaaf09e1" alt="image.png"></p>
<h4 id="2、传递性依赖"><a href="#2、传递性依赖" class="headerlink" title="2、传递性依赖"></a>2、传递性依赖</h4><p>比如一个account-email项目为例，account-email有一个compile范围的spring-code依赖，spring-code有一个compile范围的commons-logging依赖，那么commons-logging就会成为account-email的compile的范围依赖，commons-logging是account-email的一个传递性依赖</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fcea58b801" alt="image.png"></p>
<p>有了传递性依赖机制，在使用Spring Framework的时候就不用去考虑它依赖了什么，也不用担心引入多余的依赖。Maven会解析各个直接依赖的POM，将那些必要的间接依赖，以传递性依赖的形式引入到当前的项目中。</p>
<h4 id="3、依赖范围"><a href="#3、依赖范围" class="headerlink" title="3、依赖范围"></a>3、依赖范围</h4><p>假设A依赖于B,B依赖于C，我们说A对于B是第一直接依赖，B对于C是第二直接依赖，A对于C是传递性依赖。第一直接依赖和第二直接依赖的范围决定了传递性依赖的范围，如下图所示，最左边一行表示第一直接依赖范围，最上面一行表示第二直接依赖范围，中间的交叉单元格则表示传递依赖范围。</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fceba81e2b" alt="image.png"></p>
<p>从上图中，我们可以发现这样的规律：</p>
<ul>
<li>当第二直接依赖的范围是compile的时候，传递性依赖的范围与第一直接依赖的范围一致；</li>
<li>当第二直接依赖的范围是test的时候，依赖不会得以传递；</li>
<li>当第二直接依赖的范围是provided的时候，只传递第一直接依赖范围也为provided的依赖，切传递依赖的范围同样为provided;</li>
<li>当第二直接依赖的范围是runtime的时候，传递性依赖的范围与第一直接依赖的范围一致，但compile列外，此时传递性依赖范围为runtime.</li>
</ul>
<h4 id="4、依赖调解"><a href="#4、依赖调解" class="headerlink" title="4、依赖调解"></a>4、依赖调解</h4><p>  有时候，当传递性依赖造成为题的时候，就需要清楚地知道该传递性依赖是从哪条依赖路径引入的。这就是依赖调解的作用，依赖调解有两大原则： 1. <strong>路径最近者优先</strong> 比如项目有A有这样的依赖关系：A-&gt;B-&gt;C-&gt;X(1.0)、A-&gt;D-&gt;X(2.0),X是A的传递性依赖，但是两条依赖路径上有两个版本的X，所以根据第一原则，A-&gt;D-&gt;X(2.0)路径短，所以X(2.0)会被解析使用 2. 第一声明者优先 如果路径都一样长的话，第一原则就不行了，比如 A-&gt;B-&gt;Y(1.0)、A-&gt;C-&gt;Y(2.0),Y(1.0)和Y(2.0)的路径一样，所以这时候根据第二原则，<strong>2.先声明的被解析</strong>。</p>
<h4 id="5、可选依赖"><a href="#5、可选依赖" class="headerlink" title="5、可选依赖"></a>5、可选依赖</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fcf227ae4b" alt="image.png"></p>
<p>如图，项目中A依赖B，B依赖于X和Y，如果所有这三个的范围都是compile的话，那么X和Y就是A的compile范围的传递性依赖，但是如果我想X,Y不作为A的传递性依赖，不给他用的话。就需要下面提到的配置可选依赖。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.juvenxu.mvnbook<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>project-b<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>postgresql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>postgresql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.4-701.jdbc3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  <br>            <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>  <br><br></code></pre></td></tr></table></figure>

<p>配置也简单，在依赖里面添加</p>
<figure class="highlight protobuf"><table><tr><td class="code"><pre><code class="hljs protobuf">&lt;<span class="hljs-keyword">optional</span>&gt;<span class="hljs-literal">true</span>&lt;/<span class="hljs-keyword">optional</span>&gt;<br><br></code></pre></td></tr></table></figure>

<p>就表示可选依赖了，这样A如果想用X,Y就要直接显示的添加依赖了。</p>
<h4 id="6、排除依赖"><a href="#6、排除依赖" class="headerlink" title="6、排除依赖"></a>6、排除依赖</h4><p>有时候你引入的依赖中包含你不想要的依赖包，你想引入自己想要的，这时候就要用到排除依赖了，比如下图中spring-boot-starter-web自带了logback这个日志包，我想引入log4j2的，所以我先排除掉logback的依赖包，再引入想要的包就行了</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/160b27fd18cdd481-1619446521207" alt="image.png"></p>
<p>排除依赖代码结构：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>这里注意：声明exclustion的时候只需要groupId和artifactId，而不需要version元素，这是因为只需要groupId和artifactId就能唯一定位依赖图中的某个依赖。</p>
<h4 id="7、归类依赖"><a href="#7、归类依赖" class="headerlink" title="7、归类依赖"></a>7、归类依赖</h4><p>有时候我们引入的很多依赖包，他们都来自同一个项目的不同模块，所以他们的版本号都一样，这时候我们可以用属性来统一管理版本号</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.juven.mvnbook.account<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>accout-email<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">springframework.version</span>&gt;</span>1.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">springframework.version</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>  </span><br><span class="xml">    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;springframework.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   </span><br><span class="xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-beans<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>  </span><br><span class="xml">            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$</span><span class="hljs-template-variable">&#123;springframework.version&#125;</span><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>  </span><br><span class="xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>         </span><br><span class="xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span>  </span><br><span class="xml"><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span>  </span><br><br></code></pre></td></tr></table></figure>

<p>如图所示，先通过</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    这里定义你先要的版本<br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>来定义，然后在下面依赖使用${}来引入你的属性。</p>
<h3 id="第7章-概念模型"><a href="#第7章-概念模型" class="headerlink" title="第7章 概念模型"></a>第7章 概念模型</h3><blockquote>
<p>主要体现了maven的两个核心功能：依赖管理和一键构建</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590466410783-299b3b90-ad1b-4fdc-a1b6-07cd6b29ed3c.png" alt="image.png"></p>
<h3 id="第八章-操作与配置"><a href="#第八章-操作与配置" class="headerlink" title="第八章 操作与配置"></a>第八章 操作与配置</h3><h4 id="1、maven安装"><a href="#1、maven安装" class="headerlink" title="1、maven安装"></a>1、maven安装</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462182612-6397eebc-d9fc-453a-83f6-008e9591283c.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462225732-31ad500f-fb32-42cd-801c-b0e02d2cf144.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462268785-a923fa75-c203-4e3d-a22f-a2386f91bcb6.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462285129-e3ed8555-b980-4cd7-8599-947485113265.png" alt="image.png"></p>
<h4 id="2、仓库配置-amp-setting-xml文件"><a href="#2、仓库配置-amp-setting-xml文件" class="headerlink" title="2、仓库配置 &amp; setting.xml文件"></a>2、仓库配置 &amp; setting.xml文件</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590462361920-266edf79-89fc-4e33-aacc-b1b5be2da8ba.png" alt="image.png"></p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2021/xml/750382/1609464260726-beb0d377-68de-4ffc-ab3a-2c3a52ab5949.xml">📎settings.xml</a></p>
<h4 id="3、IDEA配置"><a href="#3、IDEA配置" class="headerlink" title="3、IDEA配置"></a>3、IDEA配置</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590466705287-1af47c0b-5708-40da-85be-874cc512cec7.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590466912056-d8d0b3ae-b232-4084-8d39-72347b650975.png" alt="image.png"></p>
<blockquote>
<p>-DarchetypeCatalog=internal</p>
</blockquote>
<h4 id="4、使用骨架"><a href="#4、使用骨架" class="headerlink" title="4、使用骨架"></a>4、使用骨架</h4><p><strong>java项目</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467443774-5e9900d5-e637-41db-94be-aab3bdbdc914.png" alt="image.png"><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467486838-0d400c17-c277-4fc9-9841-7d7ce9ee2a5e.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467542090-ece21f56-3f99-47a6-b2a3-bdb7d2b9f320.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467654697-b00b971a-d8a6-44b8-a114-2bd498b00abe.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467871986-d0fe715c-cf2a-426a-bc5f-3fff93bac6f6.png" alt="image.png"></p>
<p><strong>web项目</strong></p>
<p><strong><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590468187810-f81dbde9-08ef-4f79-997a-d305e7890d9b.png" alt="image.png"></strong></p>
<p><strong><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590468358025-bb3a1c33-260f-4c0c-b2fd-873fddb324c9.png" alt="image.png"></strong></p>
<h4 id="5、不用骨架"><a href="#5、不用骨架" class="headerlink" title="5、不用骨架"></a>5、不用骨架</h4><blockquote>
<p>开发中推荐不使用骨架创建maven项目</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590467973315-85ef6c32-c7ab-47a3-94b0-27a0dd27dd53.png" alt="image.png"></p>
<h4 id="6、多模块管理：方式1"><a href="#6、多模块管理：方式1" class="headerlink" title="6、多模块管理：方式1"></a>6、多模块管理：方式1</h4><blockquote>
<p>大型项目project需要分模块mudule管理。以下是maven多模块管理的测试案例一。</p>
</blockquote>
<p><strong>（1）创建空项目（project）</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744621039-2e8fd5e2-70d9-4880-a290-6ca4652297b5.png" alt="image.png"></p>
<p><strong>（2）创建parent模块（module）</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744752201-fe09ddcc-67e1-4e16-aaae-fa3440702e63.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744850509-037a4ba6-f30b-4467-96ba-933b8437ee2f.png" alt="image.png"></p>
<p><strong>（3）创建child模块（mudule）</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744893708-6e3bed66-ebe4-4138-9789-bdf4271c7277.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590744918528-93624370-9c21-42cf-9293-7e4050775cef.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745061897-63a2b568-73ce-4ab3-adbe-e2504a38cc14.png" alt="image.png"></p>
<p><strong>（4）统一管理依赖</strong></p>
<blockquote>
<p>1、父类中的依赖子类会无条件继承</p>
<p>2、使用dependencyManagement标签强制管理依赖</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745134361-ecda36e4-4528-4e17-8815-04c8d37fc078.png" alt="image.png"></p>
<p><strong>（5）获取指定依赖</strong></p>
<blockquote>
<p>子模块声明需要继承的依赖，不用写version</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745283460-b8ab6dfc-23ba-4235-9687-1fb36aeba9ee.png" alt="image.png"></p>
<p><strong>（6）管理版本号</strong></p>
<blockquote>
<p>maven管理依赖最终的目的就是管理版本号，parent一改全部跟着改</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590745187888-4f933ec9-48b9-4a77-b2cb-1855a3e529f2.png" alt="image.png"></p>
<p><a href="https://www.yuque.com/attachments/yuque/0/2020/xml/750382/1590745410720-dc2842ca-6b78-4c46-b156-591d6119cac4.xml">📎pom.xml</a>（parent的pom.xml文件）</p>
<p><strong>（7）项目结构</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746288219-b3ab1a2a-8adc-4b47-8223-81f2cfdeb5a5.png" alt="image.png"></p>
<h4 id="7、多模块管理：方式2"><a href="#7、多模块管理：方式2" class="headerlink" title="7、多模块管理：方式2"></a>7、多模块管理：方式2</h4><p><strong>（1）创建parent工程</strong></p>
<p>创建好之后同样需要删除src目录，添加packing标签，标签值为pom</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746056958-f17afa18-86db-4684-b6d2-44f98a76e4f4.png" alt="image.png"></p>
<p><strong>（2）创建child工程</strong></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746185786-17c31fc8-2821-4648-9f72-0d47a5496cb7.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746228805-df6561db-9e86-4446-ae94-2527760dfa8b.png" alt="image.png"></p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590746715532-3023502e-2a4f-4948-9af2-21e34fd90ba7.png" alt="image.png"></p>
<p><strong>其他操作，如管理依赖、管理版本号、继承指定版本号这些和方式1一致</strong></p>
<h4 id="8、调整java编译器版本"><a href="#8、调整java编译器版本" class="headerlink" title="8、调整java编译器版本"></a>8、调整java编译器版本</h4><blockquote>
<p>方式1：IDEA设置；当pom文件变化时，jdk版本还是会变成1.5</p>
</blockquote>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1590747249475-9d775676-a758-42d6-b546-0c2fafd84c4a.png" alt="image.png"></p>
<blockquote>
<p>方式2：在pom文件配置jdk编译插件的版本，这样，当pom文件引入新的依赖，也不会改变jdk的版本</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-comment">&lt;!-- jdk1.8编译插件 --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>方案3：和方案2一样的效果</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>jdk-1.8<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span><br>      <br>      <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.compilerVersion</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="第九章-转载：Maven中的profile标签"><a href="#第九章-转载：Maven中的profile标签" class="headerlink" title="第九章 转载：Maven中的profile标签"></a>第九章 转载：Maven中的profile标签</h3><p>原文连接：<a href="https://juejin.cn/post/6844903653782863879#heading-0">Maven根据pom文件中的Profile标签动态配置编译选项</a></p>
<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>  在实际项目开发中，我们需要<strong>根据不同的使用场景，构建不同的程序包</strong>。当使用Maven编译时，我们可以通过Maven的profile标签来配置编译选项，从而达到生成不同构建产物的目的。例如，在开发环境下，我们有一套适用于本机的调试配置；而在生产环境下，又需要关闭调试环境时的大量调试日志，或变更日志保存路径等。这些需求都可以通过Maven的Profile标签配置来解决。</p>
<p>  profile可以让我们定义一系列的配置信息，然后指定其激活条件。由此，我们就可以定义多个profile，然后每个profile对应不同的激活条件和配置信息，从而达到<strong>不同环境使用不同配置信息</strong>的效果。比如说，我们可以通过profile定义在jdk1.5以上使用一套配置信息，在jdk1.5以下使用另外一套配置信息；或者有时候我们可以通过操作系统的不同来使用不同的配置信息，比如windows下是一套信息，linux下又是另外一套信息，等等。</p>
<h4 id="1、profile属性的定义位置"><a href="#1、profile属性的定义位置" class="headerlink" title="1、profile属性的定义位置"></a>1、profile属性的定义位置</h4><p>  我们有多个可选位置来定义profile。定义的地方不同，它的作用范围也不同。</p>
<ul>
<li><strong>针对于特定项目的profile配置</strong>我们可以定义在该项目的pom.xml中。</li>
<li><strong>针对于特定用户的profile配置</strong>，我们可以在用户的settings.xml文件中定义profile。该文件在用户家目录下的“.m2”目录下。</li>
<li><strong>全局的profile配置</strong>。全局的profile是定义在Maven安装目录下的“conf/settings.xml”文件中的。</li>
</ul>
<h4 id="2、profile中能定义的信息"><a href="#2、profile中能定义的信息" class="headerlink" title="2、profile中能定义的信息"></a>2、profile中能定义的信息</h4><p>  profile中能够定义的配置信息跟profile所处的位置是相关的。以下就分两种情况来讨论，一种是定义在<strong>settings.xml</strong>中，另一种是定义在<strong>pom.xml</strong>中。</p>
<h4 id="3、profile定义在settings-xml中"><a href="#3、profile定义在settings-xml中" class="headerlink" title="3、profile定义在settings.xml中"></a>3、profile定义在settings.xml中</h4><p>  当profile定义在settings.xml中时意味着该profile是全局的，它会对所有项目或者某一用户的所有项目都产生作用。也正因为它是全局的，<strong>所以在settings.xml中只能定义一些相对而言范围宽泛一点的配置信息</strong>，<strong>比如远程仓库等</strong>。而一些比较细致一点的需要根据项目的不同来定义的就需要定义在项目的pom.xml中。具体而言，能够定义在settings.xml中的信息有：</p>
<ul>
<li><repositories></repositories></li>
<li><pluginRepositories></pluginRepositories></li>
<li><properties></properties></li>
<li>定义在<properties>里面的键值对可以在pom.xml中使用。</properties></li>
</ul>
<h4 id="4、profile定义在pom-xml中"><a href="#4、profile定义在pom-xml中" class="headerlink" title="4、profile定义在pom.xml中"></a>4、profile定义在pom.xml中</h4><p>定义在pom.xml中的profile可以定义更多的信息。主要有以下这些：</p>
<ul>
<li><repositories></repositories></li>
<li><pluginRepositories></pluginRepositories></li>
<li><dependencies></dependencies></li>
<li><plugins></plugins></li>
<li><properties></properties></li>
<li><dependencyManagement></dependencyManagement></li>
<li><distributionManagement></distributionManagement></li>
</ul>
<p>还有build元素下面的子元素，主要包括：</p>
<ul>
<li><defaultGoal></defaultGoal></li>
<li><resources></resources></li>
<li><testResources></testResources></li>
<li><finalName></finalName></li>
</ul>
<h4 id="5、profile标签配置的激活方式"><a href="#5、profile标签配置的激活方式" class="headerlink" title="5、profile标签配置的激活方式"></a>5、profile标签配置的激活方式</h4><p>  Maven给我们提供了多种不同的profile激活方式。比如我们可以使用-P参数在编译时，显示的激活一个profile，也可以根据环境条件的设置让它自动激活等。</p>
<h4 id="6、使用activeByDefault设置默认激活（定义在pom文件中）"><a href="#6、使用activeByDefault设置默认激活（定义在pom文件中）" class="headerlink" title="6、使用activeByDefault设置默认激活（定义在pom文件中）"></a>6、使用activeByDefault设置默认激活（定义在pom文件中）</h4><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">activation</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">activeByDefault</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">activeByDefault</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">activation</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<p>我们可以在profile下的activation标签中，通过activeByDefault标签配置激活状态，当没有在编译命令中配置任何激活条件时，activeByDefault标签在哪个profile下配置为true的时候，就表示<strong>该profile在编译时默认会被激活</strong>。</p>
<h4 id="7、在settings-xml中使用activeProfiles指定处于激活状态的profile"><a href="#7、在settings-xml中使用activeProfiles指定处于激活状态的profile" class="headerlink" title="7、在settings.xml中使用activeProfiles指定处于激活状态的profile"></a>7、在settings.xml中使用activeProfiles指定处于激活状态的profile</h4><p>  我们可以在settings.xml中使用activeProfiles来指定需要激活的profile，这种方式激活的profile将所有情况下都处于激活状态。比如现在我们定义了如下两个profile：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span> <br>            <span class="hljs-tag">&lt;<span class="hljs-name">properties.active</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">properties.active</span>&gt;</span> <br>        <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">profiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>这里的profile可以是定义在settings.xml中的，也可以是定义在pom.xml中的。当这时需要指定dev为激活状态，那么我们就可以在settings.xml中定义activeProfiles,如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span> <br></code></pre></td></tr></table></figure>

<p>考虑这样一种情况，我们在activeProfiles下同时定义了多个需要激活的profile。这里还拿上面的profile定义来举例，我们定义了同时激活dev和release。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activeProfiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>dev<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">activeProfile</span>&gt;</span>release<span class="hljs-tag">&lt;/<span class="hljs-name">activeProfile</span>&gt;</span> <br><span class="hljs-tag">&lt;/<span class="hljs-name">activeProfiles</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>那么这个时候我在pom.xml中使用属性properties.active的时候，它是根据profile定义的先后顺序来进行覆盖取值的，即<strong>后面定义的会覆盖前面定义的（定义仓库的时候也是如此）</strong>。</p>
<h4 id="8、使用-P参数显示的激活一个profile"><a href="#8、使用-P参数显示的激活一个profile" class="headerlink" title="8、使用-P参数显示的激活一个profile"></a>8、使用-P参数显示的激活一个profile</h4><p>  我们在进行Maven操作时可以使用-P参数显示的指定当前激活的是哪一个profile。比如我们需要在对项目进行打包的时候使用id为dev的profile，我们就可以这样做：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">-P dev</span><br></code></pre></td></tr></table></figure>

<p>  假如我们使用activeByDefault或settings.xml中定义了处于激活的profile，但是当我们在进行某些操作的时候又不想它处于激活状态，这个时候我们可以这样做：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">–P !dev </span><br></code></pre></td></tr></table></figure>

<p>  这里假设dev是在settings.xml中使用activeProfile标记的处于激活状态的profile，那么当我们使用“-P !dev”的时候就表示在当前操作中该profile将不处于激活状态。</p>
<h4 id="9、根据编译环境来激活profile"><a href="#9、根据编译环境来激活profile" class="headerlink" title="9、根据编译环境来激活profile"></a>9、根据编译环境来激活profile</h4><p>  profile一个非常重要的特性就是它可以根据不同的编译环境来激活，比如说根据操作系统的不同激活不同的profile，也可以根据jdk版本的不同激活不同的profile，等等。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span> <br>    <span class="hljs-tag">&lt;<span class="hljs-name">profile</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>profileTest1<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdk</span>&gt;</span>1.5<span class="hljs-tag">&lt;/<span class="hljs-name">jdk</span>&gt;</span> <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">profile</span>&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">profiles</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="第十章-举例-基于Springboot下的log4j2实践配置步骤"><a href="#第十章-举例-基于Springboot下的log4j2实践配置步骤" class="headerlink" title="第十章 举例-基于Springboot下的log4j2实践配置步骤"></a>第十章 举例-基于Springboot下的log4j2实践配置步骤</h3><p>我们以配置log4j2为例来说一说开发环境和生产环境的不同设置。</p>
<h4 id="一、在src-main-resources-下新建config目录，并在其中创建dev和release文件夹"><a href="#一、在src-main-resources-下新建config目录，并在其中创建dev和release文件夹" class="headerlink" title="一、在src/main/resources/下新建config目录，并在其中创建dev和release文件夹"></a>一、在src/main/resources/下新建config目录，并在其中创建dev和release文件夹</h4><p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a77d684d8ca9" alt="image"></p>
<h4 id="二、分别编写两个不同环境下的log4j2配置文件"><a href="#二、分别编写两个不同环境下的log4j2配置文件" class="headerlink" title="二、分别编写两个不同环境下的log4j2配置文件"></a>二、分别编写两个不同环境下的log4j2配置文件</h4><p>这两个配置文件的主要区别在于，其中的日志保存路径是不同的。（此处只是为了演示区别，随意对路径进行了配置，可自己配置所需路径） 调试用的log4j2-spring.xml:</p>
<p><img src="images/Maven%E5%9F%BA%E7%A1%80/1651a78a8e845989" alt="image">正式环境下的log4j2-spring.xml:<img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a78d9964ae46" alt="image">并分别将刚才的两个文件放置到对应的目录中。</p>
<h4 id="三、配置POM文件"><a href="#三、配置POM文件" class="headerlink" title="三、配置POM文件"></a>三、配置POM文件</h4><p>在项目的pom.xml文件中，在其根节点project下，增加profiles标签：</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a79ba34cccb9" alt="image"></p>
<p>其中：</p>
<ul>
<li><profile>标签表明当前为一个profile描述体</profile></li>
<li><id>标签表明当前profile的id，用来区分不同的profile</id></li>
<li><properties>标签中，可以自定义K、V值，这里的标签名任意，在项目的properties或xml等配置文件中可以使用${profiles.active}可以取出”dev”或“release”这个值</properties></li>
</ul>
<p>在项目的pom.xml文件中，在其build节点下，增加resource标签：</p>
<p><img src="/images/Maven%E5%9F%BA%E7%A1%80/1651a79f2eccddf6-1619449703012" alt="image"></p>
<p>其中：</p>
<ul>
<li><directory>表示编译所需的资源目录</directory></li>
<li><excludes>标签表示排除掉资源目录下的某文件或文件夹</excludes></li>
<li><targetPath>表示该资源标签下的资源打包编译后的保存路径，“.”表示当前路径 由此可见，我们将路径src/main/resources/config/${profiles.active}配置上了我们在profile中定义的Key值，这样，当我们通过-P参数来激活配置时，就可以引入对应的配置文件了。</targetPath></li>
</ul>
<h4 id="四、编译"><a href="#四、编译" class="headerlink" title="四、编译"></a>四、编译</h4><p>通过执行下面的命令进行编译：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">mvn <span class="hljs-keyword">package</span> <span class="hljs-title">-P dev</span><br></code></pre></td></tr></table></figure>

<p>激活了dev编译条件。编译生成war或jar文件后，可以解压构建包，确认配置文件被打包到构建包的根目录下。</p>
]]></content>
      <categories>
        <category>Maven</category>
      </categories>
      <tags>
        <tag>Maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring02-扫描bean定义的过程</title>
    <url>/2021/06/16/Spring02-%E6%89%AB%E6%8F%8Fbean%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<p>一、讲前扩展</p>
<p>​    1、源码扩展之事件监听机制</p>
<p>​    2、源码扩展之BeanFactoryPostProcessor</p>
<p>二、Spring扫描bean定义的源码分析</p>
<h1 id="讲前拓展"><a href="#讲前拓展" class="headerlink" title="讲前拓展"></a>讲前拓展</h1><h2 id="事件监听机制"><a href="#事件监听机制" class="headerlink" title="事件监听机制"></a>事件监听机制</h2><p>概述：本质上是观察者模式程序设计的体现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span></span>&#123;<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;收到事件:&quot;</span>+event);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/Spring02-%E6%89%AB%E6%8F%8Fbean%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B/image-20210617231054221.png" alt="image-20210617231054221"></p>
<ul>
<li>i1&gt;org.springframework.context.support.AbstractApplicationContext#refresh<ul>
<li>i2&gt;org.springframework.context.support.AbstractApplicationContext#initApplicationEventMulticaster（初始化事件多播器）</li>
<li>i3&gt;org.springframework.context.support.AbstractApplicationContext#registerListeners（把事件监听器注册到多播器上去）</li>
</ul>
</li>
</ul>
<p><strong>i2(初始化事件多播器源码解析)</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initApplicationEventMulticaster</span><span class="hljs-params">()</span> </span>&#123;<br>		ConfigurableListableBeanFactory beanFactory = getBeanFactory();<br>		/判断IOC容器中包含applicationEventMulticaster 事件多播器的Bean的name<br>		<span class="hljs-keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;<br>		    /创建一个applicationEventMulticaster的bean放在IOC 容器中,bean的name 为applicationEventMulticaster<br>			<span class="hljs-keyword">this</span>.applicationEventMulticaster =beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);<br>			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>				logger.debug(<span class="hljs-string">&quot;Using ApplicationEventMulticaster [&quot;</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>			&#125;<br>		&#125;<br>		/容器中不包含一个beanName 为applicationEventMulticaster的多播器组件<br>		<span class="hljs-keyword">else</span> &#123;<br>		    <span class="hljs-comment">//创建一个SimpleApplicationEventMulticaster 多播器</span><br>			<span class="hljs-keyword">this</span>.applicationEventMulticaster = <span class="hljs-keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);<br>			<span class="hljs-comment">//注册到容器中</span><br>			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="hljs-keyword">this</span>.applicationEventMulticaster);<br>			<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>				logger.debug(<span class="hljs-string">&quot;Unable to locate ApplicationEventMulticaster with name &#x27;&quot;</span> +<br>						APPLICATION_EVENT_MULTICASTER_BEAN_NAME +<br>						<span class="hljs-string">&quot;&#x27;: using default [&quot;</span> + <span class="hljs-keyword">this</span>.applicationEventMulticaster + <span class="hljs-string">&quot;]&quot;</span>);<br>			&#125;<br>		&#125;<br>	&#125;​<br></code></pre></td></tr></table></figure>

<p><strong>i3：把容器中的监听器注册到多播器上去 源码解析</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerListeners</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//去容器中把applicationListener 捞取出来注册到多播器上去（系统的）</span><br>		<span class="hljs-keyword">for</span> (ApplicationListener&lt;?&gt; listener : getApplicationListeners()) &#123;<br>			getApplicationEventMulticaster().addApplicationListener(listener);<br>		&#125;<br><br>        <span class="hljs-comment">//我们自己实现了ApplicationListener 的组件</span><br>		String[] listenerBeanNames = getBeanNamesForType(ApplicationListener.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>		<span class="hljs-keyword">for</span> (String listenerBeanName : listenerBeanNames) &#123;<br>			getApplicationEventMulticaster().addApplicationListenerBean(listenerBeanName);<br>		&#125;<br><br>	    <span class="hljs-comment">//在这里之前，我们早期想发布的事件 由于没有多播器没有发布，在这里我们总算有了自己的多播器，可以在这里发布早期堆积的事件了.</span><br>		Set&lt;ApplicationEvent&gt; earlyEventsToProcess = <span class="hljs-keyword">this</span>.earlyApplicationEvents;<br>		<span class="hljs-keyword">this</span>.earlyApplicationEvents = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">if</span> (earlyEventsToProcess != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">for</span> (ApplicationEvent earlyEvent : earlyEventsToProcess) &#123;<br>				getApplicationEventMulticaster().multicastEvent(earlyEvent);<br>			&#125;<br>		&#125;<br>	&#125;<br>	<br>	------------------------------------如何发布事件-------------------------------------<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;<br>		ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br>		<span class="hljs-comment">//获取到所有的监听器</span><br>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br>		    <span class="hljs-comment">//看spring 容器中是否支持线程池 异步发送事件</span><br>			Executor executor = getTaskExecutor();<br>			<span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>				executor.execute(<span class="hljs-keyword">new</span> Runnable() &#123;<br>					<span class="hljs-meta">@Override</span><br>					<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;	    <br>						invokeListener(listener, event);<br>					&#125;<br>				&#125;);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;  <span class="hljs-comment">//同步发送事件</span><br>				invokeListener(listener, event);<br>			&#125;<br>		&#125;<br>	&#125;	<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doInvokeListener</span><span class="hljs-params">(ApplicationListener listener, ApplicationEvent event)</span> </span>&#123;<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//调用对于listener的onApplicationEvent事件</span><br>			listener.onApplicationEvent(event);<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (ClassCastException ex) &#123;<br>			String msg = ex.getMessage();<br>			<span class="hljs-keyword">if</span> (msg == <span class="hljs-keyword">null</span> || matchesClassCastMessage(msg, event.getClass())) &#123;<br>				<span class="hljs-comment">// Possibly a lambda-defined listener which we could not resolve the generic event type for</span><br>				<span class="hljs-comment">// -&gt; let&#x27;s suppress the exception and just log a debug message.</span><br>				Log logger = LogFactory.getLog(getClass());<br>				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>					logger.debug(<span class="hljs-string">&quot;Non-matching event type for listener: &quot;</span> + listener, ex);<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-keyword">throw</span> ex;<br>			&#125;<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<p><strong>如何定制事件多波器并且在线程池中执行？</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;applicationEventMulticaster&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyApplicationEventMulticaster</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleApplicationEventMulticaster</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyApplicationEventMulticaster</span><span class="hljs-params">(BeanFactory beanFactory)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(beanFactory);<br>        setTaskExecutor(<span class="hljs-keyword">new</span> ThreadPoolExecutor(<span class="hljs-number">2</span>, <span class="hljs-number">5</span>,<br>                <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>                <span class="hljs-keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),<br>                Executors.defaultThreadFactory()));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="BeanFactoryPostProcessor"><a href="#BeanFactoryPostProcessor" class="headerlink" title="BeanFactoryPostProcessor"></a>BeanFactoryPostProcessor</h2><p>BeanFactory（创建bean的工厂）的后置处理器。</p>
<p>分两种</p>
<ol>
<li>BeanFactoryPostProcessor beanFactory把bean定义信息加载完毕，初始化前<ol>
<li>可以对某些bean定义信息做一些特殊配置</li>
</ol>
</li>
<li>MyBeanDefinitionRegistryPostProcessor Spring内置bean定义信息加载后，初始化前<ol>
<li>可以新增、删除bean定义信息等操作</li>
</ol>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-comment">//(spring内置BeanDefinition读取后),bean初始化前，做一些新增beanDefinition等操作</span><br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor....postProcessBeanDefinitionRegistry&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;bean 的数量&quot;</span> + registry.getBeanDefinitionCount());<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;tooth&quot;</span>,<span class="hljs-keyword">new</span> RootBeanDefinition(TestController.class));<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-comment">//BeanDefinition读取之后，bean初始化前</span><br>        System.out.println(<span class="hljs-string">&quot;MyBeanDefinitionRegistryPostProcessor postProcessBeanFactory....bean 的数量&quot;</span> + beanFactory.getBeanDefinitionCount());<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>i1:org.springframework.context.support.AbstractApplicationContext#refresh<ul>
<li>i2:org.springframework.context.support.AbstractApplicationContext#invokeBeanFactoryPostProcessors<ul>
<li>&gt;i3:org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors<ul>
<li>&gt;i4:org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanDefinitionRegistryPostProcessors<ul>
<li>&gt;i5:org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions<ul>
<li>&gt; i6:org.springframework.context.annotation.ConfigurationClassParser#parse<ul>
<li>&gt;i7:org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass<ul>
<li>&gt;i8:org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="i4标记处源码解析"><a href="#i4标记处源码解析" class="headerlink" title="i4标记处源码解析"></a>i4标记处源码解析</h3><p>org.springframework.context.support.PostProcessorRegistrationDelegate#invokeBeanFactoryPostProcessors</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">invokeBeanFactoryPostProcessors</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">			ConfigurableListableBeanFactory beanFactory, List&lt;BeanFactoryPostProcessor&gt; beanFactoryPostProcessors)</span> </span>&#123;<br><br>		<span class="hljs-comment">// Invoke BeanDefinitionRegistryPostProcessors first, if any.</span><br>		Set&lt;String&gt; processedBeans = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>        <br>        <span class="hljs-comment">//判断IOC 容器是不是BeanDefinitionRegistry的？</span><br>		<span class="hljs-keyword">if</span> (beanFactory <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistry) &#123;<br>		    <span class="hljs-comment">//把IOC容器 强制转为BeanDefinitionRegistry类型的</span><br>			BeanDefinitionRegistry registry = (BeanDefinitionRegistry) beanFactory;<br>			<span class="hljs-comment">//创建一个普通的PostProcessors的list的组件</span><br>			List&lt;BeanFactoryPostProcessor&gt; regularPostProcessors = <span class="hljs-keyword">new</span> LinkedList&lt;BeanFactoryPostProcessor&gt;();<br>			<span class="hljs-comment">//创建一个BeanDefinitionRegistryPostProcessor类型的list</span><br>			List&lt;BeanDefinitionRegistryPostProcessor&gt; registryProcessors = <span class="hljs-keyword">new</span> LinkedList&lt;BeanDefinitionRegistryPostProcessor&gt;();<br>            <br>            <span class="hljs-comment">//处理容器硬编码(new 出来的)带入的beanFacotryPostProcessors</span><br>			<span class="hljs-keyword">for</span> (BeanFactoryPostProcessor postProcessor : beanFactoryPostProcessors) &#123;<br>			    <span class="hljs-comment">//判断是不是BeanDefinitionRegistryPostProcessor</span><br>				<span class="hljs-keyword">if</span> (postProcessor <span class="hljs-keyword">instanceof</span> BeanDefinitionRegistryPostProcessor) &#123;<br>				    <br>					BeanDefinitionRegistryPostProcessor registryProcessor =<br>							(BeanDefinitionRegistryPostProcessor) postProcessor;<br>					<span class="hljs-comment">//调用BeanDefinitionRegistryPostProcessor的postProcessBeanDefinitionRegistry</span><br>					registryProcessor.postProcessBeanDefinitionRegistry(registry);<br>					<span class="hljs-comment">//加入到list集合中</span><br>					registryProcessors.add(registryProcessor);<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<span class="hljs-comment">//判断不是BeanDefinitionRegistryPostProcessor</span><br>				    <span class="hljs-comment">//加入到集合中</span><br>					regularPostProcessors.add(postProcessor);<br>				&#125;<br>			&#125;<br><br>            <span class="hljs-comment">//创建一个当前注册的RegistryProcessors的集合</span><br>			List&lt;BeanDefinitionRegistryPostProcessor&gt; currentRegistryProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanDefinitionRegistryPostProcessor&gt;();<br><br>			第一步:去容器中查询是否有BeanDefinitionRegistryPostProcessor类型的<br>			String[] postProcessorNames =<br>					beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>			<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>			    <span class="hljs-comment">//判断是不是实现了PriorityOrdered接口的</span><br>				<span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>				    <span class="hljs-comment">//添加到currentRegistryProcessors的集合中</span><br>					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>					<span class="hljs-comment">//添加到processedBeans的集合中</span><br>					processedBeans.add(ppName);<br>				&#125;<br>			&#125;<br>			<span class="hljs-comment">//进行排序</span><br>			sortPostProcessors(currentRegistryProcessors, beanFactory);<br>			registryProcessors.addAll(currentRegistryProcessors);<br>			<span class="hljs-comment">//调用BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法</span><br>			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>			currentRegistryProcessors.clear();<br><br>			<span class="hljs-comment">// Next, invoke the BeanDefinitionRegistryPostProcessors that implement Ordered.</span><br>			第二步:去容器中查询是否有BeanDefinitionRegistryPostProcessor类型的<br>			<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>			    <span class="hljs-comment">//排除被处理过的，并且实现了Ordered接口的</span><br>				<span class="hljs-keyword">if</span> (!processedBeans.contains(ppName) &amp;&amp; beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>					currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>					<span class="hljs-comment">//加到以处理的list中</span><br>					processedBeans.add(ppName);<br>				&#125;<br>			&#125;<br>			sortPostProcessors(currentRegistryProcessors, beanFactory);<br>			registryProcessors.addAll(currentRegistryProcessors);<br>			<span class="hljs-comment">//调用BeanDefinitionRegistryPostProcessors的postProcessBeanDefinitionRegistry方法</span><br>			invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>			currentRegistryProcessors.clear();<br><br>			<span class="hljs-comment">//调用普通的BeanDefinitionRegistryPostProcessors没用实现 PriorithOrdered和Ordered接口</span><br>			<span class="hljs-keyword">boolean</span> reiterate = <span class="hljs-keyword">true</span>;<br>			<span class="hljs-keyword">while</span> (reiterate) &#123;<br>				reiterate = <span class="hljs-keyword">false</span>;<br>				postProcessorNames = beanFactory.getBeanNamesForType(BeanDefinitionRegistryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br>				<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>					<span class="hljs-keyword">if</span> (!processedBeans.contains(ppName)) &#123;<br>						currentRegistryProcessors.add(beanFactory.getBean(ppName, BeanDefinitionRegistryPostProcessor.class));<br>						processedBeans.add(ppName);<br>						reiterate = <span class="hljs-keyword">true</span>;<br>					&#125;<br>				&#125;<br>				sortPostProcessors(currentRegistryProcessors, beanFactory);<br>				registryProcessors.addAll(currentRegistryProcessors);<br>				invokeBeanDefinitionRegistryPostProcessors(currentRegistryProcessors, registry);<br>				currentRegistryProcessors.clear();<br>			&#125;<br><br>			<span class="hljs-comment">//调用上诉实现了也实现了BeanFactoryPostProcessors的接口</span><br>			invokeBeanFactoryPostProcessors(registryProcessors, beanFactory);<br>			invokeBeanFactoryPostProcessors(regularPostProcessors, beanFactory);<br>		&#125;<br><br>		<span class="hljs-keyword">else</span> &#123;<br>			<span class="hljs-comment">// Invoke factory processors registered with the context instance.</span><br>			invokeBeanFactoryPostProcessors(beanFactoryPostProcessors, beanFactory);<br>		&#125;<br><br>        <span class="hljs-comment">//去IOC 容器中获取BeanFactoryPostProcessor 类型的</span><br>		String[] postProcessorNames =<br>				beanFactory.getBeanNamesForType(BeanFactoryPostProcessor.class, <span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>);<br><br>        <span class="hljs-comment">//分离实现了PriorityOrdered接口的 Ordered 接口的   普通的</span><br>		List&lt;BeanFactoryPostProcessor&gt; priorityOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();<br>		List&lt;String&gt; orderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		List&lt;String&gt; nonOrderedPostProcessorNames = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>		<br>		<span class="hljs-keyword">for</span> (String ppName : postProcessorNames) &#123;<br>			<span class="hljs-keyword">if</span> (processedBeans.contains(ppName)) &#123;<br>				<span class="hljs-comment">// skip - already processed in first phase above</span><br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, PriorityOrdered.class)) &#123;<br>				priorityOrderedPostProcessors.add(beanFactory.getBean(ppName, BeanFactoryPostProcessor.class));<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (beanFactory.isTypeMatch(ppName, Ordered.class)) &#123;<br>				orderedPostProcessorNames.add(ppName);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				nonOrderedPostProcessorNames.add(ppName);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">//调用 PriorityOrdered.</span><br>		sortPostProcessors(priorityOrderedPostProcessors, beanFactory);<br>		invokeBeanFactoryPostProcessors(priorityOrderedPostProcessors, beanFactory);<br><br>		<span class="hljs-comment">//调用 Ordered.</span><br>		List&lt;BeanFactoryPostProcessor&gt; orderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();<br>		<span class="hljs-keyword">for</span> (String postProcessorName : orderedPostProcessorNames) &#123;<br>			orderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>		&#125;<br>		sortPostProcessors(orderedPostProcessors, beanFactory);<br>		invokeBeanFactoryPostProcessors(orderedPostProcessors, beanFactory);<br><br>	    <span class="hljs-comment">//调用普通的</span><br>		List&lt;BeanFactoryPostProcessor&gt; nonOrderedPostProcessors = <span class="hljs-keyword">new</span> ArrayList&lt;BeanFactoryPostProcessor&gt;();<br>		<span class="hljs-keyword">for</span> (String postProcessorName : nonOrderedPostProcessorNames) &#123;<br>			nonOrderedPostProcessors.add(beanFactory.getBean(postProcessorName, BeanFactoryPostProcessor.class));<br>		&#125;<br>		invokeBeanFactoryPostProcessors(nonOrderedPostProcessors, beanFactory);<br><br>		<span class="hljs-comment">// Clear cached merged bean definitions since the post-processors might have</span><br>		<span class="hljs-comment">// modified the original metadata, e.g. replacing placeholders in values...</span><br>		beanFactory.clearMetadataCache();<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="i5标记处源码解析"><a href="#i5标记处源码解析" class="headerlink" title="i5标记处源码解析:"></a>i5标记处源码解析:</h3><p>org.springframework.context.annotation.ConfigurationClassPostProcessor#processConfigBeanDefinitions </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigBeanDefinitions</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> </span>&#123;<br>		List&lt;BeanDefinitionHolder&gt; configCandidates = <span class="hljs-keyword">new</span> ArrayList&lt;BeanDefinitionHolder&gt;();<br>		<span class="hljs-comment">//去IOC容器中的获取Bean定义的名称</span><br>		<span class="hljs-comment">//	private volatile List&lt;String&gt; beanDefinitionNames = new ArrayList&lt;String&gt;(256);</span><br>        <br>        <span class="hljs-comment">//没有解析之前，系统候选的bean定义配置(有自己的 有系统自带的)</span><br>		String[] candidateNames = registry.getBeanDefinitionNames();<br>        <br>        <span class="hljs-comment">//循环Bean定义的名称 找出自己的传入的主配置类的bean定义信息  configCandidates</span><br>		<span class="hljs-keyword">for</span> (String beanName : candidateNames) &#123;<br>		    <span class="hljs-comment">//去bean定义的map中获取对应的Bean定义对象</span><br>		    <span class="hljs-comment">//	private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(256);</span><br>			BeanDefinition beanDef = registry.getBeanDefinition(beanName);<br>			<span class="hljs-comment">//检查该bean定义对象是不是用来描述配置类</span><br>			<span class="hljs-keyword">if</span> (ConfigurationClassUtils.isFullConfigurationClass(beanDef) ||<br>					ConfigurationClassUtils.isLiteConfigurationClass(beanDef)) &#123;<br>				<span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>					logger.debug(<span class="hljs-string">&quot;Bean definition has already been processed as a configuration class: &quot;</span> + beanDef);<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(beanDef, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>				configCandidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(beanDef, beanName));<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// Return immediately if no @Configuration classes were found</span><br>		<span class="hljs-keyword">if</span> (configCandidates.isEmpty()) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		<span class="hljs-comment">//检查配置类排序</span><br>		Collections.sort(configCandidates, <span class="hljs-keyword">new</span> Comparator&lt;BeanDefinitionHolder&gt;() &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(BeanDefinitionHolder bd1, BeanDefinitionHolder bd2)</span> </span>&#123;<br>				<span class="hljs-keyword">int</span> i1 = ConfigurationClassUtils.getOrder(bd1.getBeanDefinition());<br>				<span class="hljs-keyword">int</span> i2 = ConfigurationClassUtils.getOrder(bd2.getBeanDefinition());<br>				<span class="hljs-keyword">return</span> (i1 &lt; i2) ? -<span class="hljs-number">1</span> : (i1 &gt; i2) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>;<br>			&#125;<br>		&#125;);<br><br>		<span class="hljs-comment">// bean的名称生成策略</span><br>		SingletonBeanRegistry sbr = <span class="hljs-keyword">null</span>;<br>		<span class="hljs-keyword">if</span> (registry <span class="hljs-keyword">instanceof</span> SingletonBeanRegistry) &#123;<br>			sbr = (SingletonBeanRegistry) registry;<br>			<span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.localBeanNameGeneratorSet &amp;&amp; sbr.containsSingleton(CONFIGURATION_BEAN_NAME_GENERATOR)) &#123;<br>				BeanNameGenerator generator = (BeanNameGenerator) sbr.getSingleton(CONFIGURATION_BEAN_NAME_GENERATOR);<br>				<span class="hljs-keyword">this</span>.componentScanBeanNameGenerator = generator;<br>				<span class="hljs-keyword">this</span>.importBeanNameGenerator = generator;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">/***创建一个配置类解析器</span><br><span class="hljs-comment">		1)元数据读取器工厂</span><br><span class="hljs-comment">		this.metadataReaderFactory = metadataReaderFactory;</span><br><span class="hljs-comment">		2)问题报告器</span><br><span class="hljs-comment">		this.problemReporter = problemReporter;</span><br><span class="hljs-comment">		//设置环境</span><br><span class="hljs-comment">		this.environment = environment;</span><br><span class="hljs-comment">		3)资源加载器</span><br><span class="hljs-comment">		this.resourceLoader = resourceLoader;</span><br><span class="hljs-comment">		4）创建了一个组件扫描器</span><br><span class="hljs-comment">		this.componentScanParser = new ComponentScanAnnotationParser(</span><br><span class="hljs-comment">				environment, resourceLoader, componentScanBeanNameGenerator, registry);</span><br><span class="hljs-comment">		this.conditionEvaluator = new ConditionEvaluator(registry, environment, resourceLoader);</span><br><span class="hljs-comment">		****/</span><br>		<br>		ConfigurationClassParser parser = <span class="hljs-keyword">new</span> ConfigurationClassParser(<br>				<span class="hljs-keyword">this</span>.metadataReaderFactory, <span class="hljs-keyword">this</span>.problemReporter, <span class="hljs-keyword">this</span>.environment,<br>				<span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.componentScanBeanNameGenerator, registry);<br>        <br>        <br>        <span class="hljs-comment">//将要被解析的配置类(把自己的configCandidates加入到 候选的)</span><br>		Set&lt;BeanDefinitionHolder&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;(configCandidates);<br>		<span class="hljs-comment">//已经被解析的配置类(由于do while 那么mainclass就一定会被解析,被解析的size为1)</span><br>		Set&lt;ConfigurationClass&gt; alreadyParsed = <span class="hljs-keyword">new</span> HashSet&lt;ConfigurationClass&gt;(configCandidates.size());<br>		<span class="hljs-keyword">do</span> &#123;<br>		    <span class="hljs-comment">//通过配置解析器真正的解析配置类</span><br>			parser.parse(candidates);<br>			<br>			<span class="hljs-comment">//进行校验</span><br>			parser.validate();<br>            <br>            <span class="hljs-comment">//获取ConfigClass (把解析过的配置bean定义信息获取出来)</span><br>			Set&lt;ConfigurationClass&gt; configClasses = <span class="hljs-keyword">new</span> LinkedHashSet&lt;ConfigurationClass&gt;(parser.getConfigurationClasses());<br>			configClasses.removeAll(alreadyParsed);<br><br>			<span class="hljs-comment">// Read the model and create bean definitions based on its content</span><br>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.reader == <span class="hljs-keyword">null</span>) &#123;<br>				<span class="hljs-keyword">this</span>.reader = <span class="hljs-keyword">new</span> ConfigurationClassBeanDefinitionReader(<br>						registry, <span class="hljs-keyword">this</span>.sourceExtractor, <span class="hljs-keyword">this</span>.resourceLoader, <span class="hljs-keyword">this</span>.environment,<br>						<span class="hljs-keyword">this</span>.importBeanNameGenerator, parser.getImportRegistry());<br>			&#125;<br>			<br>			<span class="hljs-comment">//@CompentScan是直接注册Bean定义信息的    但是通过获取@Import,@Bean这种的注解还没有注册的bean定义,</span><br>			<span class="hljs-keyword">this</span>.reader.loadBeanDefinitions(configClasses);<br>			<span class="hljs-comment">//把系统解析过我们自己的组件放在alreadyParsed</span><br>			alreadyParsed.addAll(configClasses);<br>            <span class="hljs-comment">//清除解析过的 配置文件 </span><br>			candidates.clear();<br>			<br>			<span class="hljs-comment">//已经注册的bean定义个数大于最新 开始系统+主配置类的(发生过解析)</span><br>			<span class="hljs-keyword">if</span> (registry.getBeanDefinitionCount() &gt; candidateNames.length) &#123;<br>			    <span class="hljs-comment">//获取系统+自己解析的+mainconfig的bean定义信息</span><br>				String[] newCandidateNames = registry.getBeanDefinitionNames();<br>				<span class="hljs-comment">//系统的+mainconfig的bean定义信息</span><br>				Set&lt;String&gt; oldCandidateNames = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;(Arrays.asList(candidateNames));<br>				<br>				<span class="hljs-comment">//已经解析过的自己的组件</span><br>				Set&lt;String&gt; alreadyParsedClasses = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>				<span class="hljs-keyword">for</span> (ConfigurationClass configurationClass : alreadyParsed) &#123;<br>					alreadyParsedClasses.add(configurationClass.getMetadata().getClassName());<br>				&#125;<br>				<br>				<span class="hljs-keyword">for</span> (String candidateName : newCandidateNames) &#123;<br>				    <span class="hljs-comment">//老的（系统+mainconfig） 不包含解析的</span><br>					<span class="hljs-keyword">if</span> (!oldCandidateNames.contains(candidateName)) &#123;<br>					    <span class="hljs-comment">//把当前bean定义获取出来</span><br>						BeanDefinition bd = registry.getBeanDefinition(candidateName);<br>						<span class="hljs-comment">//检查是否为解析过的</span><br>						<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bd, <span class="hljs-keyword">this</span>.metadataReaderFactory) &amp;&amp;<br>								!alreadyParsedClasses.contains(bd.getBeanClassName())) &#123;<br>							<span class="hljs-comment">//若不是解析过且通过检查的     把当前的bean定义 加入到candidates中	    </span><br>							candidates.add(<span class="hljs-keyword">new</span> BeanDefinitionHolder(bd, candidateName));<br>						&#125;<br>					&#125;<br>				&#125;<br>				把解析过的赋值给原来的 <br>				candidateNames = newCandidateNames;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">while</span> (!candidates.isEmpty());  <span class="hljs-comment">//还存主没有解析过的  再次解析</span><br><br>		<span class="hljs-comment">// Register the ImportRegistry as a bean in order to support ImportAware @Configuration classes</span><br>		<span class="hljs-keyword">if</span> (sbr != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (!sbr.containsSingleton(IMPORT_REGISTRY_BEAN_NAME)) &#123;<br>				sbr.registerSingleton(IMPORT_REGISTRY_BEAN_NAME, parser.getImportRegistry());<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.metadataReaderFactory <span class="hljs-keyword">instanceof</span> CachingMetadataReaderFactory) &#123;<br>			((CachingMetadataReaderFactory) <span class="hljs-keyword">this</span>.metadataReaderFactory).clearCache();<br>		&#125;<br>	&#125;<br></code></pre></td></tr></table></figure>

<h3 id="i6标记处源码解析"><a href="#i6标记处源码解析" class="headerlink" title="i6标记处源码解析 :"></a>i6标记处源码解析 :</h3><p>org.springframework.context.annotation.ConfigurationClassParser#parse</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parse</span><span class="hljs-params">(Set&lt;BeanDefinitionHolder&gt; configCandidates)</span> </span>&#123;<br>		<span class="hljs-keyword">this</span>.deferredImportSelectors = <span class="hljs-keyword">new</span> LinkedList&lt;DeferredImportSelectorHolder&gt;();<br><br>		<span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : configCandidates) &#123;<br>			BeanDefinition bd = holder.getBeanDefinition();<br>			<span class="hljs-keyword">try</span> &#123;<br>			    <span class="hljs-comment">//注解形式的bean定义信息</span><br>				<span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>				    <span class="hljs-comment">//解析配置类的bean定义</span><br>					parse(((AnnotatedBeanDefinition) bd).getMetadata(), holder.getBeanName());<br>				&#125;<br>				<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition &amp;&amp; ((AbstractBeanDefinition) bd).hasBeanClass()) &#123;<br>					parse(((AbstractBeanDefinition) bd).getBeanClass(), holder.getBeanName());<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<br>					parse(bd.getBeanClassName(), holder.getBeanName());<br>				&#125;<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (BeanDefinitionStoreException ex) &#123;<br>				<span class="hljs-keyword">throw</span> ex;<br>			&#125;<br>			<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>				<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<br>						<span class="hljs-string">&quot;Failed to parse configuration class [&quot;</span> + bd.getBeanClassName() + <span class="hljs-string">&quot;]&quot;</span>, ex);<br>			&#125;<br>		&#125;<br><br>		processDeferredImportSelectors();<br>	&#125;​<br>	<br>	<br>org.springframework.context.annotation.ConfigurationClassParser#parse<br>	org.springframework.context.annotation.ConfigurationClassParser#processConfigurationClass<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(configClass.getMetadata(), ConfigurationPhase.PARSE_CONFIGURATION)) &#123;<br>			<span class="hljs-keyword">return</span>;<br>		&#125;<br><br>		ConfigurationClass existingClass = <span class="hljs-keyword">this</span>.configurationClasses.get(configClass);<br>		<span class="hljs-keyword">if</span> (existingClass != <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">if</span> (configClass.isImported()) &#123;<br>				<span class="hljs-keyword">if</span> (existingClass.isImported()) &#123;<br>					existingClass.mergeImportedBy(configClass);<br>				&#125;<br>				<span class="hljs-comment">// Otherwise ignore new imported config class; existing non-imported class overrides it.</span><br>				<span class="hljs-keyword">return</span>;<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				<span class="hljs-comment">// Explicit bean definition found, probably replacing an import.</span><br>				<span class="hljs-comment">// Let&#x27;s remove the old one and go with the new one.</span><br>				<span class="hljs-keyword">this</span>.configurationClasses.remove(configClass);<br>				<span class="hljs-keyword">for</span> (Iterator&lt;ConfigurationClass&gt; it = <span class="hljs-keyword">this</span>.knownSuperclasses.values().iterator(); it.hasNext();) &#123;<br>					<span class="hljs-keyword">if</span> (configClass.equals(it.next())) &#123;<br>						it.remove();<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">//递归处理配置类及其超类层次结构。</span><br>		SourceClass sourceClass = asSourceClass(configClass);<br>		<span class="hljs-keyword">do</span> &#123;<br>			sourceClass = doProcessConfigurationClass(configClass, sourceClass);<br>		&#125;<br>		<span class="hljs-keyword">while</span> (sourceClass != <span class="hljs-keyword">null</span>);<br><br>		<span class="hljs-keyword">this</span>.configurationClasses.put(configClass, configClass);<br>	&#125;<br>	<br>	<br>org.springframework.context.annotation.ConfigurationClassParser#doProcessConfigurationClass<br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> SourceClass <span class="hljs-title">doProcessConfigurationClass</span><span class="hljs-params">(ConfigurationClass configClass, SourceClass sourceClass)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>		<span class="hljs-comment">// Recursively process any member (nested) classes first</span><br>		processMemberClasses(configClass, sourceClass);<br><br>		<span class="hljs-comment">//处理@PropertySource注解</span><br>		<span class="hljs-keyword">for</span> (AnnotationAttributes propertySource : AnnotationConfigUtils.attributesForRepeatable(<br>				sourceClass.getMetadata(), PropertySources.class,<br>				org.springframework.context.annotation.PropertySource.class)) &#123;<br>			<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.environment <span class="hljs-keyword">instanceof</span> ConfigurableEnvironment) &#123;<br>				processPropertySource(propertySource);<br>			&#125;<br>			<span class="hljs-keyword">else</span> &#123;<br>				logger.warn(<span class="hljs-string">&quot;Ignoring @PropertySource annotation on [&quot;</span> + sourceClass.getMetadata().getClassName() +<br>						<span class="hljs-string">&quot;]. Reason: Environment must implement ConfigurableEnvironment&quot;</span>);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">//处理@ComponentScan注解</span><br>		<br>		<span class="hljs-comment">//解析@ComponentScans注解的属性 封装成一个一个的componentscan对象</span><br>		Set&lt;AnnotationAttributes&gt; componentScans = AnnotationConfigUtils.attributesForRepeatable(sourceClass.getMetadata(), ComponentScans.class, ComponentScan.class);<br>		<span class="hljs-keyword">if</span> (!componentScans.isEmpty() &amp;&amp;!<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(sourceClass.getMetadata(), ConfigurationPhase.REGISTER_BEAN)) &#123;<br>			<br>			<span class="hljs-comment">//循环componentScans的set</span><br>			<span class="hljs-keyword">for</span> (AnnotationAttributes componentScan : componentScans) &#123;<br>				<span class="hljs-comment">// 立即执行扫描解析</span><br>				Set&lt;BeanDefinitionHolder&gt; scannedBeanDefinitions =<span class="hljs-keyword">this</span>.componentScanParser.parse(componentScan, sourceClass.getMetadata().getClassName());<br>				<span class="hljs-comment">//检查任何其他配置类的扫描定义集，并在需要时递归解析</span><br>				<span class="hljs-keyword">for</span> (BeanDefinitionHolder holder : scannedBeanDefinitions) &#123;<br>				    <span class="hljs-comment">//获取原始的bean定义信息</span><br>					BeanDefinition bdCand = holder.getBeanDefinition().getOriginatingBeanDefinition();<br>					<span class="hljs-keyword">if</span> (bdCand == <span class="hljs-keyword">null</span>) &#123;<br>						bdCand = holder.getBeanDefinition();<br>					&#125;<br>					<span class="hljs-comment">//检查当前的bean定义信息是不是配置类  比如MainConfig的bean定义信息</span><br>					<span class="hljs-keyword">if</span> (ConfigurationClassUtils.checkConfigurationClassCandidate(bdCand, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>					    <span class="hljs-comment">//递归调用来解析MainConfig,解析出来配置类的中导入的bean定义信息</span><br>						parse(bdCand.getBeanClassName(), holder.getBeanName());<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">//处理@Import注解   解析Import 注解的ImportSelector  ImportBeanDefinitionRegister,@Bean这种</span><br>		<span class="hljs-comment">//存放在ConfigClass中</span><br>		processImports(configClass, sourceClass, getImports(sourceClass), <span class="hljs-keyword">true</span>);<br><br>		<span class="hljs-comment">//处理 @ImportResource annotations</span><br>		<span class="hljs-keyword">if</span> (sourceClass.getMetadata().isAnnotated(ImportResource.class.getName())) &#123;<br>			AnnotationAttributes importResource =<br>					AnnotationConfigUtils.attributesFor(sourceClass.getMetadata(), ImportResource.class);<br>			String[] resources = importResource.getStringArray(<span class="hljs-string">&quot;locations&quot;</span>);<br>			Class&lt;? extends BeanDefinitionReader&gt; readerClass = importResource.getClass(<span class="hljs-string">&quot;reader&quot;</span>);<br>			<span class="hljs-keyword">for</span> (String resource : resources) &#123;<br>				String resolvedResource = <span class="hljs-keyword">this</span>.environment.resolveRequiredPlaceholders(resource);<br>				configClass.addImportedResource(resolvedResource, readerClass);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// 处理  @Bean methods</span><br>		Set&lt;MethodMetadata&gt; beanMethods = retrieveBeanMethodMetadata(sourceClass);<br>		<span class="hljs-keyword">for</span> (MethodMetadata methodMetadata : beanMethods) &#123;<br>			configClass.addBeanMethod(<span class="hljs-keyword">new</span> BeanMethod(methodMetadata, configClass));<br>		&#125;<br><br>		<span class="hljs-comment">//处理接口</span><br>		processInterfaces(configClass, sourceClass);<br><br>		<span class="hljs-comment">// 处理超类的</span><br>		<span class="hljs-keyword">if</span> (sourceClass.getMetadata().hasSuperClass()) &#123;<br>			String superclass = sourceClass.getMetadata().getSuperClassName();<br>			<span class="hljs-keyword">if</span> (!superclass.startsWith(<span class="hljs-string">&quot;java&quot;</span>) &amp;&amp; !<span class="hljs-keyword">this</span>.knownSuperclasses.containsKey(superclass)) &#123;<br>				<span class="hljs-keyword">this</span>.knownSuperclasses.put(superclass, configClass);<br>				<span class="hljs-comment">// Superclass found, return its annotation metadata and recurse</span><br>				<span class="hljs-keyword">return</span> sourceClass.getSuperClass();<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-comment">// No superclass -&gt; processing is complete</span><br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>	&#125;<br>	<br><span class="hljs-comment">//通过组件扫描器进行真正的解析	</span><br>org.springframework.context.annotation.ComponentScanAnnotationParser#parse<br>Set&lt;BeanDefinitionHolder&gt;<br><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">parse</span><span class="hljs-params">(AnnotationAttributes componentScan, <span class="hljs-keyword">final</span> String declaringClass)</span> </span>&#123;<br>		Assert.state(<span class="hljs-keyword">this</span>.environment != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;Environment must not be null&quot;</span>);<br>		Assert.state(<span class="hljs-keyword">this</span>.resourceLoader != <span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;ResourceLoader must not be null&quot;</span>);<br>        <br>        <span class="hljs-comment">//创建一个类路径下的bean定义扫描器</span><br>		ClassPathBeanDefinitionScanner scanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(<span class="hljs-keyword">this</span>.registry,<br>				componentScan.getBoolean(<span class="hljs-string">&quot;useDefaultFilters&quot;</span>), <span class="hljs-keyword">this</span>.environment, <span class="hljs-keyword">this</span>.resourceLoader);<br>        <br>        <span class="hljs-comment">//为扫描器设置一个bean 名称的生成器</span><br>		Class&lt;? extends BeanNameGenerator&gt; generatorClass = componentScan.getClass(<span class="hljs-string">&quot;nameGenerator&quot;</span>);<br>		<span class="hljs-keyword">boolean</span> useInheritedGenerator = (BeanNameGenerator.class == generatorClass);<br>		scanner.setBeanNameGenerator(useInheritedGenerator ? <span class="hljs-keyword">this</span>.beanNameGenerator :<br>				BeanUtils.instantiateClass(generatorClass));<br>        <br>        <br>		ScopedProxyMode scopedProxyMode = componentScan.getEnum(<span class="hljs-string">&quot;scopedProxy&quot;</span>);<br>		<span class="hljs-keyword">if</span> (scopedProxyMode != ScopedProxyMode.DEFAULT) &#123;<br>			scanner.setScopedProxyMode(scopedProxyMode);<br>		&#125;<br>		<span class="hljs-keyword">else</span> &#123;<br>			Class&lt;? extends ScopeMetadataResolver&gt; resolverClass = componentScan.getClass(<span class="hljs-string">&quot;scopeResolver&quot;</span>);<br>			scanner.setScopeMetadataResolver(BeanUtils.instantiateClass(resolverClass));<br>		&#125;<br><br>		scanner.setResourcePattern(componentScan.getString(<span class="hljs-string">&quot;resourcePattern&quot;</span>));<br><br>		<span class="hljs-keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="hljs-string">&quot;includeFilters&quot;</span>)) &#123;<br>			<span class="hljs-keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;<br>				scanner.addIncludeFilter(typeFilter);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">for</span> (AnnotationAttributes filter : componentScan.getAnnotationArray(<span class="hljs-string">&quot;excludeFilters&quot;</span>)) &#123;<br>			<span class="hljs-keyword">for</span> (TypeFilter typeFilter : typeFiltersFor(filter)) &#123;<br>				scanner.addExcludeFilter(typeFilter);<br>			&#125;<br>		&#125;<br><br>		<span class="hljs-keyword">boolean</span> lazyInit = componentScan.getBoolean(<span class="hljs-string">&quot;lazyInit&quot;</span>);<br>		<span class="hljs-keyword">if</span> (lazyInit) &#123;<br>			scanner.getBeanDefinitionDefaults().setLazyInit(<span class="hljs-keyword">true</span>);<br>		&#125;<br><br>		Set&lt;String&gt; basePackages = <span class="hljs-keyword">new</span> LinkedHashSet&lt;String&gt;();<br>		String[] basePackagesArray = componentScan.getStringArray(<span class="hljs-string">&quot;basePackages&quot;</span>);<br>		<span class="hljs-keyword">for</span> (String pkg : basePackagesArray) &#123;<br>			String[] tokenized = StringUtils.tokenizeToStringArray(<span class="hljs-keyword">this</span>.environment.resolvePlaceholders(pkg),<br>					ConfigurableApplicationContext.CONFIG_LOCATION_DELIMITERS);<br>			basePackages.addAll(Arrays.asList(tokenized));<br>		&#125;<br>		<span class="hljs-keyword">for</span> (Class&lt;?&gt; clazz : componentScan.getClassArray(<span class="hljs-string">&quot;basePackageClasses&quot;</span>)) &#123;<br>			basePackages.add(ClassUtils.getPackageName(clazz));<br>		&#125;<br>		<span class="hljs-keyword">if</span> (basePackages.isEmpty()) &#123;<br>			basePackages.add(ClassUtils.getPackageName(declaringClass));<br>		&#125;<br><br>		scanner.addExcludeFilter(<span class="hljs-keyword">new</span> AbstractTypeHierarchyTraversingFilter(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>) &#123;<br>			<span class="hljs-meta">@Override</span><br>			<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matchClassName</span><span class="hljs-params">(String className)</span> </span>&#123;<br>				<span class="hljs-keyword">return</span> declaringClass.equals(className);<br>			&#125;<br>		&#125;);<br>		<span class="hljs-comment">//真正扫描器扫描指定路径</span><br>		<span class="hljs-keyword">return</span> scanner.doScan(StringUtils.toStringArray(basePackages));<br>	&#125;<br><br><br><span class="hljs-comment">//创建类路径下的bean定义扫描器</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathBeanDefinitionScanner</span><span class="hljs-params">(BeanDefinitionRegistry registry, <span class="hljs-keyword">boolean</span> useDefaultFilters,</span></span><br><span class="hljs-function"><span class="hljs-params">			Environment environment, ResourceLoader resourceLoader)</span> </span>&#123;<br><br>		Assert.notNull(registry, <span class="hljs-string">&quot;BeanDefinitionRegistry must not be null&quot;</span>);<br>		<span class="hljs-keyword">this</span>.registry = registry;<br>        <br>        <span class="hljs-comment">//使用默认的扫描规则</span><br>		<span class="hljs-keyword">if</span> (useDefaultFilters) &#123;<br>			registerDefaultFilters();<br>		&#125;<br>		<span class="hljs-comment">//设置环境变量</span><br>		setEnvironment(environment);<br>		<span class="hljs-comment">//设置资源加载器</span><br>		setResourceLoader(resourceLoader);<br>	&#125;<br>	<br>	<span class="hljs-comment">//默认的扫描规则</span><br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDefaultFilters</span><span class="hljs-params">()</span> </span>&#123;<br>	    <span class="hljs-comment">//添加了Componet的解析，这就是我们为啥@Componet @Respository @Service @Controller的  @AspectJ</span><br>		<span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(Component.class));<br>		ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//添加Jsr 250规范的注解</span><br>			<span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>					((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>			logger.debug(<span class="hljs-string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>			<span class="hljs-comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br>		&#125;<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//JSR330的注解</span><br>			<span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>					((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>			logger.debug(<span class="hljs-string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br>			<span class="hljs-comment">// JSR-330 API not available - simply skip.</span><br>		&#125;<br>	&#125;<br>	<br>	<span class="hljs-comment">//使用扫描器去真正的扫描类,返回Set&lt;BeanDefinitionHolder&gt;</span><br>	org.springframework.context.annotation.ClassPathBeanDefinitionScanner#doScan<br>	<br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;<br>		Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>		<span class="hljs-comment">//创建一个Bean定义 holder的 set</span><br>		Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinitionHolder&gt;();<br>		<span class="hljs-comment">//循环扫描路径</span><br>		<span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br>		    <span class="hljs-comment">//找到候选的组件集合</span><br>			Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br>			<span class="hljs-comment">//循环候选组件集合</span><br>			<span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>				ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br>				candidate.setScope(scopeMetadata.getScopeName());<br>				<span class="hljs-comment">//生成bean的名称</span><br>				String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);<br>				<span class="hljs-comment">//判断是不是抽象的beand定义</span><br>				<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>					postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>				&#125;<br>				<span class="hljs-comment">//注解的bean定义西悉尼</span><br>				<span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br>					AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>				&#125;<br>				<br>				<span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123; <span class="hljs-comment">//检查当前的和存主的bean定义是否有冲突</span><br>				    <span class="hljs-comment">//把候选的组件封装成BeanDefinitionHolder</span><br>					BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);<br>					definitionHolder =AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>					<span class="hljs-comment">//加入到bean定义的集合中</span><br>					beanDefinitions.add(definitionHolder);<br>					<span class="hljs-comment">//注册当前的bean定义信息</span><br>					registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> beanDefinitions;<br>	&#125;<br><br>    <br>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#findCandidateComponents <br>    <span class="hljs-comment">//找到候选的组件 返回Set&lt;BeanDefinition&gt;的集合</span><br>	<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;BeanDefinition&gt; <span class="hljs-title">findCandidateComponents</span><span class="hljs-params">(String basePackage)</span> </span>&#123;<br>		<span class="hljs-comment">//候选的bean定义信息</span><br>		Set&lt;BeanDefinition&gt; candidates = <span class="hljs-keyword">new</span> LinkedHashSet&lt;BeanDefinition&gt;();<br>		<span class="hljs-keyword">try</span> &#123;<br>		    <span class="hljs-comment">//拼接需要扫描包下面的类的路径   classpath*:com/tuling/testapplicationlistener/**/*.class</span><br>			String packageSearchPath = ResourcePatternResolver.CLASSPATH_ALL_URL_PREFIX +<br>					resolveBasePackage(basePackage) + <span class="hljs-string">&#x27;/&#x27;</span> + <span class="hljs-keyword">this</span>.resourcePattern;<br>			<span class="hljs-comment">//把路径解析成一个个.class文件		</span><br>			Resource[] resources = <span class="hljs-keyword">this</span>.resourcePatternResolver.getResources(packageSearchPath);<br>			<span class="hljs-keyword">boolean</span> traceEnabled = logger.isTraceEnabled();<br>			<span class="hljs-keyword">boolean</span> debugEnabled = logger.isDebugEnabled();<br>			<br>			<span class="hljs-comment">//循环.class文件的resource对象</span><br>			<span class="hljs-keyword">for</span> (Resource resource : resources) &#123;<br>				<span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>					logger.trace(<span class="hljs-string">&quot;Scanning &quot;</span> + resource);<br>				&#125;<br>				<span class="hljs-comment">//判断class文件是否可读</span><br>				<span class="hljs-keyword">if</span> (resource.isReadable()) &#123;<br>					<span class="hljs-keyword">try</span> &#123;<br>					    <span class="hljs-comment">//把resource对象 变为一个类的原信息读取器</span><br>						MetadataReader metadataReader = <span class="hljs-keyword">this</span>.metadataReaderFactory.getMetadataReader(resource);<br>						<span class="hljs-comment">//判断类的源信息读取器是否为候选的组件</span><br>						<span class="hljs-keyword">if</span> (isCandidateComponent(metadataReader)) &#123;  <span class="hljs-comment">//是候选的组件</span><br>						    <span class="hljs-comment">//把类元信息读取器封装成一个ScannedGenericBeanDefinition</span><br>							ScannedGenericBeanDefinition sbd = <span class="hljs-keyword">new</span> ScannedGenericBeanDefinition(metadataReader);<br>							sbd.setResource(resource);<br>							sbd.setSource(resource);<br>							<span class="hljs-comment">//是候选的组件</span><br>							<span class="hljs-keyword">if</span> (isCandidateComponent(sbd)) &#123;<br>								<span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>									logger.debug(<span class="hljs-string">&quot;Identified candidate component class: &quot;</span> + resource);<br>								&#125;<br>								<span class="hljs-comment">//把当前解析出来的定义的加入到 BeanDefinition的集合中</span><br>								candidates.add(sbd);<br>							&#125;<br>							<span class="hljs-keyword">else</span> &#123;<br>								<span class="hljs-keyword">if</span> (debugEnabled) &#123;<br>									logger.debug(<span class="hljs-string">&quot;Ignored because not a concrete top-level class: &quot;</span> + resource);<br>								&#125;<br>							&#125;<br>						&#125;<br>						<span class="hljs-keyword">else</span> &#123;<br>							<span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>								logger.trace(<span class="hljs-string">&quot;Ignored because not matching any filter: &quot;</span> + resource);<br>							&#125;<br>						&#125;<br>					&#125;<br>					<span class="hljs-keyword">catch</span> (Throwable ex) &#123;<br>						<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<br>								<span class="hljs-string">&quot;Failed to read candidate component class: &quot;</span> + resource, ex);<br>					&#125;<br>				&#125;<br>				<span class="hljs-keyword">else</span> &#123;<br>					<span class="hljs-keyword">if</span> (traceEnabled) &#123;<br>						logger.trace(<span class="hljs-string">&quot;Ignored because not readable: &quot;</span> + resource);<br>					&#125;<br>				&#125;<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">catch</span> (IOException ex) &#123;<br>			<span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(<span class="hljs-string">&quot;I/O failure during classpath scanning&quot;</span>, ex);<br>		&#125;<br>		<span class="hljs-keyword">return</span> candidates;<br>	&#125;	<br><br><span class="hljs-comment">//是不是需要扫描的组件	</span><br>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isCandidateComponent<br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isCandidateComponent</span><span class="hljs-params">(MetadataReader metadataReader)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>		<span class="hljs-comment">//是不是被排除的</span><br>		<span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-keyword">this</span>.excludeFilters) &#123;<br>			<span class="hljs-keyword">if</span> (tf.match(metadataReader, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>				<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>			&#125;<br>		&#125;<br>		<span class="hljs-comment">//在被包含的组件</span><br>		<span class="hljs-keyword">for</span> (TypeFilter tf : <span class="hljs-keyword">this</span>.includeFilters) &#123;<br>			<span class="hljs-keyword">if</span> (tf.match(metadataReader, <span class="hljs-keyword">this</span>.metadataReaderFactory)) &#123;<br>				<span class="hljs-keyword">return</span> isConditionMatch(metadataReader);<br>			&#125;<br>		&#125;<br>		<span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>	&#125;	<br>	<br>	<span class="hljs-comment">//是否能够进行@Conditional判断</span><br>    org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#isConditionMatch<br>	<span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isConditionMatch</span><span class="hljs-params">(MetadataReader metadataReader)</span> </span>&#123;<br>		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.conditionEvaluator == <span class="hljs-keyword">null</span>) &#123;<br>			<span class="hljs-keyword">this</span>.conditionEvaluator = <span class="hljs-keyword">new</span> ConditionEvaluator(getRegistry(), getEnvironment(), getResourceLoader());<br>		&#125;<br>		<span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.conditionEvaluator.shouldSkip(metadataReader.getAnnotationMetadata());<br>	&#125;	<br>	<br></code></pre></td></tr></table></figure>

<h1 id="BeanDefinition加载过程"><a href="#BeanDefinition加载过程" class="headerlink" title="BeanDefinition加载过程"></a>BeanDefinition加载过程</h1><p>概述：</p>
<p>1、new AnnotationConfigApplicationContext时注入了实现priority接口的BeanDefinitionRegistryPostProcessor的工厂bean定义注册后置处理器：ConfigurationClassPostProcessor</p>
<p>2、invokeBeanFactoryPostProcessors(beanFactory); 执行时扫描到ConfigurationClassPostProcessor</p>
<p>且调用执行</p>
<p>3、ConfigurationClassPostProcessor.postProcessBeanDefinitionRegistry的作用是</p>
<ol>
<li>识别我们传入的标有@Configuration的类</li>
<li>创建ConfigurationClassParser</li>
<li>解析配置类<ol>
<li>@ComponentScan</li>
<li>@Import</li>
<li>Bean</li>
<li>@PropertySource</li>
<li>@ImportResource</li>
<li>处理其他的</li>
</ol>
</li>
</ol>
<p><img src="/images/Spring02-%E6%89%AB%E6%8F%8Fbean%E5%AE%9A%E4%B9%89%E7%9A%84%E8%BF%87%E7%A8%8B/BeanDefinition%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B.png">  </p>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>源码</tag>
        <tag>Spring</tag>
        <tag>bean定义信息</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringMVC核心流程解析</title>
    <url>/2021/06/01/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<p><strong>课程概要</strong></p>
<ol>
<li>spring mvc 设计思想与体系结构组成</li>
<li>mvc 执行流程解析</li>
<li>自定义MVC的框架实现</li>
</ol>
<h1 id="spring-mvc-功能特性"><a href="#spring-mvc-功能特性" class="headerlink" title="spring mvc 功能特性"></a>spring mvc 功能特性</h1><h2 id="回顾servlet-与jsp-执行过程"><a href="#回顾servlet-与jsp-执行过程" class="headerlink" title="回顾servlet 与jsp 执行过程"></a>回顾servlet 与jsp 执行过程</h2><p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image2.png" alt="image2"></p>
<p><strong>流程说明：</strong></p>
<ol>
<li>请求Servlet</li>
<li>处理业务逻辑</li>
<li>设置业务Model</li>
<li>forward jsp Servlet</li>
<li>jsp Servlet 解析封装html 返回</li>
</ol>
<h2 id="spring-mvc-功能特性："><a href="#spring-mvc-功能特性：" class="headerlink" title="spring mvc 功能特性："></a>spring mvc 功能特性：</h2><p>spring mvc本质上还是在使用Servlet处理，并在其基础上进行了封装简化了开发流程，提高易用性、并使用程序逻辑结构变得更清晰</p>
<ol>
<li><strong>基于注解的URL映射</strong></li>
<li><strong>表单参数映射，参数接受</strong></li>
<li><strong>全局统一异常拦截处理</strong></li>
<li><strong>文件上传与下载</strong></li>
<li><strong>MVC拦截器 HandlerInterceptor</strong></li>
</ol>
<h2 id="请求处理流程"><a href="#请求处理流程" class="headerlink" title="请求处理流程"></a><strong>请求处理流程</strong></h2><ol>
<li>Web 发起request请求</li>
<li>dispatchServlet通过HandlerMapping映射关系查找到对应的Handler</li>
<li>HandlerAdapter适配handler并且执行handler逻辑</li>
<li>handler设置业务model</li>
<li>handler设置返回页面</li>
<li>dispatchServlet接受到模型视图对象</li>
<li>dispatchServlet通过viewAdapter找到view</li>
<li>view基于模板与模型将mv渲染成写成html</li>
<li>渲染结果通过response返回Web前端</li>
</ol>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210601213936301.png" alt="image-20210601213936301"></p>
<h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.3.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="spring-mvc-xml"><a href="#spring-mvc-xml" class="headerlink" title="spring-mvc.xml"></a>spring-mvc.xml</h3><figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc</span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/hello&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;study.springmvc.controller.MyController&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;/hello1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;study.springmvc.controller.MyRequestHandler&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 注解驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;study.springmvc&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 视图仓库 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="controller"><a href="#controller" class="headerlink" title="controller"></a>controller</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Controller</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;userView&quot;</span>);<br>        modelAndView.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;24kHandsome&quot;</span>);<br>        <span class="hljs-keyword">return</span> modelAndView;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="userView-jsp"><a href="#userView-jsp" class="headerlink" title="userView.jsp"></a>userView.jsp</h3><figure class="highlight html"><table><tr><td class="code"><pre><code class="hljs html">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;<br>	pageEncoding=&quot;UTF-8&quot;%&gt;<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span> <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span> <span class="hljs-meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Insert title here<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>	the man is<br>	$&#123;name&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h1 id="mvc-体系结构详解"><a href="#mvc-体系结构详解" class="headerlink" title="mvc 体系结构详解"></a>mvc 体系结构详解</h1><h2 id="spring-mvc-框架解决的问题"><a href="#spring-mvc-框架解决的问题" class="headerlink" title="spring mvc 框架解决的问题"></a>spring mvc 框架解决的问题</h2><p>从技术角度去思考 任何一个现存的框架都有其存在理由，而这个理由就是解决实际的问题。或者提供更好的解决问题的方案。spring mvc 它解决了什么问题呢？ </p>
<ol>
<li>URL映射</li>
<li>表单参数映射</li>
<li>调用目标Control</li>
<li>数据模型映射视图解析</li>
<li>异常处理</li>
</ol>
<p>上术解决在spring mvc 中都体现在如下组件当中</p>
<ul>
<li><strong>HandlerMapping</strong> ‘hændlə  ‘mæpɪŋ<ul>
<li>url与控制器的映谢</li>
</ul>
</li>
<li><strong>HandlerAdapter</strong>  ‘hændlə ə’dæptə<ul>
<li>控制器执行适配器</li>
</ul>
</li>
<li><strong>ViewResolver</strong> vjuː  riː’zɒlvə <ul>
<li>视图仓库</li>
</ul>
</li>
<li><strong>view</strong><ul>
<li>具体解析视图</li>
</ul>
</li>
<li><strong>HandlerExceptionResolver</strong>  ‘hændlə  ɪk’sepʃ(ə)n  riː’zɒlvə<ul>
<li>异常捕捕捉器</li>
</ul>
</li>
<li><strong>HandlerInterceptor</strong>  ‘hændlə  ɪntə’septə<ul>
<li>拦截器</li>
</ul>
</li>
</ul>
<p>其对应具体uml如下 图：</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image3.png" alt="image3"></p>
<p>mvc 各组件执行流程<br><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image4.png" alt="image4"></p>
<h2 id="SpringMVC默认引入组件"><a href="#SpringMVC默认引入组件" class="headerlink" title="SpringMVC默认引入组件"></a>SpringMVC默认引入组件</h2><p>根据 org/springframework/web/servlet/DispatcherServlet.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Default implementation classes for DispatcherServlet&#x27;s strategy interfaces.</span><br><span class="hljs-comment"># Used as fallback when no matching beans are found in the DispatcherServlet context.</span><br><span class="hljs-comment"># Not meant to be customized by application developers.</span><br><br><span class="hljs-meta">org.springframework.web.servlet.LocaleResolver</span>=<span class="hljs-string">org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.ThemeResolver</span>=<span class="hljs-string">org.springframework.web.servlet.theme.FixedThemeResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.HandlerMapping</span>=<span class="hljs-string">org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping,\</span><br>   <span class="hljs-attr">org.springframework.web.servlet.mvc.annotation.DefaultAnnotationHandlerMapping</span><br><br><span class="hljs-meta">org.springframework.web.servlet.HandlerAdapter</span>=<span class="hljs-string">org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter,\</span><br>   org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter,\<br>   <span class="hljs-attr">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter</span><br><br><span class="hljs-meta">org.springframework.web.servlet.HandlerExceptionResolver</span>=<span class="hljs-string">org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerExceptionResolver,\</span><br>   org.springframework.web.servlet.mvc.annotation.ResponseStatusExceptionResolver,\<br>   <span class="hljs-attr">org.springframework.web.servlet.mvc.support.DefaultHandlerExceptionResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.RequestToViewNameTranslator</span>=<span class="hljs-string">org.springframework.web.servlet.view.DefaultRequestToViewNameTranslator</span><br><br><span class="hljs-meta">org.springframework.web.servlet.ViewResolver</span>=<span class="hljs-string">org.springframework.web.servlet.view.InternalResourceViewResolver</span><br><br><span class="hljs-meta">org.springframework.web.servlet.FlashMapManager</span>=<span class="hljs-string">org.springframework.web.servlet.support.SessionFlashMapManager</span><br></code></pre></td></tr></table></figure>

<h2 id="HandlerMapping-详解"><a href="#HandlerMapping-详解" class="headerlink" title="HandlerMapping 详解"></a>HandlerMapping 详解</h2><p>其为mvc 中url路径与Control对像的映射，DispatcherServlet 就是基于此组件来寻找对应的Control，如果找不到就会报 No mapping found for HTTP request with URI的异常。</p>
<p>HandlerMapping 接口结构分析：</p>
<p>HandlerMapping  作用是通过url找到对应的Handler ，但其HandlerMapping.getHandler()方法并不会直接返回Handler 对像，而是返回 HandlerExecutionChain 对像在通过  HandlerExecutionChain.getHandler() 返回最终的handler</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210601235555218.png" alt="image-20210601235555218"></p>
<p>目前主流的三种mapping 如下：</p>
<ol>
<li><strong>SimpleUrlHandlerMapping：基于手动配置 url 与control 映谢</strong></li>
<li><strong>BeanNameUrlHandlerMapping: 基于ioc name 中已 “/“ 开头的Bean时行 注册至映谢.</strong></li>
<li><strong>RequestMappingHandlerMapping：基于@RequestMapping注解配置对应映谢</strong></li>
</ol>
<h3 id="SimpleUrlHandlerMapping"><a href="#SimpleUrlHandlerMapping" class="headerlink" title="SimpleUrlHandlerMapping"></a>SimpleUrlHandlerMapping</h3><p>SimpleUrlHandlerMapping体系结构：基于手动配置 url 与control 映谢</p>
<img src="/images/SpringMVC核心流程解析/image-20210602000051935.png" alt="image-20210602000051935" style="zoom: 80%;">



<p> 初始化SimpleUrlHandlerMapping流程关键源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#setUrlMap<br>  &gt;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#initApplicationContext<br>    &gt;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping#registerHandlers <br>    <span class="hljs-comment">// /表示根路径 /* 表示默认路径	</span><br>    &gt;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#registerHandler()<br><br></code></pre></td></tr></table></figure>

<p>获取 Handler流程关键源码:</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.springframework.web.servlet.DispatcherServlet#doService&gt;org.springframework.web.servlet.DispatcherServlet#doDispatch<br>  &gt;org.springframework.web.servlet.DispatcherServlet#getHandler&gt;org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler<br>    &gt;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#getHandlerInternal <br>    <span class="hljs-comment">// 获取URL路径 </span><br>    &gt;org.springframework.web.util.UrlPathHelper#getPathWithinApplication <br>    <span class="hljs-comment">// 查找handler</span><br>    &gt;org.springframework.web.servlet.handler.AbstractUrlHandlerMapping#lookupHandler <br>    <span class="hljs-comment">// 封装执行链</span><br>	  &gt;org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandlerExecutionChain<br></code></pre></td></tr></table></figure>

<h3 id="BeanNameUrlHandlerMapping"><a href="#BeanNameUrlHandlerMapping" class="headerlink" title="BeanNameUrlHandlerMapping"></a>BeanNameUrlHandlerMapping</h3><p>BeanNameUrlHandlerMapping 实现上与 SimpleUrlHandlerMapping 一至，唯一区别在于 继承自AbstractDetectingUrlHandlerMapping ，通过对应detectHandlers 可以在无配置的情况下发现url 与handler 映射。</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602231512508.png"></p>
<h3 id="RequestMappingHandlerMapping（后续补充）"><a href="#RequestMappingHandlerMapping（后续补充）" class="headerlink" title="RequestMappingHandlerMapping（后续补充）"></a><strong>RequestMappingHandlerMapping</strong>（后续补充）</h3><p>其基于注解实现，在后续章节讲解注解映谢的时候在详细讲</p>
<h2 id="HandlerAdapter"><a href="#HandlerAdapter" class="headerlink" title="HandlerAdapter"></a>HandlerAdapter</h2><p>在 AbstractUrlHandlerMapping 我们可以看到存储handler 的Map 值类型是Object ，是否意味着所有的类都可以做来Handler 来使用？</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image10.png" alt="image10"></p>
<p>Handler  对应类型如下如图：</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image11.png" alt="image11"></p>
<ol>
<li><strong>Controller</strong></li>
<li><strong>HttpRequestHandler</strong></li>
<li><strong>HttpServlet</strong></li>
<li><strong>@RequestMapping</strong></li>
</ol>
<p>可以看出 Handler 没有统一的接口，当dispatchServlet获取当对应的Handler之后如何调用呢？调用其哪个方法？这里有两种解决办法，</p>
<p><strong>一是用instanceof 判断Handler 类型然后调用相关方法 。</strong></p>
<p><strong>二是通过引入适配器实现，每个适配器实现对指定Handler的调用。</strong></p>
<p>spring 采用后者。</p>
<p><strong>HandlerAdapter详解</strong></p>
<p>这里spring mvc 采用适配器模式来适配调用指定Handler，根据Handler的不同种类采用不同的Adapter,其Handler与 HandlerAdapter 对应关系如下:</p>
<table>
<thead>
<tr>
<th>Handler类别</th>
<th>对应适配器</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Controller</td>
<td>SimpleControllerHandlerAdapter</td>
<td>标准控制器，返回ModelAndView</td>
</tr>
<tr>
<td>HttpRequestHandler</td>
<td>HttpRequestHandlerAdapter</td>
<td>业务自行处理 请求，不需要通过modelAndView 转到视图</td>
</tr>
<tr>
<td>Servlet</td>
<td>SimpleServletHandlerAdapter</td>
<td>基于标准的servlet 处理</td>
</tr>
<tr>
<td>HandlerMethod</td>
<td>RequestMappingHandlerAdapter</td>
<td>基于@requestMapping对应方法处理</td>
</tr>
</tbody></table>
<p>HandlerAdapter  接口方法</p>
<img src="/images/SpringMVC核心流程解析/image-20210602232832491.png" alt="image-20210602232832491">

<p>HandlerAdapter  接口结构图</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602232931062.png" alt="image-20210602232931062"></p>
<p>上述例子中当IOC中实例化这些类之后DispatcherServlet就会通过org.springframework.web.servlet.DispatcherServlet#getHandlerAdapter() 方法查找对应handler的适配器 ，如果找不到就会报 如下异常 。</p>
<blockquote>
<p>javax.servlet.ServletException: No adapter for handler [com.tuling.control.SimpleControl@3c06b5d5]: The DispatcherServlet configuration needs to include a HandlerAdapter that supports this handlerorg.springframework.web.servlet.DispatcherServlet.getHandlerAdapter(DispatcherServlet.java:1198)org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)</p>
</blockquote>
<h2 id="ViewResolver-与View"><a href="#ViewResolver-与View" class="headerlink" title="ViewResolver 与View"></a>ViewResolver 与View</h2><p>找到应的Adapter 之后就会基于适配器调用业务处理，处理完之后业务方会返回一个ModelAndView ，在去查找对应的视图进行处理。</p>
<p>其在<strong>org.springframework.web.servlet.DispatcherServlet#resolveViewName()</strong> 中遍历 viewResolvers 列表查找，如果找不到就会报一个 Could not resolve view with name 异常。</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602233734756.png" alt="image-20210602233734756"></p>
<p>BeanNameViewREsolver示例</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">添加自定义视图:<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Map&lt;String, ?&gt; model, HttpServletRequest </span></span><br><span class="hljs-function"><span class="hljs-params">            request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;hello luban good man.&quot;</span>);<br>    &#125;<br>&#125;<br><br>修改视图跳转方法 ：<br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;myView&quot;</span>);<br>    mv.addObject(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;24kHandsome is good man&quot;</span>);<br>    <span class="hljs-keyword">return</span> mv;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">配置视图解析器：<br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;myView&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tuling.control.MyView&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.BeanNameViewResolver&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--资源解析器 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceView&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>在下一步就是基于ViewResolver**.**resolveViewName() 获取对应View来解析生成Html并返回 。</p>
<p>对应VIEW结构如下：</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210602234106079.png" alt="image-20210602234106079"></p>
<h2 id="MVC异常拦截处理HandlerExceptionResolver"><a href="#MVC异常拦截处理HandlerExceptionResolver" class="headerlink" title="MVC异常拦截处理HandlerExceptionResolver"></a>MVC异常拦截处理HandlerExceptionResolver</h2><p>HandlerExceptionResolver的类关系图</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210605144323346.png" alt="image-20210605144323346"></p>
<ul>
<li>ResponseStatuExceptionResolver<ul>
<li>用于解析带@ResponseStatus的自定义异常</li>
</ul>
</li>
<li>DefaultHandlerExceptionResolver<ul>
<li>spring mvc 默认异常处理</li>
</ul>
</li>
<li>SimpleMappingExceptionResolver<ul>
<li>异常映射，将指定异常与错误页面相对应</li>
</ul>
</li>
</ul>
<p>该组件用于指示 当出现异常时 mvc 该如何处理。 dispatcherServlet 会调用org.springframework.web.servlet.DispatcherServlet#processHandlerException() 方法，遍历 handlerExceptionResolvers 处理异常，处理完成之后返回errorView 跳转到异常视图。</p>
<p>自定义异常解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyHandlerExceptionResolver</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerExceptionResolver</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveException</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-function"><span class="hljs-params">                                         HttpServletResponse response,</span></span><br><span class="hljs-function"><span class="hljs-params">                                         Object handler, Exception ex)</span> </span>&#123;<br><br>        ModelAndView mv = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;argumentError&quot;</span>);<br>        mv.addObject(<span class="hljs-string">&quot;stack&quot;</span>,ex);<br>        <span class="hljs-keyword">return</span> mv;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>SimpleMappingExceptionResolver 示例：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultErrorView&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultStatusCode&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;500&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;exceptionMappings&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">map</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.RuntimeException&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;error&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">entry</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;java.lang.IllegalArgumentException&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;argumentError&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">map</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="提问："><a href="#提问：" class="headerlink" title="提问："></a>提问：</h3><p>IllegalArgumentException 是 RuntimeException子类，如果IllegalArgumentException  异常同时满足映射的两个条件，这时会怎么选择跳转的视图？</p>
<p>答案是会选择IllegalArgumentException 这个子类，而不是根据先后顺序</p>
<h2 id="HandlerInterceptor-调用拦截"><a href="#HandlerInterceptor-调用拦截" class="headerlink" title="HandlerInterceptor  调用拦截"></a>HandlerInterceptor  调用拦截</h2><p>HandlerInterceptor  用于对请求拦截，</p>
<p>HandlerInterceptor  常常用于对某些路径进行特殊配置，可用于</p>
<ul>
<li>参数打印 业务处理前 后</li>
<li>登陆/权限拦截 业务处理前</li>
<li>数字验签 业务处理前</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleHandlerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;preHandle&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;postHandle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>preHandle ：业务处理前执行</p>
<p>postHandle：业务处理后（异常则不执行）</p>
<p>afterCompletion：视图处理后</p>
<h3 id="Filter与Interceptor联系与区别"><a href="#Filter与Interceptor联系与区别" class="headerlink" title="Filter与Interceptor联系与区别"></a>Filter与Interceptor联系与区别</h3><ul>
<li>拦截器不依赖servlet容器，过滤器依赖于servlet容器。</li>
<li>拦截器只能对action（handler）起作用，而过滤器可以对几乎所有的请求起作用（可以保护资源）。</li>
<li>拦截器可以访问action上下文，堆栈里面的对象，而过滤器不可以。</li>
<li>执行顺序：过滤前-拦截前-Action处理-拦截后-过滤后。</li>
<li><strong>细粒度的不同</strong>拦截器提供更精细的控制，可以在controller对请求处理之前或之后被调用，<strong>也可以在渲染视图呈现给用户之后调用</strong></li>
<li><strong>中断链执行的难易程度不同</strong>拦截器可以 preHandle方法内返回 false 进行中断，过滤器就比较复杂，需要处理请求和响应对象来引发中断，需要额外的动作，比如将用户重定向到错误页面</li>
</ul>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210605230700202.png" alt="image-20210605230700202"></p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210605231527804.png" alt="image-20210605231527804"></p>
<h3 id="三者使用场景"><a href="#三者使用场景" class="headerlink" title="三者使用场景"></a>三者使用场景</h3><p>三者功能类似，但各有优势，从过滤器–》拦截器–》切面，拦截规则越来越细致，执行顺序依次是过滤器、拦截器、切面。</p>
<p>**<font style="background:yellow">一般情况下数据被过滤的时机越早对服务的性能影响越小</font>**，因此我们在编写相对比较公用的代码时，优先考虑过滤器，然后是拦截器，最后是aop。</p>
<p>比如权限校验，一般情况下（经供参考）</p>
<p>所有的请求都需要做登陆校验，此时就应该使用过滤器在最顶层做校验</p>
<p>日志记录，一般日志只会针对部分逻辑做日志记录，而且牵扯到业务逻辑完成前后的日志记录，因此使用过滤器不能细致地划分模块，此时应该考虑拦截器，然而拦截器也是依据URL做规则匹配，因此相对来说不够细致，因此我们会考虑到使用AOP实现，AOP可以针对代码的方法级别做拦截，很适合日志功能。</p>
<h2 id="RequestMapping的使用与原理"><a href="#RequestMapping的使用与原理" class="headerlink" title="@RequestMapping的使用与原理"></a>@RequestMapping的使用与原理</h2><p>演示基于注解配置mvc mapping </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs XML"><span class="hljs-comment">&lt;!-- 注解驱动 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;study.springmvc&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 视图仓库 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/page/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewClass&quot;</span></span><br><span class="hljs-tag">              <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.JstlView&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyRequestHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpRequestHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleRequest</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        request.getRequestDispatcher(<span class="hljs-string">&quot;userView&quot;</span>).forward(request,response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>提问</strong> </p>
<p>​    为什么基于&lt;mvc:annotation-driven /&gt; 配置就能实现mvc 的整个配置了</p>
<p>之前所提到的 handlerMapping 、与handlerAdapter 组件都不适用了？只要查看以类的源就可以知晓其中原因：认识 NamespaceHandler 接口查看 MvcNamespaceHandler查看AnnotationDrivenBeanDefinitionParser</p>
<p><strong>结论</strong>：</p>
<p>​    在&lt;mvc:annotation-driven /&gt; 对应的解析器，自动向ioc 里面注册了两个BeanDefinition。</p>
<p>​    分别是：<strong>RequestMappingHandlerMapping</strong>与<strong>BeanNameUrlHandlerMapping</strong></p>
<p>![image2 (2)](/images/SpringMVC核心流程解析/image2 (2).png)</p>
<ul>
<li>RequestMappingHandlerMapping :URL 映射器</li>
<li>RequestMappingHandlerAdapter：执行适配器</li>
<li>InvocableHandlerMethod：Control目标对象，包含了control Bean 及对应的method 对像，及调用方法 <ul>
<li>HandlerMethodArgumentResolverComposite：参数处理器 </li>
<li>ParameterNameDiscoverer：参数名称处理器 </li>
<li>HandlerMethodReturnValueHandlerComposite：返回结构处理器</li>
</ul>
</li>
</ul>
<p>查找mapping源码解析</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-comment">// 基于注解查找 mapping</span><br>org.springframework.web.servlet.DispatcherServlet#getHandler<br>&gt;org.springframework.web.servlet.handler.AbstractHandlerMapping#getHandler<br> &gt;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping#lookupHandlerMethod<br> &gt;org.springframework.web.servlet.handler.AbstractHandlerMethodMapping.MappingRegistry#getMappingsByUrl<br></code></pre></td></tr></table></figure>

<p>调用执行过程源码解析</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&gt;org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter#handle<br> &gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#handleInternal <br> &gt;org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter#invokeHandlerMethod<br>   &gt;org.springframework.web.method.support.InvocableHandlerMethod#invokeForRequest<br>    &gt;org.springframework.web.method.support.InvocableHandlerMethod#doInvoke<br></code></pre></td></tr></table></figure>

<h1 id="自定义MVC的框架实现"><a href="#自定义MVC的框架实现" class="headerlink" title="自定义MVC的框架实现"></a>自定义MVC的框架实现</h1><h2 id="框架需求与目标"><a href="#框架需求与目标" class="headerlink" title="框架需求与目标"></a>框架需求与目标</h2><h3 id="框架需求："><a href="#框架需求：" class="headerlink" title="框架需求："></a>框架需求：</h3><p>​    框架的需求包含<strong>功能性需求</strong> 和<strong>非功能性需求</strong>，功能性需求框架本身所提供的功能，而非功能性需求通常也指定体验性需求，即该框架对于开发者而言，是否易上手，是否需要较多的学习成本，以及在开发时需要过多的配置。</p>
<p>​    有个时候两者是互相矛盾冲突的，比如当我们想让框架支持更的功能时，那么它的结构设计将会更复杂，抽像的层次将会越多，带来的负面影响时对框架使用者的学习成本增加了。</p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210606174425301.png" alt="image-20210606174425301"></p>
<p>到底该选择更多的功能，还是更好的体验？这就需要框架作者要作出准确的定位与范围。</p>
<p>定位是该框架要完成什么目标？范围是实现该目标需实现哪些功能？两者清晰之后 自然知道哪些是必须做的，哪些是可以做的。而体验则是在保证必须功能的情况越高越好，甚至可以为了提供体验可以牺牲部分功能的完整性。</p>
<p><strong>功能性需求用例图：</strong></p>
<img src="/images/SpringMVC核心流程解析/image-20210606175802297.png" alt="image-20210606175802297" style="zoom:80%;">

<ul>
<li>URL映射<ul>
<li>基于注解自动匹配调用方法</li>
</ul>
</li>
<li>参数自动解析<ul>
<li>Form表单参数自动转换成一般对像和复杂对像</li>
</ul>
</li>
<li>请求调用<ul>
<li>基于反射调用目标方法</li>
</ul>
</li>
<li>视图支持<ul>
<li>基于返回的结果跳转至视图处理</li>
<li>支持的有jsp 视图，freemarke视图，Json视图</li>
</ul>
</li>
<li>统一异常处理<ul>
<li>出现异常统一处理，并跳转到异常页面</li>
</ul>
</li>
</ul>
<p><strong>非功能性需求与目标：</strong></p>
<ul>
<li>接近于零的配置</li>
<li>更少的学习成本<ul>
<li>尽可能使用用户之前习惯</li>
<li>概念性的东西要少一些</li>
</ul>
</li>
<li>支持动态装载</li>
</ul>
<h2 id="框架设计与编码实现"><a href="#框架设计与编码实现" class="headerlink" title="框架设计与编码实现"></a>框架设计与编码实现</h2><p>框架环境依赖：</p>
<p>​    框架名称：study-myspringMVC</p>
<p>​    jdk:1.8</p>
<p>​    依赖包：spring、freemarker、java-servlet-api</p>
<p><strong>框架流程分解：</strong></p>
<p><img src="/images/SpringMVC%E6%A0%B8%E5%BF%83%E6%B5%81%E7%A8%8B%E8%A7%A3%E6%9E%90/image-20210606221522334.png" alt="image-20210606221522334"></p>
<p><strong>实现组件：</strong></p>
<ul>
<li><strong>FreemakerView</strong><ul>
<li>freemarke视图</li>
</ul>
</li>
<li><strong>HandlerServlet</strong>（原DispatchServlet）<ul>
<li>请求参数封装，请求转发</li>
</ul>
</li>
<li><strong>MvcBeanFactory</strong>（类似HandlerMapping 持有 url对应handler的map）<ul>
<li>Mvc bean 工厂 ，从spring ioc 中扫描类装载MVC Bean</li>
</ul>
</li>
<li><strong>MvcBean</strong>（原HandlerMethod，因为只有一种handler，所以无需HandlerAdaptor）<ul>
<li>MVC 业务执行</li>
</ul>
</li>
<li><strong>MvcMaping</strong>（原@RequestMapping）<ul>
<li>MVC注解，用于注解MVC Bean，并配置url 路径</li>
</ul>
</li>
</ul>
<p>代码：</p>
<p>1、模拟DispatchServlet</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HandlerServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-comment">//IOC父容器</span><br>    <span class="hljs-keyword">private</span> WebApplicationContext context;<br>    <span class="hljs-comment">//MVC子容器</span><br>    <span class="hljs-keyword">private</span> MvcBeanFactory beanFactory;<br>    <span class="hljs-comment">//asm字节码解析器，用户解析请求参数对应的key</span><br>    <span class="hljs-keyword">final</span> ParameterNameDiscoverer parameterUtil = <span class="hljs-keyword">new</span> LocalVariableTableParameterNameDiscoverer();<br>    <br>    <span class="hljs-keyword">private</span> Configuration freemarkeConfig;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        context = WebApplicationContextUtils.getWebApplicationContext(getServletContext());<br>        beanFactory = <span class="hljs-keyword">new</span> MvcBeanFactory(context);<br><br>        Configuration freemarkeConfig = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            freemarkeConfig = context.getBean(Configuration.class);<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException e) &#123;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (freemarkeConfig == <span class="hljs-keyword">null</span>) &#123;<br>            freemarkeConfig = <span class="hljs-keyword">new</span> Configuration(Configuration.VERSION_2_3_23);<br>            freemarkeConfig.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>            freemarkeConfig.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);<br>            <span class="hljs-keyword">try</span> &#123;<br>                freemarkeConfig.setDirectoryForTemplateLoading(<span class="hljs-keyword">new</span> File(getServletContext().getRealPath(<span class="hljs-string">&quot;/WEB-INF/ftl/&quot;</span>)));<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(e);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.freemarkeConfig = freemarkeConfig;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doHandler(req, resp);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        doHandler(req, resp);<br>    &#125;<br>    <br>	<span class="hljs-comment">// TODO 处理静态文件</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doHandler</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;<br>         String uri = req.getServletPath();<br>        <span class="hljs-keyword">if</span> (uri.equals(<span class="hljs-string">&quot;/favicon.ico&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//获取Hadnler</span><br>        MvcBeanFactory.MvcBean mvcBean = beanFactory.getMvcBean(uri);<br>        <span class="hljs-keyword">if</span> (mvcBean == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(String.format(<span class="hljs-string">&quot;not found %s mapping&quot;</span>, uri));<br>        &#125;<br>        <span class="hljs-comment">//利用asm字节码工具解析参数</span><br>    	Object[] args = buildPrams(mvcBean, req, resp);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//反射运行目标对象 handlerMethod</span><br>            Object result = mvcBean.run(args);<br>            <span class="hljs-comment">//封装返回结果</span><br>            processResult(result, resp);<br>        &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (InvocationTargetException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (TemplateException e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> Object[] buildPrams(MvcBeanFactory.MvcBean mvcBean, HttpServletRequest req, HttpServletResponse resp) &#123;<br>        Method method = mvcBean.getTargetMethod();<br>        List&lt;String&gt; paramNames = Arrays.asList(parameterUtil.getParameterNames(method));<br>        Class&lt;?&gt;[] paramTypes = method.getParameterTypes(); <span class="hljs-comment">//反射</span><br>        <span class="hljs-comment">// a.b.c</span><br>        Object[] args = <span class="hljs-keyword">new</span> Object[paramTypes.length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; paramNames.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span> (paramTypes[i].isAssignableFrom(HttpServletRequest.class)) &#123;<br>                args[i] = req;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (paramTypes[i].isAssignableFrom(HttpServletResponse.class)) &#123;<br>                args[i] = resp;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (req.getParameter(paramNames.get(i)) == <span class="hljs-keyword">null</span>) &#123;<br>                    args[i] = <span class="hljs-keyword">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    args[i] = convert(req.getParameter(paramNames.get(i)), paramTypes[i]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> args;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2、模拟@RequstMapping:MvcMapping和Mvc子容器持有HandleMapping:MvcBeanFactory</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs JAVA"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(value = ElementType.METHOD)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MvcMapping &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">value</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">contentType</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> &quot;JSON&quot;</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcBeanFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ApplicationContext applicationContext;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MvcBeanFactory</span><span class="hljs-params">(ApplicationContext applicationContext)</span> </span>&#123;<br>        Assert.notNull(applicationContext, <span class="hljs-string">&quot;argument &#x27;applicationContext&#x27; must not be null&quot;</span>);<br>        <span class="hljs-keyword">this</span>.applicationContext = applicationContext;<br>        loadApiFromSpringBeans();<br>    &#125;<br><br>    <span class="hljs-comment">// API 接口住的地方 </span><br>    <span class="hljs-keyword">private</span> HashMap&lt;String, MvcBean&gt; apiMap = <span class="hljs-keyword">new</span> HashMap&lt;String, MvcBean&gt;();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadApiFromSpringBeans</span><span class="hljs-params">()</span> </span>&#123;<br>        apiMap.clear();<br>        <span class="hljs-comment">// ioc 所有BEan</span><br>        <span class="hljs-comment">// spring ioc 扫描</span><br>        String[] names = applicationContext.getBeanDefinitionNames();<br>        Class&lt;?&gt; type;<br>        <span class="hljs-keyword">for</span> (String name : names) &#123;<br>            type = applicationContext.getType(name);<br>            <span class="hljs-keyword">for</span> (Method m : type.getDeclaredMethods()) &#123;<br>                <span class="hljs-comment">// 通过反射拿到HttpMapping注解</span><br>                MvcMapping MvcMapping = m.getAnnotation(MvcMapping.class);<br>                <span class="hljs-keyword">if</span> (MvcMapping != <span class="hljs-keyword">null</span>) &#123;<br>                    <span class="hljs-comment">// 封装成一个 MVC bean</span><br>                    addApiItem(MvcMapping, name, m);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MvcBean <span class="hljs-title">getMvcBean</span><span class="hljs-params">(String apiName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> apiMap.get(apiName);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加api &lt;br/&gt;</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> MvcMapping api配置</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName   beanq在spring context中的名称</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> method</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addApiItem</span><span class="hljs-params">(MvcMapping MvcMapping, String beanName, Method method)</span> </span>&#123;<br>        MvcBean apiRun = <span class="hljs-keyword">new</span> MvcBean();<br>        apiRun.apiName = MvcMapping.value();<br>        apiRun.targetMethod = method;<br>        apiRun.targetName = beanName;<br>        apiRun.context = <span class="hljs-keyword">this</span>.applicationContext;<br>        apiMap.put(MvcMapping.value(), apiRun);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsApi</span><span class="hljs-params">(String apiName, String version)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> apiMap.containsKey(apiName + <span class="hljs-string">&quot;_&quot;</span> + version);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ApplicationContext <span class="hljs-title">getApplicationContext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> applicationContext;<br>    &#125;<br><br><br>    <span class="hljs-comment">// 用于执行对应的API方法，</span><br>    <span class="hljs-comment">//</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcBean</span> </span>&#123;<br>        String apiName;  <span class="hljs-comment">//bit.api.user.getUser</span><br><br>        String targetName; <span class="hljs-comment">//ioc bean 名称</span><br><br>        Object target; <span class="hljs-comment">// UserServiceImpl 实例</span><br>        Method targetMethod; <span class="hljs-comment">// 目标方法 getUser</span><br>        ApplicationContext context;<br><br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">run</span><span class="hljs-params">(Object... args)</span> <span class="hljs-keyword">throws</span> IllegalAccessException, IllegalArgumentException, InvocationTargetException </span>&#123;<br>            <span class="hljs-comment">// 懒加载</span><br>            <span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">// spring ioc 容器里面去服务Bean 比如GoodsServiceImpl</span><br>                target = context.getBean(targetName);<br>            &#125;<br>            <span class="hljs-keyword">return</span> targetMethod.invoke(target, args);<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> Class&lt;?&gt;[] getParamTypes() &#123;<br>            <span class="hljs-keyword">return</span> targetMethod.getParameterTypes();<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getApiName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> apiName;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTargetName</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> targetName;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> target;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Method <span class="hljs-title">getTargetMethod</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> targetMethod;<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、FreeMaker试图解析器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FreemarkeView</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String ftlPath;<br>    <span class="hljs-keyword">private</span> Map&lt;String, Object&gt; models = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreemarkeView</span><span class="hljs-params">(String ftlPath)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ftlPath = ftlPath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FreemarkeView</span><span class="hljs-params">(String ftlPath, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ftlPath = ftlPath;<br>        <span class="hljs-keyword">this</span>.models = model;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setModel</span><span class="hljs-params">(String key, Object model)</span> </span>&#123;<br>        models.put(key, model);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeModel</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        models.remove(key);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFtlPath</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ftlPath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFtlPath</span><span class="hljs-params">(String ftlPath)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.ftlPath = ftlPath;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getModels</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> models;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setModels</span><span class="hljs-params">(Map&lt;String, Object&gt; models)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.models = models;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>4、web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span> <span class="hljs-attr">xmlns:web</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;WebApp_ID&quot;</span> <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;3.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- root ioc --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>my spring mvc <span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span><br><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">description</span>&gt;</span>spring监听器<span class="hljs-tag">&lt;/<span class="hljs-name">description</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.study.mvc.HandlerServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file-list</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">welcome-file</span>&gt;</span>/index.html<span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">welcome-file-list</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>docker-docker-compose基础</title>
    <url>/2024/12/30/docker-docker-compose%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Docker基础"><a href="#Docker基础" class="headerlink" title="Docker基础"></a>Docker基础</h1><p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20241222210224661.png" alt="image-20241222210224661"></p>
<h2 id="Docker是什么"><a href="#Docker是什么" class="headerlink" title="Docker是什么"></a>Docker是什么</h2><p>​    <strong>Docker 是一个开源的容器化平台，用于开发、交付和运行应用程序。</strong>如图所示，简单来说，docker是一艘运载着许多相互隔离、互相独立的集装箱，每个箱子内部运行着独立的程序。</p>
<h2 id="为什么使用Docker"><a href="#为什么使用Docker" class="headerlink" title="为什么使用Docker"></a>为什么使用Docker</h2><p>​    Develop faster. Run anywhere，这是docker官网上的docker原话，更快的开发，到处运行。</p>
<p><strong>1、解决传统环境差异导致的兼容性问题</strong></p>
<p>按照传统开发模式，一个产品有2套部署环境：本地开发，线上环境，存在大量的运维部署问题和环境差异，费事费力。最典型的问题是开发人员——我本地明明跑起来正常的，为什么线上不行</p>
<p><strong>2、快速部署、快速迭代的兴起</strong></p>
<p>Devops的快速发展，传统的开发模式时，开发人员提供jar包，然后手动上传服务器，然后java -jar启动新的包，有时遇到，依赖的其他组件升级，那就更是麻烦，比如mysql、redis、xxljob等，涉及到了环境依赖、先后问题，运维难度极大。有了docker，结合Jenkins、可以快速实现持续开发、持续部署、编排容器。</p>
<p><strong>3、容器编排技术的兴起</strong></p>
<p>通过容器编排工具和 Docker 的结合，可以轻松地实现复杂的应用架构，如微服务架构，多个微服务可以分别打包成 Docker 容器，通过容器编排工具进行统一管理和调度</p>
<p><strong>4、资源利用和成本优化</strong></p>
<p>Docker 容器相比于传统的虚拟机，具有更轻量级的特点。虚拟机需要为每个实例运行一个完整的操作系统，而 Docker 容器共享主机操作系统内核，多个容器可以在同一主机上运行，大大减少了系统资源的占用。这使得在相同的硬件资源下，可以部署更多的应用，提高了资源利用率，降低了企业的硬件采购和运维成本。</p>
<h2 id="Docker和虚拟机的区别"><a href="#Docker和虚拟机的区别" class="headerlink" title="Docker和虚拟机的区别"></a>Docker和虚拟机的区别</h2><p>docker出现之前，虚拟技术主流就是虚拟机，对应的软件有Vmvare，VirtualBox等。</p>
<p>总的来说，docker不像虚拟机那么重，容器共用宿主机的操作系统，每个容器只需要包含自身需要的环境和程序，所以<strong>比较小</strong>，<strong>启动也快</strong>，<strong>资源利用率更高</strong></p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/3e74d992a805546fa7819562436396fa.png" alt="什么是docker，它与虚拟机有什么区别？_docker和虚拟机的区别-CSDN博客"></p>
<p><strong>应用更快速的交付和部署</strong><br>传统：一堆帮助文档，安装程序<br>Docker：打包镜像发布测试，一键运行</p>
<p><strong>更便捷的升级和扩缩容</strong><br>使用了Docker之后，我们部署应用就和搭积木一样！<br>项目打包为一个镜像，扩展服务器A！服务器B</p>
<p><strong>更简单的系统运维</strong><br>在容器化之后，我们的开发，测试环境都是高度一致的。</p>
<p><strong>更高效的计算资源利用：</strong><br>Docker是内核级别的虚拟化，可以再一个物理机上可以运行很多的容器实例！服务器的性能可以被压榨到极致。</p>
<h2 id="Docker怎么用"><a href="#Docker怎么用" class="headerlink" title="Docker怎么用"></a>Docker怎么用</h2><h3 id="docker核心概念"><a href="#docker核心概念" class="headerlink" title="docker核心概念"></a>docker核心概念</h3><h4 id="镜像（image）"><a href="#镜像（image）" class="headerlink" title="镜像（image）"></a><strong>镜像（image）</strong></h4><p>​    Docker镜像就好比是一个模板，可以通过这个模板来创建容器服务，tomcat镜像 =&gt; run =&gt; tomcat01容器， 通过这个镜像可以创建多个容器（最终服务运行或者项目运行就是在容器中的）</p>
<h4 id="容器（container）"><a href="#容器（container）" class="headerlink" title="容器（container）"></a>容器（container）</h4><p>​    Docker利用容器技术，独立运行一个或者一组应用， 通过镜像来创建的。可以理解为容器是镜像的实例</p>
<p>容器可以启动，停止，删除等</p>
<h4 id="仓库（repository）"><a href="#仓库（repository）" class="headerlink" title="仓库（repository）"></a>仓库（repository）</h4><p>​    存放镜像的地方，Docker Hub（默认是国外的），各大厂商也有自己的docker镜像仓库</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/9184d6bcf25b343837abd4562f4a9d68.png" alt="img"></p>
<h3 id="docker底层原理"><a href="#docker底层原理" class="headerlink" title="docker底层原理"></a>docker底层原理</h3><h4 id="docker如何工作"><a href="#docker如何工作" class="headerlink" title="docker如何工作"></a>docker如何工作</h4><p>​    Docker是一个Client-Server结构的服务器，Docker的守护进程运行在主机上，通过Socket从客户端访问！Docker-Server接收到Docker-Client指令，就会执行这个命令</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/94859c15deb3ab31e8c48f459f939389.png" alt="img"></p>
<h4 id="docker为什么比VM快"><a href="#docker为什么比VM快" class="headerlink" title="docker为什么比VM快"></a>docker为什么比VM快</h4><p>1、Docker有着比虚拟机更少的抽象层<br>2、docker利用的是宿主机的内核，vm需要是Guest os</p>
<p>​    所以说，新建一个容器的时候，docker不需要想虚拟机一样重新加载一个操作系统内核，避免引导。虚拟机是加载 GuestOS，分钟级别的，而docker是利用宿主机的操作系统吗，省略了这个复杂的过程，秒级！</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/c1dbf01fdabaf8feb96186744a1b55c6.png" alt="img"></p>
<h3 id="docker安装及镜像仓库配置"><a href="#docker安装及镜像仓库配置" class="headerlink" title="docker安装及镜像仓库配置"></a>docker安装及镜像仓库配置</h3><p>参考上篇</p>
<h2 id="Docker常用命令"><a href="#Docker常用命令" class="headerlink" title="Docker常用命令"></a>Docker常用命令</h2><p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/52575e34aa6632aa6e70eeca27b4785f.png" alt="在这里插入图片描述"></p>
<h3 id="帮助命令："><a href="#帮助命令：" class="headerlink" title="帮助命令："></a>帮助命令：</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker version		#查看docker版本信息<br>docker info			#显示docker系统信息，包括镜像和容器的数量<br>docker --<span class="hljs-built_in">help</span>		#帮助命令<br></code></pre></td></tr></table></figure>

<h3 id="镜像命令"><a href="#镜像命令" class="headerlink" title="镜像命令"></a>镜像命令</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker images 查看所有本地主机上的镜像<br>-a:列出本地所有镜像<br>-q:只列出镜像ID<br>–digests:显示镜像的摘要信息<br>–no trunc:显示完整的镜像信息<br>-s:列出收藏数不小于指定值的镜像<br><br>docker search 查找镜像<br><br>docker pull 镜像名[:tag] 下拉镜像 如果不写tag，默认就是latest<br><br>docker rmi 删除镜像<br><br>docker rmi $(docker images -aq)   # 删除所有镜像<br></code></pre></td></tr></table></figure>

<h3 id="容器命令"><a href="#容器命令" class="headerlink" title="容器命令"></a>容器命令</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker run [可选参数] image #运行镜像<br> <br># 参数说明<br>--name=“Name”   容器名字    tomcat01    tomcat02    用来区分容器<br>-d      后台方式运行<br>-it     使用交互方式运行，进入容器查看内容<br>-p      指定容器的端口     -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span><br>    -p  ip:主机端口：容器端口<br>    -p  主机端口：容器端口（常用）<br>    -p  容器端口<br>    容器端口<br>-p      随机指定端口<br> <br> <br># 测试，启动并进入容器<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ ~]# docker run -it centos /bin/bash<br>[root@<span class="hljs-number">74</span>e82b7980e7 /]# ls   # 查看容器内的centos，基础版本，很多命令是不完善的<br>bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var<br>dev  home  lib64  media       opt  root  sbin  sys  usr<br> <br># 从容器中退回主机<br>[root@<span class="hljs-number">77969</span>f5dcbf9 /]# <span class="hljs-keyword">exit</span><br><span class="hljs-keyword">exit</span><br><br>列出所有的运行的容器<br># docker ps  #列出本地运行的容器<br>        # 列出当前正在运行的容器<br>-a      # 列出正在运行的容器包括历史容器<br>-n=?    # 显示最近创建的容器<br>-q      # 只显示当前容器的编号<br>退出容器<br><span class="hljs-keyword">exit</span>            # 直接退出容器并关闭<br>Ctrl + P + Q    # 容器不关闭退出<br><br>删除容器<br>docker rm -f 容器id                       # 删除指定容器<br>docker rm -f $(docker ps -aq)       # 删除所有容器<br>docker ps -a -q|xargs docker rm -f  # 删除所有的容器<br><br>启动和停止容器的操作<br>docker <span class="hljs-built_in">start</span> 容器id           # 启动容器<br>docker restart 容器id         # 重启容器<br>docker stop 容器id            # 停止当前正在运行的容器<br>docker kill 容器id            # 强制停止当前的容器<br><br>显示日志<br>docker logs -tf --tail number 容器id<br>-tf                 # 显示日志<br>--tail number       # 显示日志条数<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker logs -tf --tail <span class="hljs-number">10</span> a0d580a21251<br><br>查看容器中进程信息ps<br># 命令 docker top 容器id<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ /]# docker top df358bc06b17    <br><br>查看镜像的元数据<br>docker inspect 容器id<br><br><br>进入当前正在运行的容器<br>docker exec -it 容器id /bin/bash<br>docker attach 容器id<br><br># docker exec       # 进入容器后开启一个新的终端，可以在里面操作<br># docker attach     # 进入容器正在执行的终端，不会启动新的进程<br><br><br>从容器中拷贝文件到主机<br>docker cp 容器id：容器内路径    目的地主机路径<br>#docker cp <span class="hljs-number">7</span>af535f807e0:/home/Test.java /home<br><br>提交容器成为一个新的副本<br>docker commit<br>docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者名&quot; 容器id 目标镜像名：[tag]<br></code></pre></td></tr></table></figure>

<h2 id="Docker部署软件实战"><a href="#Docker部署软件实战" class="headerlink" title="Docker部署软件实战"></a>Docker部署软件实战</h2><h3 id="1、安装Nginx"><a href="#1、安装Nginx" class="headerlink" title="1、安装Nginx"></a>1、安装Nginx</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs CMD"># <span class="hljs-number">1</span>. 搜索镜像 search 建议去docker hub搜索，可以看到帮助文档<br># <span class="hljs-number">2</span>. 下载镜像 pull<br># <span class="hljs-number">3</span>. 运行测试<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker images<br>REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE<br>centos              latest              <span class="hljs-number">0</span>d120b6ccaa8        <span class="hljs-number">32</span> hours ago        <span class="hljs-number">215</span>MB<br>nginx               latest              <span class="hljs-number">08393</span>e824c32        <span class="hljs-number">7</span> days ago          <span class="hljs-number">132</span>MB<br> <br># -d 后台运行<br># -name 给容器命名<br># -p 宿主机端口：容器内部端口<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d --name nginx01 -p <span class="hljs-number">3344</span>:<span class="hljs-number">80</span> nginx  # 后台方式启动启动镜像<br>fe9dc33a83294b1b240b1ebb0db9cb16bda880737db2c8a5c0a512fc819850e0<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker ps<br>CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                  NAMES<br>fe9dc33a8329        nginx               &quot;/docker-entrypoint.…&quot;   <span class="hljs-number">4</span> seconds ago       Up <span class="hljs-number">4</span> seconds        <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>:<span class="hljs-number">3344</span>-&gt;<span class="hljs-number">80</span>/tcp   nginx01<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:<span class="hljs-number">3344</span>    # 本地访问测试<br> <br># 进入容器<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker exec -it nginx01 /bin/bash<br><span class="hljs-function">root@fe9dc33a8329:/# <span class="hljs-title">whereis</span> <span class="hljs-title">nginx</span></span><br><span class="hljs-function"><span class="hljs-title">nginx</span>: /<span class="hljs-title">usr</span>/<span class="hljs-title">sbin</span>/<span class="hljs-title">nginx</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">lib</span>/<span class="hljs-title">nginx</span> /<span class="hljs-title">etc</span>/<span class="hljs-title">nginx</span> /<span class="hljs-title">usr</span>/<span class="hljs-title">share</span>/<span class="hljs-title">nginx</span></span><br><span class="hljs-function"><span class="hljs-title">root</span>@<span class="hljs-title">fe9dc33a8329</span>:/# <span class="hljs-title">cd</span> /<span class="hljs-title">etc</span>/<span class="hljs-title">nginx</span>/</span><br><span class="hljs-function"><span class="hljs-title">root</span>@<span class="hljs-title">fe9dc33a8329</span>:/<span class="hljs-title">etc</span>/<span class="hljs-title">nginx</span># <span class="hljs-title">ls</span></span><br><span class="hljs-function"><span class="hljs-title">conf.d</span>      <span class="hljs-title">koi</span>-<span class="hljs-title">utf</span>  <span class="hljs-title">mime.types</span>  <span class="hljs-title">nginx.conf</span>   <span class="hljs-title">uwsgi_params</span></span><br><span class="hljs-function"><span class="hljs-title">fastcgi_params</span>  <span class="hljs-title">koi</span>-<span class="hljs-title">win</span>  <span class="hljs-title">modules</span>     <span class="hljs-title">scgi_params</span>  <span class="hljs-title">win</span>-<span class="hljs-title">utf</span></span><br></code></pre></td></tr></table></figure>



<h3 id="2、安装Tomcat"><a href="#2、安装Tomcat" class="headerlink" title="2、安装Tomcat"></a>2、安装Tomcat</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs CMD"># 官方的使用<br>docker run -it --rm tomcat:<span class="hljs-number">9</span>.<span class="hljs-number">0</span><br> <br># 我们之前的启动都是后台的，停止了容器之后， 容器还是可以查到，docker run -it --rm 一般用来测试，用完就删<br> <br># 下载再启动<br>docker pull tomcat<br> <br># 启动运行<br>docker run -d -p <span class="hljs-number">3344</span>:<span class="hljs-number">8080</span> --name tomcat01 tomcat<br> <br># 测试访问没有问题<br> <br># 进入容器<br>docker exec -it tomcat01 /bin/bash<br> <br># 发现问题：<span class="hljs-number">1</span>.linux命令少了， <span class="hljs-number">2</span>. webapps下内容为空 默认是最小的镜像，所有不必要的都剔除了，保证最小可运行环境即可<br></code></pre></td></tr></table></figure>

<h3 id="3、ES-Kibana"><a href="#3、ES-Kibana" class="headerlink" title="3、ES+Kibana"></a>3、ES+Kibana</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs CMD"># es 暴露的端口很多<br># es 十分的耗内存<br># es 的数据一般需要放置到安全目录！ 挂载<br># --<span class="hljs-built_in">net</span> somenetwork 网络配置<br> <br># 启动elasticsearch<br>docker run -d --name elasticsearch --<span class="hljs-built_in">net</span> somenetwork -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e &quot;discovery.<span class="hljs-built_in">type</span>=single-node&quot; elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br> <br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# docker run -d --name elasticsearch -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e &quot;discovery.<span class="hljs-built_in">type</span>=single-node&quot; elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br>a920894a940b354d3c867079efada13d96cf9138712c76c8dea58fabd9c7e96f<br> <br># 启动了linux就卡主了，docker stats 查看cpu状态<br> <br># 测试一下es成功了<br>[root@iZ2zeg4ytp0whqtmxbsqiiZ home]# curl localhost:<span class="hljs-number">9200</span><br>&#123;<br>  &quot;name&quot; : &quot;a920894a940b&quot;,<br>  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,<br>  &quot;cluster_uuid&quot; : &quot;bxE1TJMEThKgwmk7Aa3fHQ&quot;,<br>  &quot;version&quot; : &#123;<br>    &quot;number&quot; : &quot;<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span>&quot;,<br>    &quot;build_flavor&quot; : &quot;default&quot;,<br>    &quot;build_type&quot; : &quot;docker&quot;,<br>    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,<br>    &quot;build_date&quot; : &quot;<span class="hljs-number">2020</span>-<span class="hljs-number">03</span>-<span class="hljs-number">26</span>T06:<span class="hljs-number">34</span>:<span class="hljs-number">37</span>.<span class="hljs-number">794943</span>Z&quot;,<br>    &quot;build_snapshot&quot; : false,<br>    &quot;lucene_version&quot; : &quot;<span class="hljs-number">8</span>.<span class="hljs-number">4</span>.<span class="hljs-number">0</span>&quot;,<br>    &quot;minimum_wire_compatibility_version&quot; : &quot;<span class="hljs-number">6</span>.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>&quot;,<br>    &quot;minimum_index_compatibility_version&quot; : &quot;<span class="hljs-number">6</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>-beta1&quot;<br>  &#125;,<br>  &quot;tagline&quot; : &quot;You Know, <span class="hljs-keyword">for</span> Search&quot;<br>&#125;<br> <br> <br># 增加内存限制，修改配置文件 -e 环境配置修改<br>docker run -d --name elasticsearch -p <span class="hljs-number">9200</span>:<span class="hljs-number">9200</span> -p <span class="hljs-number">9300</span>:<span class="hljs-number">9300</span> -e &quot;discovery.<span class="hljs-built_in">type</span>=single-node&quot; -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; elasticsearch:<span class="hljs-number">7</span>.<span class="hljs-number">6</span>.<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>



<h2 id="镜像讲解"><a href="#镜像讲解" class="headerlink" title="镜像讲解"></a>镜像讲解</h2><p>​    镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含某个软件所需的所有内容，包括代码、库、环境变量和配合文件。</p>
<p><strong>UnionFS(联合文件系统)</strong></p>
<p>​    UnionFS(联合文件系统):Union文件系统(UnionFS)是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下。</p>
<p>​    UnionFS 文件系统是Docker镜像的基础。镜像可以通过分层来进行继承,基于基础镜像(没有父镜像),可以制作各种具体的应用镜像。</p>
<p><strong>分层理解</strong></p>
<p>​    所有的 Docker镜像都起始于一个基础镜像层,当进行修改或增加新的内容时，就会在当前镜像层之上，创建新的镜像层。举一个简单的例子,假如基于 Ubuntu Linux 16.04创建一个新的镜像,这就是新镜像的第一层;如果在该镜像中添加 Python包就会在基础镜像层之上创建第二个镜像层;如果继续添加一个安全补丁，就会创建第三个镜像层。该镜像当前已经包含3个镜像层，如下图所示(这只是一个用于演示的很简单的例子)。</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20250105214333487.png" alt="image-20250105214333487"></p>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像的顶部!这一层就是我们通常说的容器层，容器之下的都叫镜像层，当我们对启动后的容器继续做什么操作后打包成镜像，相当于在原镜像层的基础上，再堆叠一层。</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20250105214632792.png" alt="image-20250105214632792"></p>
<h2 id="容器数据卷"><a href="#容器数据卷" class="headerlink" title="容器数据卷"></a>容器数据卷</h2><p>问题：mysql作为容器启动产生数据后，容器重启或者关闭怎么办，数据怎么保存</p>
<h3 id="什么是容器数据卷"><a href="#什么是容器数据卷" class="headerlink" title="什么是容器数据卷"></a>什么是容器数据卷</h3><p>​    容器之间可以有一个数据共享的技术，docker容器中产生的数据，同步到本地</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/7845794741e8fbd228c12dd902f13020.png" alt="img"></p>
<h3 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a><strong>使用数据卷</strong></h3><p>方式一：直接使用命令来挂载，-v</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker run -it -v 主机目录:容器目录<br>[root@localhost ~]# docker run -it -v /home/ceshi:/home centos01:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> /bin/bash<br></code></pre></td></tr></table></figure>

<h4 id="实战：安装MySQL"><a href="#实战：安装MySQL" class="headerlink" title="实战：安装MySQL"></a>实战：安装MySQL</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 获取镜像<br># docker pull mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br> <br># 运行容器， 需要做数据挂载！ # 安装启动mysql，需要配置密码（注意）<br># 官方测试， docker run --name some-mysql -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag<br> <br># 启动我们的<br>-d      # 后台运行<br>-p      # 端口隐射<br>-v      # 卷挂载<br>-e      # 环境配置<br>--name  # 容器的名字<br># docker run -d -p <span class="hljs-number">3344</span>:<span class="hljs-number">3306</span> -v /home/mysql/conf:/etc/mysql/conf.d -v /home/mysql/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> --name mysql01 mysql:<span class="hljs-number">5</span>.<span class="hljs-number">7</span><br><br># 启动成功之后，我们在本地使用navicat链接测试一下<br># navicat链接到服务器的<span class="hljs-number">3344</span> --- <span class="hljs-number">3344</span> 和 容器的<span class="hljs-number">3306</span>映射，这个时候我们就可以连接上mysql喽！<br> <br># 在本地测试创建一个数据库，查看下我们的路径是否ok！<br></code></pre></td></tr></table></figure>

<h4 id="具名挂载与匿名挂载"><a href="#具名挂载与匿名挂载" class="headerlink" title="具名挂载与匿名挂载"></a>具名挂载与匿名挂载</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 如何确定是具名挂载还是匿名挂载，还是指定路径挂载<br>-v 容器内路径			 #匿名挂载<br>-v 卷名:容器内路径	   		#具名挂载<br>-v  /宿主机路径:容器内路径	#指定路径挂载<br><br># 通过 -v 容器内路径:ro rw 改变读写权限<br>ro(只读) rw(可读可写)<br># 一旦设置了容器权限，容器对我们挂载出来额内容就有限定了<br>[root@localhost home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:ro nginx<br>[root@localhost home]# docker run -d -P --name nginx02 -v juming-nginx:/etc/nginx:rw nginx<br># ro 只要看到ro就说明这个路径只能通过宿主机来操作，容器内部是无法操作的<br></code></pre></td></tr></table></figure>

<p>所有docker容器内的卷，没有指定目录的情况下都是在<code>/var/lib/docker/volumes/xxxxx/_data</code>我们通过具名挂载可以方便的找到我们的一个卷，大多数情况下使用的是<code>具名挂载</code></p>
<h4 id="多个mysql同步数据"><a href="#多个mysql同步数据" class="headerlink" title="多个mysql同步数据"></a>多个mysql同步数据</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs CMD">[root@localhost /]# docker run -it --name docker01 syw/centos:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br>[root@<span class="hljs-number">9998</span>f8ab8c5a /]# ls<br>bin  etc   lib    lost+found  mnt  proc  run   srv  tmp  var       volume02<br>dev  home  lib64  media       opt  root  sbin  sys  usr  volume01<br>[root@localhost /]# docker run -it --name docker02 --volumes-from docker01 syw/centos:<span class="hljs-number">1</span>.<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>​    关键命令 –volumes-from 只要子容器挂载到父容器上就可以实现容器间的数据互相同步，第三个容器的数据也可以同步到第一、第二个容器中，可以同步多个容器就算删除docker01，docker02依然可以访问这个文件.这是容器间的拷贝的概念</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/ba22affc29feb98f287c6e0fe3d55de8-1736088879639.png" alt="img"></p>
<h2 id="Dockerfile介绍"><a href="#Dockerfile介绍" class="headerlink" title="Dockerfile介绍"></a>Dockerfile介绍</h2><p>​    <strong>dockerfile 就是用来构建docker镜像的构建文件</strong>，命令脚本，使用docker build</p>
<p>简单的Dockerfile例子</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 自己手写一个镜像<br># 创建dockerfile，名字可以随机，建议dockerfile<br># 文件中的内容 指令(大写) 参数<br>[root@localhost docker-test-volume]# cat dockerfile1 <br>FROM centos							#<br>								#这里的每一个命令，就是镜像的一层<br>VOLUME [&quot;/volume01&quot;,&quot;/volume02&quot;]<br><span class="hljs-built_in">CMD</span> <span class="hljs-built_in">echo</span> &quot;----end------&quot;<br><span class="hljs-built_in">CMD</span> /bin/bash<br># 生成镜像，docker build -f 镜像文件 -t 镜像名:[tag] .<br>[root@localhost docker-test-volume]# docker build -f dockerfile1 -t syw/centos:<span class="hljs-number">1</span>.<span class="hljs-number">0</span> .<br>docker images 就能查到刚刚构建的镜像<br></code></pre></td></tr></table></figure>

<h3 id="如何使用dockerfile"><a href="#如何使用dockerfile" class="headerlink" title="如何使用dockerfile"></a><strong>如何使用dockerfile</strong></h3><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">1、编写一个dockerfile文件<br>2、docker build 构建成为一个镜像<br>3、docker run运行镜像<br>4、docker push 发布镜像<br></code></pre></td></tr></table></figure>

<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/0b83310fabe80f5428dea313bb2c5791.png" alt="img"></p>
<h3 id="dockerfile搭建过程"><a href="#dockerfile搭建过程" class="headerlink" title="dockerfile搭建过程"></a><strong>dockerfile搭建过程</strong></h3><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">1、每个保留关键字(指令)都是必须是大写字母<br>2、执行从上到下顺序执行<br>3、#表示注释<br>4、每个指令都会创建提交一个新的镜像层，并提交<br></code></pre></td></tr></table></figure>

<h3 id="Dockerfile基本命令"><a href="#Dockerfile基本命令" class="headerlink" title="Dockerfile基本命令"></a><strong>Dockerfile基本命令</strong></h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">FROM			#基础镜像，一切从这里开始构建<br>MAINTAINER		#镜像是谁写的，姓名+邮箱<br>RUN				#镜像运行的时候需要运行的命令<br>ADD				#步骤，tomcat镜像，这个tomcat压缩包！添加内容<br>WORKDIR			#镜像的工作目录<br>VOLUME			#挂载的目录<br>EXPOSE			#保留端口配置<br><span class="hljs-built_in">CMD</span>				#指定这个容器启动的时候需要运行的命令<br>ENTRYPOINT		#指定这个容器启动的时候需要运行的命令，可以追加命令<br>ONBUILD			#当构建一个被继承dockerfile 这个的时候就会运行ONBUILD的指令<br><span class="hljs-built_in">COPY</span>			#类似ADD，我们文件拷贝到镜像中 <br>ENV				#构建的时候设置环境变量<br></code></pre></td></tr></table></figure>

<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/83e076992ac1c4de38bf3074de7cb686.png" alt="img"></p>
<h4 id="CMD和ENTRYPOINT的区别"><a href="#CMD和ENTRYPOINT的区别" class="headerlink" title="CMD和ENTRYPOINT的区别"></a>CMD和ENTRYPOINT的区别</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-built_in">CMD</span>	#指定这个容器启动的时候需要运行的命令，只有最后一个会生效，可被替代<br>ENTRYPOINT #指定这个容器启动的时候需要运行的命令，可以追加命令<br>一般用ENTRYPOINT结尾<br></code></pre></td></tr></table></figure>

<h4 id="DIY自制Centos镜像"><a href="#DIY自制Centos镜像" class="headerlink" title="DIY自制Centos镜像"></a>DIY自制Centos镜像</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">FROM centos:<span class="hljs-number">7</span><br>MAINTAINER handsome&lt;handsome@<span class="hljs-number">126</span>.com&gt;<br><br>RUN rm -rf /etc/yum.repos.d/CentOS-Base.repo<br>RUN curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="hljs-number">7</span>.repo<br>RUN yum clean all<br>RUN yum makecache<br>ENV MYPATH /usr/local<br>WORKDIR $MYPATH<br>RUN yum -y install vim<br>RUN yum -y install <span class="hljs-built_in">net</span>-tools<br><br>EXPOSE <span class="hljs-number">100</span><br><span class="hljs-built_in">CMD</span> <span class="hljs-built_in">echo</span> $MYPATH<br><span class="hljs-built_in">CMD</span> <span class="hljs-built_in">echo</span> &quot;--------end----------&quot;<br><span class="hljs-built_in">CMD</span> /bin/bash<br></code></pre></td></tr></table></figure>

<h4 id="DIY自制Tomcat镜像"><a href="#DIY自制Tomcat镜像" class="headerlink" title="DIY自制Tomcat镜像"></a>DIY自制Tomcat镜像</h4><p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20250126163106092.png" alt="image-20250126163106092"></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">FROM centos:<span class="hljs-number">7</span><br>ADD jdk-<span class="hljs-number">8</span>u152-linux-x64.tar.gz /usr/local<br>ADD apache-tomcat-<span class="hljs-number">9</span>.<span class="hljs-number">0</span>.<span class="hljs-number">98</span>.tar.gz /usr/local<br><br>RUN rm -rf /etc/yum.repos.d/CentOS-Base.repo<br>RUN curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-<span class="hljs-number">7</span>.repo<br>RUN yum clean all<br>RUN yum makecache<br>RUN yum -y install <span class="hljs-built_in">net</span>-tools<br><br><br><br>ENV MYPATH /usr/local<br>WORKDIR $MYPATH<br><br>ENV JAVA_HOME /usr/local/jdk1.<span class="hljs-number">8</span>.<span class="hljs-number">0</span>_152<br>ENV CLASSPATH $JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar<br>ENV CATALINA_HOME /usr/local/apache-tomcat-<span class="hljs-number">9</span>.<span class="hljs-number">0</span>.<span class="hljs-number">98</span><br>ENV <span class="hljs-built_in">PATH</span> $<span class="hljs-built_in">PATH</span>:$JAVA_HOME/bin:$CATALINA_HOME/lib #设置环境变量 分隔符是：<br>EXPOSE <span class="hljs-number">8080</span><br><span class="hljs-built_in">CMD</span> /usr/local/apache-tomcat-<span class="hljs-number">9</span>.<span class="hljs-number">0</span>.<span class="hljs-number">98</span>/bin/startup.sh &amp;&amp; tail -F /usr/local/apache-tomcat-<span class="hljs-number">9</span>.<span class="hljs-number">0</span>.<span class="hljs-number">98</span>/logs/catalina.out # 设置默认命令<br></code></pre></td></tr></table></figure>

<h3 id="SpringBoot微服务打包Docker镜像"><a href="#SpringBoot微服务打包Docker镜像" class="headerlink" title="SpringBoot微服务打包Docker镜像"></a>SpringBoot微服务打包Docker镜像</h3><p>1、定义controller</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController(&quot;/test&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br>    <span class="hljs-meta">@GetMapping(&quot;/aaa&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">aaa</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;bbb&quot;</span>;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>pom.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.example<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dockerfile-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.5.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">project.build.sourceEncoding</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">excludes</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">exclude</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">exclude</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">excludes</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2、定义Dockerfile</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">FROM openjdk:<span class="hljs-number">8</span><br>COPY *.jar /app.jar<br>CMD [<span class="hljs-string">&quot;--server.port=8080&quot;</span>]<br>EXPOSE <span class="hljs-number">8080</span><br>ENTRYPOINT [<span class="hljs-string">&quot;java&quot;</span>,<span class="hljs-string">&quot;-jar&quot;</span>,<span class="hljs-string">&quot;/app.jar&quot;</span>]<br></code></pre></td></tr></table></figure>

<p>3、上传到linux</p>
<p>4、构建镜像</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">[root@localhost Dockerfiletest]# ll<br>总用量 <span class="hljs-number">8</span><br>-rw-r--r--. <span class="hljs-number">1</span> root root  <span class="hljs-number">112</span> <span class="hljs-number">1</span>月  <span class="hljs-number">23</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span> Dockerfile<br>-rw-r--r--. <span class="hljs-number">1</span> root root <span class="hljs-number">2892</span> <span class="hljs-number">1</span>月  <span class="hljs-number">23</span> <span class="hljs-number">22</span>:<span class="hljs-number">14</span> dockerfile-test-<span class="hljs-number">1</span>.<span class="hljs-number">0</span>-SNAPSHOT.jar<br>[root@localhost Dockerfiletest]# docker build -t testdockerfile .<br>[root@localhost Dockerfiletest]# docker images<br>REPOSITORY                                          TAG                IMAGE ID       CREATED              SIZE<br>testdockerfile                                      latest             f584d98b0712   About a minute ago   <span class="hljs-number">526</span>MB<br></code></pre></td></tr></table></figure>

<p>5、启动容器</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker run -d -p <span class="hljs-number">8080</span>:<span class="hljs-number">8080</span> --name testdockerfile testdockerfile<br></code></pre></td></tr></table></figure>

<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20250123230935986.png" alt="image-20250123230935986"></p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/870f7f09e9c11aae5b84dd43427b07eb.png" alt="img"></p>
<h2 id="Docker网络"><a href="#Docker网络" class="headerlink" title="Docker网络"></a>Docker网络</h2><p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20250106222458708.png" alt="image-20250106222458708"></p>
<p>如上所示，只要装了docker，就会给本机新增一个docker0的网卡。</p>
<p><strong>容器内网络情况</strong></p>
<p><strong>思考： 宿主机能不能ping通容器？</strong>可以相互ping</p>
<p><strong>原理</strong>:我们每启动一个docker容器， docker就会给docker容器分配一个ip， 我们只要安装了docker，就会有一个网卡 docker0桥接模式，使用的技术是veth-pair技术！</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs CMD"># 我们发现这个容器带来的网卡都是一对对的，<br># evth-pair 就是一对虚拟设备接口，它们都是成对出现的，一段连着协议，一段彼此相连<br># 正因为这个特性，evth-pair充当一个桥梁，连接各种虚拟网络设备<br># OpenStack，docker容器间的连接，OVS的连接，都是使用evth-pair 技术<br></code></pre></td></tr></table></figure>

<p><strong>思考：tomcat01、tomcat02 是否可以ping通？</strong>可以</p>
<p>结论：tomcat01和tomcat02是共用一个路由器，docker0</p>
<p>所有容器不指定网络的情况下，都是docker0来路由的，docker会给我们的容器分配一个默认的可用ip，因此tomcat01可以ping通tomcat02</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/980b9291e0e0e0bb7763f029ad85a15c.png" alt="img"></p>
<p>Docker使用的是linux的桥接，宿主机是一个docker容器的网桥</p>
<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/50740c6a04ef55769fe50513b9babb1a.png" alt="img"></p>
<h3 id="link（不适用当前）"><a href="#link（不适用当前）" class="headerlink" title="link（不适用当前）"></a>link（不适用当前）</h3><p>思考一个场景，我们编写了一个微服务，database url=ip: ,项目不重启，数据库ip换掉，我们希望可以处理这个问题，可以名字来进行访问容器。不用网络地址可以ping通</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">[root@localhost ~]# docker exec -it tomcat01 <span class="hljs-built_in">ping</span> tomcat02<br><span class="hljs-function">ping: <span class="hljs-title">tomcat02</span>: <span class="hljs-title">Name</span> <span class="hljs-title">or</span> <span class="hljs-title">service</span> <span class="hljs-title">not</span> <span class="hljs-title">known</span></span><br></code></pre></td></tr></table></figure>

<p>如何解决这个问题？</p>
<p><strong>添加了–link 实现容器名ping通，不需要通过网路ip</strong></p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">[root@localhost ~]# docker run -d -P --name tomcat03 --link tomcat02 tomcat<br>[root@localhost ~]# docker exec -it tomcat03 <span class="hljs-built_in">ping</span> tomcat02<br><span class="hljs-number">64</span> bytes from tomcat02 (<span class="hljs-number">172</span>.<span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>): icmp_seq=<span class="hljs-number">74</span> ttl=<span class="hljs-number">64</span> <span class="hljs-built_in">time</span>=<span class="hljs-number">0</span>.<span class="hljs-number">134</span> ms<br><span class="hljs-number">64</span> bytes from tomcat02 (<span class="hljs-number">172</span>.<span class="hljs-number">17</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>): icmp_seq=<span class="hljs-number">75</span> ttl=<span class="hljs-number">64</span> <span class="hljs-built_in">time</span>=<span class="hljs-number">0</span>.<span class="hljs-number">156</span> ms<br># 反向不能<span class="hljs-built_in">ping</span>通<br></code></pre></td></tr></table></figure>

<p>–link就是我们在hosts配置中增加了一个 172.17.0.3 tomcat02 容器id 这种格式的host配置，但是这样写的太死了，不可持续，难以维护。</p>
<h3 id="自定义网络"><a href="#自定义网络" class="headerlink" title="自定义网络"></a>自定义网络</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">查看所有的docker网络<br>[root@localhost ~]# docker network ls<br>NETWORK ID     NAME              DRIVER    SCOPE<br>cd0629f7a781   bridge            bridge    local<br>c797f67cfda9   flink_default     bridge    local<br><span class="hljs-number">83848</span>de4da79   graylog_graylog   bridge    local<br><span class="hljs-number">0</span>d408d098017   host              host      local<br><span class="hljs-number">345</span>eb395330e   kafka_default     bridge    local<br><span class="hljs-number">6591455</span>a2f45   none              null      local<br></code></pre></td></tr></table></figure>

<p><strong>网络模式</strong></p>
<p>bridge：桥接docker （默认，自己创建的网络也是用bridge 模式）</p>
<p>none：不配置网络</p>
<p>host：和宿主机共享网络</p>
<p>container：容器网络连通（用的少，局限很大）</p>
<p>我们默认启动时其实就是默认 –net bridge，默认使用桥接的docker0这个网络</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 我们直接启动命令，--<span class="hljs-built_in">net</span> bridge,而这个就是我们的docker0<br>docker run -d -P --name tomcat01 tomcat <br>docker run -d -P --name tomcat01 --<span class="hljs-built_in">net</span> bridge tomcat		#等同于上一个命令<br></code></pre></td></tr></table></figure>

<h4 id="自定义网络-1"><a href="#自定义网络-1" class="headerlink" title="自定义网络"></a><strong>自定义网络</strong></h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">docker network create mynetwork --driver bridge --subnet <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/<span class="hljs-number">16</span> --gateway <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br>mynetwork是网络名<br>--driver bridge 是网络模式<br>--subnet <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/<span class="hljs-number">16</span> 子网是<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span> 前<span class="hljs-number">16</span>位是网络号，后<span class="hljs-number">16</span>位是主机号<br>--gateway <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span> 网关是<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span><br><br><br>#查看刚刚自定义的网络<br>[root@localhost ~]# docker network list<br>NETWORK ID     NAME              DRIVER    SCOPE<br>cd0629f7a781   bridge            bridge    local<br>c797f67cfda9   flink_default     bridge    local<br><span class="hljs-number">83848</span>de4da79   graylog_graylog   bridge    local<br><span class="hljs-number">0</span>d408d098017   host              host      local<br><span class="hljs-number">345</span>eb395330e   kafka_default     bridge    local<br><span class="hljs-number">6</span>cea02844ca7   mynetwork         bridge    local<br><span class="hljs-number">6591455</span>a2f45   none              null      local<br><br>#启动容器并绑定到自定义的网络<br>docker rm -f $(docker ps -aq)<br>docker run -d -p <span class="hljs-number">3344</span>:<span class="hljs-number">8080</span> --name tomcat01 --network mynetwork tomcat<br>docker run -d -p <span class="hljs-number">3345</span>:<span class="hljs-number">8080</span> --name tomcat02 --network mynetwork tomcat<br>[root@localhost ~]# docker network inspect mynetwork<br>[<br>    &#123;<br>        &quot;Name&quot;: &quot;mynetwork&quot;,<br>        &quot;Id&quot;: &quot;<span class="hljs-number">6</span>cea02844ca734056bc69f14e79fdce871d2b7f610a402d259345f7dcf294daf&quot;,<br>        &quot;Created&quot;: &quot;<span class="hljs-number">2025</span>-<span class="hljs-number">01</span>-<span class="hljs-number">21</span>T22:<span class="hljs-number">07</span>:<span class="hljs-number">18</span>.<span class="hljs-number">289053597</span>+<span class="hljs-number">08</span>:<span class="hljs-number">00</span>&quot;,<br>        &quot;Scope&quot;: &quot;local&quot;,<br>        &quot;Driver&quot;: &quot;bridge&quot;,<br>        &quot;EnableIPv6&quot;: false,<br>        &quot;IPAM&quot;: &#123;<br>            &quot;Driver&quot;: &quot;default&quot;,<br>            &quot;Options&quot;: &#123;&#125;,<br>            &quot;Config&quot;: [<br>                &#123;<br>                    &quot;Subnet&quot;: &quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>/<span class="hljs-number">16</span>&quot;,<br>                    &quot;Gateway&quot;: &quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>&quot;<br>                &#125;<br>            ]<br>        &#125;,<br>        &quot;Internal&quot;: false,<br>        &quot;Attachable&quot;: false,<br>        &quot;Ingress&quot;: false,<br>        &quot;ConfigFrom&quot;: &#123;<br>            &quot;Network&quot;: &quot;&quot;<br>        &#125;,<br>        &quot;ConfigOnly&quot;: false,<br>        &quot;Containers&quot;: &#123;<br>            &quot;<span class="hljs-number">567797</span>a34578a54334a6bb4ac39cf2fc06fc9a322b3cfb49d7956f5b04da73a8&quot;: &#123;<br>                &quot;Name&quot;: &quot;tomcat01&quot;,<br>                &quot;EndpointID&quot;: &quot;<span class="hljs-number">0</span>e85ead22dc53f01ed2fdae970d740a5811e7f6d5a51575a6c69f2514b879c1e&quot;,<br>                &quot;MacAddress&quot;: &quot;<span class="hljs-number">02</span>:<span class="hljs-number">42</span>:c0:a8:<span class="hljs-number">00</span>:<span class="hljs-number">02</span>&quot;,<br>                &quot;IPv4Address&quot;: &quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">2</span>/<span class="hljs-number">16</span>&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;,<br>            &quot;a69aeaa3bfef9e7a17b6b77538a1b9e8b9d5d67f457f1181194c3213e0ea46ab&quot;: &#123;<br>                &quot;Name&quot;: &quot;tomcat02&quot;,<br>                &quot;EndpointID&quot;: &quot;<span class="hljs-number">1</span>b45e31f53e87aed935068e6761b35488d1164f2ac9d7f45942d7f551dc427d4&quot;,<br>                &quot;MacAddress&quot;: &quot;<span class="hljs-number">02</span>:<span class="hljs-number">42</span>:c0:a8:<span class="hljs-number">00</span>:<span class="hljs-number">03</span>&quot;,<br>                &quot;IPv4Address&quot;: &quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>/<span class="hljs-number">16</span>&quot;,<br>                &quot;IPv6Address&quot;: &quot;&quot;<br>            &#125;<br>        &#125;,<br>        &quot;Options&quot;: &#123;&#125;,<br>        &quot;Labels&quot;: &#123;&#125;<br>    &#125;<br>]<br><br># 不使用--link都可以<span class="hljs-built_in">ping</span>通<br>[root@localhost ~]# docker exec -it tomcat-<span class="hljs-built_in">net</span>-<span class="hljs-number">01</span> <span class="hljs-built_in">ping</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><br>[root@localhost ~]# docker exec -it tomcat-<span class="hljs-built_in">net</span>-<span class="hljs-number">01</span> <span class="hljs-built_in">ping</span> tomcat-<span class="hljs-built_in">net</span>-<span class="hljs-number">02</span><br><br></code></pre></td></tr></table></figure>

<h4 id="网络连接"><a href="#网络连接" class="headerlink" title="网络连接"></a>网络连接</h4><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">[root@localhost ~]# docker network connect --<span class="hljs-built_in">help</span><br><br><span class="hljs-function">Usage:  <span class="hljs-title">docker</span> <span class="hljs-title">network</span> <span class="hljs-title">connect</span> [<span class="hljs-title">OPTIONS</span>] <span class="hljs-title">NETWORK</span> <span class="hljs-title">CONTAINER</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Connect</span> <span class="hljs-title">a</span> <span class="hljs-title">container</span> <span class="hljs-title">to</span> <span class="hljs-title">a</span> <span class="hljs-title">network</span></span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-title">Options</span>:</span><br><span class="hljs-function">      --<span class="hljs-title">alias</span> <span class="hljs-title">strings</span>           <span class="hljs-title">Add</span> <span class="hljs-title">network</span>-<span class="hljs-title">scoped</span> <span class="hljs-title">alias</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">container</span></span><br><span class="hljs-function">      --<span class="hljs-title">driver</span>-<span class="hljs-title">opt</span> <span class="hljs-title">strings</span>      <span class="hljs-title">driver</span> <span class="hljs-title">options</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">network</span></span><br><span class="hljs-function">      --<span class="hljs-title">ip</span> <span class="hljs-title">string</span>               <span class="hljs-title">IPv4</span> <span class="hljs-title">address</span> (<span class="hljs-title">e.g</span>., &quot;172.30.100.104&quot;)</span><br><span class="hljs-function">      --<span class="hljs-title">ip6</span> <span class="hljs-title">string</span>              <span class="hljs-title">IPv6</span> <span class="hljs-title">address</span> (<span class="hljs-title">e.g</span>., &quot;2001:<span class="hljs-title">db8</span>::33&quot;)</span><br><span class="hljs-function">      --<span class="hljs-title">link</span> <span class="hljs-title">list</span>               <span class="hljs-title">Add</span> <span class="hljs-title">link</span> <span class="hljs-title">to</span> <span class="hljs-title">another</span> <span class="hljs-title">container</span></span><br><span class="hljs-function">      --<span class="hljs-title">link</span>-<span class="hljs-title">local</span>-<span class="hljs-title">ip</span> <span class="hljs-title">strings</span>   <span class="hljs-title">Add</span> <span class="hljs-title">a</span> <span class="hljs-title">link</span>-<span class="hljs-title">local</span> <span class="hljs-title">address</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">container</span></span><br><span class="hljs-function"></span><br><span class="hljs-function">[<span class="hljs-title">root</span>@<span class="hljs-title">localhost</span> ~]# <span class="hljs-title">docker</span> <span class="hljs-title">run</span> -<span class="hljs-title">d</span> -<span class="hljs-title">p</span> 3346:8080 --<span class="hljs-title">name</span> <span class="hljs-title">tomcat03</span> <span class="hljs-title">tomcat</span></span><br><span class="hljs-function"># 连接<span class="hljs-title">tomcat03</span> 到自定义网络 <span class="hljs-title">mynetwork</span> </span><br><span class="hljs-function">[<span class="hljs-title">root</span>@<span class="hljs-title">localhost</span> ~]# <span class="hljs-title">docker</span> <span class="hljs-title">network</span> <span class="hljs-title">connect</span> <span class="hljs-title">mynetwork</span> <span class="hljs-title">tomcat03</span></span><br><span class="hljs-function">[<span class="hljs-title">root</span>@<span class="hljs-title">localhost</span> ~]# <span class="hljs-title">docker</span> <span class="hljs-title">inspect</span> <span class="hljs-title">network</span> <span class="hljs-title">mynetwork</span></span><br><span class="hljs-function">[</span><br><span class="hljs-function">    &#123;</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Name</span>&quot;: &quot;<span class="hljs-title">mynetwork</span>&quot;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Id</span>&quot;: &quot;6<span class="hljs-title">cea02844ca734056bc69f14e79fdce871d2b7f610a402d259345f7dcf294daf</span>&quot;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Created</span>&quot;: &quot;2025-01-21<span class="hljs-title">T22</span>:07:18.289053597+08:00&quot;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Scope</span>&quot;: &quot;<span class="hljs-title">local</span>&quot;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Driver</span>&quot;: &quot;<span class="hljs-title">bridge</span>&quot;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">EnableIPv6</span>&quot;: <span class="hljs-title">false</span>,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">IPAM</span>&quot;: &#123;</span><br><span class="hljs-function">            &quot;<span class="hljs-title">Driver</span>&quot;: &quot;<span class="hljs-title">default</span>&quot;,</span><br><span class="hljs-function">            &quot;<span class="hljs-title">Options</span>&quot;: &#123;&#125;,</span><br><span class="hljs-function">            &quot;<span class="hljs-title">Config</span>&quot;: [</span><br><span class="hljs-function">                &#123;</span><br><span class="hljs-function">                    &quot;<span class="hljs-title">Subnet</span>&quot;: &quot;192.168.0.0/16&quot;,</span><br><span class="hljs-function">                    &quot;<span class="hljs-title">Gateway</span>&quot;: &quot;192.168.0.1&quot;</span><br><span class="hljs-function">                &#125;</span><br><span class="hljs-function">            ]</span><br><span class="hljs-function">        &#125;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Internal</span>&quot;: <span class="hljs-title">false</span>,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Attachable</span>&quot;: <span class="hljs-title">false</span>,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Ingress</span>&quot;: <span class="hljs-title">false</span>,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">ConfigFrom</span>&quot;: &#123;</span><br><span class="hljs-function">            &quot;<span class="hljs-title">Network</span>&quot;: &quot;&quot;</span><br><span class="hljs-function">        &#125;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">ConfigOnly</span>&quot;: <span class="hljs-title">false</span>,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Containers</span>&quot;: &#123;</span><br><span class="hljs-function">            &quot;1<span class="hljs-title">f85ca4a00dbf7d502ae16564d9694830c5fcff782e2afe3f28590915b8ed789</span>&quot;: &#123;</span><br><span class="hljs-function">                &quot;<span class="hljs-title">Name</span>&quot;: &quot;<span class="hljs-title">tomcat03</span>&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">EndpointID</span>&quot;: &quot;<span class="hljs-title">e44f71b65dc14944103448e094dfe4e085cd070495eb006c4cd848e78fa8d10a</span>&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">MacAddress</span>&quot;: &quot;02:42:<span class="hljs-title">c0:a8</span>:00:04&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">IPv4Address</span>&quot;: &quot;192.168.0.4/16&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">IPv6Address</span>&quot;: &quot;&quot;</span><br><span class="hljs-function">            &#125;,</span><br><span class="hljs-function">            &quot;567797<span class="hljs-title">a34578a54334a6bb4ac39cf2fc06fc9a322b3cfb49d7956f5b04da73a8</span>&quot;: &#123;</span><br><span class="hljs-function">                &quot;<span class="hljs-title">Name</span>&quot;: &quot;<span class="hljs-title">tomcat01</span>&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">EndpointID</span>&quot;: &quot;0<span class="hljs-title">e85ead22dc53f01ed2fdae970d740a5811e7f6d5a51575a6c69f2514b879c1e</span>&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">MacAddress</span>&quot;: &quot;02:42:<span class="hljs-title">c0:a8</span>:00:02&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">IPv4Address</span>&quot;: &quot;192.168.0.2/16&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">IPv6Address</span>&quot;: &quot;&quot;</span><br><span class="hljs-function">            &#125;,</span><br><span class="hljs-function">            &quot;<span class="hljs-title">a69aeaa3bfef9e7a17b6b77538a1b9e8b9d5d67f457f1181194c3213e0ea46ab</span>&quot;: &#123;</span><br><span class="hljs-function">                &quot;<span class="hljs-title">Name</span>&quot;: &quot;<span class="hljs-title">tomcat02</span>&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">EndpointID</span>&quot;: &quot;1<span class="hljs-title">b45e31f53e87aed935068e6761b35488d1164f2ac9d7f45942d7f551dc427d4</span>&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">MacAddress</span>&quot;: &quot;02:42:<span class="hljs-title">c0:a8</span>:00:03&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">IPv4Address</span>&quot;: &quot;192.168.0.3/16&quot;,</span><br><span class="hljs-function">                &quot;<span class="hljs-title">IPv6Address</span>&quot;: &quot;&quot;</span><br><span class="hljs-function">            &#125;</span><br><span class="hljs-function">        &#125;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Options</span>&quot;: &#123;&#125;,</span><br><span class="hljs-function">        &quot;<span class="hljs-title">Labels</span>&quot;: &#123;&#125;</span><br><span class="hljs-function">    &#125;</span><br><span class="hljs-function">]</span><br><span class="hljs-function"># 实现了跨网段用名称进行通信--这样就能<span class="hljs-title">ping</span>通了</span><br><span class="hljs-function">[<span class="hljs-title">root</span>@<span class="hljs-title">localhost</span> ~]# <span class="hljs-title">docker</span> <span class="hljs-title">exec</span> -<span class="hljs-title">it</span> <span class="hljs-title">tomcat01</span> <span class="hljs-title">ping</span> <span class="hljs-title">tomcat</span>-<span class="hljs-title">net</span>-01</span><br></code></pre></td></tr></table></figure>

<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><p>我们自定义的网络docker都已经帮我们维护好了对应的关系，推荐我们平时这样使用网络</p>
<p>好处：</p>
<p>Redis- 不同的集群使用不同的网络，保证集群是安全和健康的</p>
<p>mysql- 不同的集群使用不同的网络，保证集群是安全和健康的</p>
<h3 id="实战：部署Redis集群"><a href="#实战：部署Redis集群" class="headerlink" title="实战：部署Redis集群"></a>实战：部署Redis集群</h3><p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/43709643b2d36ce19323f02b1bf484b0.png" alt="img"></p>
<p>测试六台服务器的集群，r-m3宕机，r-s3替补</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 通过脚本创建六个redis配置<br><span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> $(seq <span class="hljs-number">1</span> <span class="hljs-number">6</span>); \<br><span class="hljs-keyword">do</span> \<br><span class="hljs-built_in">mkdir</span> -p /mydata/redis/node-$&#123;port&#125;/conf<br>touch /mydata/redis/node-$&#123;port&#125;/conf/redis.conf<br>cat &lt;&lt; EOF &gt;/mydata/redis/node-$&#123;port&#125;/conf/redis.conf<br>port <span class="hljs-number">6379</span><br>bind <span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span><br>cluster-enabled yes<br>cluster-config-file nodes.conf<br>cluster-node-timeout <span class="hljs-number">5000</span><br>cluster-announce-ip <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>$&#123;port&#125;<br>cluster-announce-port <span class="hljs-number">6379</span><br>cluster-announce-bus-port <span class="hljs-number">16379</span><br>appendonly yes<br>EOF<br>done <br><br># 创建结点<br><span class="hljs-keyword">for</span> port <span class="hljs-keyword">in</span> $(seq <span class="hljs-number">1</span> <span class="hljs-number">6</span>); \<br><span class="hljs-keyword">do</span> \<br>docker run -p <span class="hljs-number">637</span>$&#123;port&#125;:<span class="hljs-number">6379</span> -p <span class="hljs-number">1637</span>$&#123;port&#125;:<span class="hljs-number">16379</span> --name redis-$&#123;port&#125; \<br>-v /mydata/redis/node-$&#123;port&#125;/data:/data \<br>-v /mydata/redis/node-$&#123;port&#125;/conf/redis.conf:/etc/redis/redis.conf \<br>-d --<span class="hljs-built_in">net</span> redis --ip <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>$&#123;port&#125; redis:<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">9</span>-alpine3.<span class="hljs-number">11</span> redis-server /etc/redis/redis.conf<br><br>done <br><br>[root@localhost ~]# docker exec -it redis-<span class="hljs-number">1</span> /bin/sh<br>/data # redis-cli --cluster create <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">11</span>:<span class="hljs-number">6379</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span>:<span class="hljs-number">6379</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">13</span>:<span class="hljs-number">6379</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">14</span>:<span class="hljs-number">6379</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>:<span class="hljs-number">6379</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">16</span>:<span class="hljs-number">6379</span><br> --cluster-replicas <span class="hljs-number">1</span><br>&gt;&gt;&gt; Performing hash slots allocation on <span class="hljs-number">6</span> nodes...<br>Master[<span class="hljs-number">0</span>] -&gt; Slots <span class="hljs-number">0</span> - <span class="hljs-number">5460</span><br>Master[<span class="hljs-number">1</span>] -&gt; Slots <span class="hljs-number">5461</span> - <span class="hljs-number">10922</span><br>Master[<span class="hljs-number">2</span>] -&gt; Slots <span class="hljs-number">10923</span> - <span class="hljs-number">16383</span><br>Adding replica <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>:<span class="hljs-number">6379</span> to <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">11</span>:<span class="hljs-number">6379</span><br>Adding replica <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">16</span>:<span class="hljs-number">6379</span> to <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span>:<span class="hljs-number">6379</span><br>Adding replica <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">14</span>:<span class="hljs-number">6379</span> to <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">13</span>:<span class="hljs-number">6379</span><br><span class="hljs-function">M: 259<span class="hljs-title">ef84d4826a362bdc73ad25345513c9ebf9447</span> 172.38.0.11:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>:[0-5460] (5461 <span class="hljs-title">slots</span>) <span class="hljs-title">master</span></span><br><span class="hljs-function"><span class="hljs-title">M</span>: 911<span class="hljs-title">abefbfae1d70df6d76003c361f25878ce0e77</span> 172.38.0.12:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>:[5461-10922] (5462 <span class="hljs-title">slots</span>) <span class="hljs-title">master</span></span><br><span class="hljs-function"><span class="hljs-title">M</span>: 5<span class="hljs-title">bec694e52aa2bae43dc2755e325e1b0aaf87552</span> 172.38.0.13:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>:[10923-16383] (5461 <span class="hljs-title">slots</span>) <span class="hljs-title">master</span></span><br><span class="hljs-function"><span class="hljs-title">S</span>: <span class="hljs-title">e240a6400ca97fc7de11d9d356e88bcc51515508</span> 172.38.0.14:6379</span><br><span class="hljs-function">   <span class="hljs-title">replicates</span> 5<span class="hljs-title">bec694e52aa2bae43dc2755e325e1b0aaf87552</span></span><br><span class="hljs-function"><span class="hljs-title">S</span>: <span class="hljs-title">fd596021d140108df6dda7f2cbcf76261e7aa74f</span> 172.38.0.15:6379</span><br><span class="hljs-function">   <span class="hljs-title">replicates</span> 259<span class="hljs-title">ef84d4826a362bdc73ad25345513c9ebf9447</span></span><br><span class="hljs-function"><span class="hljs-title">S</span>: <span class="hljs-title">fcd076bcd8314f935c1d1b99c47bf5a7b444e443</span> 172.38.0.16:6379</span><br><span class="hljs-function">   <span class="hljs-title">replicates</span> 911<span class="hljs-title">abefbfae1d70df6d76003c361f25878ce0e77</span></span><br><span class="hljs-function"><span class="hljs-title">Can</span> <span class="hljs-title">I</span> <span class="hljs-title">set</span> <span class="hljs-title">the</span> <span class="hljs-title">above</span> <span class="hljs-title">configuration</span>? (<span class="hljs-title">type</span> &#x27;<span class="hljs-title">yes</span>&#x27; <span class="hljs-title">to</span> <span class="hljs-title">accept</span>): <span class="hljs-title">yes</span></span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">Nodes</span> <span class="hljs-title">configuration</span> <span class="hljs-title">updated</span></span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">Assign</span> <span class="hljs-title">a</span> <span class="hljs-title">different</span> <span class="hljs-title">config</span> <span class="hljs-title">epoch</span> <span class="hljs-title">to</span> <span class="hljs-title">each</span> <span class="hljs-title">node</span></span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">Sending</span> <span class="hljs-title">CLUSTER</span> <span class="hljs-title">MEET</span> <span class="hljs-title">messages</span> <span class="hljs-title">to</span> <span class="hljs-title">join</span> <span class="hljs-title">the</span> <span class="hljs-title">cluster</span></span><br><span class="hljs-function"><span class="hljs-title">Waiting</span> <span class="hljs-title">for</span> <span class="hljs-title">the</span> <span class="hljs-title">cluster</span> <span class="hljs-title">to</span> <span class="hljs-title">join</span></span><br><span class="hljs-function">...</span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">Performing</span> <span class="hljs-title">Cluster</span> <span class="hljs-title">Check</span> (<span class="hljs-title">using</span> <span class="hljs-title">node</span> 172.38.0.11:6379)</span><br><span class="hljs-function"><span class="hljs-title">M</span>: 259<span class="hljs-title">ef84d4826a362bdc73ad25345513c9ebf9447</span> 172.38.0.11:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>:[0-5460] (5461 <span class="hljs-title">slots</span>) <span class="hljs-title">master</span></span><br><span class="hljs-function">   1 <span class="hljs-title">additional</span> <span class="hljs-title">replica</span>(<span class="hljs-title">s</span>)</span><br><span class="hljs-function"><span class="hljs-title">M</span>: 911<span class="hljs-title">abefbfae1d70df6d76003c361f25878ce0e77</span> 172.38.0.12:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>:[5461-10922] (5462 <span class="hljs-title">slots</span>) <span class="hljs-title">master</span></span><br><span class="hljs-function">   1 <span class="hljs-title">additional</span> <span class="hljs-title">replica</span>(<span class="hljs-title">s</span>)</span><br><span class="hljs-function"><span class="hljs-title">S</span>: <span class="hljs-title">fcd076bcd8314f935c1d1b99c47bf5a7b444e443</span> 172.38.0.16:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>: (0 <span class="hljs-title">slots</span>) <span class="hljs-title">slave</span></span><br><span class="hljs-function">   <span class="hljs-title">replicates</span> 911<span class="hljs-title">abefbfae1d70df6d76003c361f25878ce0e77</span></span><br><span class="hljs-function"><span class="hljs-title">S</span>: <span class="hljs-title">fd596021d140108df6dda7f2cbcf76261e7aa74f</span> 172.38.0.15:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>: (0 <span class="hljs-title">slots</span>) <span class="hljs-title">slave</span></span><br><span class="hljs-function">   <span class="hljs-title">replicates</span> 259<span class="hljs-title">ef84d4826a362bdc73ad25345513c9ebf9447</span></span><br><span class="hljs-function"><span class="hljs-title">S</span>: <span class="hljs-title">e240a6400ca97fc7de11d9d356e88bcc51515508</span> 172.38.0.14:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>: (0 <span class="hljs-title">slots</span>) <span class="hljs-title">slave</span></span><br><span class="hljs-function">   <span class="hljs-title">replicates</span> 5<span class="hljs-title">bec694e52aa2bae43dc2755e325e1b0aaf87552</span></span><br><span class="hljs-function"><span class="hljs-title">M</span>: 5<span class="hljs-title">bec694e52aa2bae43dc2755e325e1b0aaf87552</span> 172.38.0.13:6379</span><br><span class="hljs-function">   <span class="hljs-title">slots</span>:[10923-16383] (5461 <span class="hljs-title">slots</span>) <span class="hljs-title">master</span></span><br><span class="hljs-function">   1 <span class="hljs-title">additional</span> <span class="hljs-title">replica</span>(<span class="hljs-title">s</span>)</span><br><span class="hljs-function">[<span class="hljs-title">OK</span>] <span class="hljs-title">All</span> <span class="hljs-title">nodes</span> <span class="hljs-title">agree</span> <span class="hljs-title">about</span> <span class="hljs-title">slots</span> <span class="hljs-title">configuration</span>.</span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">Check</span> <span class="hljs-title">for</span> <span class="hljs-title">open</span> <span class="hljs-title">slots</span>...</span><br><span class="hljs-function">&gt;&gt;&gt; <span class="hljs-title">Check</span> <span class="hljs-title">slots</span> <span class="hljs-title">coverage</span>...</span><br><span class="hljs-function">[<span class="hljs-title">OK</span>] <span class="hljs-title">All</span> 16384 <span class="hljs-title">slots</span> <span class="hljs-title">covered</span>.</span><br><span class="hljs-function"></span><br><span class="hljs-function">#至此<span class="hljs-title">docker</span>搭建<span class="hljs-title">redis</span>集群完成！</span><br><span class="hljs-function"></span><br></code></pre></td></tr></table></figure>

<p>测试节点宕机，从节点提供服务</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">#进入redis-<span class="hljs-number">1</span><br>[root@localhost ~]# docker exec -it redis-<span class="hljs-number">1</span><br>#查看集群信息<br><span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">11</span>:<span class="hljs-number">6379</span>&gt; cluster nodes<br><span class="hljs-number">259</span>ef84d4826a362bdc73ad25345513c9ebf9447 <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">11</span>:<span class="hljs-number">6379</span>@<span class="hljs-number">16379</span> myself,master - <span class="hljs-number">0</span> <span class="hljs-number">1737557695000</span> <span class="hljs-number">1</span> connected <span class="hljs-number">0</span>-<span class="hljs-number">5460</span><br><span class="hljs-number">911</span>abefbfae1d70df6d76003c361f25878ce0e77 <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">12</span>:<span class="hljs-number">6379</span>@<span class="hljs-number">16379</span> slave fcd076bcd8314f935c1d1b99c47bf5a7b444e443 <span class="hljs-number">0</span> <span class="hljs-number">1737557695528</span> <span class="hljs-number">7</span> connected<br>fcd076bcd8314f935c1d1b99c47bf5a7b444e443 <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">16</span>:<span class="hljs-number">6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1737557695000</span> <span class="hljs-number">7</span> connected <span class="hljs-number">5461</span>-<span class="hljs-number">10922</span><br>fd596021d140108df6dda7f2cbcf76261e7aa74f <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>:<span class="hljs-number">6379</span>@<span class="hljs-number">16379</span> slave <span class="hljs-number">259</span>ef84d4826a362bdc73ad25345513c9ebf9447 <span class="hljs-number">0</span> <span class="hljs-number">1737557694514</span> <span class="hljs-number">5</span> connected<br>e240a6400ca97fc7de11d9d356e88bcc51515508 <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">14</span>:<span class="hljs-number">6379</span>@<span class="hljs-number">16379</span> slave <span class="hljs-number">5</span>bec694e52aa2bae43dc2755e325e1b0aaf87552 <span class="hljs-number">0</span> <span class="hljs-number">1737557694109</span> <span class="hljs-number">4</span> connected<br><span class="hljs-number">5</span>bec694e52aa2bae43dc2755e325e1b0aaf87552 <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">13</span>:<span class="hljs-number">6379</span>@<span class="hljs-number">16379</span> master - <span class="hljs-number">0</span> <span class="hljs-number">1737557695629</span> <span class="hljs-number">3</span> connected <span class="hljs-number">10923</span>-<span class="hljs-number">16383</span><br><br>#设置a的值<br><span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">15</span>:<span class="hljs-number">6379</span>&gt; <span class="hljs-built_in">set</span> a bbb<br>-&gt; Redirected to slot [<span class="hljs-number">15495</span>] located <span class="hljs-built_in">at</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">13</span>:<span class="hljs-number">6379</span><br><br>停用redis-<span class="hljs-number">3</span>的容器服务<br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; get a<br>-&gt; Redirected to slot [<span class="hljs-number">15495</span>] located <span class="hljs-built_in">at</span> <span class="hljs-number">172</span>.<span class="hljs-number">38</span>.<span class="hljs-number">0</span>.<span class="hljs-number">14</span>:<span class="hljs-number">6379</span><br>&quot;bbb&quot;<br></code></pre></td></tr></table></figure>



<p><img src="/images/docker-docker-compose%E5%9F%BA%E7%A1%80/image-20250122225932814.png" alt="image-20250122225932814"></p>
<h1 id="Docker-Compose"><a href="#Docker-Compose" class="headerlink" title="Docker Compose"></a>Docker Compose</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>​    简单来说，Docker Compose是Docker开源的另一个项目，来轻松高效的管理容器，定义运行多个容器。</p>
<p>Dockerfile build run 只能启动一个容器，如果有多个容器，可以借助docker-compose.yaml定义文件和docker-compose up -d 命令启动来编排和定义先后依赖关系，做到批量启动。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>​    参考前文</p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><p>只构建镜像</p>
<p>当构建文件（Dockerfile）出错时，修改后，加build会重新构建</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose build<br></code></pre></td></tr></table></figure>

<p>只下载镜像docker-compose.yml文件中的镜像</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose pull<br></code></pre></td></tr></table></figure>

<p>启动容器，<code>-d</code>后台启动</p>
<p>执行此命令会先pull后启动</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose up -d<br></code></pre></td></tr></table></figure>

<p>查看使用docker-compose.yml启动的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose ps<br></code></pre></td></tr></table></figure>

<p>临时进入docker-compose.yml启动的容器(查看不到)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose run  容器名 /bin/sh<br></code></pre></td></tr></table></figure>

<p>启动docker-compose.yml中的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose start<br></code></pre></td></tr></table></figure>

<p>停止docker-compose.yml中的容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose stop<br></code></pre></td></tr></table></figure>

<p>删除使用docker-compose.yml运行的容器(需要先stop)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">docker-compose rm<br></code></pre></td></tr></table></figure>

<h2 id="YAML规则"><a href="#YAML规则" class="headerlink" title="YAML规则"></a>YAML规则</h2><p><a href="https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples">https://docs.docker.com/compose/compose-file/#compose-file-structure-and-examples</a></p>
<p><code>docker-compose.yaml</code> 的语法规则，包括版本、服务（含众多服务关键字）、网络（含网络关键字）、卷、配置项、密钥等的定义</p>
<p>docker-compose.yaml举例</p>
<p>主要有几个部分组成：version、services、volumes、networks，每个service的内容与每个dockerFile定义镜像类似的去describe每个服务的信息</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span>  <span class="hljs-comment"># 指定docker-compose语法版本</span><br><span class="hljs-attr">services:</span>    <span class="hljs-comment"># 从以下定义服务配置列表</span><br>  <span class="hljs-attr">server_name:</span>   <span class="hljs-comment"># 可将server_name替换为自定义的名字，如mysql/php都可以</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">container_name</span>  <span class="hljs-comment"># 指定实例化后的容器名，可将container_name替换为自定义名</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxx:latest</span> <span class="hljs-comment"># 指定使用的镜像名及标签</span><br>    <span class="hljs-attr">build:</span>  <span class="hljs-comment"># 如果没有现成的镜像，需要自己构建使用这个选项</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">/xxx/xxx/Dockerfile</span>  <span class="hljs-comment"># 指定构建镜像文件的路径</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">....</span>     <span class="hljs-comment"># 指定Dockerfile文件名，上一条指定，这一条就不要了</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;00:00&quot;</span>  <span class="hljs-comment"># 容器内的映射端口，本地端口:容器内端口</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;00:00&quot;</span>  <span class="hljs-comment"># 可指定多个</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test1:/xx/xx</span>  <span class="hljs-comment"># 这里使用managed volume的方法，将容器内的目录映射到物理机，方便管理</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test2:/xx/xx</span>  <span class="hljs-comment"># 前者是volumes目录下的名字，后者是容器内目录</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">test3:/xx/xx</span>  <span class="hljs-comment"># 在文件的最后还要使用volumes指定这几个tests</span><br>    <span class="hljs-attr">volumes_from:</span>  <span class="hljs-comment"># 指定卷容器</span><br>       <span class="hljs-bullet">-</span> <span class="hljs-string">volume_container_name</span>  <span class="hljs-comment"># 卷容器名</span><br>    <span class="hljs-attr">restarts:</span> <span class="hljs-string">always</span>  <span class="hljs-comment"># 设置无论遇到什么错，重启容器</span><br>    <span class="hljs-attr">depends_on:</span>       <span class="hljs-comment"># 用来解决依赖关系，如这个服务的启动，必须在哪个服务启动之后</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">server_name</span>   <span class="hljs-comment"># 这个是名字其他服务在这个文件中的server_name</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">server_name1</span>  <span class="hljs-comment"># 按照先后顺序启动</span><br>    <span class="hljs-attr">links:</span>  <span class="hljs-comment"># 与depend_on相对应，上面控制容器启动，这个控制容器连接</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">mysql</span>  <span class="hljs-comment"># 值可以是- 服务名，比较复杂，可以在该服务中使用links中mysql代替这个mysql的ip</span><br>    <span class="hljs-attr">networks:</span> <span class="hljs-comment"># 加入指定的网络，与之前的添加网卡名类似</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">my_net</span>  <span class="hljs-comment"># bridge类型的网卡名</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">myapp_net</span> <span class="hljs-comment"># 如果没有网卡会被创建,建议使用时先创建号，在指定</span><br>    <span class="hljs-attr">environment:</span> <span class="hljs-comment"># 定义变量，类似dockerfile中的ENV</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">TZ=Asia/Shanghai</span>  <span class="hljs-comment"># 这里设置容器的时区为亚洲上海，也就解决了容器通过compose编排启动的 时区问题！！！！解决了容器的时区问题！！！</span><br>      <span class="hljs-string">变量值:</span> <span class="hljs-string">变量名</span>   <span class="hljs-comment"># 这些变量将会被直接写到镜像中的/etc/profile</span><br>    <span class="hljs-attr">command:</span> [                        <span class="hljs-comment">#使用 command 可以覆盖容器启动后默认执行的命令</span><br>            <span class="hljs-string">&#x27;--character-set-server=utf8mb4&#x27;</span>,            <span class="hljs-comment">#设置数据库表的数据集</span><br>            <span class="hljs-string">&#x27;--collation-server=utf8mb4_unicode_ci&#x27;</span>,    <span class="hljs-comment">#设置数据库表的数据集</span><br>            <span class="hljs-string">&#x27;--default-time-zone=+8:00&#x27;</span>                    <span class="hljs-comment">#设置mysql数据库的 时区问题！！！！ 而不是设置容器的时区问题！！！！</span><br>    ]<br>  <span class="hljs-attr">server_name2:</span>  <span class="hljs-comment"># 开始第二个容器</span><br>    <span class="hljs-attr">server_name:</span><br>      <span class="hljs-attr">stdin_open:</span> <span class="hljs-literal">true</span> <span class="hljs-comment"># 类似于docker run -d</span><br>      <span class="hljs-attr">tty:</span> <span class="hljs-literal">true</span>  <span class="hljs-comment"># 类似于docker run -t</span><br><span class="hljs-attr">volumes:</span>   <span class="hljs-comment"># 以上每个服务中挂载映射的目录都在这里写入一次,也叫作声明volume</span><br>  <span class="hljs-attr">test1:</span><br>  <span class="hljs-attr">test2:</span><br>  <span class="hljs-attr">test3:</span><br><span class="hljs-attr">networks:</span>  <span class="hljs-comment"># 如果要指定ip网段，还是创建好在使用即可，声明networks</span><br>  <span class="hljs-attr">my_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span>  <span class="hljs-comment"># 指定网卡类型</span><br>  <span class="hljs-attr">myapp_net:</span><br>    <span class="hljs-attr">driver:</span> <span class="hljs-string">bridge</span> <br></code></pre></td></tr></table></figure>

<h1 id="Docker-Swarm"><a href="#Docker-Swarm" class="headerlink" title="Docker Swarm"></a>Docker Swarm</h1><p>docker：容器</p>
<p>docker-compose：一个节点上的一系列容器</p>
<p>docker-swarm：多个主机或者集群上的多套环境容器的管理大规模容器化应用，</p>
<p>docker-swarm对标K8S</p>
<p>不过业界用docker-swarm比较少，学习意义不大</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>计算机基础</tag>
        <tag>docker</tag>
        <tag>vmware</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-MQ-03RabbitMQ整合SpringBoot&amp;集群搭建</title>
    <url>/2022/05/25/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-03RabbitMQ%E6%95%B4%E5%90%88SpringBoot/</url>
    <content><![CDATA[<h1 id="RabbitMQ整合SpringBoot-amp-集群搭建"><a href="#RabbitMQ整合SpringBoot-amp-集群搭建" class="headerlink" title="RabbitMQ整合SpringBoot&amp;集群搭建"></a>RabbitMQ整合SpringBoot&amp;集群搭建</h1><h2 id="RabbitMQ整合SpringBoot"><a href="#RabbitMQ整合SpringBoot" class="headerlink" title="RabbitMQ整合SpringBoot"></a>RabbitMQ整合SpringBoot</h2><h3 id="Producer"><a href="#Producer" class="headerlink" title="Producer"></a>Producer</h3><p>1、配置文件 application.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.136.1</span><br><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-meta">spring.rabbitmq.virtual-host</span>=<span class="hljs-string">/</span><br><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-comment">#开启消息确认模式</span><br><span class="hljs-meta">spring.rabbitmq.publisher-confirms</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#开启消息可达监听</span><br><span class="hljs-meta">spring.rabbitmq.publisher-returns</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#开启不可达消息不会被broker给删除</span><br><span class="hljs-meta">spring.rabbitmq.template.mandatory</span>=<span class="hljs-string">true</span><br><span class="hljs-comment">#设置连接超时</span><br><span class="hljs-meta">spring.rabbitmq.connection-timeout</span>=<span class="hljs-string">10000</span><br></code></pre></td></tr></table></figure>

<p>2、设置RabbitMQ的交换机、队列、绑定关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitMqConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">testBootDirectExchange</span><span class="hljs-params">()</span> </span>&#123;<br>        DirectExchange directExchange = <span class="hljs-keyword">new</span> DirectExchange(<span class="hljs-string">&quot;springboot.direct.exchange&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> directExchange;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title">delayExchange</span><span class="hljs-params">()</span> </span>&#123;<br>        Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        args.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomExchange(<span class="hljs-string">&quot;delayExchange&quot;</span>, <span class="hljs-string">&quot;x-delayed-message&quot;</span>,<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>,args);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">testBootQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;testBootQueue&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">testClusterQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;testClusterQueue&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">testBootDelayQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;testBootDelayQueue&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">testBootBinder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(testBootQueue()).to(testBootDirectExchange()).with(<span class="hljs-string">&quot;springboot.key&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">testClusterBinder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(testClusterQueue()).to(testBootDirectExchange()).with(<span class="hljs-string">&quot;rabbitmq.cluster.key&quot;</span>);<br>    &#125;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(testBootDelayQueue()).to(delayExchange()).with(<span class="hljs-string">&quot;springboot.delay.key&quot;</span>).noargs();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>3、声明消息发送者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMsgSender</span></span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试发送我们的消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg 消息内容</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msgProp 消息属性</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(Object msg, Map&lt;String,Object&gt; msgProp)</span> </span>&#123;<br><br>        MessageHeaders messageHeaders = <span class="hljs-keyword">new</span> MessageHeaders(msgProp);<br><br>        <span class="hljs-comment">//构建消息对象</span><br>        Message message = MessageBuilder.createMessage(msg,messageHeaders);<br><br>        rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());<br>        <span class="hljs-comment">//构建correlationData 用于做可靠性投递得,ID:必须为全局唯一的 根据业务规则</span><br>        CorrelationData correlationData = <span class="hljs-keyword">new</span> CorrelationData(UUID.randomUUID().toString());<br>        <span class="hljs-comment">//开启确认模式</span><br>        rabbitTemplate.setConfirmCallback(<span class="hljs-keyword">new</span> MsgConfirmCallBack());<br><br>        <span class="hljs-comment">//开启消息可达监听</span><br>        rabbitTemplate.setReturnCallback(<span class="hljs-keyword">new</span> MsgRetrunCallBack());<br><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;springboot.direct.exchange&quot;</span>,<span class="hljs-string">&quot;springboot.key&quot;</span>,message,correlationData);<br><br>        rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;springboot.direct.exchange&quot;</span>,<span class="hljs-string">&quot;springboot.key2&quot;</span>,message,correlationData);<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgConfirmCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ConfirmCallback</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-keyword">boolean</span> ack, String cause)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;correlationData:========&gt;&#123;&#125;&quot;</span>,correlationData.getId());<br>        log.info(<span class="hljs-string">&quot;ack:================&#123;&#125;&quot;</span>,ack);<br>        <span class="hljs-keyword">if</span>(ack) &#123;<br>            log.info(<span class="hljs-string">&quot;mq生产端消息已经成功投递到了broker,更新我们消息日志表&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            log.warn(<span class="hljs-string">&quot;mq生产端没有被broker ack,原因:&#123;&#125;&quot;</span>,cause);<br>        &#125;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 消息不可达监听</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgRetrunCallBack</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ReturnCallback</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;<br><br>        log.warn(<span class="hljs-string">&quot;correlationId:&#123;&#125;&quot;</span>,message.getMessageProperties().getCorrelationId());<br>        log.warn(<span class="hljs-string">&quot;replyText:&#123;&#125;&quot;</span>,replyText);<br>        log.warn(<span class="hljs-string">&quot;消息内容:&#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> String(message.getBody()));<br>        log.warn(<span class="hljs-string">&quot;replyCode:&#123;&#125;&quot;</span>,replyCode);<br>        log.warn(<span class="hljs-string">&quot;交换机:&#123;&#125;&quot;</span>,exchange);<br>        log.warn(<span class="hljs-string">&quot;routingKey:&#123;&#125;&quot;</span>,routingKey);<br>        log.info(<span class="hljs-string">&quot;需要更新数据库日志表得消息记录为不可达&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>4、测试消息发送</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">()</span> </span>&#123;<br>    Map&lt;String,Object&gt; msgProp = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    msgProp.put(<span class="hljs-string">&quot;company&quot;</span>,<span class="hljs-string">&quot;testCompany&quot;</span>);<br>    msgProp.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;testName&quot;</span>);<br>    <span class="hljs-comment">/*    String msgBody = &quot;hello tuling &quot;;*/</span><br>    Order order = <span class="hljs-keyword">new</span> Order();<br>    order.setOrderNo(UUID.randomUUID().toString());<br>    order.setUserName(<span class="hljs-string">&quot;test&quot;</span>);<br>    order.setPayMoney(<span class="hljs-number">10000.00</span>);<br>    order.setCreateDt(<span class="hljs-keyword">new</span> Date());<br>    testMsgSender.sendMsg(JSON.toJSONString(order),msgProp);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-03RabbitMQ%E6%95%B4%E5%90%88SpringBoot/image-20220527091547220.png" alt="image-20220527091547220"></p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8888</span><br><span class="hljs-meta">spring.rabbitmq.host</span>=<span class="hljs-string">192.168.136.1</span><br><span class="hljs-meta">spring.rabbitmq.port</span>=<span class="hljs-string">5672</span><br><span class="hljs-meta">spring.rabbitmq.virtual-host</span>=<span class="hljs-string">/</span><br><span class="hljs-meta">spring.rabbitmq.username</span>=<span class="hljs-string">guest</span><br><span class="hljs-meta">spring.rabbitmq.password</span>=<span class="hljs-string">guest</span><br><br><span class="hljs-comment">#手动签收</span><br><span class="hljs-meta">spring.rabbitmq.listener.simple.acknowledge-mode</span>=<span class="hljs-string">manual</span><br><span class="hljs-meta">spring.rabbitmq.listener.simple.concurrency</span>=<span class="hljs-string">1</span><br><span class="hljs-meta">spring.rabbitmq.listener.simple.max-concurrency</span>=<span class="hljs-string">1</span><br><span class="hljs-meta">spring.rabbitmq.listener.simple.prefetch</span>=<span class="hljs-string">5</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMsgConsumer</span> </span>&#123;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;&quot;testBootQueue&quot;&#125;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumerMsg</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        log.info(<span class="hljs-string">&quot;消费消息:&#123;&#125;&quot;</span>, JSON.parseObject(<span class="hljs-keyword">new</span> String(message.getBody()),Order.class));<br>        <span class="hljs-comment">//手工签收</span><br>        Long deliveryTag = message.getMessageProperties().getDeliveryTag();<br>        log.info(<span class="hljs-string">&quot;接受deliveryTag:&#123;&#125;&quot;</span>,deliveryTag);<br>        channel.basicAck(deliveryTag,<span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>可以处理的消息类型</strong></p>
<p>​    java对象、json、String、图片、excel文件等 </p>
<h2 id="延时队列的实现"><a href="#延时队列的实现" class="headerlink" title="延时队列的实现"></a>延时队列的实现</h2><h3 id="下载启动延时组件"><a href="#下载启动延时组件" class="headerlink" title="下载启动延时组件"></a>下载启动延时组件</h3><p>wget <a href="https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip">https://dl.bintray.com/rabbitmq/community-plugins/3.6.x/rabbitmq_delayed_message_exchange/rabbitmq_delayed_message_exchange-20171215-3.6.x.zip</a></p>
<p>解压延时插件:  unzip  </p>
<p>rabbitmq_delayed_message_exchange-20171215-3.6.x.zip</p>
<p>把延时插件拷贝到指定目录下:cp rabbitmq_delayed_message_exchange-20171215-3.6.x.ez</p>
<p>/usr/lib/rabbitmq/lib/rabbitmq_server-3.7.5/plugins</p>
<p>启动延时插件: rabbitmq-plugins enable rabbitmq_delayed_message_exchange</p>
<h3 id="声明延时队列"><a href="#声明延时队列" class="headerlink" title="声明延时队列"></a>声明延时队列</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> CustomExchange <span class="hljs-title">delayExchange</span><span class="hljs-params">()</span> </span>&#123;<br>     Map&lt;String, Object&gt; args = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>     args.put(<span class="hljs-string">&quot;x-delayed-type&quot;</span>, <span class="hljs-string">&quot;direct&quot;</span>);<br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> CustomExchange(<span class="hljs-string">&quot;delayExchange&quot;</span>, <span class="hljs-string">&quot;x-delayed-message&quot;</span>,<span class="hljs-keyword">true</span>, <span class="hljs-keyword">false</span>,args);<br> &#125;<br><br> <span class="hljs-meta">@Bean</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">testBootDelayQueue</span><span class="hljs-params">()</span> </span>&#123;<br>     Queue queue = <span class="hljs-keyword">new</span> Queue(<span class="hljs-string">&quot;testBootDelayQueue&quot;</span>,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br>     <span class="hljs-keyword">return</span> queue;<br> &#125;<br> <br> <span class="hljs-meta">@Bean</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">binding</span><span class="hljs-params">()</span> </span>&#123;<br>     <span class="hljs-keyword">return</span> BindingBuilder.bind(testBootDelayQueue()).to(delayExchange()).with(<span class="hljs-string">&quot;springboot.delay.key&quot;</span>).noargs();<br> &#125;   <br></code></pre></td></tr></table></figure>

<p>发送延时消息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 发送延时消息</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> msgTxtBo</span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">senderDelayCheckMsg</span><span class="hljs-params">(MsgTxtBo msgTxtBo)</span> </span>&#123;<br><br>       log.info(<span class="hljs-string">&quot;发送的消息ID:&#123;&#125;&quot;</span>,msgTxtBo.getOrderNo());<br>       <span class="hljs-comment">//表示为延时消息</span><br>       CorrelationData correlationData = <span class="hljs-keyword">new</span> CorrelationData(msgTxtBo.getMsgId()+<span class="hljs-string">&quot;_&quot;</span>+msgTxtBo.getOrderNo()+<span class="hljs-string">&quot;_delay&quot;</span>);<br>       rabbitTemplate.setMessageConverter(<span class="hljs-keyword">new</span> Jackson2JsonMessageConverter());<br>       rabbitTemplate.convertAndSend(<span class="hljs-string">&quot;delayExchange&quot;</span>, <span class="hljs-string">&quot;springboot.delay.key&quot;</span>, msgTxtBo, <span class="hljs-keyword">new</span> MessagePostProcessor() &#123;<br>           <span class="hljs-meta">@Override</span><br>           <span class="hljs-keyword">public</span> org.springframework.amqp.core.<span class="hljs-function">Message <span class="hljs-title">postProcessMessage</span><span class="hljs-params">(org.springframework.amqp.core.Message message)</span> <span class="hljs-keyword">throws</span> AmqpException </span>&#123;<br>               message.getMessageProperties().setHeader(<span class="hljs-string">&quot;x-delay&quot;</span>, <span class="hljs-number">30000</span>);<span class="hljs-comment">//设置延迟时间</span><br>               <span class="hljs-keyword">return</span> message;<br>           &#125;<br>       &#125;,correlationData);<br><br>   &#125; <br></code></pre></td></tr></table></figure>
<h2 id="可靠消息方案案例"><a href="#可靠消息方案案例" class="headerlink" title="可靠消息方案案例"></a>可靠消息方案案例</h2><p><strong>消息成功投递 + 消费幂等</strong></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-MQ-03RabbitMQ%E6%95%B4%E5%90%88SpringBoot/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%EF%BC%88%E6%B6%88%E6%81%AF%E5%8F%AF%E9%9D%A0%E6%80%A7%E6%8A%95%E9%80%92%E4%B9%8B%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E7%89%88%E6%9C%AC%EF%BC%89_00-1653578533880.png" alt="分布式事务解决方案（消息可靠性投递之定时任务版本）_00"></p>
<p>相关实体</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `message_content`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `message_content` (<br>  `msg_id` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `msg_status` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span> COMMENT <span class="hljs-string">&#x27;(0,&quot;发送中&quot;),(1,&quot;mq的broker确认接受到消息&quot;),(2,&quot;没有对应交换机&quot;),(3,&quot;没有对应的路由&quot;),(4,&quot;消费端成功消费消息&quot;)&#x27;</span>,<br>  `exchange` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `routing_key` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `err_cause` <span class="hljs-type">varchar</span>(<span class="hljs-number">1000</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `order_no` <span class="hljs-type">bigint</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `max_retry` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `current_retry` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `product_no` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`msg_id`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `order_info`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `order_info` (<br>  `order_no` <span class="hljs-type">bigint</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> AUTO_INCREMENT,<br>  `create_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `update_time` datetime <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `user_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `money` <span class="hljs-keyword">double</span>(<span class="hljs-number">10</span>,<span class="hljs-number">2</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `product_no` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `order_status` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`order_no`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB AUTO_INCREMENT <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> IF <span class="hljs-keyword">EXISTS</span> `product_info`;<br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> `product_info` (<br>  `product_no` <span class="hljs-type">int</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span>,<br>  `product_name` <span class="hljs-type">varchar</span>(<span class="hljs-number">50</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  `product_num` <span class="hljs-type">int</span>(<span class="hljs-number">10</span>) <span class="hljs-keyword">DEFAULT</span> <span class="hljs-keyword">NULL</span>,<br>  <span class="hljs-keyword">PRIMARY</span> KEY (`product_no`)<br>) ENGINE<span class="hljs-operator">=</span>InnoDB <span class="hljs-keyword">DEFAULT</span> CHARSET<span class="hljs-operator">=</span>utf8;<br><br><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> `product_info` <span class="hljs-keyword">VALUES</span> (<span class="hljs-string">&#x27;1&#x27;</span>, <span class="hljs-string">&#x27;华为meta30&#x27;</span>, <span class="hljs-string">&#x27;61&#x27;</span>);<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageContent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String msgId;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> orderNo;<br><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-keyword">private</span> Integer msgStatus;<br><br>    <span class="hljs-keyword">private</span> String exchange;<br><br>    <span class="hljs-keyword">private</span> String routingKey;<br><br>    <span class="hljs-keyword">private</span> String errCause;<br><br>    <span class="hljs-keyword">private</span> Integer maxRetry;<br><br>    <span class="hljs-keyword">private</span> Integer currentRetry=<span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">private</span> Integer productNo;<br>&#125;<br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderInfo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> orderNo;<br><br>    <span class="hljs-keyword">private</span> Date createTime;<br><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-keyword">private</span> String userName;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> money;<br><br>    <span class="hljs-keyword">private</span> Integer productNo;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductInfo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer productNo;<br><br>    <span class="hljs-keyword">private</span> String productName;<br><br>    <span class="hljs-keyword">private</span> String productNum;<br>&#125;<br><br><span class="hljs-meta">@Getter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">MsgStatusEnum</span> </span>&#123;<br><br>    SENDING(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;发送中&quot;</span>),<br><br>    SENDING_SUCCESS(<span class="hljs-number">1</span>,<span class="hljs-string">&quot;消息发送成功&quot;</span>),<br><br>    SENDING_FAIL(<span class="hljs-number">2</span>,<span class="hljs-string">&quot;消息发送失败&quot;</span>),<br><br>    CONSUMER_SUCCESS(<span class="hljs-number">3</span>,<span class="hljs-string">&quot;消费成功&quot;</span>),<br><br>    CONSUMER_FAIL(<span class="hljs-number">4</span>,<span class="hljs-string">&quot;消费失败&quot;</span>);<br><br>    <span class="hljs-keyword">private</span> Integer code;<br><br>    <span class="hljs-keyword">private</span> String msgStatus;<br><br>    MsgStatusEnum(Integer code, String msgStatus) &#123;<br>        <span class="hljs-keyword">this</span>.code = code;<br>        <span class="hljs-keyword">this</span>.msgStatus = msgStatus;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgTxtBo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> orderNo;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> productNo;<br><br>    <span class="hljs-keyword">private</span> String msgId;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="消息可靠性投递基于定时任务解决方案-消息生产端"><a href="#消息可靠性投递基于定时任务解决方案-消息生产端" class="headerlink" title="消息可靠性投递基于定时任务解决方案(消息生产端)"></a>消息可靠性投递基于定时任务解决方案(消息生产端)</h3><p><strong>1、application.yml</strong></p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#数据源配置</span><br><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">druid</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">username</span>: <span class="hljs-string">root</span><br>      <span class="hljs-attr">password</span>: <span class="hljs-string">123456</span><br>      <span class="hljs-attr">jdbcUrl</span>: <span class="hljs-string">jdbc:mysql://localhost:3306/rabbitmq?serverTimezone=Asia/Shanghai</span><br><br>      <span class="hljs-attr">driverClassName</span>: <span class="hljs-string">com.mysql.jdbc.Driver</span><br>      <span class="hljs-attr">initialSize</span>: <span class="hljs-string">5</span><br>      <span class="hljs-attr">minIdle</span>: <span class="hljs-string">5</span><br>      <span class="hljs-attr">maxActive</span>: <span class="hljs-string">20</span><br>      <span class="hljs-attr">maxWait</span>: <span class="hljs-string">60000</span><br>      <span class="hljs-attr">timeBetweenEvictionRunsMillis</span>: <span class="hljs-string">60000</span><br>      <span class="hljs-attr">minEvictableIdleTimeMillis</span>: <span class="hljs-string">300000</span><br>      <span class="hljs-attr">validationQuery</span>: <span class="hljs-string">SELECT 1 FROM DUAL</span><br>      <span class="hljs-attr">testWhileIdle</span>: <span class="hljs-string">true</span><br>      <span class="hljs-attr">testOnBorrow</span>: <span class="hljs-string">false</span><br>      <span class="hljs-attr">testOnReturn</span>: <span class="hljs-string">false</span><br>      <span class="hljs-attr">poolPreparedStatements</span>: <span class="hljs-string">true</span><br>      <span class="hljs-attr">filters</span>: <span class="hljs-string">stat,wall</span><br>      <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize</span>: <span class="hljs-string">20</span><br>      <span class="hljs-attr">useGlobalDataSourceStat</span>: <span class="hljs-string">true</span><br>      <span class="hljs-attr">connectionProperties</span>: <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br><span class="hljs-comment">  #rabbitmq生产端配置</span><br>  <span class="hljs-attr">rabbitmq</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">host</span>: <span class="hljs-string">192.168.136.1</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-string">5672</span><br>    <span class="hljs-meta">virtual-host</span>: <span class="hljs-string">/</span><br>    <span class="hljs-attr">username</span>: <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password</span>: <span class="hljs-string">guest</span><br>    <span class="hljs-meta">publisher-confirms</span>: <span class="hljs-string">true</span><br>    <span class="hljs-meta">publisher-returns</span>: <span class="hljs-string">true</span><br><span class="hljs-comment">    #防止不可达消息被删除</span><br>    <span class="hljs-attr">template</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">mandatory</span>: <span class="hljs-string">true</span><br>    <span class="hljs-meta">connection-timeout</span>: <span class="hljs-string">1000000</span><br><span class="hljs-comment">#配置mybatis</span><br><span class="hljs-attr">mybatis</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">mapper-locations</span>: <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br>  <span class="hljs-attr">configuration</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">map-underscore-to-camel-case</span>: <span class="hljs-string">true</span><br><span class="hljs-attr">logging</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">level</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">com.study.mapper</span>: <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure>

<p><strong>2、MQ绑定关系配置</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RabbitmqConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DirectExchange <span class="hljs-title">orderToProductExchange</span><span class="hljs-params">()</span> </span>&#123;<br>        DirectExchange directExchange = <span class="hljs-keyword">new</span> DirectExchange(MqConst.ORDER_TO_PRODUCT_EXCHANGE_NAME,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> directExchange;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Queue <span class="hljs-title">orderToProductQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        Queue queue = <span class="hljs-keyword">new</span> Queue(MqConst.ORDER_TO_PRODUCT_QUEUE_NAME,<span class="hljs-keyword">true</span>,<span class="hljs-keyword">false</span>,<span class="hljs-keyword">false</span>);<br>        <span class="hljs-keyword">return</span> queue;<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Binding <span class="hljs-title">orderToProductBinding</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> BindingBuilder.bind(orderToProductQueue()).to(orderToProductExchange()).with(MqConst.ORDER_TO_PRODUCT_ROUTING_KEY);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>3、生产者</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgSender</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RabbitTemplate rabbitTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgComfirm msgComfirm;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgRetrunListener msgRetrunListener;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法实现说明:真正的发送消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>:smlz</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msgTxtBo:发送的消息对象</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>:</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>:</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span>:2019/10/11 20:01</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  <span class="hljs-keyword">void</span> <span class="hljs-title">senderMsg</span><span class="hljs-params">(MsgTxtBo msgTxtBo)</span></span>&#123;<br><br>        log.info(<span class="hljs-string">&quot;发送的消息ID:&#123;&#125;&quot;</span>,msgTxtBo.getMsgId());<br><br>        CorrelationData correlationData = <span class="hljs-keyword">new</span> CorrelationData(msgTxtBo.getMsgId());<br><br>        rabbitTemplate.convertAndSend(MqConst.ORDER_TO_PRODUCT_EXCHANGE_NAME,MqConst.ORDER_TO_PRODUCT_ROUTING_KEY,msgTxtBo,correlationData);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        rabbitTemplate.setConfirmCallback(msgComfirm);<br>        rabbitTemplate.setReturnCallback(msgRetrunListener);<br>        <span class="hljs-comment">//设置消息转换器</span><br>        Jackson2JsonMessageConverter jackson2JsonMessageConverter = <span class="hljs-keyword">new</span> Jackson2JsonMessageConverter();<br>        rabbitTemplate.setMessageConverter(jackson2JsonMessageConverter);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>4、消息确认回调监听</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgComfirm</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ConfirmCallback</span></span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgContentMapper msgContentMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">confirm</span><span class="hljs-params">(CorrelationData correlationData, <span class="hljs-keyword">boolean</span> ack, String cause)</span> </span>&#123;<br>        String msgId = correlationData.getId();<br><br>        <span class="hljs-keyword">if</span>(ack) &#123;<br>            log.info(<span class="hljs-string">&quot;消息Id:&#123;&#125;对应的消息被broker签收成功&quot;</span>,msgId);<br>            updateMsgStatusWithAck(msgId);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            log.warn(<span class="hljs-string">&quot;消息Id:&#123;&#125;对应的消息被broker签收失败:&#123;&#125;&quot;</span>,msgId,cause);<br>            updateMsgStatusWithNack(msgId,cause);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 方法实现说明:更新消息表状态为</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@author</span>:smlz</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msgId:消息ID</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@exception</span>:</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@date</span>:2019/10/11 18:01</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMsgStatusWithAck</span><span class="hljs-params">(String msgId)</span> </span>&#123;<br>        MessageContent messageContent = builderUpdateContent(msgId);<br>        messageContent.setMsgStatus(MsgStatusEnum.SENDING_SUCCESS.getCode());<br>        msgContentMapper.updateMsgStatus(messageContent);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMsgStatusWithNack</span><span class="hljs-params">(String msgId,String cause)</span></span>&#123;<br><br>        MessageContent messageContent = builderUpdateContent(msgId);<br><br>        messageContent.setMsgStatus(MsgStatusEnum.SENDING_FAIL.getCode());<br>        messageContent.setErrCause(cause);<br>        msgContentMapper.updateMsgStatus(messageContent);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> MessageContent <span class="hljs-title">builderUpdateContent</span><span class="hljs-params">(String msgId)</span> </span>&#123;<br>        MessageContent messageContent = <span class="hljs-keyword">new</span> MessageContent();<br>        messageContent.setMsgId(msgId);<br>        messageContent.setUpdateTime(<span class="hljs-keyword">new</span> Date());<br>        <span class="hljs-keyword">return</span> messageContent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>5、消息拒绝返回监听</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgRetrunListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RabbitTemplate</span>.<span class="hljs-title">ReturnCallback</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgContentMapper msgContentMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">returnedMessage</span><span class="hljs-params">(Message message, <span class="hljs-keyword">int</span> replyCode, String replyText, String exchange, String routingKey)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>            ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>            MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(),MsgTxtBo.class);<br>            log.info(<span class="hljs-string">&quot;无法路由消息内容:&#123;&#125;,cause:&#123;&#125;&quot;</span>,msgTxtBo,replyText);<br><br>            <span class="hljs-comment">//构建消息对象</span><br>            MessageContent messageContent = <span class="hljs-keyword">new</span> MessageContent();<br>            messageContent.setErrCause(replyText);<br>            messageContent.setUpdateTime(<span class="hljs-keyword">new</span> Date());<br>            messageContent.setMsgStatus(MsgStatusEnum.SENDING_FAIL.getCode());<br>            messageContent.setMsgId(msgTxtBo.getMsgId());<br>            <span class="hljs-comment">//更新消息表</span><br>            msgContentMapper.updateMsgStatus(messageContent);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;更新消息表异常:&#123;&#125;&quot;</span>,e);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>6、生成消息</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IOrderInfoService orderInfoService;<br>    <span class="hljs-meta">@RequestMapping(&quot;/saveOrder&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">saveOrder</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> JsonProcessingException </span>&#123;<br><br>        OrderInfo orderInfo = <span class="hljs-keyword">new</span> OrderInfo();<br>        orderInfo.setOrderNo(System.currentTimeMillis());<br>        orderInfo.setCreateTime(<span class="hljs-keyword">new</span> Date());<br>        orderInfo.setUpdateTime(<span class="hljs-keyword">new</span> Date());<br>        orderInfo.setUserName(<span class="hljs-string">&quot;handsome boy&quot;</span>);<br>        orderInfo.setMoney(<span class="hljs-number">10000</span>);<br>        orderInfo.setProductNo(<span class="hljs-number">1</span>);<br>        orderInfoService.saveOrderInfoWithMessage(orderInfo);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ok&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>7、定时任务扫描重试推送</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RetryMsgTask</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgSender msgSender;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgContentMapper msgContentMapper;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 延时5s启动</span><br><span class="hljs-comment">     * 周期10S一次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Scheduled(initialDelay = 10000,fixedDelay = 10000)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">retrySend</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;-----------------------------&quot;</span>);<br>        <span class="hljs-comment">//查询创建时间超过30s &amp;&amp; 状态 != 消费成功 &amp;&amp; 重试次数没超过限制的 消息</span><br>        List&lt;MessageContent&gt; messageContentList = msgContentMapper.qryNeedRetryMsg(MsgStatusEnum.CONSUMER_SUCCESS.getCode(), MqConst.TIME_DIFF);<br>        <span class="hljs-keyword">for</span>(MessageContent messageContent:messageContentList) &#123;<br>            <span class="hljs-keyword">if</span>(messageContent.getMaxRetry()&gt;messageContent.getCurrentRetry()) &#123;<br>                MsgTxtBo msgTxtBo = <span class="hljs-keyword">new</span> MsgTxtBo();<br>                msgTxtBo.setMsgId(messageContent.getMsgId());<br>                msgTxtBo.setProductNo(messageContent.getProductNo());<br>                msgTxtBo.setOrderNo(messageContent.getOrderNo());<br>                <span class="hljs-comment">//更新消息重试次数</span><br>                msgContentMapper.updateMsgRetryCount(msgTxtBo.getMsgId());<br>                msgSender.senderMsg(msgTxtBo);<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                log.warn(<span class="hljs-string">&quot;消息:&#123;&#125;以及达到最大重试次数&quot;</span>,messageContent);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="消费者幂等消费"><a href="#消费者幂等消费" class="headerlink" title="消费者幂等消费"></a>消费者幂等消费</h3><p>1、application.yml</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">druid</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">username</span>: <span class="hljs-string">root</span><br>      <span class="hljs-attr">password</span>: <span class="hljs-string">123456</span><br>      <span class="hljs-attr">jdbcUrl</span>: <span class="hljs-string">jdbc:mysql://localhost:3306/rabbitmq?serverTimezone=Asia/Shanghai</span><br>      <span class="hljs-attr">driverClassName</span>: <span class="hljs-string">com.mysql.jdbc.Driver</span><br>      <span class="hljs-attr">initialSize</span>: <span class="hljs-string">5</span><br>      <span class="hljs-attr">minIdle</span>: <span class="hljs-string">5</span><br>      <span class="hljs-attr">maxActive</span>: <span class="hljs-string">20</span><br>      <span class="hljs-attr">maxWait</span>: <span class="hljs-string">60000</span><br>      <span class="hljs-attr">timeBetweenEvictionRunsMillis</span>: <span class="hljs-string">60000</span><br>      <span class="hljs-attr">minEvictableIdleTimeMillis</span>: <span class="hljs-string">300000</span><br>      <span class="hljs-attr">validationQuery</span>: <span class="hljs-string">SELECT 1 FROM DUAL</span><br>      <span class="hljs-attr">testWhileIdle</span>: <span class="hljs-string">true</span><br>      <span class="hljs-attr">testOnBorrow</span>: <span class="hljs-string">false</span><br>      <span class="hljs-attr">testOnReturn</span>: <span class="hljs-string">false</span><br>      <span class="hljs-attr">poolPreparedStatements</span>: <span class="hljs-string">true</span><br>      <span class="hljs-attr">filters</span>: <span class="hljs-string">stat,wall</span><br>      <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize</span>: <span class="hljs-string">20</span><br>      <span class="hljs-attr">useGlobalDataSourceStat</span>: <span class="hljs-string">true</span><br>      <span class="hljs-attr">connectionProperties</span>: <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br>  <span class="hljs-attr">rabbitmq</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">host</span>: <span class="hljs-string">192.168.136.1</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-string">5672</span><br>    <span class="hljs-meta">virtual-host</span>: <span class="hljs-string">/</span><br>    <span class="hljs-attr">username</span>: <span class="hljs-string">guest</span><br>    <span class="hljs-attr">password</span>: <span class="hljs-string">guest</span><br>    <span class="hljs-attr">listener</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">simple</span>:<span class="hljs-string"></span><br>        <span class="hljs-attr">concurrency</span>: <span class="hljs-string">5</span><br>        <span class="hljs-meta">max-concurrency</span>: <span class="hljs-string">10</span><br>        <span class="hljs-meta">acknowledge-mode</span>: <span class="hljs-string">manual</span><br>        <span class="hljs-attr">prefetch</span>: <span class="hljs-string">1</span><br>        <span class="hljs-meta">default-requeue-rejected</span>: <span class="hljs-string">false</span><br>  <span class="hljs-attr">redis</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">host</span>: <span class="hljs-string">127.0.0.1</span><br>    <span class="hljs-attr">port</span>: <span class="hljs-string">6379</span><br><br><br><br><span class="hljs-attr">mybatis</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">mapper-locations</span>: <span class="hljs-string">classpath:mybatis/mapper/*.xml</span><br>  <span class="hljs-attr">configuration</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">map-underscore-to-camel-case</span>: <span class="hljs-string">true</span><br><span class="hljs-attr">logging</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">level</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">com.tuling.mapper</span>: <span class="hljs-string">debug</span><br><span class="hljs-attr">server</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">port</span>: <span class="hljs-string">8888</span><br></code></pre></td></tr></table></figure>

<p>2、消费者</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MqConsumer</span> </span>&#123;<br>    <span class="hljs-comment">/**队列名称*/</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String ORDER_TO_PRODUCT_QUEUE_NAME = <span class="hljs-string">&quot;order-to-product.queue&quot;</span>;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String LOCK_KEY=<span class="hljs-string">&quot;LOCK_KEY&quot;</span>;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> IProductService productService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgContentMapper msgContentMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@RabbitListener(queues = &#123;ORDER_TO_PRODUCT_QUEUE_NAME&#125;)</span><br>    <span class="hljs-meta">@RabbitHandler</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">consumerMsgWithLock</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><br>        ObjectMapper objectMapper = <span class="hljs-keyword">new</span> ObjectMapper();<br>        MsgTxtBo msgTxtBo = objectMapper.readValue(message.getBody(), MsgTxtBo.class);<br>        Long deliveryTag = (Long) message.getMessageProperties().getDeliveryTag();<br><br>        <span class="hljs-keyword">if</span> (redisTemplate.opsForValue().setIfAbsent(LOCK_KEY + msgTxtBo.getMsgId(), msgTxtBo.getMsgId())) &#123;<br>            log.info(<span class="hljs-string">&quot;消费消息:&#123;&#125;&quot;</span>, msgTxtBo);<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//更新消息表也业务表</span><br>                productService.updateProductStore(msgTxtBo);<br>                <span class="hljs-comment">//消息签收</span><br>                <span class="hljs-comment">//模拟网络异常</span><br>                <span class="hljs-comment">//System.out.println(1/0);</span><br>                channel.basicAck(deliveryTag, <span class="hljs-keyword">false</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                <span class="hljs-comment">/**</span><br><span class="hljs-comment">                 * 更新数据库异常说明业务没有操作成功需要删除分布式锁</span><br><span class="hljs-comment">                 */</span><br>                <span class="hljs-keyword">if</span> (e <span class="hljs-keyword">instanceof</span> BizExp) &#123;<br>                    BizExp bizExp = (BizExp) e;<br>                    log.info(<span class="hljs-string">&quot;数据业务异常:&#123;&#125;,即将删除分布式锁&quot;</span>, bizExp.getErrMsg());<br>                    <span class="hljs-comment">//删除分布式锁</span><br>                    redisTemplate.delete(LOCK_KEY);<br>                &#125;<br><br>                <span class="hljs-comment">//更新消息表状态</span><br>                MessageContent messageContent = <span class="hljs-keyword">new</span> MessageContent();<br>                messageContent.setMsgStatus(MsgStatusEnum.CONSUMER_FAIL.getCode());<br>                messageContent.setUpdateTime(<span class="hljs-keyword">new</span> Date());<br>                messageContent.setErrCause(e.getMessage());<br>                messageContent.setMsgId(msgTxtBo.getMsgId());<br>                msgContentMapper.updateMsgStatus(messageContent);<br>                channel.basicReject(deliveryTag,<span class="hljs-keyword">false</span>);<br>            &#125;<br><br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            log.warn(<span class="hljs-string">&quot;请不要重复消费消息&#123;&#125;&quot;</span>, msgTxtBo);<br>            channel.basicReject(deliveryTag,<span class="hljs-keyword">false</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IProductService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> ProductInfoMapper productInfoMapper;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MsgContentMapper msgContentMapper;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">updateProductStore</span><span class="hljs-params">(MsgTxtBo msgTxtBo)</span> </span>&#123;<br>        <span class="hljs-keyword">boolean</span> updateFlag = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br>            <span class="hljs-comment">//更新库存</span><br>            productInfoMapper.updateProductStoreById(msgTxtBo.getProductNo());<br><br>            <span class="hljs-comment">//更新消息表状态</span><br>            MessageContent messageContent = <span class="hljs-keyword">new</span> MessageContent();<br>            messageContent.setMsgId(msgTxtBo.getMsgId());<br>            messageContent.setUpdateTime(<span class="hljs-keyword">new</span> Date());<br>            messageContent.setMsgStatus(MsgStatusEnum.CONSUMER_SUCCESS.getCode());<br>            msgContentMapper.updateMsgStatus(messageContent);<br>            <span class="hljs-comment">//模拟业务异常</span><br>            <span class="hljs-comment">//System.out.println(1/0);</span><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;更新数据库失败:&#123;&#125;&quot;</span>,e);<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BizExp(<span class="hljs-number">0</span>,<span class="hljs-string">&quot;更新数据库异常&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> updateFlag;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="消费者的几种写法"><a href="#消费者的几种写法" class="headerlink" title="消费者的几种写法"></a>消费者的几种写法</h2><p>目前主流做法是 <strong>直接避免代码重复消费</strong> 和 <strong>代码支持重复消费，业务上幂等</strong></p>
<h3 id="1、唯一业务ID"><a href="#1、唯一业务ID" class="headerlink" title="1、唯一业务ID"></a>1、唯一业务ID</h3><p>​    代码接受重复消息，但还是业务上结果是幂等的：如果有插入数据库的业务，根据唯一业务id获取分布式锁，进行插入或者更新（重复消费时）</p>
<h3 id="2、（唯一业务ID-（辅助标志位（UUID、时间戳等是业务场景而定））or-唯一消息id"><a href="#2、（唯一业务ID-（辅助标志位（UUID、时间戳等是业务场景而定））or-唯一消息id" class="headerlink" title="2、（唯一业务ID +（辅助标志位（UUID、时间戳等是业务场景而定））or 唯一消息id"></a>2、（唯一业务ID +（辅助标志位（UUID、时间戳等是业务场景而定））or 唯一消息id</h3><p>​    消费时redis setnx成功则继续消费，失败则视为重复消费，跳过消费返回ack</p>
<p>3、消费者模板</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMessageListener</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelAwareMessageListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> RedisTemplate redisTemplate;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CHARSET = <span class="hljs-string">&quot;UTF-8&quot;</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 消息处理器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> mqParam 接收到MQ消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 业务处理是否成功</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 抛出业务处理异常 保存数据库</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(T mqParam)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 提供给子类进行异常日志打印的方法，默认</span><br><span class="hljs-comment">     * 子类可以根据自己选择进行重写</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> e 异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">logErrorMsg</span><span class="hljs-params">(Exception e)</span> </span>&#123;<br>        log.error(<span class="hljs-string">&quot;Listener:&#123;&#125; MQ消费异常：&quot;</span>, beanName, e);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 获得当前类的bean名称，用来保存错误信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Getter</span><br>    <span class="hljs-keyword">private</span> String beanName;<br><br>    <span class="hljs-keyword">private</span> Class&lt;T&gt; clazz;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> singleMqListener;<br><br>    <span class="hljs-keyword">private</span> Channel channel;<br><br>    <span class="hljs-keyword">private</span> Message message;<br><br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br>        Class&lt;? extends BaseMessageListener&gt; aClass = <span class="hljs-keyword">this</span>.getClass();<br>        Component annotation = aClass.getAnnotation(Component.class);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == annotation) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SystemException(<span class="hljs-string">&quot;必须手动设置@Component注解,并设置beanName&quot;</span>);<br>        &#125;<br>        String value = annotation.value();<br>        <span class="hljs-keyword">if</span> (StrUtil.isBlank(value)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SystemException(<span class="hljs-string">&quot;必须手动设置beanName&quot;</span>);<br>        &#125;<br>        beanName = value;<br>        <span class="hljs-comment">// clazz = (Class&lt;T&gt;) ((ParameterizedType) aClass.getGenericSuperclass()).getActualTypeArguments()[0];</span><br>        Type genType = aClass.getGenericSuperclass();<br>        <span class="hljs-keyword">if</span> (genType <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>            Type[] params = ((ParameterizedType) genType).getActualTypeArguments();<br>            Type param = params[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">if</span> (param <span class="hljs-keyword">instanceof</span> Class) &#123;<br>                clazz = (Class&lt;T&gt;) param;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((param <span class="hljs-keyword">instanceof</span> ParameterizedTypeImpl)) &#123;<br>                ParameterizedTypeImpl paramImpl = (ParameterizedTypeImpl) param;<br>                <span class="hljs-keyword">if</span> (paramImpl.getRawType() != <span class="hljs-keyword">null</span>) &#123;<br>                    clazz = (Class&lt;T&gt;) paramImpl.getRawType();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == clazz) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SystemException(<span class="hljs-string">&quot;初始化BaseMessageListener时出现未知错误&quot;</span>);<br>        &#125;<br><br>        SingleMqListener singleMqAnnotation = aClass.getAnnotation(SingleMqListener.class);<br>        singleMqListener = singleMqAnnotation != <span class="hljs-keyword">null</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onMessage</span><span class="hljs-params">(Message message, Channel channel)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">this</span>.channel = channel;<br>        <span class="hljs-keyword">this</span>.message = message;<br><br>        <span class="hljs-keyword">boolean</span> handleSucceed = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 判断是否单线程mq，如果是单线程mq，需要获取分布式锁，没有获得锁，将消息退回给mq</span><br>            <span class="hljs-keyword">if</span> (singleMqListener) &#123;<br>                <span class="hljs-comment">//redisTemplate.tryMacLock(getMacLockName(), TIME_10_SECOND, TIME_1_SECOND);</span><br>                <span class="hljs-comment">//获取分布式锁</span><br>                <span class="hljs-keyword">boolean</span> tryMacLock = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">if</span> (!tryMacLock) &#123;<br>                    <span class="hljs-comment">//放回队列</span><br>                    channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">true</span>);<br><br>                    channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">true</span>);<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">//转换消息</span><br>            T mqParam = <span class="hljs-keyword">this</span>.convertMsg(message, CHARSET);<br>            handleSucceed = handleMessage(mqParam);<br><br>        &#125;<span class="hljs-keyword">catch</span>(ConcurrentHandlerException e)&#123;<br>            log.error(<span class="hljs-string">&quot;Listener:&#123;&#125; MQ捕捉到并发异常：&#123;&#125;&quot;</span>, beanName, e);<br>            basicReject();<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (ValidateException e) &#123;<br>            log.warn(<span class="hljs-string">&quot;Listener:&#123;&#125; MQ捕捉到验证异常：&#123;&#125;&quot;</span>, beanName, e);<br>            channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logErrorMsg(e);<br>            handleErrorMsg(message, channel, e.getMessage(), CHARSET);<br>            <span class="hljs-keyword">return</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (singleMqListener) &#123;<br>                <span class="hljs-comment">//释放分布式锁</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (handleSucceed) &#123;<br>            channel.basicAck(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * mq输入参数转型</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message 消息体</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> charSet 字符集</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 参数</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception 消息转换异常</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> T <span class="hljs-title">convertMsg</span><span class="hljs-params">(Message message, String charSet)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String body = <span class="hljs-keyword">new</span> String(message.getBody(), charSet);<br>        <span class="hljs-keyword">if</span>(StrUtil.isEmpty(body.trim())) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ValidateException(<span class="hljs-string">&quot;非业务报错。MQ 接收到的数据为空格&quot;</span>);<br>        &#125;<br>        log.info(<span class="hljs-string">&quot;Listener:&#123;&#125;  MQ:&#123;&#125;&quot;</span>, beanName, body);<br>        JSON parse = (JSON) JSONObject.parse(body);<br>        <span class="hljs-keyword">return</span> parse.toJavaObject(clazz);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 记录异常信息, 没有保存成功的时候，退回queue。让其循环报错</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> errorMsg 错误信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleErrorMsg</span><span class="hljs-params">(Message message, Channel channel, String errorMsg, String charSet)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == message) &#123;<br>            log.info(<span class="hljs-string">&quot;接收到空信息,不保存错误信息&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == message.getMessageProperties()) &#123;<br>            log.info(<span class="hljs-string">&quot;接收到空信息,不保存错误信息&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        String jsonString = <span class="hljs-keyword">new</span> String(message.getBody(), charSet);<br>        String msgClassName = clazz.getName();<br>        <span class="hljs-keyword">try</span> &#123;<br>            JSON parse = (JSON) JSONObject.parse(jsonString);<br>            <span class="hljs-comment">//errorMsgService.saveErrorMsg(parse, msgClassName, beanName, errorMsg);</span><br>            <span class="hljs-comment">//记录消息状态</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            log.error(<span class="hljs-string">&quot;MQ异常信息保存数据库失败&quot;</span>, e);<br>        &#125;<br>        channel.basicReject(message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">false</span>);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">basicReject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>&#123;<br>        <span class="hljs-keyword">if</span>(channel == <span class="hljs-keyword">null</span> || message == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> SystemException(<span class="hljs-string">&quot;手工抛回队列异常，必要数据为空&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">this</span>.channel.basicReject(<span class="hljs-keyword">this</span>.message.getMessageProperties().getDeliveryTag(), <span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(name = &quot;XXXContainer&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> SimpleMessageListenerContainer <span class="hljs-title">XXXMessageListenerContainer</span><span class="hljs-params">(</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Qualifier(&quot;XXXConnectionFactory&quot;)</span> ConnectionFactory connectionFactory,</span></span><br><span class="hljs-function"><span class="hljs-params">        <span class="hljs-meta">@Qualifier(&quot;XXXListener&quot;)</span> ChannelAwareMessageListener cuttingBedChangeListener)</span> </span>&#123;<br>    SimpleMessageListenerContainer container = <span class="hljs-keyword">new</span> SimpleMessageListenerContainer(connectionFactory);<br>    container.setQueues(<span class="hljs-keyword">new</span> Queue(Constant.MES_PIMS_CUTTING_BED_QUEUE, <span class="hljs-keyword">true</span>));<br>    container.setExposeListenerChannel(<span class="hljs-keyword">true</span>);<br>    container.setMaxConcurrentConsumers(<span class="hljs-number">1</span>);<br>    container.setConcurrentConsumers(<span class="hljs-number">1</span>);<br>    container.setAcknowledgeMode(AcknowledgeMode.MANUAL);<br>    container.setMessageListener(cuttingBedChangeListener);<br>    container.setAutoStartup(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">return</span> container;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XXXListener</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMessageListener</span>&lt;<span class="hljs-title">XXXDTO</span>&gt;</span>&#123;<br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">handleMessage</span><span class="hljs-params">(XXXDTO dto)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//业务逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>MQ</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-Redis02-持久化和集群</title>
    <url>/2022/04/04/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/</url>
    <content><![CDATA[<h1 id="Redis持久化"><a href="#Redis持久化" class="headerlink" title="Redis持久化"></a>Redis持久化</h1><h2 id="RDB快照（snapshot）"><a href="#RDB快照（snapshot）" class="headerlink" title="RDB快照（snapshot）"></a>RDB快照（snapshot）</h2><p>​    在默认情况下，Redis将内存数据库快照保存在名字为<strong>dump.rdb</strong>的<strong>二进制</strong>文件中，你可以对Redis进行设置，让它在“N秒内数据集至少有M个改动”这一条件被满足时，自动保存一次数据集。比如说，以下设置会让Redis在满足“60秒内有至少有1000个键被改动”这一条件时，自动保存一次数据集：</p>
<p><strong>save 60 1000</strong></p>
<p>关闭RDB只需要将所有的save保存策略注释掉即可，还可以手动执行命令生成RDB快照，进入redis客户端执行命令save或bgsave可以生成dump.rdb文件，每次命令执行都会将所有redis内存快照到一个新的rdb文件里，并覆盖原有rdb快照文件。save是同步命令，bgsave是异步命令，bgsave会从redis主进程fork（fork()是linux函数）出一个子进程专门用来生成rdb快照文件</p>
<p><strong>save与bgsave对比：</strong></p>
<table>
<thead>
<tr>
<th>命令</th>
<th>save</th>
<th>bgsave</th>
</tr>
</thead>
<tbody><tr>
<td>IO类型</td>
<td>同步</td>
<td>异步</td>
</tr>
<tr>
<td>是否阻塞其他redis命令</td>
<td>阻塞</td>
<td>非阻塞</td>
</tr>
<tr>
<td>复杂度</td>
<td>O(n)</td>
<td>O(n)</td>
</tr>
<tr>
<td>优点</td>
<td>不会消耗额外内存</td>
<td>阻塞客户端命令</td>
</tr>
<tr>
<td>缺点</td>
<td>阻塞客户端命令</td>
<td>需要fork子进程，消耗内存</td>
</tr>
</tbody></table>
<p><strong>配置自动生成rdb文件后台使用的是bgsave方式。</strong></p>
<h2 id="AOF（append-only-file）"><a href="#AOF（append-only-file）" class="headerlink" title="AOF（append-only file）"></a>AOF（append-only file）</h2><p>​    快照功能并不是非常耐久（durable）：如果Redis因为某些原因而造成故障停机，那么服务器将丢失最近写入、且仍未保存到快照中的那些数据。从1.1版本开始，Redis增加了一种完全耐久的持久化方式：AOF持久化，将修改的每一条指令记录进文件appendonly.aof中你可以通过修改配置文件来打开AOF功能：</p>
<p><strong>appendonly yes</strong> </p>
<p>从现在开始，每当Redis执行一个改变数据集的命令时（比如SET），这个命令就会被追加到AOF文件的末尾。这样的话，当Redis重新启动时，程序就可以通过重新执行AOF文件中的命令来达到重建数据集的目的。你可以配置Redis多久才将数据fsync 到磁盘一次。</p>
<p>有三个选项：</p>
<p><strong>appendfsync always</strong>：每次有新命令追加到AOF文件时就执行一次fsync，非常慢，也非常安全。<strong>appendfsync everysec</strong>：每秒fsync一次，足够快（和使用RDB持久化差不多），并且在故障时只会丢失1秒钟的数据。</p>
<p><strong>appendfsync no</strong>：从不fsync，将数据交给操作系统来处理。更快，也更不安全的选择。推荐（并且也是默认）的措施为每秒fsync一次，这种fsync策略可以兼顾速度和安全性。</p>
<h3 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a><strong>AOF重写</strong></h3><p>AOF文件里可能有太多没用指令，所以AOF会定期根据<strong>内存的最新数据</strong>生成aof文件如：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; incr readcount<br>(integer) <span class="hljs-number">1</span><br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; incr readcount<br>(integer) <span class="hljs-number">2</span><br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; incr readcount<br>(integer) <span class="hljs-number">3</span><br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; incr readcount<br>(integer) <span class="hljs-number">4</span><br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; incr readcount<br>(integer) <span class="hljs-number">5</span><br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">6379</span>&gt; bgrewriteaof<br><br>//重写后<br><span class="hljs-built_in">SET</span><br>$<span class="hljs-number">9</span><br>readcount<br>$<span class="hljs-number">1</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>如下两个配置可以控制AOF自动重写频率 </p>
<p><strong>auto-aof-rewrite-min-size 64mb</strong> :aof文件至少要达到64M才会自动重写，文件太小恢复速度本来就很快，重写的意义不大</p>
<p><strong>auto-aof-rewrite-percentage 100</strong> :aof文件自上一次重写后文件大小增长了100%则再次触发重写</p>
<p><strong>bgrewriteaof</strong>:手动触发aof重写，AOF重写redis会fork出一个子进程去做，不会对redis正常命令处理有太多影响</p>
<h2 id="RDB与AOF"><a href="#RDB与AOF" class="headerlink" title="RDB与AOF"></a>RDB与AOF</h2><table>
<thead>
<tr>
<th>命令</th>
<th>RDB</th>
<th>AOF</th>
</tr>
</thead>
<tbody><tr>
<td>启动优先级</td>
<td>低</td>
<td>高</td>
</tr>
<tr>
<td>体积</td>
<td>小</td>
<td>大</td>
</tr>
<tr>
<td>数据恢复速度</td>
<td>快</td>
<td>慢</td>
</tr>
<tr>
<td>数据安全性</td>
<td>容易丢数据</td>
<td>根据策略决定，一般数据较新</td>
</tr>
</tbody></table>
<p>redis启动时如果既有rdb文件又有aof文件则优先选择aof文件恢复数据，因为aof一般来说数据更全一点</p>
<h2 id="Redis-4-0-混合持久化"><a href="#Redis-4-0-混合持久化" class="headerlink" title="Redis 4.0 混合持久化"></a>Redis 4.0 混合持久化</h2><p>重启Redis时，我们很少使用RDB来恢复内存状态，因为会丢失大量数据。我们通常使用AOF日志重放，但是重放AOF日志性能相对RDB来说要慢很多，这样在Redis实例很大的情况下，启动需要花费很长的时间。Redis4.0为了解决这个问题，带来了一个新的持久化选项——混合持久化</p>
<p>通过如下配置可以开启混合持久化：</p>
<p><strong># aof-use-rdb-preamble yes</strong> </p>
<p>​    如果开启了混合持久化，AOF在重写时，不再是单纯将内存数据转换为RESP命令写入AOF文件，而是将重写这一刻之前的内存做RDB快照处理，并且将RDB快照内容和增量的AOF修改内存数据的命令存在一起，都写入新的AOF文件，新的文件一开始不叫appendonly.aof，等到重写完新的AOF文件才会进行改名，原子的覆盖原有的AOF文件，完成新旧两个AOF文件的替换。于是在Redis重启的时候，可以先加载RDB的内容，然后再重放增量AOF日志就可以完全替代之前的AOF全量文件重放，因此重启效率大幅得到提升。</p>
<p>混合持久化AOF文件结构 ：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220405212052206.png" alt="image-20220405212052206"></p>
<h1 id="Redis主从架构"><a href="#Redis主从架构" class="headerlink" title="Redis主从架构"></a>Redis主从架构</h1><img src="/images/分布式-Redis02-持久化和集群/image-20220405215418953.png" alt="image-20220405215418953" style="zoom:50%;">

<h2 id="Redis主从工作原理"><a href="#Redis主从工作原理" class="headerlink" title="Redis主从工作原理"></a>Redis主从工作原理</h2><p>​    如果你为master配置了一个slave，不管这个slave是否是第一次连接上Master，它都会发送一个SYNC命 令(redis2.8版本之前的命令)给master请求复制数据。 </p>
<p>​    master收到SYNC命令后，会在后台进行数据持久化通过bgsave生成最新的rdb快照文件，持久化期间， master会继续接收客户端的请求，它会把这些可能修改数据集的请求缓存在内存中。当持久化进行完毕以 后，master会把这份rdb文件数据集发送给slave，slave会把接收到的数据进行持久化生成rdb，然后再加 载到内存中。然后，master再将之前缓存在内存中的命令发送给slave。 当master与slave之间的连接由于某些原因而断开时，slave能够自动重连Master，如果master收到了多 个slave并发连接请求，它只会进行一次持久化，而不是一个连接一次，然后再把这一份持久化的数据发送 给多个并发连接的slave。 当master和slave断开重连后，一般都会对整份数据进行复制。但从redis2.8版本开始，master和slave断 开重连后支持部分复制。</p>
<h3 id="主从复制-全量复制-流程图"><a href="#主从复制-全量复制-流程图" class="headerlink" title="主从复制(全量复制)流程图"></a>主从复制(全量复制)流程图</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220405220449763.png" alt="image-20220405220449763"></p>
<h3 id="主从复制-部分复制-流程图："><a href="#主从复制-部分复制-流程图：" class="headerlink" title="主从复制(部分复制)流程图："></a>主从复制(部分复制)流程图：</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220405220554914.png" alt="image-20220405220554914"></p>
<h2 id="主从架构搭建"><a href="#主从架构搭建" class="headerlink" title="主从架构搭建"></a>主从架构搭建</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">logfile &quot;<span class="hljs-number">6380</span>.log&quot; <br><span class="hljs-built_in">dir</span> /soft/redis‐<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>/<span class="hljs-number">6380</span> <br>配置主从复制 <br>replicaof <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span> <span class="hljs-number">6379</span> # 从本机<span class="hljs-number">6379</span>的redis实例复制数据 <br>replica‐read‐only yes <br>启动从节点 <br>redis‐server redis.conf <br>连接从节点 <br>redis‐cli ‐p <span class="hljs-number">6380</span> <br>测试在<span class="hljs-number">6379</span>实例上写数据，<span class="hljs-number">6380</span>实例是否能及时同步新修改数据 <br><br>可以自己再配置一个<span class="hljs-number">6381</span>的从节点<br></code></pre></td></tr></table></figure>

<p>启动6379,6380,6381 3个redis实例，主节点可读可写、从节点只可读</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220407214902817.png" alt="image-20220407214902817"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220407215205669.png" alt="image-20220407215205669"></p>
<h1 id="Redis哨兵模式"><a href="#Redis哨兵模式" class="headerlink" title="Redis哨兵模式"></a>Redis哨兵模式</h1><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220407223143755.png" alt="image-20220407223143755"></p>
<p>​    <strong>sentinel哨兵</strong>是特殊的redis服务，不提供读写服务，主要用来监控redis实例节点。 <strong>哨兵架构下client端第一次从哨兵找出redis的主节点，后续就直接访问redis的主节点，不会每次都通过 sentinel代理访问redis的主节点，当redis的主节点发生变化，哨兵会第一时间感知到，并且将新的redis 主节点通知给client端(这里面redis的client端一般都实现了订阅功能，订阅sentinel发布的节点变动消息)</strong></p>
<h2 id="redis哨兵架构搭建步骤"><a href="#redis哨兵架构搭建步骤" class="headerlink" title="redis哨兵架构搭建步骤"></a>redis哨兵架构搭建步骤</h2><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">1</span>、复制一份sentinel.conf文件<br>cp sentinel.conf sentinel‐<span class="hljs-number">26379</span>.conf <br><span class="hljs-number">2</span>、将相关配置修改为如下值：<br>port <span class="hljs-number">26379</span> <br>daemonize yes <br>pidfile &quot;/var/run/redis‐sentinel‐<span class="hljs-number">26379</span>.pid&quot;<br>logfile &quot;/soft/redis-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>/<span class="hljs-number">26379</span>.log&quot; <span class="hljs-number">9</span> <span class="hljs-built_in">dir</span> &quot;/soft/redis-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>/<span class="hljs-number">27369</span>&quot; <br>#sentinel monitor &lt;master‐name&gt; &lt;ip&gt; &lt;redis‐port&gt; &lt;quorum&gt; #quorum是一个数字，指明当有多少个sentinel认为一个master失效时(值一般为：sentinel总数/<span class="hljs-number">2</span> + <span class="hljs-number">1</span>)，master才算真正失效<br>sentinel monitor mymaster <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">0</span>.<span class="hljs-number">60</span> <span class="hljs-number">6379</span> <span class="hljs-number">2</span> <br><span class="hljs-number">3</span>、启动sentinel哨兵实例 <br>src/redis‐sentinel sentinel‐<span class="hljs-number">26379</span>.conf <br><span class="hljs-number">4</span>、查看sentinel的info信息 <br>src/redis‐cli ‐p <span class="hljs-number">26379</span> <span class="hljs-number">19</span> <br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">26379</span>&gt;info <br>可以看到Sentinel的info里已经识别出了redis的主从<br><span class="hljs-number">5</span>、可以自己再配置两个sentinel，端口<span class="hljs-number">26380</span>和<span class="hljs-number">26381</span>，注意上述配置文件里的对应数字都要修改<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220408091050994.png" alt="image-20220408091050994"></p>
<h3 id="Jedis测试代码"><a href="#Jedis测试代码" class="headerlink" title="Jedis测试代码"></a>Jedis测试代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JedisSentinelTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        JedisPoolConfig config = <span class="hljs-keyword">new</span> JedisPoolConfig();<br>        config.setMaxTotal(<span class="hljs-number">20</span>);<br>        config.setMaxIdle(<span class="hljs-number">10</span>);<br>        config.setMinIdle(<span class="hljs-number">5</span>);<br>        String masterName = <span class="hljs-string">&quot;mymaster&quot;</span>;<br>        Set&lt;String&gt; sentinels = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;();<br>        sentinels.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">&quot;192.168.136.1&quot;</span>,<span class="hljs-number">26379</span>).toString());<br>        sentinels.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">&quot;192.168.136.1&quot;</span>,<span class="hljs-number">26380</span>).toString());<br>        sentinels.add(<span class="hljs-keyword">new</span> HostAndPort(<span class="hljs-string">&quot;192.168.136.1&quot;</span>,<span class="hljs-number">26381</span>).toString());<br><br>        <span class="hljs-comment">//JedisSentinelPool其实本质跟JedisPool类似，都是与redis主节点建立的连接池</span><br>        <span class="hljs-comment">//JedisSentinelPool并不是说与sentinel建立的连接池，而是通过sentinel发现redis主节点并与其建立连接</span><br><br>        JedisSentinelPool jedisSentinelPool = <span class="hljs-keyword">new</span> JedisSentinelPool(masterName, sentinels, config, <span class="hljs-number">3000</span>, <span class="hljs-keyword">null</span>);<br>        Jedis jedis = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span>&#123;<br><br>            jedis = jedisSentinelPool.getResource();<br>            System.out.println(jedis.set(<span class="hljs-string">&quot;sentinelKey&quot;</span>, <span class="hljs-string">&quot;sentinelValue&quot;</span>));<br>            System.out.println(jedis.get(<span class="hljs-string">&quot;sentinelKey&quot;</span>));<br>            <span class="hljs-comment">//管道示例</span><br>            <span class="hljs-comment">//管道的命令执行方式：cat redis.txt | redis‐cli ‐h 127.0.0.1 ‐a password ‐ p 6379 ‐‐pipe</span><br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            jedis.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SpringBoot测试代码"><a href="#SpringBoot测试代码" class="headerlink" title="SpringBoot测试代码"></a>SpringBoot测试代码</h3><figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">3000</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">100</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">50</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">1000</span><br>    <span class="hljs-attr">sentinel:</span><br>      <span class="hljs-attr">master:</span> <span class="hljs-string">mymaster</span><br>      <span class="hljs-attr">nodes:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.1</span><span class="hljs-string">:26379,192.168.136.1:26380,192.168.136.1:26381</span><br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestController</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Logger logger = LoggerFactory.getLogger(TestController.class);<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> StringRedisTemplate redisTemplate;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/testSentinel&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSentinel</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-keyword">true</span>)&#123;<br>            redisTemplate.opsForValue().set(<span class="hljs-string">&quot;testSentinel&quot;</span>+i,<span class="hljs-string">&quot;testSentinel&quot;</span>+i);<br>            i++;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="Redis集群模式"><a href="#Redis集群模式" class="headerlink" title="Redis集群模式"></a>Redis集群模式</h1><h2 id="Redis集群方案比较"><a href="#Redis集群方案比较" class="headerlink" title="Redis集群方案比较"></a>Redis集群方案比较</h2><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220410125124943.png" alt="image-20220410125124943"></p>
<p>在redis3.0以前的版本要实现集群一般是借助哨兵sentinel工具来监控master节点的状态，如果master节点异常，则会做主从切换，将某一台slave作为master，哨兵的<strong>配置略微复杂</strong>，并且<strong>性能和高可用性等各方面表现一般</strong>，特别是在主从切换的瞬间存在<strong>访问瞬断</strong>的情况，而且哨兵模式只有一个主节点对外提供服务，没法支持很高的并发，且单个主节点内存也不宜设置得过大，否则会导致<strong>持久化文件过大</strong>，影响数据恢复或主从同步的效率</p>
<p><strong>缺点：</strong></p>
<p>1、主从切换存在访问瞬断</p>
<p>2、单一主节点提供服务，并发量不高，内存存在限制<br>    （一般而言一台Redis 内存不超过4G(内存过大会导致持久化文件过大)，最大连接数不超过10W）</p>
<p>3、配置略微复杂</p>
<p><strong>优点：</strong></p>
<p>1、主节点故障时支持主从切换</p>
<h3 id="高可用的集群模式"><a href="#高可用的集群模式" class="headerlink" title="高可用的集群模式"></a>高可用的集群模式</h3><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220410125706773.png" alt="image-20220410125706773"></p>
<p>redis集群是一个<strong>由多个主从节点群组成的分布式服务器群</strong>，它具有<strong>复制</strong>、<strong>高可用</strong>和<strong>分片</strong>特性。Redis集群不需要sentinel哨兵也能完成节点移除和故障转移的功能。需要将每个节点设置成集群模式，这种集群模式没有中心节点，可<strong>水平扩展</strong>，据官方文档称可以线性扩展到上万个节点(<strong>官方推荐不超过1000个节点</strong>)。redis集群的性能和高可用性均优于之前版本的哨兵模式，且集群配置非常简单 </p>
<p><strong>优点：</strong></p>
<p>1、配置简单</p>
<p>2、访问瞬断影响范围小（某个主节点A挂了，A节点切换主从时只会暂时影响路由到该节点的请求，其他请求正常）</p>
<p>3、集群提供服务：高吞吐，支持水平拓展</p>
<h2 id="Redis高可用集群搭建"><a href="#Redis高可用集群搭建" class="headerlink" title="Redis高可用集群搭建"></a>Redis高可用集群搭建</h2><p>redis集群需要至少三个master节点，我们这里搭建三个master节点，并且给每个master再搭建一个slave节点，总共6个redis节点，这里用三台机器部署6个redis实例，每台机器一主一从，搭建集群的步骤如下：</p>
<p>配置第一台</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">进入/soft/redis-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span><br>第一步：在第一台机器的/usr/local下创建文件夹redis-cluster，然后在其下面分别创建<span class="hljs-number">2</span>个文件夾如下<br>（<span class="hljs-number">1</span>）<span class="hljs-built_in">mkdir</span> <span class="hljs-number">8001</span> <span class="hljs-number">8004</span><br><br>第二步：把之前的redis-<span class="hljs-number">7369</span>.conf复制为redis-cluster-<span class="hljs-number">8001</span>.conf，修改如下内容：<br>（<span class="hljs-number">1</span>）daemonize yes<br>（<span class="hljs-number">2</span>）port <span class="hljs-number">8001</span>（分别对每个机器的端口号进行设置）<br>（<span class="hljs-number">3</span>）pidfile /soft/redis-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>/redis_8001.pid  # 把pid进程号写入pidfile配置的文件<br>（<span class="hljs-number">4</span>）<span class="hljs-built_in">dir</span> /soft/redis-<span class="hljs-number">5</span>.<span class="hljs-number">0</span>.<span class="hljs-number">3</span>/<span class="hljs-number">8001</span>/（指定数据文件存放位置，必须要指定不同的目录位置，不然会丢失数据）<br>（<span class="hljs-number">5</span>）cluster-enabled yes（启动集群模式）<br>（<span class="hljs-number">6</span>）cluster-config-file nodes-<span class="hljs-number">8001</span>.conf（集群节点信息文件，这里<span class="hljs-number">800</span>x最好和port对应上）<br>（<span class="hljs-number">7</span>）cluster-node-timeout <span class="hljs-number">10000</span><br> (<span class="hljs-number">8</span>)# bind <span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>（bind绑定的是自己机器网卡的ip，如果有多块网卡可以配多个ip，代表允许客户端通过机器的哪些网卡ip去访问，内网一般可以不配置bind，注释掉即可）<br> (<span class="hljs-number">9</span>)protected-<span class="hljs-built_in">mode</span>  no   （关闭保护模式）<br> (<span class="hljs-number">10</span>)appendonly yes<br>如果要设置密码需要增加如下配置：<br> (<span class="hljs-number">11</span>)requirepass <span class="hljs-number">12345</span>     (设置redis访问密码)<br> (<span class="hljs-number">12</span>)masterauth <span class="hljs-number">12345</span>      (设置集群节点间访问密码，跟上面一致)<br><br>第三步：把修改后的配置文件，<span class="hljs-built_in">copy</span>到<span class="hljs-number">8004</span>，修改第<span class="hljs-number">2</span>、<span class="hljs-number">3</span>、<span class="hljs-number">4</span>、<span class="hljs-number">6</span>项里的端口号，可以用批量替换：<br>:%s/源字符串/目的字符串/g <br><br>第四步：另外两台机器也需要做上面几步操作，第二台机器用<span class="hljs-number">8002</span>和<span class="hljs-number">8005</span>，第三台机器用<span class="hljs-number">8003</span>和<span class="hljs-number">8006</span><br><br>第五步：分别启动<span class="hljs-number">6</span>个redis实例，然后检查是否启动成功<br>（<span class="hljs-number">1</span>）redis-server /usr/local/redis-cluster/<span class="hljs-number">800</span>*/redis.conf<br>（<span class="hljs-number">2</span>）ps -ef | grep redis 查看是否启动成功<br>    <br>第六步：用redis-cli创建整个redis集群(redis5以前的版本集群是依靠ruby脚本redis-trib.rb实现)<br># 下面命令里的<span class="hljs-number">1</span>代表为每个创建的主服务器节点创建一个从服务器节点<br># 执行这条命令需要确认三台机器之间的redis实例要能相互访问，可以先简单把所有机器防火墙关掉，如果不关闭防火墙则需要打开redis服务端口和集群节点gossip通信端口<span class="hljs-number">16379</span>(默认是在redis端口号上加<span class="hljs-number">1</span>W)<br># 关闭防火墙<br># systemctl stop firewalld # 临时关闭防火墙<br># systemctl disable firewalld # 禁止开机启动<br># 注意：下面这条创建集群的命令大家不要直接复制，里面的空格编码可能有问题导致创建集群不成功<br>（<span class="hljs-number">1</span>）redis-cli -a <span class="hljs-number">12345</span> --cluster create --cluster-replicas <span class="hljs-number">1</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span>:<span class="hljs-number">8002</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">3</span>:<span class="hljs-number">8003</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8004</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span>:<span class="hljs-number">8005</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">3</span>:<span class="hljs-number">8006</span> <br><br>第七步：验证集群：<br>（<span class="hljs-number">1</span>）连接任意一个客户端即可：./redis-cli -c -h -p (-a访问服务端密码，-c表示集群模式，指定ip地址和端口号）<br>    如：redis-cli -a <span class="hljs-number">12345</span> -c -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span> -p <span class="hljs-number">800</span>*<br>（<span class="hljs-number">2</span>）进行验证： cluster info（查看集群信息）、cluster nodes（查看节点列表）<br><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span>&gt;cluster info<br><span class="hljs-function">cluster_state:<span class="hljs-title">ok</span></span><br><span class="hljs-function"><span class="hljs-title">cluster_slots_assigned</span>:16384</span><br><span class="hljs-function"><span class="hljs-title">cluster_slots_ok</span>:16384</span><br><span class="hljs-function"><span class="hljs-title">cluster_slots_pfail</span>:0</span><br><span class="hljs-function"><span class="hljs-title">cluster_slots_fail</span>:0</span><br><span class="hljs-function"><span class="hljs-title">cluster_known_nodes</span>:6</span><br><span class="hljs-function"><span class="hljs-title">cluster_size</span>:3</span><br><span class="hljs-function"><span class="hljs-title">cluster_current_epoch</span>:6</span><br><span class="hljs-function"><span class="hljs-title">cluster_my_epoch</span>:1</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_ping_sent</span>:222</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_pong_sent</span>:224</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_sent</span>:446</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_ping_received</span>:219</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_pong_received</span>:222</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_meet_received</span>:5</span><br><span class="hljs-function"><span class="hljs-title">cluster_stats_messages_received</span>:446</span><br><span class="hljs-function"></span><br><span class="hljs-function">127.0.0.1:8001&gt; <span class="hljs-title">cluster</span> <span class="hljs-title">nodes</span></span><br><span class="hljs-function">71<span class="hljs-title">f22e18856c6f6084cf8a21beaf3d0f8fa5c781</span> 192.168.136.3:8006@18006 <span class="hljs-title">slave</span> 687<span class="hljs-title">ccdac68ef3ea3ef2141817ffcdbf8ffc1d62a</span> 0 1649599402000 6 <span class="hljs-title">connected</span></span><br><span class="hljs-function"><span class="hljs-title">db58daf98f0db426e7a079a72ab0fe8fdee36718</span> 192.168.136.2:8005@18005 <span class="hljs-title">slave</span> 09<span class="hljs-title">b4cef366fe5786f8e5a887de316d81a793982a</span> 0 1649599403019 5 <span class="hljs-title">connected</span></span><br><span class="hljs-function">09<span class="hljs-title">b4cef366fe5786f8e5a887de316d81a793982a</span> 192.168.136.1:8001@18001 <span class="hljs-title">myself</span>,<span class="hljs-title">master</span> - 0 1649599401000 1 <span class="hljs-title">connected</span> 0-5460</span><br><span class="hljs-function">687<span class="hljs-title">ccdac68ef3ea3ef2141817ffcdbf8ffc1d62a</span> 192.168.136.2:8002@18002 <span class="hljs-title">master</span> - 0 1649599402000 2 <span class="hljs-title">connected</span> 5461-10922</span><br><span class="hljs-function">24<span class="hljs-title">c1c961d5a9b23b3f7fb670060a41dac253a0f1</span> 192.168.136.1:8004@18004 <span class="hljs-title">slave</span> 7<span class="hljs-title">bea82570c2568a0bfcbe0f91aafa8d908dfb5ce</span> 0 1649599400000 4 <span class="hljs-title">connected</span></span><br><span class="hljs-function">7<span class="hljs-title">bea82570c2568a0bfcbe0f91aafa8d908dfb5ce</span> 192.168.136.3:8003@18003 <span class="hljs-title">master</span> - 0 1649599403000 3 <span class="hljs-title">connected</span> 10923-16383</span><br><span class="hljs-function">（3）进行数据操作验证</span><br><span class="hljs-function">127.0.0.1:8001&gt; <span class="hljs-title">keys</span> * </span><br><span class="hljs-function">(<span class="hljs-title">empty</span> <span class="hljs-title">list</span> <span class="hljs-title">or</span> <span class="hljs-title">set</span>)</span><br><span class="hljs-function">127.0.0.1:8001&gt; <span class="hljs-title">set</span> <span class="hljs-title">key1</span> <span class="hljs-title">value1</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">Redirected</span> <span class="hljs-title">to</span> <span class="hljs-title">slot</span> [9189] <span class="hljs-title">located</span> <span class="hljs-title">at</span> 192.168.136.2:8002</span><br><span class="hljs-function"><span class="hljs-title">OK</span></span><br><span class="hljs-function">192.168.136.2:8002&gt; <span class="hljs-title">set</span> <span class="hljs-title">key2</span> <span class="hljs-title">value2</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">Redirected</span> <span class="hljs-title">to</span> <span class="hljs-title">slot</span> [4998] <span class="hljs-title">located</span> <span class="hljs-title">at</span> 192.168.136.1:8001</span><br><span class="hljs-function"><span class="hljs-title">OK</span></span><br><span class="hljs-function">192.168.136.1:8001&gt; <span class="hljs-title">set</span> <span class="hljs-title">key3</span> <span class="hljs-title">value3</span></span><br><span class="hljs-function"><span class="hljs-title">OK</span></span><br><span class="hljs-function">192.168.136.1:8001&gt; <span class="hljs-title">set</span> <span class="hljs-title">key4</span> <span class="hljs-title">value4</span></span><br><span class="hljs-function">-&gt; <span class="hljs-title">Redirected</span> <span class="hljs-title">to</span> <span class="hljs-title">slot</span> [13120] <span class="hljs-title">located</span> <span class="hljs-title">at</span> 192.168.136.3:8003</span><br><span class="hljs-function"><span class="hljs-title">OK</span></span><br><span class="hljs-function">192.168.136.3:8003&gt; </span><br><span class="hljs-function"></span><br><span class="hljs-function">（4）关闭集群则需要逐个进行关闭，使用命令：</span><br><span class="hljs-function"><span class="hljs-title">redis</span>-<span class="hljs-title">cli</span> -<span class="hljs-title">a</span> 12345 -<span class="hljs-title">c</span> -<span class="hljs-title">h</span> 192.168.0.60 -<span class="hljs-title">p</span> 800* <span class="hljs-title">shutdown</span></span><br></code></pre></td></tr></table></figure>

<p><strong>VMWare克隆Centos镜像</strong></p>
<p>192.168.136.1实例的镜像为192.168.136.2,192.168.136.3</p>
<p>复制VMware 虚拟机（<a href="https://blog.csdn.net/qq_42339115/article/details/117919290">静态ip配置参考</a>）</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"># 配置静态ip<br>systemctl stop NetworkManager<br>systemctl disable NetworkManager<br>vim /etc/sysconfig/network-scripts/ifcfg-ens33<br>内容如下 删除UUID这行<br><span class="hljs-built_in">TYPE</span>=&quot;Ethernet&quot;<br>PROXY_METHOD=&quot;none&quot;<br>BROWSER_ONLY=&quot;no&quot;<br>BOOTPROTO=&quot;static&quot;<br>DEFROUTE=&quot;yes&quot;<br>IPV4_FAILURE_FATAL=&quot;no&quot;<br>IPV6INIT=&quot;yes&quot;<br>IPV6_AUTOCONF=&quot;yes&quot;<br>IPV6_DEFROUTE=&quot;yes&quot;<br>IPV6_FAILURE_FATAL=&quot;no&quot;<br>IPV6_ADDR_GEN_MODE=&quot;stable-privacy&quot;<br>NAME=&quot;ens33&quot;<br>#UUID=&quot;f8e1b7b3-<span class="hljs-number">4</span>aaf-<span class="hljs-number">487</span>a-<span class="hljs-number">9</span>c91-a883fe938397&quot;<br>DEVICE=&quot;ens33&quot;<br>ONBOOT=&quot;yes&quot;<br>IPADDR=<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span><br>NETMASK=<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">255</span>.<span class="hljs-number">0</span><br>GATEWAY=<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span><br>DNS1=<span class="hljs-number">114</span>.<span class="hljs-number">114</span>.<span class="hljs-number">114</span>.<span class="hljs-number">114</span><br><br>#重启网卡<br>service network restart<br></code></pre></td></tr></table></figure>

<h2 id="Java操作redis集群"><a href="#Java操作redis集群" class="headerlink" title="Java操作redis集群"></a>Java操作redis集群</h2><h3 id="Jedis"><a href="#Jedis" class="headerlink" title="Jedis"></a>Jedis</h3><figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">public class JedisClusterTest &#123;<br>    public static void main(String[] args) &#123;<br>        JedisPoolConfig config = new JedisPoolConfig();<br>        config.setMaxTotal(<span class="hljs-number">20</span>);<br>        config.setMaxIdle(<span class="hljs-number">10</span>);<br>        config.setMinIdle(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">Set</span>&lt;HostAndPort&gt; hostAndPorts = new HashSet&lt;&gt;();<br>        hostAndPorts.add(new HostAndPort(&quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>&quot;,<span class="hljs-number">8001</span>));<br>        hostAndPorts.add(new HostAndPort(&quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>&quot;,<span class="hljs-number">8004</span>));<br>        hostAndPorts.add(new HostAndPort(&quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span>&quot;,<span class="hljs-number">8002</span>));<br>        hostAndPorts.add(new HostAndPort(&quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span>&quot;,<span class="hljs-number">8005</span>));<br>        hostAndPorts.add(new HostAndPort(&quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">3</span>&quot;,<span class="hljs-number">8003</span>));<br>        hostAndPorts.add(new HostAndPort(&quot;<span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">4</span>&quot;,<span class="hljs-number">8006</span>));<br>        JedisCluster jedisCluster = null;<br>        try &#123;<br>            jedisCluster= new JedisCluster(hostAndPorts,<span class="hljs-number">6000</span>,<span class="hljs-number">5000</span>,<span class="hljs-number">10</span>,&quot;<span class="hljs-number">12345</span>&quot;,config);<br>            jedisCluster.<span class="hljs-built_in">set</span>(&quot;clusterKey&quot;,&quot;clusterValue&quot;);<br>            System.out.println(jedisCluster.get(&quot;clusterKey&quot;));<br>        &#125;catch (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;finally &#123;<br>            jedisCluster.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/testCluster&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCluster</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>    stringRedisTemplate.opsForValue().set(<span class="hljs-string">&quot;testClusterKey&quot;</span>,<span class="hljs-string">&quot;testClusterValue&quot;</span>);<br>    System.out.println(stringRedisTemplate.opsForValue().get(<span class="hljs-string">&quot;testClusterKey&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight yml"><table><tr><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">database:</span> <span class="hljs-number">0</span><br>    <span class="hljs-attr">timeout:</span> <span class="hljs-number">3000</span><br>    <span class="hljs-attr">lettuce:</span><br>      <span class="hljs-attr">pool:</span><br>        <span class="hljs-attr">max-active:</span> <span class="hljs-number">100</span><br>        <span class="hljs-attr">max-idle:</span> <span class="hljs-number">50</span><br>        <span class="hljs-attr">min-idle:</span> <span class="hljs-number">10</span><br>        <span class="hljs-attr">max-wait:</span> <span class="hljs-number">1000</span><br>    <span class="hljs-attr">cluster:</span><br>      <span class="hljs-attr">nodes:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.1</span><span class="hljs-string">:8001,192.168.136.2:8002,192.168.136.3:8003,192.168.136.1:8004,192.168.136.2:8005,192.168.136.3:8006</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-number">12345</span><br></code></pre></td></tr></table></figure>

<h2 id="Redis集群原理分析"><a href="#Redis集群原理分析" class="headerlink" title="Redis集群原理分析"></a>Redis集群原理分析</h2><p>Redis Cluster 将所有数据划分为 16384 个 slots(槽位)，每个节点负责其中一部分槽位。槽位的信息存储于每个节点中。</p>
<p>当 Redis Cluster 的客户端来连接集群时，它也会得到一份集群的槽位配置信息并将其缓存在客户端本地。这样当客户端要查找某个 key 时，可以直接定位到目标节点。同时因为槽位的信息可能会存在客户端与服务器不一致的情况，还需要纠正机制来实现槽位信息的校验调整。</p>
<p><strong>槽位定位算法</strong></p>
<p>Cluster 默认会对 key 值使用 crc16 算法进行 hash 得到一个整数值，然后用这个整数值对 16384 进行取模来得到具体槽位。</p>
<p>HASH_SLOT = CRC16(key) mod 16384</p>
<p><strong>跳转重定位</strong></p>
<p>当客户端向一个错误的节点发出了指令，该节点会发现指令的 key 所在的槽位并不归自己管理，这时它会向客户端发送一个特殊的跳转指令携带目标操作的节点地址，告诉客户端去连这个节点去获取数据。客户端收到指令后除了跳转到正确的节点上去操作，还会同步更新纠正本地的槽位映射表缓存，后续所有 key 将使用新的槽位映射表。</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd"><span class="hljs-number">127</span>.<span class="hljs-number">0</span>.<span class="hljs-number">0</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span>&gt; <span class="hljs-built_in">set</span> key1 value1<br>-&gt; Redirected to slot [<span class="hljs-number">9189</span>] located <span class="hljs-built_in">at</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span>:<span class="hljs-number">8002</span><br>OK<br><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">2</span>:<span class="hljs-number">8002</span>&gt; <span class="hljs-built_in">set</span> key2 value2<br>-&gt; Redirected to slot [<span class="hljs-number">4998</span>] located <span class="hljs-built_in">at</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span><br>OK<br></code></pre></td></tr></table></figure>

<h3 id="Redis集群节点间的通信机制"><a href="#Redis集群节点间的通信机制" class="headerlink" title="Redis集群节点间的通信机制"></a>Redis集群节点间的通信机制</h3><p>redis cluster节点间采取gossip协议进行通信 </p>
<ul>
<li>维护集群的元数据(集群节点信息，主从角色，节点数量，各节点共享的数据等)有两种方式：集中式和gossip </li>
</ul>
<p><strong>集中式：</strong> </p>
<p>优点在于元数据的更新和读取，时效性非常好，一旦元数据出现变更立即就会更新到集中式的存储中，其他节点读取的时候立即就可以立即感知到；不足在于所有的元数据的更新压力全部集中在一个地方，可能导致元数据的存储压力。 很多中间件都会借助<strong>zookeeper</strong>集中式存储元数据。</p>
<p><strong>gossip：</strong></p>
<p>gossip协议包含多种消息，包括ping，pong，meet，fail等等。 </p>
<p><strong>meet</strong>：某个节点发送meet给新加入的节点，让新节点加入集群中，然后新节点就会开始与其他节点进行通信；</p>
<p><strong>ping</strong>：每个节点都会频繁给其他节点发送ping，其中包含自己的状态还有自己维护的集群元数据，互相通过ping交换元数据(类似自己感知到的集群节点增加和移除，hash slot信息等)； </p>
<p><strong>pong</strong>: 对ping和meet消息的返回，包含自己的状态和其他信息，也可以用于信息广播和更新； </p>
<p><strong>fail</strong>: 某个节点判断另一个节点fail之后，就发送fail给其他节点，通知其他节点，指定的节点宕机了。</p>
<p>gossip协议的优点在于元数据的更新比较分散，不是集中在一个地方，更新请求会陆陆续续，打到所有节点上去更新，有一定的延时，降低了压力；缺点在于元数据更新有延时可能导致集群的一些操作会有一些滞后。</p>
<p><strong>gossip通信的10000端口</strong> </p>
<p>每个节点都有一个专门用于节点间gossip通信的端口，就是自己提供服务的端口号+10000，比如7001，那么用于节点间通信的就是17001端口。 每个节点每隔一段时间都会往另外几个节点发送ping消息，同时其他几点接收到ping消息之后返回pong消息。</p>
<p><strong>网络抖动</strong></p>
<p>真实世界的机房网络往往并不是风平浪静的，它们经常会发生各种各样的小问题。比如网络抖动就是非常常见的一种现象，突然之间部分连接变得不可访问，然后很快又恢复正常。</p>
<p>为解决这种问题，Redis Cluster 提供了一种选项cluster-node-timeout，表示当某个节点持续 timeout 的时间失联时，才可以认定该节点出现故障，需要进行主从切换。如果没有这个选项，网络抖动会导致主从频繁切换 (数据的重新复制)。</p>
<h3 id="Redis集群选举原理分析"><a href="#Redis集群选举原理分析" class="headerlink" title="Redis集群选举原理分析"></a><strong>Redis集群选举原理分析</strong></h3><p>当slave发现自己的master变为FAIL状态时，便尝试进行Failover，以期成为新的master。由于挂掉的master可能会有多个slave，从而存在多个slave竞争成为master节点的过程， 其过程如下：</p>
<p>1.slave发现自己的master变为FAIL</p>
<p>2.将自己记录的集群currentEpoch加1，并广播FAILOVER_AUTH_REQUEST 信息</p>
<p>3.其他节点收到该信息，只有master响应，判断请求者的合法性，并发送FAILOVER_AUTH_ACK，对每一个epoch只发送一次ack</p>
<p>4.尝试failover的slave收集master返回的FAILOVER_AUTH_ACK</p>
<p>5.slave收到超过半数master的ack后变成新Master(这里解释了集群为什么至少需要三个主节点，如果只有两个，当其中一个挂了，只剩一个主节点是不能选举成功的)</p>
<p>6.slave广播Pong消息通知其他集群节点。</p>
<p>从节点并不是在主节点一进入 FAIL 状态就马上尝试发起选举，而是有一定延迟，一定的延迟确保我们等待FAIL状态在集群中传播，slave如果立即尝试选举，其它masters或许尚未意识到FAIL状态，可能会拒绝投票</p>
<p>•<strong>延迟计算公式</strong>：</p>
<p> DELAY = 500ms + random(0 ~ 500ms) + SLAVE_RANK * 1000ms</p>
<p>•SLAVE_RANK表示此slave已经从master复制数据的总量的rank。Rank越小代表已复制的数据越新。这种方式下，<strong>持有最新数据的slave将会首先发起选举（理论上）</strong>。</p>
<p><strong>集群脑裂数据丢失问题</strong></p>
<p>redis集群没有过半机制会有脑裂问题，网络分区导致脑裂后多个主节点对外提供写服务，一旦网络分区恢复，会将其中一个主节点变为从节点，这时会有大量数据丢失。</p>
<p>规避方法可以在redis配置里加上参数(这种方法不可能百分百避免数据丢失，参考集群leader选举机制)：</p>
<p>​                min-replicas-to-write 1 //写数据成功最少同步的slave数量，这个数量可以模仿大于半数机制配置，比如集群总共三个节点可以配置1，加上leader就是2，超过了半数              </p>
<p><strong>注意</strong>：这个配置在一定程度上会影响集群的可用性，比如slave要是少于1个，这个集群就算leader正常也不能提供服务了，需要具体场景权衡选择。</p>
<p><strong>集群是否完整才能对外提供服务</strong></p>
<p>当redis.conf的配置cluster-require-full-coverage为no时，表示当负责一个插槽的主库下线且没有相应的从库进行故障恢复时，集群仍然可用，如果为yes则集群不可用。</p>
<p><strong>Redis集群为什么至少需要三个master节点，并且推荐节点数为奇数？</strong></p>
<p>因为新master的选举需要大于半数的集群master节点同意才能选举成功，如果只有两个master节点，当其中一个挂了，是达不到选举新master的条件的。</p>
<p> 奇数个master节点可以在满足选举该条件的基础上节省一个节点，比如三个master节点和四个master节点的集群相比，大家如果都挂了一个master节点都能选举新master节点，如果都挂了两个master节点都没法选举新master节点了，所以奇数的master节点更多的是==<strong>从节省机器资源角度出发</strong>==说的。</p>
<p><strong>Redis集群对批量操作命令的支持</strong></p>
<p>对于类似mset，mget这样的多个key的原生批量操作命令，redis集群只支持所有key落在同一slot的情况，如果有多个key一定要用mset命令在redis集群上操作，则可以在key的前面加上{XX}，这样参数数据分片hash计算的只会是大括号里的值，这样能确保不同的key能落到同一slot里去，示例如下：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">mset &#123;user1&#125;:<span class="hljs-number">1</span>:name <span class="hljs-number">12345</span> &#123;user1&#125;:<span class="hljs-number">1</span>:age <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure>

<p>假设name和age计算的hash slot值不一样，但是这条命令在集群下执行，redis只会用大括号里的 user1 做hash slot计算，所以算出来的slot值肯定相同，最后都能落在同一slot。</p>
<p><strong>哨兵leader选举流程</strong></p>
<p>当一个master服务器被某sentinel视为下线状态后，该sentinel会与其他sentinel协商选出sentinel的leader进行故障转移工作。每个发现master服务器进入下线的sentinel都可以要求其他sentinel选自己为sentinel的leader，选举是先到先得。同时每个sentinel每次选举都会自增配置纪元(选举周期)，每个纪元中只会选择一个sentinel的leader。如果所有超过一半的sentinel选举某sentinel作为leader。之后该sentinel进行故障转移操作，从存活的slave中选举出新的master，这个选举过程跟集群的master选举很类似。</p>
<p>哨兵集群只有一个哨兵节点，redis的主从也能正常运行以及选举master，如果master挂了，那唯一的那个哨兵节点就是哨兵leader了，可以正常选举新master。</p>
<p>不过为了高可用一般都推荐至少部署三个哨兵节点。为什么推荐奇数个哨兵节点原理跟集群奇数个master节点类似。</p>
<h3 id="Redis集群水平扩展"><a href="#Redis集群水平扩展" class="headerlink" title="Redis集群水平扩展"></a>Redis集群水平扩展</h3><p>Redis3.0以后的版本虽然有了集群功能，提供了比之前版本的哨兵模式更高的性能与可用性，但是集群的水平扩展却比较麻烦，今天就来带大家看看redis高可用集群如何做水平扩展，原始集群(见下图)由6个节点组成，6个节点分布在三台机器上，采用三主三从的模式</p>
<p>   <img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411085210207.png" alt="image-20220411085210207"></p>
<p><strong>1、启动集群</strong></p>
<p># 启动整个集群</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">redis-server redis-cluster-<span class="hljs-number">8001</span>.conf<br>redis-server redis-cluster-<span class="hljs-number">8002</span>.conf<br>redis-server redis-cluster-<span class="hljs-number">8003</span>.conf<br>redis-server redis-cluster-<span class="hljs-number">8004</span>.conf<br>redis-server redis-cluster-<span class="hljs-number">8005</span>.conf<br>redis-server redis-cluster-<span class="hljs-number">8006</span>.conf<br></code></pre></td></tr></table></figure>



<p># 客户端连接8001端口的redis实例</p>
<p>redis-cli -a 12345 -c -h 8001域名 -p 8001              </p>
<p># 查看集群状态</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411085223187.png" alt="image-20220411085223187"></p>
<p> 从上图可以看出，整个集群运行正常，三个master节点和三个slave节点，8001端口的实例节点存储0-5460这些hash槽，8002端口的实例节点存储5461-10922这些hash槽，8003端口的实例节点存储10923-16383这些hash槽，这三个master节点存储的所有hash槽组成redis集群的存储槽位，slave点是每个主节点的备份从节点，不显示存储槽位  </p>
<p><strong>2、集群操作</strong></p>
<p>我们在原始集群基础上再增加一主(8007)一从(8008)，增加节点后的集群参见下图，新增节点用虚线框表示</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411085245118.png" alt="image-20220411085245118"></p>
<ul>
<li><strong>增加redis实例</strong></li>
</ul>
<p>在8001机器上创建8007，8008实例，参考上面内容     </p>
<ul>
<li> <strong>查看redis集群的命令帮助</strong></li>
</ul>
<p>​        cd /usr/local/redis-5.0.3 src/redis-cli –cluster help              </p>
 <img src="/images/分布式-Redis02-持久化和集群/image-20220411085508108.png" alt="image-20220411085508108" style="zoom: 80%;">

<p>1.create：创建一个集群环境host1:port1 … hostN:portN</p>
<p>2.call：可以执行redis命令</p>
<p>3.add-node：将一个节点添加到集群里，第一个参数为新节点的ip:port，第二个参数为集群中任意一个已经存在的节点的ip:port </p>
<p>4.del-node：移除一个节点</p>
<p>5.reshard：重新分片</p>
<p>6.check：检查集群状态 </p>
<ul>
<li><strong>配置8007为集群主节点</strong></li>
</ul>
<p># 使用add-node命令新增一个主节点8007(master)，前面的ip:port为新增节点，后面的ip:port为已知存在节点，看到日志最后有”[OK] New node added correctly”提示代表新节点加入成功</p>
 <figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">redis-cli -a <span class="hljs-number">12345</span> --cluster add-node <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8007</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span>              <br></code></pre></td></tr></table></figure>

<p># 查看集群状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">redis-cli -a <span class="hljs-number">12345</span> -c -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span> -p <span class="hljs-number">8001</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span>&gt; cluster nodes<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411091336869.png" alt="image-20220411091336869"></p>
<p>注意：当添加节点成功以后，新增的节点不会有任何数据，因为它还没有分配任何的slot(hash槽)，我们需要为新节点手工分配hash槽</p>
<p># 使用redis-cli命令为8007分配hash槽，找到集群中的任意一个主节点，对其进行重新分片工作            </p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">redis-cli -a zhuge --cluster reshard <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span> <br></code></pre></td></tr></table></figure>

<p>输出如下：</p>
<p>… …</p>
<p>How many slots do you want to move (from 1 to 16384)? <strong>600</strong></p>
<p>(ps:需要多少个槽移动到新的节点上，自己设置，比如600个hash槽)</p>
<p>What is the receiving node ID? <strong>2728a594a0498e98e4b83a537e19f9a0a3790f38</strong></p>
<p>(ps:把这600个hash槽移动到哪个节点上去，需要指定节点id)</p>
<p>Please enter all the source node IDs.</p>
<p> Type ‘all’ to use all the nodes as source nodes for the hash slots.</p>
<p> Type ‘done’ once you entered all the source nodes IDs.</p>
<p>Source node 1:<strong>all</strong></p>
<p>(ps:输入all为从所有主节点(8001,8002,8003)中分别抽取相应的槽数指定到新节点中，抽取的总槽数为600个)</p>
<p> … …</p>
<p>Do you want to proceed with the proposed reshard plan (yes/no)? <strong>yes</strong></p>
<p>(ps:输入yes确认开始执行分片任务)</p>
<p>… …</p>
<p># 查看下最新的集群状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">src/redis-cli -a zhuge -c -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span> -p <span class="hljs-number">8001</span> <br><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span>&gt; cluster nodes<br></code></pre></td></tr></table></figure>



<p>如上图所示，现在我们的8007已经有hash槽了，也就是说可以在8007上进行读写数据啦！到此为止我们的8007已经加入到集群中，并且是主节点(Master)</p>
<ul>
<li><strong>配置8008为8007的从节点</strong></li>
</ul>
<p># 添加从节点8008到集群中去并查看集群状态</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">redis-cli -a <span class="hljs-number">12345</span> --cluster add-node <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8008</span> <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8001</span>        <br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411092207999.png" alt="image-20220411092207999"></p>
<p>如图所示，还是一个master节点，没有被分配任何的hash槽。</p>
<p># 我们需要执行replicate命令来指定当前节点(从节点)的主节点id为哪个,首先需要连接新加的8008节点的客户端，然后使用集群命令进行操作，把当前的8008(slave)节点指定到一个主节点下(这里使用之前创建的8007主节点)</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><code class="hljs cmd">src/redis-cli -a zhuge -c -h <span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span> -p <span class="hljs-number">8008</span> <br><span class="hljs-number">192</span>.<span class="hljs-number">168</span>.<span class="hljs-number">136</span>.<span class="hljs-number">1</span>:<span class="hljs-number">8008</span>&gt; cluster replicate <span class="hljs-number">2728</span>a594a0498e98e4b83a537e19f9a0a3790f38  #后面这串id为<span class="hljs-number">8007</span>的节点id         <br></code></pre></td></tr></table></figure>

<p># 查看集群状态，8008节点已成功添加为8007节点的从节点</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411092342046.png" alt="image-20220411092342046"></p>
<ul>
<li> <strong>删除8008从节点</strong></li>
</ul>
<p># 用del-node删除从节点8008，指定删除节点ip和端口，以及节点id(红色为8008节点id)</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redis</span>-cli -a <span class="hljs-number">12345</span> --cluster del-node <span class="hljs-number">192.168.136.1:8008</span> a<span class="hljs-number">1</span>cfe<span class="hljs-number">35722</span>d<span class="hljs-number">151</span>cf<span class="hljs-number">70585</span>cee<span class="hljs-number">21275565393</span>c<span class="hljs-number">0956</span>              <br></code></pre></td></tr></table></figure>

<p># 再次查看集群状态，如下图所示，8008这个slave节点已经移除，并且该节点的redis服务也已被停止</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411092451299.png" alt="image-20220411092451299"></p>
<ul>
<li><strong>删除8007主节点</strong></li>
</ul>
<p>最后，我们尝试删除之前加入的主节点8007，这个步骤相对比较麻烦一些，因为主节点的里面是有分配了hash槽的，所以我们这里必须先把8007里的hash槽放入到其他的可用主节点中去，然后再进行移除节点操作，不然会出现数据丢失问题(目前只能把master的数据迁移到一个节点上，暂时做不了平均分配功能)，执行命令如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">/usr/</span>local<span class="hljs-regexp">/redis-5.0.3/</span>src/redis-cli -a <span class="hljs-number">12345</span> --cluster reshard <span class="hljs-number">192.168</span>.<span class="hljs-number">136.1</span>:<span class="hljs-number">8007</span><br></code></pre></td></tr></table></figure>

<p>输出如下</p>
<p> … …</p>
<p>How many slots do you want to move (from 1 to 16384)? <strong>600</strong></p>
<p>What is the receiving node ID? <strong>dfca1388f124dec92f394a7cc85cf98cfa02f86f</strong></p>
<p>(ps:这里是需要把数据移动到哪？8001的主节点id)</p>
<p>Please enter all the source node IDs.</p>
<p> Type ‘all’ to use all the nodes as source nodes for the hash slots.</p>
<p> Type ‘done’ once you entered all the source nodes IDs.</p>
<p>Source node 1:<strong>2728a594a0498e98e4b83a537e19f9a0a3790f38</strong></p>
<p>(ps:这里是需要数据源，也就是我们的8007节点id)</p>
<p>Source node 2:done</p>
<p>(ps:这里直接输入done 开始生成迁移计划)</p>
<p> … …</p>
<p>Do you want to proceed with the proposed reshard plan (yes/no)? <strong>Yes</strong></p>
<p>(ps:这里输入yes开始迁移)</p>
<p>至此，我们已经成功的把8007主节点的数据迁移到8001上去了，我们可以看一下现在的集群状态如下图，你会发现8007下面已经没有任何hash槽了，证明迁移成功！</p>
<p>  <img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411092631159.png" alt="image-20220411092631159"></p>
<p># 最后我们直接使用del-node命令删除8007主节点即可</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">redis</span>-cli -a <span class="hljs-number">12345</span> --cluster del-node <span class="hljs-number">192.168.136.1:8007</span> <span class="hljs-number">2728</span>a<span class="hljs-number">594</span>a<span class="hljs-number">0498</span>e<span class="hljs-number">98</span>e<span class="hljs-number">4</span>b<span class="hljs-number">83</span>a<span class="hljs-number">537</span>e<span class="hljs-number">19</span>f<span class="hljs-number">9</span>a<span class="hljs-number">0</span>a<span class="hljs-number">3790</span>f<span class="hljs-number">38</span>              <br></code></pre></td></tr></table></figure>

<p># 查看集群状态，一切还原为最初始状态啦！大功告成！</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-Redis02-%E6%8C%81%E4%B9%85%E5%8C%96%E5%92%8C%E9%9B%86%E7%BE%A4/image-20220411092653605.png" alt="image-20220411092653605"></p>
]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title>并发编程07-Executor线程池原理与源码分析</title>
    <url>/2021/11/21/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h1 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h1><h2 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h2><p>​    <strong>线程池</strong>:“线程池”，顾名思义就是一个线程缓存，线程是稀缺资源，如果被无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，因此Java中提供线程池对线程进行统一分配、调优和监控</p>
<p>​    在web开发中，服务器需要接受并处理请求，所以会<font style="background:yellow;font-weight:bold">为一个请求来分配一个线程来进行处理</font>。如果每次请求都新创建一个线程的话实现起来非常简便，但是存在一个问题： 如果并发的请求数量非常多，但每个线程执行的时间很短，这样就会频繁的创建和销毁 线程，如此一来会大大降低系统的效率。可能出现服务器在为每个请求创建新线程和销毁线程上花费的时间和消耗的系统资源要比处理实际的用户请求的时间和资源更多。</p>
<p>​    那么有没有一种办法使执行完一个任务，并不被销毁，而是可以继续执行其他的任务呢？这就是线程池了。线程池为线程生命周期的开销和资源不足问题提供了解决方案。<strong>通过对多个任务重用线程，线程创建的开销被分摊到了多个任务上</strong>。<br>​    总的来说：任务提交给线程池后，它会给任务分配工作线程（Worker）来执行任务，任务完成后，工作线程回到ThreadPoolExecutor，被回收或者等待后续任务</p>
<h2 id="线程池的优势"><a href="#线程池的优势" class="headerlink" title="线程池的优势"></a>线程池的优势</h2><p>什么时候使用线程池？</p>
<ul>
<li>单个任务处理时间比较短</li>
<li>需要处理的任务数量很大 </li>
</ul>
<p><strong>线程池优势</strong>    </p>
<p>1、减少开销，提升响应速度，可用性：重复使用已创建的线程，减少线程创建、销毁的性能开销，提高性能、无需等待线程创建即可立即执行。<br>2、便于管理：线程是稀缺资源，如果无限制创建，会消耗系统资源，提高线程切换时间，进而减低系统稳定性。<strong>使用线程池可以对线程资源统一调度，调优和监控</strong>。</p>
<h2 id="线程的实现方式"><a href="#线程的实现方式" class="headerlink" title="线程的实现方式"></a>线程的实现方式</h2><ol>
<li><strong>new Thread(Runnable runnable)</strong></li>
<li>继承<strong>Tread</strong>，重写run方法</li>
<li><strong>Callable</strong>，借助，new Thread(new FutureTask(new Callable&lt;返回类型&gt;() ))</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 实现Runnable接口的类将被Thread执行，表示一个基本的任务 </span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123; <br>    <span class="hljs-comment">// run方法就是它所有的内容，就是实际执行的任务 </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span>; </span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function"><span class="hljs-comment">//Callable同样是任务，与Runnable接口的区别在于它接收泛型，同时它执行任务后带 有返回内容 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> interface Callable&lt;V&gt; </span>&#123; <br>    <span class="hljs-comment">// 相对于run方法的带有返回值的call方法 </span><br>    <span class="hljs-function">V <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception; </span><br><span class="hljs-function">&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="Executor框架"><a href="#Executor框架" class="headerlink" title="Executor框架"></a>Executor框架</h2><p>Executor接口是线程池框架中最基础的部分，定义了一个用于执行Runnable的execute方 法。</p>
<p>下图为它的继承与实现</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211114234452760.png" alt="image-20211114234452760"></p>
<h3 id="ExecutorService"><a href="#ExecutorService" class="headerlink" title="ExecutorService"></a>ExecutorService</h3><p>​    Executor下的一个重要子接口ExecutorService，其中定义了线程池的具体行为</p>
<p><strong>1、excute（Runnable command）：执行Runnable任务</strong></p>
<p><strong>2、submit（Task）：提交Callable或者Runnable任务，并返回任务对应的FutureTask对象</strong></p>
<p><strong>3、shutdown()：在完成已提交的任务后封闭办事，不在接受新任务</strong></p>
<p><strong>4、shutdownNow()：停止所有正在履行的任务，不在接受新任务。</strong></p>
<p><strong>5、isTerminated()：测试是否所有任务都履行完毕</strong></p>
<p><strong>6、isShutdown：测试是否该ExecutorService已被关闭</strong></p>
<h3 id="线程池的具体实现"><a href="#线程池的具体实现" class="headerlink" title="线程池的具体实现"></a>线程池的具体实现</h3><p>1、<strong>ThreadPoolExecutor 默认线程池</strong> </p>
<p>2、<strong>ScheduledThreadPoolExecutor 定时线程池</strong> </p>
<h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="线程池重点属性"><a href="#线程池重点属性" class="headerlink" title="线程池重点属性"></a>线程池重点属性</h3><h4 id="ctl"><a href="#ctl" class="headerlink" title="ctl"></a>ctl</h4><p>​    ctl是对线程池的运行状态和线程池中有效线程的数量进行控制的一个字段，它包含两部分的信息:</p>
<p><strong>线程池的运行状态</strong>(runState)、<strong>线程池内有效线程的数量</strong>(workerCount)，这里可以看到，使用了Integer类型来保存，<strong>高3位保存runState，低29位保存workerCount</strong>。COUNT_BITS就是29，CAPACITY就是1左移29位减1（29个1），这个常量表示workerCount的上限值，大约是5亿。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="hljs-number">0</span>)); <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="hljs-number">3</span>; <br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> CAPACITY = (<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS) - <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure>

<h4 id="ctl相关方法"><a href="#ctl相关方法" class="headerlink" title="ctl相关方法"></a><strong>ctl相关方法</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取运行状态； </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">runStateOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &amp; ~CAPACITY; &#125; <br><span class="hljs-comment">//获取活动线程数；</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">workerCountOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> c)</span> </span>&#123; <span class="hljs-keyword">return</span> c &amp; CAPACITY; &#125; <br><span class="hljs-comment">//获取运行状态和活动线程数的值。 </span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">ctlOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> rs, <span class="hljs-keyword">int</span> wc)</span> </span>&#123; <span class="hljs-keyword">return</span> rs | wc; &#125;	<br><br><span class="hljs-comment">//线程池存在5种状态 </span><br>RUNNING = -<span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为111 </span><br>SHUTDOWN = <span class="hljs-number">0</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为000 </span><br>STOP = <span class="hljs-number">1</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为001 </span><br>TIDYING = <span class="hljs-number">2</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为010 </span><br>TERMINATED = <span class="hljs-number">3</span> &lt;&lt; COUNT_BITS; <span class="hljs-comment">//高3位为011</span><br></code></pre></td></tr></table></figure>

<p><strong>1、RUNNING</strong> </p>
<p>(1) 状态说明：线程池处在RUNNING状态时，能够接收新任务，以及对已添加的任务进行 处理。<br>(02) 状态切换：线程池的初始化状态是RUNNING。换句话说，线程池被一旦被创建，就处 于RUNNING状态，并且线程池中的任务数为0！ </p>
<p><strong>2、 SHUTDOWN</strong><br>(1) 状态说明：线程池处在SHUTDOWN状态时，不接收新任务，但能处理已添加的任务。<br>(2) 状态切换：调用线程池的shutdown()接口时，线程池由RUNNING -&gt; SHUTDOWN。 </p>
<p><strong>3、STOP</strong><br>(1) 状态说明：线程池处在STOP状态时，不接收新任务，不处理已添加的任务，并且会中 断正在处理的任务。<br>(2) 状态切换：调用线程池的shutdownNow()接口时，线程池由(RUNNING or SHUTDOWN ) -&gt; STOP。</p>
<p><strong>4、TIDYING</strong><br>(1) 状态说明：当所有的任务已终止，ctl记录的”任务数量”为0，线程池会变为TIDYING 状态。当线程池变为TIDYING状态时，会执行钩子函数terminated()。terminated()在 ThreadPoolExecutor类中是空的，若用户想在线程池变为TIDYING时，进行相应的处理； 可以通过重载terminated()函数来实现。<br>(2) 状态切换：当线程池在SHUTDOWN状态下，阻塞队列为空并且线程池中执行的任务也 为空时，就会由 SHUTDOWN -&gt; TIDYING。 当线程池在STOP状态下，线程池中执行的 任务为空时，就会由STOP -&gt; TIDYING。 </p>
<p><strong>5、 TERMINATED</strong><br>(1) 状态说明：线程池彻底终止，就变成TERMINATED状态。<br>(2) 状态切换：线程池处在TIDYING状态时，执行完terminated()之后，就会由 TIDYING - &gt; TERMINATED。 进入TERMINATED的条件如下： 线程池不是RUNNING状态； 线程池状态不是TIDYING状态或TERMINATED状态； 如果线程池状态是SHUTDOWN并且workerQueue为空； workerCount为0； 设置TIDYING状态成功。</p>
<h3 id="任务提交API"><a href="#任务提交API" class="headerlink" title="任务提交API"></a><strong>任务提交API</strong></h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//线程池的创建</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> corePoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">int</span> maximumPoolSize,</span></span><br><span class="hljs-function"><span class="hljs-params">                          <span class="hljs-keyword">long</span> keepAliveTime, </span></span><br><span class="hljs-function"><span class="hljs-params">                          TimeUnit unit, </span></span><br><span class="hljs-function"><span class="hljs-params">                          BlockingQueue&lt;Runnable&gt; workQueue, </span></span><br><span class="hljs-function"><span class="hljs-params">                          ThreadFactory threadFactory, </span></span><br><span class="hljs-function"><span class="hljs-params">                          RejectedExecutionHandler handler)</span> </span><br><span class="hljs-function"><span class="hljs-comment">//任务提交 </span></span><br><span class="hljs-function">1、<span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-comment">//提交任务无返回值 </span></span><br><span class="hljs-function">2、<span class="hljs-keyword">public</span> Future&lt;?&gt; <span class="hljs-title">submit</span><span class="hljs-params">()</span> <span class="hljs-comment">//任务执行完成后有返回值</span></span><br></code></pre></td></tr></table></figure>

<blockquote>
<p><strong>参数解释</strong> </p>
<p><strong>corePoolSize</strong> </p>
<p>线程池中的核心线程数，当提交一个任务时，线程池创建一个新线程执行任务，直到当前线程数等于corePoolSize；如果当前线程数为corePoolSize，继续提交的任务被保存到 阻塞队列中，等待被执行；如果执行了线程池的prestartAllCoreThreads()方法，线程池会 提前创建并启动所有核心线程。 </p>
<p><strong>maximumPoolSize</strong> </p>
<p>线程池中允许的最大线程数。如果当前阻塞队列满了，且继续提交任务，则创建新的线程执行任务，前提是当前线程数小于maximumPoolSize； </p>
<p><strong>keepAliveTime</strong> </p>
<p>线程池维护线程所允许的空闲时间。当线程池中的线程数量大于corePoolSize的时候，如果这时没有新的任务提交，核心线程外的线程不会立即销毁，而是会等待，直到等待 的时间超过了keepAliveTime； </p>
<p><strong>unit</strong></p>
<p>keepAliveTime的单位； </p>
<p><strong>workQueue</strong> </p>
<p>用来保存等待被执行的任务的阻塞队列，且任务必须实现Runable接口，在JDK中提供了如下阻塞队列： </p>
<p>1、ArrayBlockingQueue：基于数组结构的有界阻塞队列，按FIFO排序任务； </p>
<p>2、LinkedBlockingQuene：基于链表结构的阻塞队列，按FIFO排序任务，吞吐量通常要高于ArrayBlockingQuene；</p>
<p>3、SynchronousQuene：一个不存储元素的阻塞队列，每个插入操作必须等到另一个线程调用移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于LinkedBlockingQuene； </p>
<p>4、priorityBlockingQuene：具有优先级的无界阻塞队列； </p>
<p><strong>threadFactory</strong> </p>
<p>它是ThreadFactory类型的变量，用来创建新线程。默认使用Executors.defaultThreadFactory() 来创建线程。使用默认的ThreadFactory来创建线程 时，会使新创建的线程具有相同的NORM_PRIORITY优先级并且是非守护线程，同时也设 置了线程的名称。 </p>
<p><strong>handler</strong> </p>
<p>线程池的饱和策略，当阻塞队列满了，且没有空闲的工作线程，如果继续提交任务，必须采取一种策略处理该任务，线程池提供了4种策略： </p>
<p>1、AbortPolicy：直接抛出异常，默认策略； </p>
<p>2、CallerRunsPolicy：用调用者所在的线程来执行任务； </p>
<p>3、DiscardOldestPolicy：丢弃阻塞队列中靠最前的任务，并执行当前任务； </p>
<p>4、DiscardPolicy：直接丢弃任务； </p>
<p>上面的4种策略都是ThreadPoolExecutor的内部类。 当然也可以根据应用场景实RejectedExecutionHandler接口，自定义饱和策略，如记录日志或持久化存储不能处理的任务。</p>
</blockquote>
<h4 id="使用例子"><a href="#使用例子" class="headerlink" title="使用例子"></a>使用例子</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolicySample</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> ExecutionException, InterruptedException </span>&#123;<br>        ThreadPoolExecutor pool = <span class="hljs-keyword">new</span> ThreadPoolExecutor(<br>                <span class="hljs-number">3</span>,<br>                <span class="hljs-number">5</span>,<br>                <span class="hljs-number">3</span>,<br>                TimeUnit.SECONDS,<br>                <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(<span class="hljs-number">2</span>),<br>                Executors.defaultThreadFactory(),<br>                <span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<br>        Future&lt;String&gt; future = <span class="hljs-keyword">null</span>;<br>        List&lt;Future&lt;String&gt;&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Future&lt;String&gt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">20</span>;i++)&#123;<br>            list.add(pool.submit(<span class="hljs-keyword">new</span> CallTask(i+<span class="hljs-number">1</span>)));<br>            Thread.sleep(<span class="hljs-number">50</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CallTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Callable</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CallTask</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.i = i;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">call</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        TimeUnit.SECONDS.sleep(<span class="hljs-number">2</span>);<br>        System.out.println(Thread.currentThread().getName()+<span class="hljs-string">&quot;提交顺序&quot;</span>+i);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;callTask 方法输出&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//4、5这2个任务进入阻塞队列后，6被提交发现阻塞队列也满了，就判断 核心线程数 &lt; 当前线程 &lt; 最大线程数，新开线程接受6、7</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>提交顺序<span class="hljs-number">1</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>提交顺序<span class="hljs-number">2</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">3</span>提交顺序<span class="hljs-number">3</span> <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">4</span>提交顺序<span class="hljs-number">6</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">5</span>提交顺序<span class="hljs-number">7</span><br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">1</span>提交顺序<span class="hljs-number">4</span> <br>pool-<span class="hljs-number">1</span>-thread-<span class="hljs-number">2</span>提交顺序<span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<h3 id="线程池监控"><a href="#线程池监控" class="headerlink" title="线程池监控"></a>线程池监控</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getTaskCount</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程池已执行与未执行的任务总数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">long</span> <span class="hljs-title">getCompletedTaskCount</span><span class="hljs-params">()</span> <span class="hljs-comment">//已完成的任务数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getPoolSize</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程池当前的线程数 </span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getActiveCount</span><span class="hljs-params">()</span> <span class="hljs-comment">//线程池中正在执行任务的线程数量</span></span><br></code></pre></td></tr></table></figure>

<h3 id="线程池原理"><a href="#线程池原理" class="headerlink" title="线程池原理"></a>线程池原理</h3><p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211118233809035.png" alt="image-20211118233809035"></p>
<h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (command == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>    <span class="hljs-comment">//正在执行的线程数小于核心线程数，则启动一个新线程，且把该任务当做第一个任务</span><br>    <span class="hljs-keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;<br>        <span class="hljs-keyword">if</span> (addWorker(command, <span class="hljs-keyword">true</span>))<br>            <span class="hljs-keyword">return</span>;<br>        c = ctl.get();<br>    &#125;<br>    <br>    <span class="hljs-keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;<br>        <span class="hljs-keyword">int</span> recheck = ctl.get();<br>        <span class="hljs-keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))<br>            reject(command);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (workerCountOf(recheck) == <span class="hljs-number">0</span>)<br>            <span class="hljs-comment">//入队成功，正在执行的线程数大于核心线程数且小于最大线程数，启动一个新线程执行新提交的任务</span><br>            addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>    <span class="hljs-comment">//入队失败，队列已满且正在执行的线程数小于于最大线程数，则启动线程执行该任务，否则执行拒绝策略</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!addWorker(command, <span class="hljs-keyword">false</span>))<br>        reject(command);<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121174123772.png" alt="image-20211121174123772"></p>
<h4 id="addWorker方法"><a href="#addWorker方法" class="headerlink" title="addWorker方法"></a>addWorker方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable firstTask, <span class="hljs-keyword">boolean</span> core)</span> </span>&#123;<br>        retry:<br>    	<span class="hljs-comment">//整个循环做一些前置判断，判断线程池状态并且cas新增ctl的工作线程数成功，则真正进入创建worker过程</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">int</span> c = ctl.get();<br>            <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>            <span class="hljs-comment">// Check if queue empty only if necessary.</span><br>            <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;<br>                ! (rs == SHUTDOWN &amp;&amp;<br>                   firstTask == <span class="hljs-keyword">null</span> &amp;&amp;<br>                   ! workQueue.isEmpty()))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br><br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br>                <span class="hljs-keyword">if</span> (wc &gt;= CAPACITY ||<br>                    wc &gt;= (core ? corePoolSize : maximumPoolSize))<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>                <span class="hljs-keyword">if</span> (compareAndIncrementWorkerCount(c))<br>                    <span class="hljs-keyword">break</span> retry;<br>                c = ctl.get();  <span class="hljs-comment">// Re-read ctl</span><br>                <span class="hljs-keyword">if</span> (runStateOf(c) != rs)<br>                    <span class="hljs-keyword">continue</span> retry;<br>                <span class="hljs-comment">// else CAS failed due to workerCount change; retry inner loop</span><br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>        Worker w = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            w = <span class="hljs-keyword">new</span> Worker(firstTask);<br>            <span class="hljs-keyword">final</span> Thread t = w.thread;<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>                <span class="hljs-comment">//上锁</span><br>                mainLock.lock();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">// Recheck while holding lock.</span><br>                    <span class="hljs-comment">// Back out on ThreadFactory failure or if</span><br>                    <span class="hljs-comment">// shut down before lock acquired.</span><br>                    <span class="hljs-keyword">int</span> rs = runStateOf(ctl.get());<br><br>                    <span class="hljs-keyword">if</span> (rs &lt; SHUTDOWN ||<br>                        (rs == SHUTDOWN &amp;&amp; firstTask == <span class="hljs-keyword">null</span>)) &#123;<br>                        <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// precheck that t is startable</span><br>                            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                        workers.add(w);<br>                        <span class="hljs-keyword">int</span> s = workers.size();<br>                        <span class="hljs-keyword">if</span> (s &gt; largestPoolSize)<br>                            largestPoolSize = s;<br>                        workerAdded = <span class="hljs-keyword">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    mainLock.unlock();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (workerAdded) &#123;<br>                    t.start();<br>                    workerStarted = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (! workerStarted)<br>                addWorkerFailed(w);<br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h4 id="Worker类"><a href="#Worker类" class="headerlink" title="Worker类"></a>Worker类</h4><p>​    线程池中的每一个线程被封装成一个Worker对象，ThreadPool维护的其实就是一组Worker对象，请参见JDK源码。</p>
<p>Worker类继承了AQS，并实现了Runnable接口，注意其中的firstTask和thread属性：firstTask用它来保存传入的任务；thread是在调用构造方法时通过ThreadFactory来创建的线程，是用来处理任务的线程。在调用构造方法时，需要把任务传入，这里通过getThreadFactory().newThread(this);来新建一个线程，newThread方法传入的参数是this，因为Worker本身继承了Runnable接口，也就是一个线程，所以一个Worker对象在启动的时候会调用Worker类中的run方法。Worker继承了AQS，使用AQS来实现独占锁的功能。为什么不使用ReentrantLock来实现呢？可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的：</p>
<ol>
<li>lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</li>
<li>如果正在执行任务，则不应该中断线程；</li>
<li>如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</li>
<li>线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程池中的线程是否是空闲状态；</li>
<li>之所以设置为不可重入，是因为我们不希望任务在调用像setCorePoolSize这样的线程池控制方法时重新获取锁。如果使用ReentrantLock，它是可重入的，这样如果在任务中调用了如setCorePoolSize这类线程池控制的方法，会中断正在运行的线程。</li>
</ol>
<p>所以，Worker继承自AQS，用于判断线程是否空闲以及是否可以被中断。此外，在构造方法中执行了setState(-1);，把state变量设置为-1，为什么这么做呢？</p>
<p>​    是因为AQS中默认的state是0，如果刚创建了一个Worker对象，还没有执行任务时，这时就不应该被中断，看一下tryAquire方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123; <br>    <span class="hljs-comment">//cas修改state，不可重入 </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123; <br>        setExclusiveOwnerThread(Thread.currentThread()); <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>; <br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; <br>&#125; <br></code></pre></td></tr></table></figure>

<p>​    tryAcquire方法是根据state是否是0来判断的，所以，setState(-1);将state设置为-1是 为了禁止在执行任务前对线程进行中断。 正因为如此，在runWorker方法中会先调用Worker对象的unlock方法将state设置为 0。</p>
<h4 id="runWorker方法"><a href="#runWorker方法" class="headerlink" title="runWorker方法"></a>runWorker方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker w)</span> </span>&#123;<br>        Thread wt = Thread.currentThread();<br>        Runnable task = w.firstTask;<br>        w.firstTask = <span class="hljs-keyword">null</span>;<br>        w.unlock(); <span class="hljs-comment">// allow interrupts</span><br>        <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task = getTask()) != <span class="hljs-keyword">null</span>) &#123;<br>                w.lock();<br>                <span class="hljs-comment">// If pool is stopping, ensure thread is interrupted;</span><br>                <span class="hljs-comment">// if not, ensure thread is not interrupted.  This</span><br>                <span class="hljs-comment">// requires a recheck in second case to deal with</span><br>                <span class="hljs-comment">// shutdownNow race while clearing interrupt</span><br>                <span class="hljs-keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||<br>                     (Thread.interrupted() &amp;&amp;<br>                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;<br>                    !wt.isInterrupted())<br>                    wt.interrupt();<br>                <span class="hljs-keyword">try</span> &#123;<br>                    beforeExecute(wt, task);<br>                    Throwable thrown = <span class="hljs-keyword">null</span>;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        task.run();<br>                    &#125; <span class="hljs-keyword">catch</span> (RuntimeException x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Error x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> x;<br>                    &#125; <span class="hljs-keyword">catch</span> (Throwable x) &#123;<br>                        thrown = x; <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Error(x);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        afterExecute(task, thrown);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-keyword">null</span>;<br>                    w.completedTasks++;<br>                    w.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(w, completedAbruptly);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>这里说明一下第一个if判断，目的是：</p>
<p>​    如果线程池正在停止，那么要保证当前线程是中断状态；</p>
<p>​    如果不是的话，则要保证当前线程不是中断状态；</p>
<p>这里要考虑在执行该if语句期间可能也执行了shutdownNow方法，shutdownNow方法会把状态设置为STOP，回顾一下STOP状态：</p>
<p>​    不能接受新任务，也不处理队列中的任务，会中断正在处理任务的线程。</p>
<p>​    在线程池处于RUNNING或SHUTDOWN状态时，调用shutdownNow()方法会使线程池进入到该状态。</p>
<p>STOP状态要中断线程池中的所有线程，而这里使用Thread.interrupted()来判断是否中断是为了确保在RUNNING或者SHUTDOWN状态时线程是非中断状态的，因为Thread.interrupted()方法会复位中断的状态。</p>
<p>总结一下runWorker方法的执行过程：</p>
<p>​    1.while循环不断地通过getTask()方法获取任务；</p>
<p>​    2.getTask()方法从阻塞队列中取任务；</p>
<p>​    3.如果线程池正在停止，那么要保证当前线程是中断状态，否则要保证当前线程不是中断状态；</p>
<p>​    4.调用task.run()执行任务；</p>
<p>​    5.如果task为null则跳出循环，执行processWorkerExit()方法；</p>
<p>​    6.runWorker方法执行完毕，也代表着Worker中的run方法执行完毕，销毁线程。</p>
<p>这里的beforeExecute方法和afterExecute方法在ThreadPoolExecutor类中是空的，留给子类来实现。completedAbruptly变量来表示在执行任务过程中是否出现了异常，在processWorkerExit方法中会对该变量的值进行判断。</p>
<h4 id="getTask方法"><a href="#getTask方法" class="headerlink" title="getTask方法"></a>getTask方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span> timedOut = <span class="hljs-keyword">false</span>; <span class="hljs-comment">// Did the last poll() time out?</span><br><br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-keyword">int</span> rs = runStateOf(c);<br><br>       <span class="hljs-comment">/** 如果线程池状态rs &gt;= SHUTDOWN，也就是非RUNNING状态，再进行以下判断： </span><br><span class="hljs-comment">         * 1. rs &gt;= STOP，线程池是否正在stop；</span><br><span class="hljs-comment">         * 2. 阻塞队列是否为空。</span><br><span class="hljs-comment">         * 如果以上条件满足，则将workerCount减1并返回null。</span><br><span class="hljs-comment">         * 因为如果当前线程池状态的值是SHUTDOWN或以上时，不允许再向阻塞队列中添加 任务。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;<br>            decrementWorkerCount();<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> wc = workerCountOf(c);<br><br>      	<span class="hljs-comment">// Are workers subject to culling? </span><br>        <span class="hljs-comment">// timed变量用于判断是否需要进行超时控制。 </span><br>        <span class="hljs-comment">// allowCoreThreadTimeOut默认是false，也就是核心线程不允许进行超 时； </span><br>        <span class="hljs-comment">// wc &gt; corePoolSize，表示当前线程池中的线程数量大于核心线程数量； </span><br>        <span class="hljs-comment">// 对于超过核心线程数量的这些线程，需要进行超时控制</span><br>        <span class="hljs-keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;<br><br>        <br>        <span class="hljs-keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))<br>            &amp;&amp; (wc &gt; <span class="hljs-number">1</span> || workQueue.isEmpty())) &#123;<br>            <span class="hljs-keyword">if</span> (compareAndDecrementWorkerCount(c))<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>			<span class="hljs-comment">/** 根据timed来判断，如果为true，则通过阻塞队列的poll方法进行超时控 制，如果在keepAliveTime时间内没有获取到任务，则返回null；</span><br><span class="hljs-comment">            * 否则通过take方法，如果这时队列为空，则take方法会阻塞直到队列不为空。 </span><br><span class="hljs-comment">            **/</span><br>            Runnable r = timed ?<br>                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :<br>                workQueue.take();<br>            <span class="hljs-keyword">if</span> (r != <span class="hljs-keyword">null</span>)<br>                <span class="hljs-keyword">return</span> r;<br>            timedOut = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException retry) &#123;<br>            timedOut = <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>​    这里重要的地方是第二个if判断，目的是控制线程池的有效线程数量。由上文中的分析可以知道，在执行execute方法时，如果当前线程池的线程数量超过了corePoolSize且小于maximumPoolSize，并且workQueue已满时，则可以增加工作线程，但这时如果超时没有获取到任务，也就是timedOut为true的情况，说明workQueue已经为空了，也就说明了当前线程池中不需要那么多线程来执行任务了，可以把多于corePoolSize数量的线程销毁掉，保持线程数量在corePoolSize即可。</p>
<p>​    什么时候会销毁？当然是runWorker方法执行完之后，也就是Worker中的run方法执行完，由JVM自动回收。</p>
<p>​    getTask方法返回null时，在runWorker方法中会跳出while循环，然后会执行processWorkerExit方法。</p>
<h4 id="processWorkerExit方法"><a href="#processWorkerExit方法" class="headerlink" title="processWorkerExit方法"></a>processWorkerExit方法</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker w, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (completedAbruptly) <span class="hljs-comment">// If abrupt, then workerCount wasn&#x27;t adjusted</span><br>        decrementWorkerCount();<br><br>    <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>    mainLock.lock();<br>    <span class="hljs-keyword">try</span> &#123;<br>        completedTaskCount += w.completedTasks;<br>        workers.remove(w);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        mainLock.unlock();<br>    &#125;<br><br>    tryTerminate();<br><br>    <span class="hljs-keyword">int</span> c = ctl.get();<br>   	 <span class="hljs-comment">/** </span><br><span class="hljs-comment">   	  * 当线程池是RUNNING或SHUTDOWN状态时，如果worker是异常结束，那么会直接 addWorker；</span><br><span class="hljs-comment">      * 如果allowCoreThreadTimeOut=true，并且等待队列有任务，至少保留一个 worker；</span><br><span class="hljs-comment">      * 如果allowCoreThreadTimeOut=false，workerCount不少于corePoolSize。</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-keyword">if</span> (runStateLessThan(c, STOP)) &#123;<br>        <span class="hljs-keyword">if</span> (!completedAbruptly) &#123;<br>            <span class="hljs-keyword">int</span> min = allowCoreThreadTimeOut ? <span class="hljs-number">0</span> : corePoolSize;<br>            <span class="hljs-keyword">if</span> (min == <span class="hljs-number">0</span> &amp;&amp; ! workQueue.isEmpty())<br>                min = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (workerCountOf(c) &gt;= min)<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// replacement not needed</span><br>        &#125;<br>        addWorker(<span class="hljs-keyword">null</span>, <span class="hljs-keyword">false</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>至此，processWorkerExit执行完之后，工作线程被销毁，以上就是整个工作线程的生命周期，从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121174031239.png" alt="image-20211121174031239"></p>
<h4 id="work实现AQS不继承ReentrantLock的原因"><a href="#work实现AQS不继承ReentrantLock的原因" class="headerlink" title="work实现AQS不继承ReentrantLock的原因"></a>work实现AQS不继承ReentrantLock的原因</h4><p>可以看到tryAcquire方法，它是不允许重入的，而ReentrantLock是允许重入的</p>
<p>Worker线程具有以下特性：</p>
<p>1、lock方法一旦获取了独占锁，表示当前线程正在执行任务中；</p>
<p>2、如果正在执行任务，则不应该中断线程；</p>
<p>3、如果该线程现在不是独占锁的状态，也就是空闲的状态，说明它没有在处理任务，这时可以对该线程进行中断；</p>
<p>4、线程池在执行shutdown方法或tryTerminate方法时会调用interruptIdleWorkers方法来中断空闲的线程，interruptIdleWorkers方法会使用tryLock方法来判断线程是否拥有锁来判断线程是否是空闲状态；</p>
<p>5、之所以使用不可重入锁，是为了避免正在执行的任务调用像setCorePoolSize这样的线程池控制方法时重新获取锁从而中断正在运行的线程。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryAcquire</span><span class="hljs-params">(<span class="hljs-keyword">int</span> unused)</span> </span>&#123;<br>    <span class="hljs-comment">//cas修改state，不可重入 </span><br>    <span class="hljs-keyword">if</span> (compareAndSetState(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>)) &#123;<br>        setExclusiveOwnerThread(Thread.currentThread()); <br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>; &#125;<br></code></pre></td></tr></table></figure>



<h2 id="自定义线程池"><a href="#自定义线程池" class="headerlink" title="自定义线程池"></a>自定义线程池</h2><p>MyExecutor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MyExecutor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable command)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MyThreadPoolExecutor.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadPoolExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MyExecutor</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认队列大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> defaultQueueSize = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认池的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> defaultPoolSize = <span class="hljs-number">5</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> defaultAliveTime = <span class="hljs-number">60l</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池最大的大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxPoolSize = <span class="hljs-number">50</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 线程池大小</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">int</span> poolsize;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 任务容量</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> completedTaskCount;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拒绝策略</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> RejectPolicy handler;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否已经中断</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> isShutDown = <span class="hljs-keyword">false</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * active当前激活线程数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> AtomicInteger ctl = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BlockingQueue&lt;Runnable&gt; <span class="hljs-title">getWorkQueue</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> workQueue;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 队列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Lock</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">new</span> ReentrantLock();<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * worker集合</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="hljs-keyword">new</span> HashSet&lt;Worker&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否允许超时</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> allowThreadTimeOut;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> keepAliveTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(defaultPoolSize,defaultQueueSize,defaultAliveTime,<span class="hljs-keyword">new</span> DefaultRejectPolicy());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolsize)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>(poolsize,defaultQueueSize,defaultAliveTime,<span class="hljs-keyword">new</span> DefaultRejectPolicy());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MyThreadPoolExecutor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> poolsize, <span class="hljs-keyword">int</span> queueSize, <span class="hljs-keyword">long</span> keepAliveTime, RejectPolicy handler)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(poolsize &lt;= <span class="hljs-number">0</span> || poolsize &gt; maxPoolSize )<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;线程池大小不能&lt;=0&quot;</span>);<br>        <span class="hljs-keyword">this</span>.poolsize = poolsize;<br>        <span class="hljs-keyword">this</span>.handler = handler;<br>        <span class="hljs-keyword">this</span>.keepAliveTime = keepAliveTime;<br>        <span class="hljs-keyword">if</span>(keepAliveTime &gt; <span class="hljs-number">0</span>)<br>            allowThreadTimeOut = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">this</span>.workQueue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Runnable&gt;(queueSize);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 执行任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Runnable task)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(task == <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;任务不能为空&quot;</span>);<br>        <span class="hljs-keyword">if</span>(isShutDown)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;线程池已销毁,禁止提交任务...&quot;</span>);<br><br>        <span class="hljs-keyword">int</span> c = ctl.get();<br>        <span class="hljs-comment">//任务数小于</span><br>        <span class="hljs-keyword">if</span>(c &lt; poolsize)&#123;<br>            <span class="hljs-keyword">if</span>(addWorker(task,<span class="hljs-keyword">true</span>))<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(workQueue.offer(task))&#123;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            handler.rejected(task,<span class="hljs-keyword">this</span>);<span class="hljs-comment">//任务拒绝策略</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">shutdown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            isShutDown = <span class="hljs-keyword">true</span>;<br>            <span class="hljs-keyword">for</span> (Worker w : workers)&#123;<br>                Thread t = w.thread;<br>                <span class="hljs-keyword">if</span>(!t.isInterrupted() &amp;&amp; w.tryLock())&#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        t.interrupt();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-comment">//e.printStackTrace();</span><br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        w.unlock();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 取出任务</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Runnable <span class="hljs-title">getTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> allowThreadTimeOut ? workQueue.poll(keepAliveTime, TimeUnit.SECONDS) : workQueue.take();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isShutdown</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> isShutDown;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">runWorker</span><span class="hljs-params">(Worker worker)</span></span>&#123;<br>        Thread wt = Thread.currentThread();<br>        Runnable task = worker.firstTask;<br>        worker.firstTask = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">boolean</span> completedAbruptly = <span class="hljs-keyword">true</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (task != <span class="hljs-keyword">null</span> || (task=getTask())!=<span class="hljs-keyword">null</span>)&#123;<br>                worker.lock();<br>                <span class="hljs-keyword">if</span> (isShutDown &amp;&amp; !wt.isInterrupted())&#123;<br>                    wt.interrupt();<br>                &#125;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    task.run();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    task = <span class="hljs-keyword">null</span>;<br>                    worker.completedTask++; <span class="hljs-comment">//当前线程完成的任务数</span><br>                    worker.unlock();<br>                &#125;<br>            &#125;<br>            completedAbruptly = <span class="hljs-keyword">false</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            processWorkerExit(worker,completedAbruptly);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processWorkerExit</span><span class="hljs-params">(Worker worker, <span class="hljs-keyword">boolean</span> completedAbruptly)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(completedAbruptly)<br>            ctl.decrementAndGet();<br><br>        <span class="hljs-keyword">final</span> ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>        mainLock.lock();<br>        <span class="hljs-keyword">try</span> &#123;<br>            completedTaskCount += worker.completedTask;<br>            workers.remove(worker);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            mainLock.unlock();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(completedAbruptly &amp;&amp; !workQueue.isEmpty())&#123;<br>            addWorker(<span class="hljs-keyword">null</span>,<span class="hljs-keyword">false</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 是否启动线程执行任务 or 放入</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> r</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> startNew</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">addWorker</span><span class="hljs-params">(Runnable r,<span class="hljs-keyword">boolean</span> startNew)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(startNew)&#123;<br>            ctl.incrementAndGet();<br>        &#125;<br>        <span class="hljs-keyword">boolean</span> workerAdded = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">boolean</span> workerStarted = <span class="hljs-keyword">false</span>;<br><br>        Worker w = <span class="hljs-keyword">new</span> Worker(r);<br>        Thread t = w.thread;<br>        <span class="hljs-keyword">if</span>(t != <span class="hljs-keyword">null</span>)&#123;<br>            ReentrantLock mainLock = <span class="hljs-keyword">this</span>.mainLock;<br>            mainLock.lock();<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span>(!isShutDown)&#123; <span class="hljs-comment">// 线程池未关闭</span><br>                    <span class="hljs-keyword">if</span> (t.isAlive()) <span class="hljs-comment">// 检查线程是否已经处于运行状态，start方法不能重复调用执行</span><br>                        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br>                    workers.add(w);<br>                    workerAdded = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                mainLock.unlock();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (workerAdded)&#123;<br>                t.start();<br>                workerStarted = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> workerStarted;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> AtomicInteger atomic = <span class="hljs-keyword">new</span> AtomicInteger();<br><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ReentrantLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">long</span> completedTask;<br>        <span class="hljs-keyword">final</span> Thread thread;<br>        Runnable firstTask;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Worker</span><span class="hljs-params">(Runnable r)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.firstTask = r;<br>            <span class="hljs-keyword">this</span>.thread = <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">this</span>,<span class="hljs-string">&quot;thread-name-&quot;</span>+atomic.incrementAndGet());<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            runWorker(<span class="hljs-keyword">this</span>);<br>        &#125;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>RejectPolicy 线程池满拒绝策略相关</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RejectPolicy</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 拒绝策略</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> task</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> executor</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">rejected</span><span class="hljs-params">(Runnable task, MyThreadPoolExecutor executor)</span></span>;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DiscardOldestRejectPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectPolicy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DiscardOldestRejectPolicy</span><span class="hljs-params">()</span></span>&#123;&#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejected</span><span class="hljs-params">(Runnable task, MyThreadPoolExecutor executor)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(!executor.isShutdown())&#123;<br>            executor.getWorkQueue().poll();<br>            executor.execute(task);<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PolicyException</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">RuntimeException</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PolicyException</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PolicyException</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(message);<br>    &#125;<br><br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultRejectPolicy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RejectPolicy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">DefaultRejectPolicy</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rejected</span><span class="hljs-params">(Runnable task, MyThreadPoolExecutor executor)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;任务已经满了&quot;</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> PolicyException(<span class="hljs-string">&quot;任务已经满了&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyThreadTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        MyThreadPoolExecutor pool = <span class="hljs-keyword">new</span> MyThreadPoolExecutor(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>,<span class="hljs-number">60</span>,<span class="hljs-keyword">new</span> DiscardOldestRejectPolicy());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-number">10</span>;i++)&#123;<br>            pool.execute(<span class="hljs-keyword">new</span> MyTask(i));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        pool.shutdown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121222630602.png" alt="image-20211121222630602"></p>
<h2 id="拒绝策略"><a href="#拒绝策略" class="headerlink" title="拒绝策略"></a>拒绝策略</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">AbortPolicy <span class="hljs-comment">//拒绝任务并报错</span><br>DiscardPolicy <span class="hljs-comment">//静默抛弃任务</span><br>DiscardOldestPolicy <span class="hljs-comment">//它丢弃最旧的未处理请求</span><br>CallerRunsPolicy <span class="hljs-comment">//任务被拒绝时，直接在execute方法的调用线程中运行被拒绝的任务——适用于一些必须执行的场景</span><br></code></pre></td></tr></table></figure>

<h2 id="Executors工具类"><a href="#Executors工具类" class="headerlink" title="Executors工具类"></a>Executors工具类</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">*  <span class="hljs-function">ExecutorService <span class="hljs-title">newFixedThreadPool</span><span class="hljs-params">(线程大小 n)</span></span>;创建大小固定的线程池<br>*  <span class="hljs-function">ExecutorService <span class="hljs-title">newCachedThreadPool</span><span class="hljs-params">()</span></span>;缓存线程池，可根据需要，更改线程池大小<br>*  <span class="hljs-function">ExecutorService <span class="hljs-title">newSingleThreadExecutor</span><span class="hljs-params">()</span></span>;创建单个线程池，只有一个线程<br>*  <span class="hljs-function">ScheduledExecutorService <span class="hljs-title">newScheduledThreadPool</span><span class="hljs-params">(线程大小 n)</span></span>;线程大小固定，可以延迟或定时执行任务<br></code></pre></td></tr></table></figure>

<h2 id="线程池配置"><a href="#线程池配置" class="headerlink" title="线程池配置"></a>线程池配置</h2><h3 id="tomcat默认线程池配置"><a href="#tomcat默认线程池配置" class="headerlink" title="tomcat默认线程池配置"></a>tomcat默认线程池配置</h3><figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">#tomcat 线程池默认配置 <br>server.tomcat.threads.max=200<br>server.tomcat.threads.min-spare=10<br>如果端口号是8080<br>那么接收到请求的线程名称格式：http-nio-8080-exec-1<br>参考文档：https://blog.csdn.net/m0_52789121/article/details/126080963<br></code></pre></td></tr></table></figure>

<h3 id="一般的应用线程池配置"><a href="#一般的应用线程池配置" class="headerlink" title="一般的应用线程池配置"></a>一般的应用线程池配置</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ExecutorPoolConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">//默认线程池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DEFAULT_EXECUTOR_POOL = <span class="hljs-string">&quot;DefaultExecutorPool&quot;</span>;<br>    <span class="hljs-comment">//永不抛弃线程池</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CALLER_RUNS_EXECUTOR_POOL = <span class="hljs-string">&quot;CallerRunsExecutorPool&quot;</span>;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.default.corePoolSize&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> corePoolSize;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.default.maxPoolSize&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxPoolSize;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.default.queueSize&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueSize;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.default.keepAlive&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keepAlive;<br>    <br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.callRuns.corePoolSize&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> corePoolSizeCallerRuns;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.callRuns.maxPoolSize&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> maxPoolSizeCallerRuns;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.callRuns.queueSize&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> queueSizeCallerRuns;<br>    <span class="hljs-meta">@Value(&quot;$&#123;thread.pool.callRuns.keepAlive&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> keepAliveCallerRuns;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  默认线程池</span><br><span class="hljs-comment">     * DiscardPolicy，线程池满了后，任务可能会被丢弃</span><br><span class="hljs-comment">     * 但是有一个优势，就是不会阻塞主线程，进而不会阻塞TCP队列</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean(DEFAULT_EXECUTOR_POOL)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title">defaultExecutorPool</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(corePoolSize);<br>        executor.setMaxPoolSize(maxPoolSize);<br>        executor.setQueueCapacity(queueSize);<br>        executor.setKeepAliveSeconds(keepAlive);<br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.DiscardPolicy());<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;@DefaultThreadPool-&quot;</span>);<br>        <span class="hljs-comment">// 关闭inheritableThreadLocal</span><br>        executor.setThreadFactory(TtlExecutors.getDisableInheritableThreadFactory(executor));<br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 定时器适用线程池</span><br><span class="hljs-comment">     * CallerRunsPolicy，不会丢弃任何的任务</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean(name = CALLER_RUNS_EXECUTOR_POOL)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ThreadPoolTaskExecutor <span class="hljs-title">callerRunsExecutorPool</span><span class="hljs-params">()</span> </span>&#123;<br>        ThreadPoolTaskExecutor executor = <span class="hljs-keyword">new</span> ThreadPoolTaskExecutor();<br>        executor.setCorePoolSize(corePoolSizeCallerRuns);<br>        executor.setMaxPoolSize(maxPoolSizeCallerRuns);<br>        executor.setQueueCapacity(queueSizeCallerRuns);<br>        executor.setKeepAliveSeconds(keepAliveCallerRuns);<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * CALLER_RUNS：不在新线程中执行任务，而是由调用者所在的线程来执行</span><br><span class="hljs-comment">         */</span><br>        executor.setRejectedExecutionHandler(<span class="hljs-keyword">new</span> ThreadPoolExecutor.CallerRunsPolicy());<br>        executor.setThreadNamePrefix(<span class="hljs-string">&quot;CallerRunsThreadPool-&quot;</span>);<br>        <span class="hljs-comment">// 关闭inheritableThreadLocal</span><br>        executor.setThreadFactory(TtlExecutors.getDisableInheritableThreadFactory(executor));<br>        executor.initialize();<br>        <span class="hljs-keyword">return</span> executor;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="TtlExecutors"><a href="#TtlExecutors" class="headerlink" title="TtlExecutors"></a>TtlExecutors</h2><p><a href="https://www.cnblogs.com/LittleSix/p/15818748.html">参考</a></p>
<h3 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h3><p>​    线程变量不能传递给子线程</p>
<h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>​    线程变量可以传递给子线程，但是遇到线程池使用场景时，只有线程创建的那一次实现了传递。</p>
<ul>
<li><strong>继承性</strong>：InheritableThreadLocal是ThreadLocal的一个子类，它扩展了ThreadLocal的功能，使得子线程可以继承父线程的ThreadLocal变量的值。当父线程创建一个新的子线程时，子线程会接收到父线程InheritableThreadLocal变量的一个副本。</li>
<li><strong>使用场景</strong>：在某些情况下，当父线程需要向子线程传递一些数据时，InheritableThreadLocal非常有用。但是，它并不能解决在线程池或异步任务调用链中传递ThreadLocal值的问题，因为在这些场景中，线程是复用的，而不是新创建的</li>
</ul>
<h3 id="TransmittableThreadLocal"><a href="#TransmittableThreadLocal" class="headerlink" title="TransmittableThreadLocal"></a>TransmittableThreadLocal</h3><p>​    线程变量可以传递给子线程，在TtlExecutors提供的线程池中或者通过new Thread(TtlRunnable runnable)新启的线程，可以实现变量实时在父子线程中传递。</p>
<ul>
<li><strong>跨线程传递</strong>：TransmittableThreadLocal（TTL）是阿里巴巴开源的一个框架，它解决了标准ThreadLocal无法在线程池或异步任务中正确传递值的问题。TTL允许在线程切换时（例如，在线程池中使用线程）保留原始线程的变量值，并在切换后恢复这些值。</li>
<li><strong>增强的功能</strong>：TTL不仅提供了InheritableThreadLocal的继承性，还增强了它，使其能够在复杂的线程环境中（如线程池、异步任务等）正确传递ThreadLocal值。这使得TTL成为处理跨线程上下文或状态传递的强大工具。</li>
<li><strong>使用场景</strong>：在需要跨线程传递上下文或状态的场景中，TTL非常有用。例如，在分布式系统中，你可能需要在多个线程或任务之间传递全链路id、用户信息等。TTL可以方便地帮助你实现这一点</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TransmittableThreadLocalTest</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="hljs-keyword">new</span> ThreadLocal&lt;String&gt; ();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InheritableThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="hljs-keyword">new</span> InheritableThreadLocal&lt;String&gt; ();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> TransmittableThreadLocal&lt;String&gt; transmittableThreadLocal = <span class="hljs-keyword">new</span> TransmittableThreadLocal&lt;String&gt; ();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        threadLocal.set(<span class="hljs-string">&quot;threadLocal&quot;</span>);<br>        inheritableThreadLocal.set(<span class="hljs-string">&quot;inheritableThreadLocal&quot;</span>);<br>        transmittableThreadLocal.set(<span class="hljs-string">&quot;transmittableThreadLocal&quot;</span>);<br><br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            System.out.println(threadLocal.get());<br>            System.out.println(inheritableThreadLocal.get());<br>            System.out.println(transmittableThreadLocal.get());<br><br>        &#125;).start();<br>        ExecutorService executorService1 = Executors.newCachedThreadPool();<br>        <span class="hljs-comment">//ttlExecutor execute或者submit方法自动包裹TtlRunable</span><br>        Executor ttlExecutor = TtlExecutors.getTtlExecutor(executorService1);<br>        Runnable run = <span class="hljs-keyword">new</span> Runnable() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>                System.out.println(threadLocal.get());<br>                System.out.println(inheritableThreadLocal.get());<br>                System.out.println(transmittableThreadLocal.get());<br>            &#125;<br>        &#125;;<br>        ttlExecutor.execute(run);<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">1000L</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        threadLocal.set(<span class="hljs-string">&quot;threadLocal-1&quot;</span>);<br>        inheritableThreadLocal.set(<span class="hljs-string">&quot;inheritableThreadLocal-1&quot;</span>);<br>        transmittableThreadLocal.set(<span class="hljs-string">&quot;transmittableThreadLocal-1&quot;</span>);<br>        ttlExecutor.execute(run);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">null</span> <br>inheritableThreadLocal 普通新建线程，inheritableThreadLocal默认生效<br>transmittableThreadLocal 普通新建线程，transmittableThreadLocal默认生效<br><span class="hljs-keyword">null</span><br>inheritableThreadLocal Ttl线程池新建线程 inheritableThreadLocal默认生效<br>transmittableThreadLocal Ttl线程池新建线程 transmittableThreadLocal默认生效<br><span class="hljs-keyword">null</span><br>inheritableThreadLocal Ttl线程池复用线程 inheritableThreadLocal 不生效<br>transmittableThreadLocal-<span class="hljs-number">1</span> Ttl线程池复用线程 inheritableThreadLocal 不生效<br></code></pre></td></tr></table></figure>



<h2 id="提问"><a href="#提问" class="headerlink" title="提问"></a>提问</h2><p><strong>1、ThreadPoolExecutor自身有哪些状态，如何维护这些状态?</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><code class="hljs text">//线程池存在5种状态 <br>RUNNING = -1 &lt;&lt; COUNT_BITS; //高3位为111 <br>SHUTDOWN = 0 &lt;&lt; COUNT_BITS; //高3位为000 <br>STOP = 1 &lt;&lt; COUNT_BITS; //高3位为001 <br>TIDYING = 2 &lt;&lt; COUNT_BITS; //高3位为010 <br>TERMINATED = 3 &lt;&lt; COUNT_BITS; //高3位为011<br></code></pre></td></tr></table></figure>

<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20221112231057056.png" alt="image-20221112231057056"></p>
<p><strong>2、ThreadPoolExecutor如何维护内部的工作线程?</strong></p>
<p>维护HashSet<Worker> workers，记录线程池里正在工作异步线程。</Worker></p>
<p>正常情况下，整个工作线程的生命周期：从execute方法开始，Worker使用ThreadFactory创建新的工作线程，runWorker通过getTask获取任务，然后执行任务，如果getTask返回null，进入processWorkerExit方法，整个线程结束，如图所示：</p>
<p><img src="/images/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B07-Executor%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/image-20211121174031239-1668349440222.png" alt="image-20211121174031239"></p>
<p><strong>3、ThreadPoolExecutor处理任务的整体逻辑是什么样的?</strong></p>
<p>提交任务给线程池后：</p>
<p>1、当前线程数 &lt; 核心线程数，则添加工作线程并执行</p>
<p>2、否则，阻塞队列未满？，则添加至阻塞队列排队</p>
<p>3、否则，当前线程数 &lt; 最大线程数，则添加工作线程并执行</p>
<p>4、否则，执行拒绝策略，任务提交失败</p>
]]></content>
      <categories>
        <category>并发编程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
        <tag>Executor</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day01</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day01/</url>
    <content><![CDATA[<h1 id="1，设计模式概述"><a href="#1，设计模式概述" class="headerlink" title="1，设计模式概述"></a>1，设计模式概述</h1><h2 id="1-1-软件设计模式的产生背景"><a href="#1-1-软件设计模式的产生背景" class="headerlink" title="1.1 软件设计模式的产生背景"></a>1.1 软件设计模式的产生背景</h2><p>“设计模式”最初并不是出现在软件设计中，而是被用于建筑领域的设计中。</p>
<p>1977年美国著名建筑大师、加利福尼亚大学伯克利分校环境结构中心主任<code>克里斯托夫·亚历山大（Christopher Alexander）</code>在他的著作《建筑模式语言：城镇、建筑、构造》中描述了一些常见的建筑设计问题，并提出了 253 种关于对城镇、邻里、住宅、花园和房间等进行设计的基本模式。</p>
<p>1990年软件工程界开始研讨设计模式的话题，后来召开了多次关于设计模式的研讨会。直到1995 年，艾瑞克·伽马（ErichGamma）、理査德·海尔姆（Richard Helm）、拉尔夫·约翰森（Ralph Johnson）、约翰·威利斯迪斯（John Vlissides）等 4 位作者合作出版了《设计模式：可复用面向对象软件的基础》一书，在此书中收录了 23 个设计模式，这是设计模式领域里程碑的事件，导致了软件设计模式的突破。这 4 位作者在软件开发领域里也以他们的“四人组”（Gang of Four，GoF）著称。  </p>
<h2 id="1-2-软件设计模式的概念"><a href="#1-2-软件设计模式的概念" class="headerlink" title="1.2 软件设计模式的概念"></a>1.2 软件设计模式的概念</h2><p>软件设计模式（Software Design Pattern），又称设计模式，<strong>是一套被反复使用、多数人知晓的、经过分类编目的、代码设计经验的总结</strong>。==它描==述了在软件设计过程中的一些不断重复发生的问题，以及该问题的解决方案。也就是说，它是解决特定问题的一系列套路，是前辈们的代码设计经验的总结，具有一定的普遍性，可以反复使用。</p>
<h2 id="1-3-学习设计模式的必要性"><a href="#1-3-学习设计模式的必要性" class="headerlink" title="1.3 学习设计模式的必要性"></a>1.3 学习设计模式的必要性</h2><p>设计模式的本质是面向对象设计原则的实际运用，是对类的封装性、继承性和多态性以及类的关联关系和组合关系的充分理解。</p>
<p>正确使用设计模式具有以下优点。</p>
<ul>
<li>可以提高程序员的思维能力、编程能力和设计能力。</li>
<li>使程序设计更加标准化、代码编制更加工程化，使软件开发效率大大提高，从而缩短软件的开发周期。</li>
<li>使设计的代码可重用性高、可读性强、可靠性高、灵活性好、可维护性强。</li>
</ul>
<h2 id="1-4-设计模式分类"><a href="#1-4-设计模式分类" class="headerlink" title="1.4 设计模式分类"></a>1.4 设计模式分类</h2><h3 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a><strong>创建型模式</strong></h3><p>用于描述“怎样创建对象”，它的主要特点是“==将对象的创建与使用分离==”。GoF（四人组）书中提供了<strong>单例、原型、工厂方法、抽象工厂、建造者</strong>等 5 种创建型模式。</p>
<h3 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h3><p>用于描述如何==将类或对象按某种布局组成更大的结构==，GoF（四人组）书中提供了代理、适配器、桥接、装饰、外观、享元、组合等 7 种结构型模式。</p>
<h3 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h3><p>用于描述==类或对象之间怎样相互协作共同完成单个对象无法单独完成的任务==，以及怎样分配职责。GoF（四人组）书中提供了模板方法、策略、命令、职责链、状态、观察者、中介者、迭代器、访问者、备忘录、解释器等 11 种行为型模式。</p>
<h1 id="2，UML图"><a href="#2，UML图" class="headerlink" title="2，UML图"></a>2，UML图</h1><p>统一建模语言（Unified Modeling Language，UML）是用来设计软件的可视化建模语言。它的特点是简单、统一、图形化、能表达软件设计中的动态与静态信息。</p>
<p>UML 从目标系统的不同角度出发，定义了用例图、类图、对象图、状态图、活动图、时序图、协作图、构件图、部署图等 9 种图。</p>
<h2 id="2-1-类图概述"><a href="#2-1-类图概述" class="headerlink" title="2.1 类图概述"></a>2.1 类图概述</h2><p>类图(Class diagram)是显示了模型的静态结构，特别是模型中存在的类、类的内部结构以及它们与其他类的关系等。类图不显示暂时性的信息。类图是面向对象建模的主要组成部分。</p>
<h2 id="2-2-类图的作用"><a href="#2-2-类图的作用" class="headerlink" title="2.2 类图的作用"></a>2.2 类图的作用</h2><ul>
<li>在软件工程中，类图是一种静态的结构图，描述了系统的类的集合，类的属性和类之间的关系，可以简化了人们对系统的理解；</li>
<li>类图是系统分析和设计阶段的重要产物，是系统编码和测试的重要模型。</li>
</ul>
<h2 id="2-3-类图表示法"><a href="#2-3-类图表示法" class="headerlink" title="2.3 类图表示法"></a>2.3 类图表示法</h2><h3 id="2-3-1-类的表示方式"><a href="#2-3-1-类的表示方式" class="headerlink" title="2.3.1 类的表示方式"></a>2.3.1 类的表示方式</h3><p>在UML类图中，类使用包含类名、属性(field) 和方法(method) 且带有分割线的矩形来表示，比如下图表示一个Employee类，它包含name,age和address这3个属性，以及work()方法。 </p>
<p><img src="/images/design-model-day01/Employee.jpg"></p>
<p>属性/方法名称前加的加号和减号表示了这个属性/方法的可见性，UML类图中表示可见性的符号有三种：</p>
<ul>
<li><p><strong>+：表示public</strong></p>
</li>
<li><p><strong>-：表示private</strong></p>
</li>
<li><p><strong>#：表示protected</strong></p>
</li>
</ul>
<p>属性的完整表示方式是： <strong>可见性  名称 ：类型 [ = 缺省值]</strong>  </p>
<p>方法的完整表示方式是： <strong>可见性  名称(参数列表) [ ： 返回类型]</strong></p>
<blockquote>
<p>注意：</p>
<p>​    1，中括号中的内容表示是可选的</p>
<p>​    2，也有将类型放在变量名前面，返回值类型放在方法名前面</p>
</blockquote>
<p><strong>举个栗子：</strong></p>
<p><img src="/images/design-model-day01/demo.png"></p>
<p>上图Demo类定义了三个方法：</p>
<ul>
<li>method()方法：修饰符为public，没有参数，没有返回值。</li>
<li>method1()方法：修饰符为private，没有参数，返回值类型为String。</li>
<li>method2()方法：修饰符为protected，接收两个参数，第一个参数类型为int，第二个参数类型为String，返回值类型是int。</li>
</ul>
<h3 id="2-3-2-类与类之间关系的表示方式"><a href="#2-3-2-类与类之间关系的表示方式" class="headerlink" title="2.3.2 类与类之间关系的表示方式"></a>2.3.2 类与类之间关系的表示方式</h3><h4 id="2-3-2-1-关联关系"><a href="#2-3-2-1-关联关系" class="headerlink" title="2.3.2.1 关联关系"></a>2.3.2.1 关联关系</h4><p><strong>关联关系是对象之间的一种引用关系</strong>，用于表示一类对象与另一类对象之间的联系，如老师和学生、师傅和徒弟、丈夫和妻子等。关联关系是类与类之间最常用的一种关系，分为一般关联关系、聚合关系和组合关系。我们先介绍一般关联。</p>
<p>关联又可以分为单向关联，双向关联，自关联。</p>
<h5 id="1，单向关联"><a href="#1，单向关联" class="headerlink" title="1，单向关联"></a><strong>1，单向关联</strong></h5><p><img src="/images/design-model-day01/customer_address.png"></p>
<p>在UML类图中单向关联用一个带箭头的实线表示。上图表示每个顾客都有一个地址，这通过让Customer类持有一个类型为Address的成员变量类实现。</p>
<h5 id="2，双向关联"><a href="#2，双向关联" class="headerlink" title="2，双向关联"></a><strong>2，双向关联</strong></h5><p><img src="/images/design-model-day01/customer_product.png"></p>
<p>从上图中我们很容易看出，所谓的双向关联就是双方各自持有对方类型的成员变量。</p>
<p>在UML类图中，双向关联用一个不带箭头的直线表示。上图中在Customer类中维护一个List&lt;Product&gt;，表示一个顾客可以购买多个商品；在Product类中维护一个Customer类型的成员变量表示这个产品被哪个顾客所购买。</p>
<h5 id="3，自关联"><a href="#3，自关联" class="headerlink" title="3，自关联"></a><strong>3，自关联</strong></h5><p><img src="/images/design-model-day01/node.png"></p>
<p>自关联在UML类图中用一个带有箭头且指向自身的线表示。上图的意思就是Node类包含类型为Node的成员变量，也就是“自己包含自己”。</p>
<h4 id="2-3-2-2-聚合关系"><a href="#2-3-2-2-聚合关系" class="headerlink" title="2.3.2.2 聚合关系"></a>2.3.2.2 聚合关系</h4><p><strong>聚合关系是关联关系的一种</strong>，是强关联关系，是==整体和部分之间的关系==。</p>
<p>聚合关系也是通过成员对象来实现的，<strong>其中成员对象是整体对象的一部分，但是成员对象可以脱离整体对象而独立存在。</strong>例如，学校与老师的关系，学校包含老师，但如果学校停办了，老师依然存在。</p>
<p>在 UML 类图中，聚合关系可以用带空心菱形的实线来表示，菱形指向整体。下图所示是大学和教师的关系图：</p>
<p><img src="/images/design-model-day01/image-20191229173422328.png"></p>
<h4 id="2-3-2-3-组合关系"><a href="#2-3-2-3-组合关系" class="headerlink" title="2.3.2.3 组合关系"></a>2.3.2.3 组合关系</h4><p>组合表示类之间的整体与部分的关系，但它是一种<strong>更强烈的聚合关系</strong>。</p>
<p>在组合关系中，整体对象可以控制部分对象的生命周期，<strong>一旦整体对象不存在，部分对象也将不存在，部分对象不能脱离整体对象而存在。</strong>例如，头和嘴的关系，没有了头，嘴也就不存在了。</p>
<p>在 UML 类图中，组合关系用带实心菱形的实线来表示，菱形指向整体。下图所示是头和嘴的关系图：</p>
<p><img src="/images/design-model-day01/image-20191229173455149.png"></p>
<h4 id="2-3-2-4-依赖关系"><a href="#2-3-2-4-依赖关系" class="headerlink" title="2.3.2.4 依赖关系"></a>2.3.2.4 依赖关系</h4><p>依赖关系是一种使用关系，它是对象之间耦合度最弱的一种关联方式，是临时性的关联。在代码中，<strong>某个类的方法通过局部变量、方法的参数或者对静态方法的调用来访问另一个类</strong>（被依赖类）中的某些方法来完成一些职责。</p>
<p>在 UML 类图中，依赖关系使用带箭头的虚线来表示，箭头从使用类指向被依赖的类。下图所示是司机和汽车的关系图，司机驾驶汽车：</p>
<p><img src="/images/design-model-day01/image-20191229173518926.png"></p>
<h4 id="2-3-2-5-继承关系"><a href="#2-3-2-5-继承关系" class="headerlink" title="2.3.2.5 继承关系"></a>2.3.2.5 继承关系</h4><p>继承关系是对象之间耦合度最大的一种关系，表示一般与特殊的关系，是父类与子类之间的关系，是一种继承关系。</p>
<p>在 UML 类图中，泛化关系用带空心三角箭头的实线来表示，箭头从子类指向父类。在代码实现时，使用面向对象的继承机制来实现泛化关系。例如，Student 类和 Teacher 类都是 Person 类的子类，其类图如下图所示：</p>
<p><img src="/images/design-model-day01/image-20191229173539838.png"></p>
<h4 id="2-3-2-6-实现关系"><a href="#2-3-2-6-实现关系" class="headerlink" title="2.3.2.6 实现关系"></a>2.3.2.6 实现关系</h4><p>实现关系是接口与实现类之间的关系。在这种关系中，类实现了接口，类中的操作实现了接口中所声明的所有的抽象操作。</p>
<p>在 UML 类图中，实现关系使用带空心三角箭头的虚线来表示，箭头从实现类指向接口。例如，汽车和船实现了交通工具，其类图如图 9 所示。</p>
<p><img src="/images/design-model-day01/image-20191229173554296.png"></p>
<h1 id="3，软件设计原则"><a href="#3，软件设计原则" class="headerlink" title="3，软件设计原则"></a>3，软件设计原则</h1><p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据6条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。</p>
<h2 id="3-1-开闭原则"><a href="#3-1-开闭原则" class="headerlink" title="3.1 开闭原则"></a>3.1 开闭原则</h2><p><strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p>
<p>想要达到这样的效果，我们需要使用接口和抽象类。</p>
<p>因为抽象灵活性好，适应性广，只要抽象的合理，可以基本保持软件架构的稳定。而软件中易变的细节可以从抽象派生来的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>
<p>下面以 <code>搜狗输入法</code> 的皮肤为例介绍开闭原则的应用。</p>
<p>【例】<code>搜狗输入法</code> 的皮肤设计。</p>
<p>分析：<code>搜狗输入法</code> 的皮肤是输入法背景图片、窗口颜色和声音等元素的组合。用户可以根据自己的喜爱更换自己的输入法的皮肤，也可以从网上下载新的皮肤。这些皮肤有共同的特点，可以为其定义一个抽象类（AbstractSkin），而每个具体的皮肤（DefaultSpecificSkin和HeimaSpecificSkin）是其子类。用户窗体可以根据需要选择或者增加新的主题，而不需要修改原代码，所以它是满足开闭原则的。</p>
<p><img src="/images/design-model-day01/open-close.png"></p>
<h2 id="3-2-里氏代换原则"><a href="#3-2-里氏代换原则" class="headerlink" title="3.2 里氏代换原则"></a>3.2 里氏代换原则</h2><p>里氏代换原则是面向对象设计的基本原则之一。</p>
<p>里氏代换原则：任何基类可以出现的地方，子类一定可以出现。通俗理解：<strong>子类可以扩展父类的功能，但不能改变父类原有的功能。</strong>换句话说，子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。</p>
<p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的可复用性会比较差，特别是运用多态比较频繁时，程序运行出错的概率会非常大。</p>
<p>下面看一个里氏替换原则中经典的一个例子</p>
<p>【例】正方形不是长方形。</p>
<p>在数学领域里，正方形毫无疑问是长方形，它是一个长宽相等的长方形。所以，我们开发的一个与几何图形相关的软件系统，就可以顺理成章的让正方形继承自长方形。</p>
<p><img src="/images/design-model-day01/%E6%AD%A3%E6%96%B9%E5%BD%A2%E4%B8%8D%E6%98%AF%E9%95%BF%E6%96%B9%E5%BD%A2.png"></p>
<p>代码如下：</p>
<p><strong>长方形类（Rectangle）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> length;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> width;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getLength</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.length = length;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getWidth</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> width;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.width = width;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>正方形（Square）：</strong></p>
<p>由于正方形的长和宽相同，所以在方法setLength和setWidth中，对长度和宽度都需要赋相同值。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Square</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Rectangle</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setWidth</span><span class="hljs-params">(<span class="hljs-keyword">double</span> width)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setLength(width);<br>        <span class="hljs-keyword">super</span>.setWidth(width);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLength</span><span class="hljs-params">(<span class="hljs-keyword">double</span> length)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.setLength(length);<br>        <span class="hljs-keyword">super</span>.setWidth(length);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>类RectangleDemo是我们的软件系统中的一个组件，它有一个resize方法依赖基类Rectangle，resize方法是RectandleDemo类中的一个方法，用来实现宽度逐渐增长的效果。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RectangleDemo</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resize</span><span class="hljs-params">(Rectangle rectangle)</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (rectangle.getWidth() &lt;= rectangle.getLength()) &#123;<br>            rectangle.setWidth(rectangle.getWidth() + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//打印长方形的长和宽</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printLengthAndWidth</span><span class="hljs-params">(Rectangle rectangle)</span> </span>&#123;<br>        System.out.println(rectangle.getLength());<br>        System.out.println(rectangle.getWidth());<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Rectangle rectangle = <span class="hljs-keyword">new</span> Rectangle();<br>        rectangle.setLength(<span class="hljs-number">20</span>);<br>        rectangle.setWidth(<span class="hljs-number">10</span>);<br>        resize(rectangle);<br>        printLengthAndWidth(rectangle);<br><br>        System.out.println(<span class="hljs-string">&quot;============&quot;</span>);<br><br>        Rectangle rectangle1 = <span class="hljs-keyword">new</span> Square();<br>        rectangle1.setLength(<span class="hljs-number">10</span>);<br>        resize(rectangle1);<br>        printLengthAndWidth(rectangle1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>我们运行一下这段代码就会发现，假如我们把一个普通长方形作为参数传入resize方法，就会看到长方形宽度逐渐增长的效果，当宽度大于长度,代码就会停止，这种行为的结果符合我们的预期；假如我们再把一个正方形作为参数传入resize方法后，就会看到正方形的宽度和长度都在不断增长，代码会一直运行下去，直至系统产生溢出错误。所以，普通的长方形是适合这段代码的，正方形不适合。<br>我们得出结论：在resize方法中，Rectangle类型的参数是不能被Square类型的参数所代替，如果进行了替换就得不到预期结果。因此，Square类和Rectangle类之间的继承关系违反了里氏代换原则，它们之间的继承关系不成立，正方形不是长方形。</p>
<p>如何改进呢？此时我们需要重新设计他们之间的关系。抽象出来一个四边形接口(Quadrilateral)，让Rectangle类和Square类实现Quadrilateral接口</p>
<img src="/images/design-model-day01/正方形不是长方形改进.png" style="zoom:80%;">



<h2 id="3-3-依赖倒转原则"><a href="#3-3-依赖倒转原则" class="headerlink" title="3.3 依赖倒转原则"></a>3.3 依赖倒转原则</h2><p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。简单的说就是要求对抽象进行编程，不要对实现进行编程，这样就降低了客户与实现模块间的耦合。</p>
<p>下面看一个例子来理解依赖倒转原则</p>
<p>【例】组装电脑</p>
<p>现要组装一台电脑，需要配件cpu，硬盘，内存条。只有这些配置都有了，计算机才能正常的运行。选择cpu有很多选择，如Intel，AMD等，硬盘可以选择希捷，西数等，内存条可以选择金士顿，海盗船等。</p>
<p><strong>类图如下：</strong></p>
<img src="/images/design-model-day01/依赖倒转原则.png" style="zoom:80%;">

<p>代码如下：</p>
<p><strong>希捷硬盘类（XiJieHardDisk）:</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XiJieHardDisk</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HardDisk</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷硬盘存储数据&quot;</span> + data);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用希捷希捷硬盘取数据&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;数据&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Intel处理器（IntelCpu）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntelCpu</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cpu</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用Intel处理器&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>金士顿内存条（KingstonMemory）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KingstonMemory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;使用金士顿作为内存条&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> XiJieHardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> IntelCpu cpu;<br>    <span class="hljs-keyword">private</span> KingstonMemory memory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IntelCpu <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(IntelCpu cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> KingstonMemory <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(KingstonMemory memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> XiJieHardDisk <span class="hljs-title">getHardDisk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHardDisk</span><span class="hljs-params">(XiJieHardDisk hardDisk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>        cpu.run();<br>        memory.save();<br>        String data = hardDisk.get();<br>        System.out.println(<span class="hljs-string">&quot;从硬盘中获取的数据为：&quot;</span> + data);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>测试类（TestComputer）：</strong></p>
<p>测试类用来组装电脑。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestComputer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        computer.setHardDisk(<span class="hljs-keyword">new</span> XiJieHardDisk());<br>        computer.setCpu(<span class="hljs-keyword">new</span> IntelCpu());<br>        computer.setMemory(<span class="hljs-keyword">new</span> KingstonMemory());<br><br>        computer.run();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码可以看到已经组装了一台电脑，但是似乎组装的电脑的cpu只能是Intel的，内存条只能是金士顿的，硬盘只能是希捷的，这对用户肯定是不友好的，用户有了机箱肯定是想按照自己的喜好，选择自己喜欢的配件。</p>
<p>根据依赖倒转原则进行改进：</p>
<p>代码我们只需要修改Computer类，让Computer类依赖抽象（各个配件的接口），而不是依赖于各个组件具体的实现类。</p>
<p><strong>类图如下：</strong></p>
<img src="/images/design-model-day01/依赖倒转原则改进.png" alt="image-20191229173554296" style="zoom:70%;">

<p><strong>电脑（Computer）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> HardDisk hardDisk;<br>    <span class="hljs-keyword">private</span> Cpu cpu;<br>    <span class="hljs-keyword">private</span> Memory memory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HardDisk <span class="hljs-title">getHardDisk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHardDisk</span><span class="hljs-params">(HardDisk hardDisk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.hardDisk = hardDisk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Cpu <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(Cpu cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memory <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(Memory memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;计算机工作&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>面向对象的开发很好的解决了这个问题，一般情况下抽象的变化概率很小，让用户程序依赖于抽象，实现的细节也依赖于抽象。即使实现细节不断变动，只要抽象不变，客户程序就不需要变化。这大大降低了客户程序与实现细节的耦合度。</p>
<h2 id="3-4-接口隔离原则"><a href="#3-4-接口隔离原则" class="headerlink" title="3.4 接口隔离原则"></a>3.4 接口隔离原则</h2><p>客户端不应该被迫依赖于它不使用的方法；一个类对另一个类的依赖应该建立在最小的接口上。</p>
<p>下面看一个例子来理解接口隔离原则</p>
<p>【例】安全门案例</p>
<p>我们需要创建一个<code>黑马</code>品牌的安全门，该安全门具有防火、防水、防盗的功能。可以将防火，防水，防盗功能提取成一个接口，形成一套规范。类图如下：</p>
<p><img src="/images/design-model-day01/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%99.png"></p>
<p>上面的设计我们发现了它存在的问题，黑马品牌的安全门具有防盗，防水，防火的功能。现在如果我们还需要再创建一个传智品牌的安全门，而该安全门只具有防盗、防水功能呢？很显然如果实现SafetyDoor接口就违背了接口隔离原则，那么我们如何进行修改呢？看如下类图：</p>
<p><img src="/images/design-model-day01/%E6%8E%A5%E5%8F%A3%E9%9A%94%E7%A6%BB%E5%8E%9F%E5%88%991.png"></p>
<p>代码如下：</p>
<p><strong>AntiTheft（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">AntiTheft</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">antiTheft</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Fireproof（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Fireproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">fireproof</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Waterproof（接口）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Waterproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">waterproof</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>HeiMaSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeiMaSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AntiTheft</span>,<span class="hljs-title">Fireproof</span>,<span class="hljs-title">Waterproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">antiTheft</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireproof</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waterproof</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防水&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>ItcastSafetyDoor（类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItcastSafetyDoor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AntiTheft</span>,<span class="hljs-title">Fireproof</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">antiTheft</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防盗&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fireproof</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;防火&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-5-迪米特法则"><a href="#3-5-迪米特法则" class="headerlink" title="3.5 迪米特法则"></a>3.5 迪米特法则</h2><p><strong>迪米特法则又叫最少知识原则。</strong></p>
<p>只和你的直接朋友交谈，不跟“陌生人”说话（Talk only to your immediate friends and not to strangers）。</p>
<p>其含义是：如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>
<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>
<p>下面看一个例子来理解迪米特法则</p>
<p>【例】明星与经纪人的关系实例</p>
<p>明星由于全身心投入艺术，所以许多日常事务由经纪人负责处理，如和粉丝的见面会，和媒体公司的业务洽淡等。这里的经纪人是明星的朋友，而粉丝和媒体公司是陌生人，所以适合使用迪米特法则。</p>
<p>类图如下：</p>
<img src="/images/design-model-day01/迪米特法则.png" alt="image-20191229173554296" style="zoom:80%;">

<p>代码如下：</p>
<p><strong>明星类（Star）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Star</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Star</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>粉丝类（Fans）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fans</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Fans</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>媒体公司类（Company）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Company</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Company</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name=name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>经纪人类（Agent）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Agent</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Star star;<br>    <span class="hljs-keyword">private</span> Fans fans;<br>    <span class="hljs-keyword">private</span> Company company;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStar</span><span class="hljs-params">(Star star)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.star = star;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFans</span><span class="hljs-params">(Fans fans)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fans = fans;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCompany</span><span class="hljs-params">(Company company)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">meeting</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(fans.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;见面了。&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">business</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(company.getName() + <span class="hljs-string">&quot;与明星&quot;</span> + star.getName() + <span class="hljs-string">&quot;洽淡业务。&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-6-合成复用原则"><a href="#3-6-合成复用原则" class="headerlink" title="3.6 合成复用原则"></a>3.6 合成复用原则</h2><p>合成复用原则是指：<strong>尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现</strong>。</p>
<p>通常类的复用分为<strong>继承复用</strong>和<strong>合成复用</strong>两种。</p>
<p>继承复用虽然有简单和易实现的优点，但它也存在以下缺点：</p>
<ol>
<li>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</li>
<li>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</li>
<li>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</li>
</ol>
<p>采用组合或聚合复用时，可以将已有对象纳入新对象中，使之成为新对象的一部分，新对象可以调用已有对象的功能，它有以下优点：</p>
<ol>
<li>它维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>
<li>对象间的耦合度低。可以在类的成员位置声明抽象。</li>
<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>
</ol>
<p>下面看一个例子来理解合成复用原则</p>
<p>【例】汽车分类管理程序</p>
<p>汽车按“动力源”划分可分为汽油汽车、电动汽车等；按“颜色”划分可分为白色汽车、黑色汽车和红色汽车等。如果同时考虑这两种分类，其组合就很多。类图如下： </p>
<img src="/images/design-model-day01/合成复用原则.png" alt="image-20191229173554296" style="zoom:80%;">

<p>从上面类图我们可以看到使用继承复用产生了很多子类，如果现在又有新的动力源或者新的颜色的话，就需要再定义新的类。我们试着将继承复用改为聚合复用看一下。</p>
<img src="/images/design-model-day01/合成复用原则1.png" alt="image-20191229173554296" style="zoom:80%;">



<h1 id="4，创建者模式"><a href="#4，创建者模式" class="headerlink" title="4，创建者模式"></a>4，创建者模式</h1><p>创建型模式的主要关注点是“怎样创建对象？”，它的主要特点是“将对象的创建与使用分离”。</p>
<p>这样可以降低系统的耦合度，使用者不需要关注对象的创建细节。</p>
<p>创建型模式分为：</p>
<ul>
<li>单例模式</li>
<li>工厂方法模式</li>
<li>抽象工程模式</li>
<li>原型模式</li>
<li>建造者模式</li>
</ul>
<h2 id="4-1-单例设计模式"><a href="#4-1-单例设计模式" class="headerlink" title="4.1 单例设计模式"></a>4.1 单例设计模式</h2><p>单例模式（Singleton Pattern）是 Java 中最简单的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<h3 id="4-1-1-单例模式的结构"><a href="#4-1-1-单例模式的结构" class="headerlink" title="4.1.1 单例模式的结构"></a>4.1.1 单例模式的结构</h3><p>单例模式的主要有以下角色：</p>
<ul>
<li>单例类。只能创建一个实例的类</li>
<li>访问类。使用单例类</li>
</ul>
<h3 id="4-1-2-单例模式的实现"><a href="#4-1-2-单例模式的实现" class="headerlink" title="4.1.2 单例模式的实现"></a>4.1.2 单例模式的实现</h3><blockquote>
<p>单例设计模式分类两种：</p>
<p>​    饿汉式：类加载就会导致该单实例对象被创建    </p>
<p>​    懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建</p>
</blockquote>
<ol>
<li><p>饿汉式-方式1（静态变量方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 饿汉式</span><br><span class="hljs-comment"> *      静态变量创建类的对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance = <span class="hljs-keyword">new</span> Singleton();<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，并创建Singleton类的对象instance。instance对象是随着类的加载而创建的。如果该对象足够大的话，而一直没有使用就会造成内存的浪费。</p>
</li>
<li><p>饿汉式-方式2（静态代码块方式）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恶汉式</span><br><span class="hljs-comment"> *      在静态代码块中创建该类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        instance = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    该方式在成员位置声明Singleton类型的静态变量，而对象的创建是在静态代码块中，也是对着类的加载而创建。所以和饿汉式的方式1基本上一样，当然该方式也存在内存浪费问题。</p>
</li>
<li><p>懒汉式-方式1（线程不安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程不安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    从上面代码我们可以看出该方式在成员位置声明Singleton类型的静态变量，并没有进行对象的赋值操作，那么什么时候赋值的呢？当调用getInstance()方法获取Singleton类的对象的时候才创建Singleton类的对象，这样就实现了懒加载的效果。但是，如果是多线程环境，会出现线程安全问题。</p>
</li>
<li><p>懒汉式-方式2（线程安全）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 懒汉式</span><br><span class="hljs-comment"> *  线程安全</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-comment">//在成员位置创建该类的对象</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">synchronized</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    该方式也实现了懒加载效果，同时又解决了线程安全问题。但是在getInstance()方法上添加了synchronized关键字，导致该方法的执行效果特别低。从上面代码我们可以看出，其实就是在初始化instance的时候才会出现线程安全问题，一旦初始化完成就不存在了。</p>
</li>
<li><p>懒汉式-方式3（双重检查锁）</p>
<p>再来讨论一下懒汉模式中加锁的问题，对于 <code>getInstance()</code> 方法来说，绝大部分的操作都是读操作，读操作是线程安全的，所以我们没必让每个线程必须持有锁才能调用该方法，我们需要调整加锁的时机。由此也产生了一种新的实现模式：双重检查锁模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123; <br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实例</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为null</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>双重检查锁模式是一种非常好的单例实现模式，解决了单例、性能、线程安全问题，上面的双重检测锁模式看上去完美无缺，其实是存在问题，在多线程的情况下，可能会出现空指针问题，出现问题的原因是JVM在实例化对象的时候会进行优化和指令重排序操作。</p>
<p>要解决双重检查锁模式带来空指针异常的问题，只需要使用 <code>volatile</code> 关键字, <code>volatile</code> 关键字可以保证可见性和有序性。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双重检查方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>   <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">//第一次判断，如果instance不为null，不进入抢锁阶段，直接返回实际</span><br>        <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>                <span class="hljs-comment">//抢到锁之后再次判断是否为空</span><br>                <span class="hljs-keyword">if</span>(instance == <span class="hljs-keyword">null</span>) &#123;<br>                    instance = <span class="hljs-keyword">new</span> Singleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">小结：</font></p>
<p>添加 <code>volatile</code> 关键字之后的双重检查锁模式是一种比较好的单例实现模式，能够保证在多线程的情况下线程安全也不会有性能问题。</p>
</li>
</ol>
<ol start="6">
<li><p>懒汉式-方式4（静态内部类方式）</p>
<p>静态内部类单例模式中实例由内部类创建，由于 JVM 在加载外部类的过程中, 是不会加载静态内部类的, 只有内部类的属性/方法被调用时才会被加载, 并初始化其静态属性。静态属性由于被 <code>static</code> 修饰，保证只被实例化一次，并且严格保证实例化顺序。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 静态内部类方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    第一次加载Singleton类时不会去初始化INSTANCE，只有第一次调用getInstance，虚拟机加载SingletonHolder</p>
<p>并初始化INSTANCE，这样不仅能确保线程安全，也能保证 Singleton 类的唯一性。</p>
<p><font color="red">小结：</font></p>
<p>​    静态内部类单例模式是一种优秀的单例模式，是开源项目中比较常用的一种单例模式。在没有加任何锁的情况下，保证了多线程下的安全，并且没有任何性能影响和空间的浪费。</p>
</li>
<li><p>枚举方式</p>
<p>枚举类实现单例模式是极力推荐的单例实现模式，因为枚举类型是线程安全的，并且只会装载一次，设计者充分的利用了枚举的这个特性来实现单例模式，枚举的写法非常简单，而且枚举类型是所用单例实现中唯一一种不会被破坏的单例实现模式。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 枚举方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">Singleton</span> </span>&#123;<br>    INSTANCE;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">说明：</font></p>
<p>​    枚举方式属于恶汉式方式。</p>
</li>
</ol>
<h3 id="4-1-3-存在的问题"><a href="#4-1-3-存在的问题" class="headerlink" title="4.1.3 存在的问题"></a>4.1.3 存在的问题</h3><h4 id="4-1-3-1-问题演示"><a href="#4-1-3-1-问题演示" class="headerlink" title="4.1.3.1 问题演示"></a>4.1.3.1 问题演示</h4><p>破坏单例模式：</p>
<p>使上面定义的单例类（Singleton）可以创建多个对象，枚举方式除外。有两种方式，分别是克隆、序列化和反射。</p>
<ul>
<li><p>序列化反序列化</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Singleton INSTANCE = <span class="hljs-keyword">new</span> Singleton();<br>    &#125;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Test类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//往文件中写对象</span><br>        <span class="hljs-comment">//writeObject2File();</span><br>        <span class="hljs-comment">//从文件中读取对象</span><br>        Singleton s1 = readObjectFromFile();<br>        Singleton s2 = readObjectFromFile();<br><br>        <span class="hljs-comment">//判断两个反序列化后的对象是否是同一个对象</span><br>        System.out.println(s1 == s2);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">readObjectFromFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//创建对象输入流对象</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//第一个读取Singleton对象</span><br>        Singleton instance = (Singleton) ois.readObject();<br><br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeObject2File</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//获取Singleton类的对象</span><br>        Singleton instance = Singleton.getInstance();<br>        <span class="hljs-comment">//创建对象输出流</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>));<br>        <span class="hljs-comment">//将instance对象写出到文件中</span><br>        oos.writeObject(instance);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式。</p>
</blockquote>
</li>
<li><p>反射</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> </span>&#123;<br><br>    <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>Test类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>              <span class="hljs-comment">//通过getInstance()获取</span><br>        Singleton singleton = Singleton.getInstance();<br>        System.out.println(<span class="hljs-string">&quot;singleton的hashCode:&quot;</span>+singleton.hashCode());<br>        <span class="hljs-comment">//通过克隆获取</span><br>        Singleton clob = (Singleton) Singleton.getInstance().clone();<br>        System.out.println(<span class="hljs-string">&quot;clob的hashCode:&quot;</span>+clob.hashCode());<br>        <span class="hljs-comment">//通过序列化，反序列化获取</span><br>        ByteArrayOutputStream bos = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(bos);<br>        oos.writeObject(Singleton.getInstance());<br>        ByteArrayInputStream bis = <span class="hljs-keyword">new</span> ByteArrayInputStream(bos.toByteArray());<br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(bis);<br>        Singleton serialize = (Singleton) ois.readObject();<br>        System.out.println(<span class="hljs-string">&quot;serialize的hashCode:&quot;</span>+serialize.hashCode());<br>        <span class="hljs-comment">//通过反射获取</span><br>        Constructor&lt;Singleton&gt; constructor = Singleton.class.getDeclaredConstructor();<br>        constructor.setAccessible(<span class="hljs-keyword">true</span>);<br>      Singleton reflex = constructor.newInstance();<br>        System.out.println(<span class="hljs-string">&quot;reflex的hashCode:&quot;</span>+reflex.hashCode());<br>        <span class="hljs-keyword">if</span>(ois != <span class="hljs-keyword">null</span>)&#123;<br>            ois.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bis != <span class="hljs-keyword">null</span>)&#123;<br>            bis.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(oos != <span class="hljs-keyword">null</span>)&#123;<br>            oos.close();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(bos != <span class="hljs-keyword">null</span>)&#123;<br>            bos.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>上面代码运行结果是<code>false</code>，表明序列化和反序列化已经破坏了单例设计模式</p>
</blockquote>
</li>
</ul>
<blockquote>
<p><font color="red">注意：</font>枚举方式不会出现这两个问题。</p>
</blockquote>
<h4 id="4-1-3-2-问题的解决"><a href="#4-1-3-2-问题的解决" class="headerlink" title="4.1.3.2 问题的解决"></a>4.1.3.2 问题的解决</h4><ul>
<li><p>序列化、反序列方式破坏单例模式的解决方法</p>
<p>在Singleton类中添加<code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新new出来的对象。</p>
<p><strong>Singleton类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Singleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span>,<span class="hljs-title">Cloneable</span> </span>&#123;<br><br>      <span class="hljs-comment">//私有构造方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Singleton</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">           反射破解单例模式需要添加的代码</span><br><span class="hljs-comment">        */</span><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">volatile</span> Singleton instance;<br><br>    <span class="hljs-comment">//对外提供静态方法获取该对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Singleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br><br>        <span class="hljs-keyword">synchronized</span> (Singleton.class) &#123;<br>            <span class="hljs-keyword">if</span>(instance != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> instance;<br>            &#125;<br>            instance = <span class="hljs-keyword">new</span> Singleton();<br>            <span class="hljs-keyword">return</span> instance;<br>        &#125;<br>    &#125;<br>    <br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br>    <br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 下面是为了解决序列化反序列化破解单例模式</span><br><span class="hljs-comment">     */</span><br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> Singleton.getInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>源码解析：</strong></p>
<p>ObjectInputStream类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Object <span class="hljs-title">readObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException, ClassNotFoundException</span>&#123;<br>    ...<br>    <span class="hljs-comment">// if nested read, passHandle contains handle of enclosing object</span><br>    <span class="hljs-keyword">int</span> outerHandle = passHandle;<br>    <span class="hljs-keyword">try</span> &#123;<br>        Object obj = readObject0(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//重点查看readObject0方法</span><br>    .....<br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readObject0</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>	...<br>    <span class="hljs-keyword">try</span> &#123;<br>		<span class="hljs-keyword">switch</span> (tc) &#123;<br>			...<br>			<span class="hljs-keyword">case</span> TC_OBJECT:<br>				<span class="hljs-keyword">return</span> checkResolve(readOrdinaryObject(unshared));<span class="hljs-comment">//重点查看readOrdinaryObject方法</span><br>			...<br>        &#125;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        depth--;<br>        bin.setBlockDataMode(oldMode);<br>    &#125;    <br>&#125;<br>    <br><span class="hljs-function"><span class="hljs-keyword">private</span> Object <span class="hljs-title">readOrdinaryObject</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> unshared)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>	...<br>	<span class="hljs-comment">//isInstantiable 返回true，执行 desc.newInstance()，通过反射创建新的单例类，</span><br>    obj = desc.isInstantiable() ? desc.newInstance() : <span class="hljs-keyword">null</span>; <br>    ...<br>    <span class="hljs-comment">// 在Singleton类中添加 readResolve 方法后 desc.hasReadResolveMethod() 方法执行结果为true</span><br>    <span class="hljs-keyword">if</span> (obj != <span class="hljs-keyword">null</span> &amp;&amp; handles.lookupException(passHandle) == <span class="hljs-keyword">null</span> &amp;&amp; desc.hasReadResolveMethod()) &#123;<br>    	<span class="hljs-comment">// 通过反射调用 Singleton 类中的 readResolve 方法，将返回值赋值给rep变量</span><br>    	<span class="hljs-comment">// 这样多次调用ObjectInputStream类中的readObject方法，继而就会调用我们定义的readResolve方法，所以返回的是同一个对象。</span><br>    	Object rep = desc.invokeReadResolve(obj);<br>     	...<br>    &#125;<br>    <span class="hljs-keyword">return</span> obj;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-1-4-JDK源码解析-Runtime类"><a href="#4-1-4-JDK源码解析-Runtime类" class="headerlink" title="4.1.4 JDK源码解析-Runtime类"></a>4.1.4 JDK源码解析-Runtime类</h3><p>Runtime类就是使用的单例设计模式。</p>
<ol>
<li><p>通过源代码查看使用的是哪儿种单例模式</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runtime currentRuntime = <span class="hljs-keyword">new</span> Runtime();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Returns the runtime object associated with the current Java application.</span><br><span class="hljs-comment">     * Most of the methods of class &lt;code&gt;Runtime&lt;/code&gt; are instance</span><br><span class="hljs-comment">     * methods and must be invoked with respect to the current runtime object.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>  the &lt;code&gt;Runtime&lt;/code&gt; object associated with the current</span><br><span class="hljs-comment">     *          Java application.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title">getRuntime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-comment">/** Don&#x27;t let anyone else instantiate this class */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Runtime</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面源代码中可以看出Runtime类使用的是恶汉式（静态属性）方式来实现单例模式的。</p>
</li>
<li><p>使用Runtime类中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RuntimeDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">//获取Runtime类对象</span><br>        Runtime runtime = Runtime.getRuntime();<br><br>        <span class="hljs-comment">//返回 Java 虚拟机中的内存总量。</span><br>        System.out.println(runtime.totalMemory());<br>        <span class="hljs-comment">//返回 Java 虚拟机试图使用的最大内存量。</span><br>        System.out.println(runtime.maxMemory());<br><br>        <span class="hljs-comment">//创建一个新的进程执行指定的字符串命令，返回进程对象</span><br>        Process process = runtime.exec(<span class="hljs-string">&quot;ipconfig&quot;</span>);<br>        <span class="hljs-comment">//获取命令执行后的结果，通过输入流获取</span><br>        InputStream inputStream = process.getInputStream();<br>        <span class="hljs-keyword">byte</span>[] arr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>* <span class="hljs-number">100</span>];<br>        <span class="hljs-keyword">int</span> b = inputStream.read(arr);<br>        System.out.println(<span class="hljs-keyword">new</span> String(arr,<span class="hljs-number">0</span>,b,<span class="hljs-string">&quot;gbk&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day02</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/</url>
    <content><![CDATA[<h1 id="4，创建型模式"><a href="#4，创建型模式" class="headerlink" title="4，创建型模式"></a>4，创建型模式</h1><h2 id="4-2-工厂模式"><a href="#4-2-工厂模式" class="headerlink" title="4.2 工厂模式"></a>4.2 工厂模式</h2><h3 id="4-2-1-概述"><a href="#4-2-1-概述" class="headerlink" title="4.2.1 概述"></a>4.2.1 概述</h3><p>需求：设计一个咖啡店点餐系统。  </p>
<p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡【AmericanCoffee】和拿铁咖啡【LatteCoffee】）；再设计一个咖啡店类（CoffeeStore），咖啡店具有点咖啡的功能。</p>
<p>具体类的设计如下：</p>
<img src="/images/设计模式-day02/工厂设计模式引入.png" style="zoom:80%;">

<p>在java中，万物皆对象，这些对象都需要创建，如果创建的时候直接new该对象，就会对该对象耦合严重，假如我们要更换对象，所有new对象的地方都需要修改一遍，这显然违背了软件设计的开闭原则。如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p>
<p>在本教程中会介绍三种工厂的使用</p>
<ul>
<li>简单工厂模式（不属于GOF的23种经典设计模式）</li>
<li>工厂方法模式</li>
<li>抽象工厂模式</li>
</ul>
<h3 id="4-2-2-简单工厂模式"><a href="#4-2-2-简单工厂模式" class="headerlink" title="4.2.2 简单工厂模式"></a>4.2.2 简单工厂模式</h3><p>简单工厂不是一种设计模式，反而比较像是一种编程习惯。</p>
<h4 id="4-2-2-1-结构"><a href="#4-2-2-1-结构" class="headerlink" title="4.2.2.1 结构"></a>4.2.2.1 结构</h4><p>简单工厂包含如下角色：</p>
<ul>
<li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品 ：实现或者继承抽象产品的子类</li>
<li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li>
</ul>
<h4 id="4-2-2-2-实现"><a href="#4-2-2-2-实现" class="headerlink" title="4.2.2.2 实现"></a>4.2.2.2 实现</h4><p>现在使用简单工厂对上面案例进行改进，类图如下：</p>
<img src="/images/设计模式-day02/简单工厂模式.png" style="zoom:70%;">

<p>工厂类代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> AmericanoCoffee();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> LatteCoffee();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>工厂（factory）处理创建对象的细节，一旦有了SimpleCoffeeFactory，CoffeeStore类中的orderCoffee()就变成此对象的客户，后期如果需要Coffee对象直接从工厂中获取即可。这样也就解除了和Coffee实现类的耦合，同时又产生了新的耦合，CoffeeStore对象和SimpleCoffeeFactory工厂对象的耦合，工厂对象和商品对象的耦合。</p>
<p>后期如果再加新品种的咖啡，我们势必要需求修改SimpleCoffeeFactory的代码，违反了开闭原则。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p>
<h4 id="4-2-2-4-优缺点"><a href="#4-2-2-4-优缺点" class="headerlink" title="4.2.2.4 优缺点"></a>4.2.2.4 优缺点</h4><p><strong>优点：</strong></p>
<p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p>
<p><strong>缺点：</strong></p>
<p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p>
<h4 id="4-2-2-3-扩展"><a href="#4-2-2-3-扩展" class="headerlink" title="4.2.2.3 扩展"></a>4.2.2.3 扩展</h4><p><strong>静态工厂</strong></p>
<p>在开发中也有一部分人将工厂类中的创建对象的功能定义为静态的，这个就是静态工厂模式，它也不是23种设计模式中的。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleCoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;americano&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> AmericanoCoffee();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;latte&quot;</span>.equals(type)) &#123;<br>            coffee = <span class="hljs-keyword">new</span> LatteCoffee();<br>        &#125;<br>        <span class="hljs-keyword">return</span> coffe;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-2-3-工厂方法模式"><a href="#4-2-3-工厂方法模式" class="headerlink" title="4.2.3 工厂方法模式"></a>4.2.3 工厂方法模式</h3><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p>
<h4 id="4-2-3-1-概念"><a href="#4-2-3-1-概念" class="headerlink" title="4.2.3.1 概念"></a>4.2.3.1 概念</h4><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p>
<h4 id="4-2-3-2-结构"><a href="#4-2-3-2-结构" class="headerlink" title="4.2.3.2 结构"></a>4.2.3.2 结构</h4><p>工厂方法模式的主要角色：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li>
<li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li>
</ul>
<h4 id="4-2-3-3-实现"><a href="#4-2-3-3-实现" class="headerlink" title="4.2.3.3 实现"></a>4.2.3.3 实现</h4><p>使用工厂方法模式对上例进行改进，类图如下：</p>
<img src="/images/设计模式-day02/工厂方法模式.png" style="zoom:70%;">

<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function">Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LatteCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LatteCoffee();<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanCoffeeFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffee();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>咖啡店类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeStore</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> CoffeeFactory factory;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CoffeeStore</span><span class="hljs-params">(CoffeeFactory factory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.factory = factory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">orderCoffee</span><span class="hljs-params">(String type)</span> </span>&#123;<br>        Coffee coffee = factory.createCoffee();<br>        coffee.addMilk();<br>        coffee.addsugar();<br>        <span class="hljs-keyword">return</span> coffee;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p>
<p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p>
<h4 id="4-2-3-4-优缺点"><a href="#4-2-3-4-优缺点" class="headerlink" title="4.2.3.4 优缺点"></a>4.2.3.4 优缺点</h4><p><strong>优点：</strong></p>
<ul>
<li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li>
<li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li>
</ul>
<h3 id="4-2-4-抽象工厂模式"><a href="#4-2-4-抽象工厂模式" class="headerlink" title="4.2.4 抽象工厂模式"></a>4.2.4 抽象工厂模式</h3><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、传智播客只培养计算机软件专业的学生等。</p>
<p>这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p>
<p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示横轴是产品等级，也就是同一类产品；纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</p>
<img src="/images/设计模式-day02/image-20200401214509176.png" style="zoom:67%;">

<img src="/images/设计模式-day02/image-20200401222951963.png" style="zoom:67%;">

<h4 id="4-2-4-1-概念"><a href="#4-2-4-1-概念" class="headerlink" title="4.2.4.1 概念"></a>4.2.4.1 概念</h4><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p>
<p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p>
<h4 id="4-2-4-2-结构"><a href="#4-2-4-2-结构" class="headerlink" title="4.2.4.2 结构"></a>4.2.4.2 结构</h4><p>抽象工厂模式的主要角色如下：</p>
<ul>
<li>抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法，可以创建多个不同等级的产品。</li>
<li>具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li>
<li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li>
<li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。</li>
</ul>
<h4 id="4-2-4-2-实现"><a href="#4-2-4-2-实现" class="headerlink" title="4.2.4.2 实现"></a>4.2.4.2 实现</h4><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏、抹茶慕斯等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生类爆炸情况。其中拿铁咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；拿铁咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）。所以这个案例可以使用抽象工厂模式实现。类图如下：</p>
<img src="/images/设计模式-day02/抽象工厂模式.png" style="zoom:67%;">

<p>代码如下：</p>
<p>抽象工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function">Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>具体工厂：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//美式甜点工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AmericanDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AmericanCoffee();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MatchaMousse();<br>    &#125;<br>&#125;<br><span class="hljs-comment">//意大利风味甜点工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ItalyDessertFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DessertFactory</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> LatteCoffee();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Dessert <span class="hljs-title">createDessert</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Tiramisu();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p>
<h4 id="4-2-4-3-优缺点"><a href="#4-2-4-3-优缺点" class="headerlink" title="4.2.4.3 优缺点"></a>4.2.4.3 优缺点</h4><p><strong>优点：</strong></p>
<p>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</p>
<p><strong>缺点：</strong></p>
<p>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</p>
<h4 id="4-2-4-4-使用场景"><a href="#4-2-4-4-使用场景" class="headerlink" title="4.2.4.4 使用场景"></a>4.2.4.4 使用场景</h4><ul>
<li><p>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</p>
</li>
<li><p>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</p>
</li>
<li><p>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</p>
</li>
</ul>
<p>如：输入法换皮肤，一整套一起换。生成不同操作系统的程序。</p>
<h3 id="4-2-5-模式扩展"><a href="#4-2-5-模式扩展" class="headerlink" title="4.2.5 模式扩展"></a>4.2.5 模式扩展</h3><p><strong>简单工厂+配置文件解除耦合</strong></p>
<p>可以通过工厂模式+配置文件的方式解除工厂对象和产品对象的耦合。在工厂类中加载配置文件中的全类名，并创建对象进行存储，客户端如果需要对象，直接进行获取即可。</p>
<p>第一步：定义配置文件</p>
<p>为了演示方便，我们使用properties文件作为配置文件，名称为bean.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">american</span>=<span class="hljs-string">com.itheima.pattern.factory.config_factory.AmericanCoffee</span><br><span class="hljs-attr">latte</span>=<span class="hljs-string">com.itheima.pattern.factory.config_factory.LatteCoffee</span><br></code></pre></td></tr></table></figure>

<p>第二步：改进工厂类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CoffeeFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Map&lt;String,Coffee&gt; map = <span class="hljs-keyword">new</span> HashMap();<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        Properties p = <span class="hljs-keyword">new</span> Properties();<br>        InputStream is = CoffeeFactory.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;bean.properties&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            p.load(is);<br>            <span class="hljs-comment">//遍历Properties集合对象</span><br>            Set&lt;Object&gt; keys = p.keySet();<br>            <span class="hljs-keyword">for</span> (Object key : keys) &#123;<br>                <span class="hljs-comment">//根据键获取值（全类名）</span><br>                String className = p.getProperty((String) key);<br>                <span class="hljs-comment">//获取字节码对象</span><br>                Class clazz = Class.forName(className);<br>                Coffee obj = (Coffee) clazz.newInstance();<br>                map.put((String)key,obj);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Coffee <span class="hljs-title">createCoffee</span><span class="hljs-params">(String name)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> map.get(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>静态成员变量用来存储创建的对象（键存储的是名称，值存储的是对应的对象），而读取配置文件以及创建对象写在静态代码块中，目的就是只需要执行一次。</p>
<h3 id="4-2-6-JDK源码解析-Collection-iterator方法"><a href="#4-2-6-JDK源码解析-Collection-iterator方法" class="headerlink" title="4.2.6 JDK源码解析-Collection.iterator方法"></a>4.2.6 JDK源码解析-Collection.iterator方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        list.add(<span class="hljs-string">&quot;令狐冲&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;风清扬&quot;</span>);<br>        list.add(<span class="hljs-string">&quot;任我行&quot;</span>);<br><br>        <span class="hljs-comment">//获取迭代器对象</span><br>        Iterator&lt;String&gt; it = list.iterator();<br>        <span class="hljs-comment">//使用迭代器遍历</span><br>        <span class="hljs-keyword">while</span>(it.hasNext()) &#123;<br>            String ele = it.next();<br>            System.out.println(ele);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对上面的代码大家应该很熟，使用迭代器遍历集合，获取集合中的元素。而单列集合获取迭代器的方法就使用到了工厂方法模式。我们看通过类图看看结构：</p>
<img src="/images/设计模式-day02/jdk源码解析.png" style="zoom:75%;">

<p>Collection接口是抽象工厂类，ArrayList是具体的工厂类；Iterator接口是抽象商品类，ArrayList类中的Iter内部类是具体的商品类。在具体的工厂类中iterator()方法创建具体的商品类的对象。</p>
<blockquote>
<p>另：</p>
<p>​    1,DateForamt类中的getInstance()方法使用的是工厂模式；</p>
<p>​    2,Calendar类中的getInstance()方法使用的是工厂模式；</p>
</blockquote>
<h2 id="4-3-原型模式"><a href="#4-3-原型模式" class="headerlink" title="4.3 原型模式"></a>4.3 原型模式</h2><h3 id="4-3-1-概述"><a href="#4-3-1-概述" class="headerlink" title="4.3.1 概述"></a>4.3.1 概述</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型对象相同的新对象。</p>
<h3 id="4-3-2-结构"><a href="#4-3-2-结构" class="headerlink" title="4.3.2 结构"></a>4.3.2 结构</h3><p>原型模式包含如下角色：</p>
<ul>
<li>抽象原型类：规定了具体原型对象必须实现的的 clone() 方法。</li>
<li>具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。</li>
<li>访问类：使用具体原型类中的 clone() 方法来复制新的对象。</li>
</ul>
<p>接口类图如下：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day02/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F.png"></p>
<h3 id="4-3-3-实现"><a href="#4-3-3-实现" class="headerlink" title="4.3.3 实现"></a>4.3.3 实现</h3><p>原型模式的克隆分为浅克隆和深克隆。</p>
<blockquote>
<p>浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</p>
<p>深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。</p>
</blockquote>
<p>Java中的Object类中提供了 <code>clone()</code> 方法来实现浅克隆。 Cloneable 接口是上面的类图中的抽象原型类，而实现了Cloneable接口的子实现类就是具体的原型类。代码如下：</p>
<p><strong>Realizetype（具体的原型类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Realizetype</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Realizetype</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体的原型对象创建完成！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Realizetype <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;具体原型复制成功！&quot;</span>);<br>        <span class="hljs-keyword">return</span> (Realizetype) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>PrototypeTest（测试访问类）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Realizetype r1 = <span class="hljs-keyword">new</span> Realizetype();<br>        Realizetype r2 = r1.clone();<br><br>        System.out.println(<span class="hljs-string">&quot;对象r1和r2是同一个对象？&quot;</span> + (r1 == r2));<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//false : 浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。</span><br></code></pre></td></tr></table></figure>

<h3 id="4-3-4-案例"><a href="#4-3-4-案例" class="headerlink" title="4.3.4 案例"></a>4.3.4 案例</h3><p><strong>用原型模式生成“三好学生”奖状</strong></p>
<p>同一学校的“三好学生”奖状除了获奖人姓名不同，其他都相同，可以使用原型模式复制多个“三好学生”奖状出来，然后在修改奖状上的名字即可。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day02/原型模式1.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//奖状类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.name);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Citation <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Citation) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试访问类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        c1.setName(<span class="hljs-string">&quot;张三&quot;</span>);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//将奖状的名字修改李四</span><br>        c2.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-3-5-使用场景"><a href="#4-3-5-使用场景" class="headerlink" title="4.3.5 使用场景"></a>4.3.5 使用场景</h3><ul>
<li>对象的创建非常复杂，可以使用原型模式快捷的创建对象。</li>
<li>性能和安全要求比较高。</li>
</ul>
<h3 id="4-3-6-扩展（深克隆）"><a href="#4-3-6-扩展（深克隆）" class="headerlink" title="4.3.6 扩展（深克隆）"></a>4.3.6 扩展（深克隆）</h3><p>将上面的“三好学生”奖状的案例中Citation类的name属性修改为Student类型的属性。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//奖状类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Citation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Student stu;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">getStu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> stu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setStu</span><span class="hljs-params">(Student stu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.stu = stu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(stu.getName() + <span class="hljs-string">&quot;同学：在2020学年第一学期中表现优秀，被评为三好学生。特发此状！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Citation <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> (Citation) <span class="hljs-keyword">super</span>.clone();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//学生类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> String address;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">(String name, String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Student</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getAddress</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> address;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAddress</span><span class="hljs-params">(String address)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.address = address;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br><br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//复制奖状</span><br>        Citation c2 = c1.clone();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="/images/设计模式-day02/原型模式2.png" style="zoom:80%;">

<p><font color="red">说明：</font></p>
<p>​    stu对象和stu1对象是同一个对象，就会产生将stu1对象中name属性值改为“李四”，两个Citation（奖状）对象中显示的都是李四。这就是浅克隆的效果，对具体原型类（Citation）中的引用类型的属性进行引用的复制。这种情况需要使用深克隆，而进行深克隆需要使用对象流。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CitationTest1</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        Citation c1 = <span class="hljs-keyword">new</span> Citation();<br>        Student stu = <span class="hljs-keyword">new</span> Student(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;西安&quot;</span>);<br>        c1.setStu(stu);<br><br>        <span class="hljs-comment">//创建对象输出流对象</span><br>        ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));<br>        <span class="hljs-comment">//将c1对象写出到文件中</span><br>        oos.writeObject(c1);<br>        oos.close();<br><br>        <span class="hljs-comment">//创建对象出入流对象</span><br>        ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\b.txt&quot;</span>));<br>        <span class="hljs-comment">//读取对象</span><br>        Citation c2 = (Citation) ois.readObject();<br>        <span class="hljs-comment">//获取c2奖状所属学生对象</span><br>        Student stu1 = c2.getStu();<br>        stu1.setName(<span class="hljs-string">&quot;李四&quot;</span>);<br><br>        <span class="hljs-comment">//判断stu对象和stu1对象是否是同一个对象</span><br>        System.out.println(<span class="hljs-string">&quot;stu和stu1是同一个对象？&quot;</span> + (stu == stu1));<br><br>        c1.show();<br>        c2.show();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果为：</p>
<img src="/images/设计模式-day02/原型模式3.png" style="zoom:80%;">

<blockquote>
<p>注意：Citation类和Student类必须实现Serializable接口，否则会抛NotSerializableException异常。</p>
</blockquote>
<h2 id="4-5-建造者模式"><a href="#4-5-建造者模式" class="headerlink" title="4.5 建造者模式"></a>4.5 建造者模式</h2><h3 id="4-4-1-概述"><a href="#4-4-1-概述" class="headerlink" title="4.4.1 概述"></a>4.4.1 概述</h3><p>将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示。</p>
<img src="/images/设计模式-day02/image-20200413225341516.png" style="zoom:60%;">

<ul>
<li>分离了部件的构造(由Builder来负责)和装配(由Director负责)。 从而可以构造出复杂的对象。这个模式适用于：某个对象的构建过程复杂的情况。</li>
<li>由于实现了构建和装配的解耦。不同的构建器，相同的装配，也可以做出不同的对象；相同的构建器，不同的装配顺序也可以做出不同的对象。也就是实现了构建算法、装配算法的解耦，实现了更好的复用。</li>
<li>建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</li>
</ul>
<h3 id="4-4-2-结构"><a href="#4-4-2-结构" class="headerlink" title="4.4.2 结构"></a>4.4.2 结构</h3><p>建造者（Builder）模式包含如下角色：</p>
<ul>
<li><p>抽象建造者类（Builder）：这个接口规定要实现复杂对象的那些部分的创建，并不涉及具体的部件对象的创建。 </p>
</li>
<li><p>具体建造者类（ConcreteBuilder）：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。在构造过程完成后，提供产品的实例。 </p>
</li>
<li><p>产品类（Product）：要创建的复杂对象。</p>
</li>
<li><p>指挥者类（Director）：调用具体建造者来创建复杂对象的各个部分，在指导者中不涉及具体产品的信息，只负责保证对象各部分完整创建或按某种顺序创建。 </p>
</li>
</ul>
<p>类图如下：</p>
<img src="/images/设计模式-day02/建造者模式.png" style="zoom:80%;">



<h3 id="4-4-3-实例"><a href="#4-4-3-实例" class="headerlink" title="4.4.3 实例"></a>4.4.3 实例</h3><p><strong>创建共享单车</strong></p>
<p>生产自行车是一个复杂的过程，它包含了车架，车座等组件的生产。而车架又有碳纤维，铝合金等材质的，车座有橡胶，真皮等材质。对于自行车的生产就可以使用建造者模式。</p>
<p>这里Bike是产品，包含车架，车座等组件；Builder是抽象建造者，MobikeBuilder和OfoBuilder是具体的建造者；Director是指挥者。类图如下：</p>
<img src="/images/设计模式-day02/建造者模式1.png" style="zoom:80%;">

<p>具体的代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//自行车类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bike</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String frame;<br>    <span class="hljs-keyword">private</span> String seat;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> frame;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFrame</span><span class="hljs-params">(String frame)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.frame = frame;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> seat;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setSeat</span><span class="hljs-params">(String seat)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.seat = seat;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 抽象 builder 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Bike mBike = <span class="hljs-keyword">new</span> Bike();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//摩拜单车Builder类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MobikeBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setFrame(<span class="hljs-string">&quot;铝合金车架&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setSeat(<span class="hljs-string">&quot;真皮车座&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBike;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//ofo单车Builder类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OfoBuilder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setFrame(<span class="hljs-string">&quot;碳纤维车架&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span> </span>&#123;<br>        mBike.setSeat(<span class="hljs-string">&quot;橡胶车座&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mBike;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//指挥者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Builder mBuilder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        mBuilder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        mBuilder.buildFrame();<br>        mBuilder.buildSeat();<br>        <span class="hljs-keyword">return</span> mBuilder.createBike();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        showBike(<span class="hljs-keyword">new</span> OfoBuilder());<br>        showBike(<span class="hljs-keyword">new</span> MobikeBuilder());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">showBike</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        Director director = <span class="hljs-keyword">new</span> Director(builder);<br>        Bike bike = director.construct();<br>        System.out.println(bike.getFrame());<br>        System.out.println(bike.getSeat());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<p>上面示例是 Builder模式的常规用法，指挥者类 Director 在建造者模式中具有很重要的作用，它用于指导具体构建者如何构建产品，控制调用先后次序，并向调用者返回完整的产品类，但是有些情况下需要简化系统结构，可以把指挥者类和抽象建造者进行结合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 抽象 builder 类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> Bike mBike = <span class="hljs-keyword">new</span> Bike();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildFrame</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildSeat</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> Bike <span class="hljs-title">createBike</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Bike <span class="hljs-title">construct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.buildFrame();<br>        <span class="hljs-keyword">this</span>.BuildSeat();<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.createBike();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>说明：</strong></p>
<p>这样做确实简化了系统结构，但同时也加重了抽象建造者类的职责，也不是太符合单一职责原则，如果construct() 过于复杂，建议还是封装到 Director 中。</p>
<h3 id="4-4-4-优缺点"><a href="#4-4-4-优缺点" class="headerlink" title="4.4.4 优缺点"></a>4.4.4 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>建造者模式的封装性很好。使用建造者模式可以有效的封装变化，在使用建造者模式的场景中，一般产品类和建造者类是比较稳定的，因此，将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。</li>
<li>在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li>
<li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li>
<li>建造者模式很容易进行扩展。如果有新的需求，通过实现一个新的建造者类就可以完成，基本上不用修改之前已经测试通过的代码，因此也就不会对原有功能引入风险。符合开闭原则。</li>
</ul>
<p><strong>缺点：</strong></p>
<p>造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</p>
<h3 id="4-4-5-使用场景"><a href="#4-4-5-使用场景" class="headerlink" title="4.4.5 使用场景"></a>4.4.5 使用场景</h3><p>建造者（Builder）模式创建的是复杂对象，其产品的各个部分经常面临着剧烈的变化，但将它们组合在一起的算法却相对稳定，所以它通常在以下场合使用。</p>
<ul>
<li>创建的对象较复杂，由多个部件构成，各部件面临着复杂的变化，但构件间的建造顺序是稳定的。</li>
<li>创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。</li>
</ul>
<h3 id="4-4-6-模式扩展"><a href="#4-4-6-模式扩展" class="headerlink" title="4.4.6 模式扩展"></a>4.4.6 模式扩展</h3><p>建造者模式除了上面的用途外，在开发中还有一个常用的使用方式，就是当一个类构造器需要传入很多参数时，如果创建这个类的实例，代码可读性会非常差，而且很容易引入错误，此时就可以利用建造者模式进行重构。</p>
<p>重构前代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Phone</span><span class="hljs-params">(String cpu, String screen, String memory, String mainboard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>        <span class="hljs-keyword">this</span>.screen = screen;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>        <span class="hljs-keyword">this</span>.mainboard = mainboard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getCpu</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCpu</span><span class="hljs-params">(String cpu)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.cpu = cpu;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getScreen</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> screen;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setScreen</span><span class="hljs-params">(String screen)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.screen = screen;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMemory</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemory</span><span class="hljs-params">(String memory)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memory = memory;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMainboard</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> mainboard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMainboard</span><span class="hljs-params">(String mainboard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.mainboard = mainboard;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//构建Phone对象</span><br>        Phone phone = <span class="hljs-keyword">new</span> Phone(<span class="hljs-string">&quot;intel&quot;</span>,<span class="hljs-string">&quot;三星屏幕&quot;</span>,<span class="hljs-string">&quot;金士顿&quot;</span>,<span class="hljs-string">&quot;华硕&quot;</span>);<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面在客户端代码中构建Phone对象，传递了四个参数，如果参数更多呢？代码的可读性及使用的成本就是比较高。</p>
<p>重构后代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Phone</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String cpu;<br>    <span class="hljs-keyword">private</span> String screen;<br>    <span class="hljs-keyword">private</span> String memory;<br>    <span class="hljs-keyword">private</span> String mainboard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Phone</span><span class="hljs-params">(Builder builder)</span> </span>&#123;<br>        cpu = builder.cpu;<br>        screen = builder.screen;<br>        memory = builder.memory;<br>        mainboard = builder.mainboard;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> String cpu;<br>        <span class="hljs-keyword">private</span> String screen;<br>        <span class="hljs-keyword">private</span> String memory;<br>        <span class="hljs-keyword">private</span> String mainboard;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Builder</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">cpu</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            cpu = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">screen</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            screen = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">memory</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            memory = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">mainboard</span><span class="hljs-params">(String val)</span> </span>&#123;<br>            mainboard = val;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Phone <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Phone(<span class="hljs-keyword">this</span>);&#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Phone&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;cpu=&#x27;&quot;</span> + cpu + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, screen=&#x27;&quot;</span> + screen + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, memory=&#x27;&quot;</span> + memory + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, mainboard=&#x27;&quot;</span> + mainboard + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Phone phone = <span class="hljs-keyword">new</span> Phone.Builder()<br>                .cpu(<span class="hljs-string">&quot;intel&quot;</span>)<br>                .mainboard(<span class="hljs-string">&quot;华硕&quot;</span>)<br>                .memory(<span class="hljs-string">&quot;金士顿&quot;</span>)<br>                .screen(<span class="hljs-string">&quot;三星&quot;</span>)<br>                .build();<br>        System.out.println(phone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>重构后的代码在使用起来更方便，某种程度上也可以提高开发效率。从软件设计上，对程序员的要求比较高。</p>
<h2 id="4-6-创建者模式对比"><a href="#4-6-创建者模式对比" class="headerlink" title="4.6 创建者模式对比"></a>4.6 创建者模式对比</h2><h3 id="4-6-1-工厂方法模式VS建造者模式"><a href="#4-6-1-工厂方法模式VS建造者模式" class="headerlink" title="4.6.1 工厂方法模式VS建造者模式"></a>4.6.1 工厂方法模式VS建造者模式</h3><p>工厂方法模式注重的是整体对象的创建方式；而建造者模式注重的是部件构建的过程，意在通过一步一步地精确构造创建出一个复杂的对象。</p>
<p>我们举个简单例子来说明两者的差异，如要制造一个超人，如果使用工厂方法模式，直接产生出来的就是一个力大无穷、能够飞翔、内裤外穿的超人；而如果使用建造者模式，则需要组装手、头、脚、躯干等部分，然后再把内裤外穿，于是一个超人就诞生了。</p>
<h3 id="4-6-2-抽象工厂模式VS建造者模式"><a href="#4-6-2-抽象工厂模式VS建造者模式" class="headerlink" title="4.6.2 抽象工厂模式VS建造者模式"></a>4.6.2 抽象工厂模式VS建造者模式</h3><p>抽象工厂模式实现对产品家族的创建，一个产品家族是这样的一系列产品：具有不同分类维度的产品组合，采用抽象工厂模式则是不需要关心构建过程，只关心什么产品由什么工厂生产即可。</p>
<p>建造者模式则是要求按照指定的蓝图建造产品，它的主要目的是通过组装零配件而产生一个新产品。</p>
<p>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day03</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/</url>
    <content><![CDATA[<h1 id="5，结构型模式"><a href="#5，结构型模式" class="headerlink" title="5，结构型模式"></a>5，结构型模式</h1><p>结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。</p>
<p>由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下 7 种：</p>
<ul>
<li>代理模式</li>
<li>适配器模式</li>
<li>装饰者模式</li>
<li>桥接模式</li>
<li>外观模式</li>
<li>组合模式</li>
<li>享元模式</li>
</ul>
<h2 id="5-1-代理模式"><a href="#5-1-代理模式" class="headerlink" title="5.1 代理模式"></a>5.1 代理模式</h2><h3 id="5-1-1-概述"><a href="#5-1-1-概述" class="headerlink" title="5.1.1 概述"></a>5.1.1 概述</h3><p>由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>Java中的代理按照代理类生成时机不同又分为<strong>静态代理</strong>和<strong>动态代理</strong>。**==静态代理代理类在编译期就生成，而动态代理代理类则是在Java运行时动态生成。动态代理又有JDK代理和CGLib代理两种。==**</p>
<h3 id="5-1-2-结构"><a href="#5-1-2-结构" class="headerlink" title="5.1.2 结构"></a>5.1.2 结构</h3><p>代理（Proxy）模式分为三种角色：</p>
<ul>
<li>抽象主题（Subject）类： 通过接口或抽象类声明真实主题和代理对象实现的业务方法。</li>
<li>真实主题（Real Subject）类： 实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。</li>
<li>代理（Proxy）类 ： 提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。</li>
</ul>
<h3 id="5-1-3-静态代理"><a href="#5-1-3-静态代理" class="headerlink" title="5.1.3 静态代理"></a>5.1.3 静态代理</h3><p>我们通过案例来感受一下静态代理。</p>
<p>【例】火车站卖票</p>
<p>如果要买火车票的话，需要去火车站买票，坐车到火车站，排队等一系列的操作，显然比较麻烦。而火车站在多个地方都有代售点，我们去代售点买票就方便很多了。这个例子其实就是典型的代理模式，火车站是目标对象，代售点是代理对象。类图如下：</p>
<img src="/images/设计模式-day03/静态代理.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//卖票接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代售点</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyPoint</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用&quot;</span>);<br>        station.sell();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ProxyPoint pp = <span class="hljs-keyword">new</span> ProxyPoint();<br>        pp.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码中可以看出测试类直接访问的是ProxyPoint类对象，也就是说ProxyPoint作为访问对象和目标对象的中介。同时也对sell方法进行了增强（代理点收取一些服务费用）。</p>
<h3 id="5-1-4-JDK动态代理"><a href="#5-1-4-JDK动态代理" class="headerlink" title="5.1.4 JDK动态代理"></a>5.1.4 JDK动态代理</h3><p>接下来我们使用动态代理实现上面案例，先说说JDK提供的动态代理。Java中提供了一个动态代理类Proxy，Proxy并不是我们上述所说的代理对象的类，而是提供了一个创建代理对象的静态方法（newProxyInstance方法）来获取代理对象。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//卖票接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//火车站  火车站具有卖票功能，所以需要实现SellTickets接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂，用来创建代理对象</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SellTickets <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用Proxy获取代理对象</span><br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">            newProxyInstance()方法参数说明：</span><br><span class="hljs-comment">                ClassLoader loader ： 类加载器，用于加载代理类，使用真实对象的类加载器即可</span><br><span class="hljs-comment">                Class&lt;?&gt;[] interfaces ： 真实对象所实现的接口，代理模式真实对象和代理对象实现相同的接口</span><br><span class="hljs-comment">                InvocationHandler h ： 代理对象的调用处理程序</span><br><span class="hljs-comment">         */</span><br>        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),<br>                station.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <span class="hljs-comment">/*</span><br><span class="hljs-comment">                        InvocationHandler中invoke方法参数说明：</span><br><span class="hljs-comment">                            proxy ： 代理对象</span><br><span class="hljs-comment">                            method ： 对应于在代理对象上调用的接口方法的 Method 实例</span><br><span class="hljs-comment">                            args ： 代理对象调用接口方法时传递的实际参数</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);<br>                        <span class="hljs-comment">//执行真实对象</span><br>                        Object result = method.invoke(station, args);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> sellTickets;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取代理对象</span><br>        ProxyFactory factory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        <br>        SellTickets proxyObject = factory.getProxyObject();<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><font color="red">使用了动态代理，我们思考下面问题：</font></p>
<ul>
<li><p>ProxyFactory是代理类吗？</p>
<p>ProxyFactory不是代理模式中所说的代理类，而代理类是程序在运行过程中动态的在内存中生成的类。通过阿里巴巴开源的 Java 诊断工具（Arthas【阿尔萨斯】）查看代理类的结构：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.sun.proxy;<br><br><span class="hljs-keyword">import</span> com.itheima.proxy.dynamic.jdk.SellTickets;<br><span class="hljs-keyword">import</span> java.lang.reflect.InvocationHandler;<br><span class="hljs-keyword">import</span> java.lang.reflect.Method;<br><span class="hljs-keyword">import</span> java.lang.reflect.Proxy;<br><span class="hljs-keyword">import</span> java.lang.reflect.UndeclaredThrowableException;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m0;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-keyword">super</span>(invocationHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            m1 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;equals&quot;</span>, Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>));<br>            m2 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;toString&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m3 = Class.forName(<span class="hljs-string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            m0 = Class.forName(<span class="hljs-string">&quot;java.lang.Object&quot;</span>).getMethod(<span class="hljs-string">&quot;hashCode&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (NoSuchMethodException noSuchMethodException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchMethodError(noSuchMethodException.getMessage());<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (ClassNotFoundException classNotFoundException) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoClassDefFoundError(classNotFoundException.getMessage());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">equals</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Boolean)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m1, <span class="hljs-keyword">new</span> Object[]&#123;object&#125;);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (String)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m2, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> <span class="hljs-title">hashCode</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> (Integer)<span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m0, <span class="hljs-keyword">null</span>);<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">null</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Error | RuntimeException throwable) &#123;<br>            <span class="hljs-keyword">throw</span> throwable;<br>        &#125;<br>        <span class="hljs-keyword">catch</span> (Throwable throwable) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UndeclaredThrowableException(throwable);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面的类中，我们可以看到以下几个信息：</p>
<ul>
<li>代理类（$Proxy0）实现了SellTickets。这也就印证了我们之前说的真实类和代理类实现同样的接口。</li>
<li>代理类（$Proxy0）将我们提供了的匿名内部类对象传递给了父类。</li>
</ul>
</li>
<li><p>动态代理的执行流程是什么样？</p>
<p>下面是摘取的重点代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//程序运行过程中动态生成的代理类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> $<span class="hljs-title">Proxy0</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SellTickets</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Method m3;<br><br>    <span class="hljs-keyword">public</span> $Proxy0(InvocationHandler invocationHandler) &#123;<br>        <span class="hljs-keyword">super</span>(invocationHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        m3 = Class.forName(<span class="hljs-string">&quot;com.itheima.proxy.dynamic.jdk.SellTickets&quot;</span>).getMethod(<span class="hljs-string">&quot;sell&quot;</span>, <span class="hljs-keyword">new</span> Class[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.h.invoke(<span class="hljs-keyword">this</span>, m3, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//Java提供的动态代理相关类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Proxy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>	<span class="hljs-keyword">protected</span> InvocationHandler h;<br>	 <br>	<span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-title">Proxy</span><span class="hljs-params">(InvocationHandler h)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.h = h;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TrainStation station = <span class="hljs-keyword">new</span> TrainStation();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SellTickets <span class="hljs-title">getProxyObject</span><span class="hljs-params">()</span> </span>&#123;<br>        SellTickets sellTickets = (SellTickets) Proxy.newProxyInstance(station.getClass().getClassLoader(),<br>                station.getClass().getInterfaces(),<br>                <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>                    <br>                    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br><br>                        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(JDK动态代理方式)&quot;</span>);<br>                        Object result = method.invoke(station, args);<br>                        <span class="hljs-keyword">return</span> result;<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">return</span> sellTickets;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-comment">//测试访问类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//获取代理对象</span><br>        ProxyFactory factory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        SellTickets proxyObject = factory.getProxyObject();<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<p>执行流程如下：</p>
<ol>
<li><strong>在测试类中通过代理对象调用sell()方法</strong></li>
<li><strong>根据多态的特性，执行的是代理类（$Proxy0）中的sell()方法</strong></li>
<li><strong>代理类（$Proxy0）中的sell()方法中又调用了InvocationHandler接口的子实现类对象的invoke方法</strong></li>
<li><strong>invoke方法通过反射执行了真实对象所属类(TrainStation)中的sell()方法</strong></li>
</ol>
<h3 id="5-1-5-CGLIB动态代理"><a href="#5-1-5-CGLIB动态代理" class="headerlink" title="5.1.5 CGLIB动态代理"></a>5.1.5 CGLIB动态代理</h3><p>同样是上面的案例，我们再次使用CGLIB代理实现。</p>
<p>如果没有定义SellTickets接口，只定义了TrainStation(火车站类)。很显然JDK代理是无法使用了，因为JDK动态代理要求必须定义接口，对接口进行代理。</p>
<p>CGLIB是一个功能强大，高性能的代码生成包。它为没有实现接口的类提供代理，为JDK的动态代理提供了很好的补充。</p>
<p>CGLIB是第三方提供的包，所以需要引入jar包的坐标：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>cglib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.2.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//火车站</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainStation</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sell</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;火车站卖票&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//代理工厂</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProxyFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span></span>&#123;<br><br><br>    <span class="hljs-keyword">public</span> &lt;T extends Object&gt; <span class="hljs-function">T <span class="hljs-title">getProxyObject</span><span class="hljs-params">(T object)</span></span>&#123;<br>        Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>        <span class="hljs-comment">//设置目标类的字节码文件</span><br>        enhancer.setSuperclass(object.getClass());<br>        <span class="hljs-comment">//设置回调函数</span><br>        enhancer.setCallback(<span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">return</span> (T)enhancer.create();<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o,Method method,Object[] objects,MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable</span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;代理点收取一些服务费用(CGLIB动态代理方式))&quot;</span>);<br>        <span class="hljs-keyword">return</span> methodProxy.invokeSuper(o,objects);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>        TrainStation proxyObject = proxyFactory.getProxyObject(<span class="hljs-keyword">new</span> TrainStation());<br>        proxyObject.sell();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="5-1-6-三种代理的对比"><a href="#5-1-6-三种代理的对比" class="headerlink" title="5.1.6 三种代理的对比"></a>5.1.6 三种代理的对比</h3><ul>
<li><p>jdk代理和CGLIB代理</p>
<p>使用CGLib实现动态代理，CGLib底层采用ASM字节码生成框架，使用字节码技术生成代理类，在JDK1.6之前比使用Java反射效率要高。唯一需要注意的是，CGLib不能对声明为final的类或者方法进行代理，因为CGLib原理是动态生成被代理类的子类。</p>
<p>在JDK1.6、JDK1.7、JDK1.8逐步对JDK动态代理优化之后，在调用次数较少的情况下，JDK代理效率高于CGLib代理效率，只有当进行大量调用的时候，JDK1.6和JDK1.7比CGLib代理效率低一点，但是到JDK1.8的时候，JDK代理效率高于CGLib代理。所以如果有接口使用JDK动态代理，如果没有接口使用CGLIB代理。</p>
</li>
<li><p>动态代理和静态代理</p>
<p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler.invoke）。这样，在接口方法数量比较多的时候，我们可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。</p>
<p>如果接口增加一个方法，静态代理模式除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法。增加了代码维护的复杂度。而动态代理不会出现该问题</p>
</li>
</ul>
<h3 id="5-1-7-优缺点"><a href="#5-1-7-优缺点" class="headerlink" title="5.1.7 优缺点"></a>5.1.7 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理对象可以扩展目标对象的功能；</li>
<li>代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>增加了系统的复杂度；</li>
</ul>
<h3 id="5-1-8-使用场景"><a href="#5-1-8-使用场景" class="headerlink" title="5.1.8 使用场景"></a>5.1.8 使用场景</h3><h4 id="1、远程（Remote）代理"><a href="#1、远程（Remote）代理" class="headerlink" title="==1、远程（Remote）代理=="></a><strong>==1、远程（Remote）代理==</strong></h4><p>本地服务通过网络请求远程服务。为了实现本地到远程的通信，我们需要实现网络通信，处理其中可能的异常。为良好的代码设计和可维护性，我们将网络通信部分隐藏起来，只暴露给本地服务一个接口，通过该接口即可访问远程服务提供的功能，而不必过多关心通信部分的细节。</p>
<h4 id="2、防火墙（Firewall）代理（vpn）"><a href="#2、防火墙（Firewall）代理（vpn）" class="headerlink" title="==2、防火墙（Firewall）代理（vpn）=="></a><strong>==2、防火墙（Firewall）代理（vpn）==</strong></h4><p>当你将浏览器配置成使用代理功能时，防火墙就将你的浏览器的请求转给互联网；当互联网返回响应时，代理服务器再把它转给你的浏览器。</p>
<h4 id="3、保护（Protect-or-Access）代理（网关）"><a href="#3、保护（Protect-or-Access）代理（网关）" class="headerlink" title="==3、保护（Protect or Access）代理（网关）=="></a><strong>==3、保护（Protect or Access）代理（网关）==</strong></h4><p>控制对一个对象的访问，如果需要，可以给不同的用户提供不同级别的使用权限。</p>
<h2 id="5-2-适配器模式"><a href="#5-2-适配器模式" class="headerlink" title="5.2 适配器模式"></a>5.2 适配器模式</h2><h3 id="5-2-1-概述"><a href="#5-2-1-概述" class="headerlink" title="5.2.1 概述"></a>5.2.1 概述</h3><p>如果去欧洲国家去旅游的话，他们的插座如下图最左边，是欧洲标准。而我们使用的插头如下图最右边的。因此我们的笔记本电脑，手机在当地不能直接充电。所以就需要一个插座转换器，转换器第1面插入当地的插座，第2面供我们充电，这样使得我们的插头在当地能使用。生活中这样的例子很多，手机充电器（将220v转换为5v的电压），读卡器等，其实就是使用到了适配器模式。</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/%E8%BD%AC%E6%8E%A5%E5%A4%B4.png"></p>
<p><strong>定义：</strong></p>
<p>​    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p>
<p>​    适配器模式分为类适配器模式和对象适配器模式，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。</p>
<h3 id="5-2-2-结构"><a href="#5-2-2-结构" class="headerlink" title="5.2.2 结构"></a>5.2.2 结构</h3><p>适配器模式（Adapter）包含以下主要角色：</p>
<ul>
<li>目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。</li>
<li>适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。</li>
<li>适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。</li>
</ul>
<h3 id="5-2-3-类适配器模式"><a href="#5-2-3-类适配器模式" class="headerlink" title="5.2.3 类适配器模式"></a>5.2.3 类适配器模式</h3><p>实现方式：定义一个适配器类来实现当前系统的业务接口，同时又继承现有组件库中已经存在的组件。</p>
<p>【例】读卡器</p>
<p>现有一台电脑只能读取SD卡，而要读取TF卡中的内容的话就需要使用到适配器模式。创建一个读卡器，将TF卡中的内容读取出来。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day03/适配器模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//SD卡的接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">SDCard</span> </span>&#123;<br>    <span class="hljs-comment">//读取SD卡方法</span><br>    <span class="hljs-function">String <span class="hljs-title">readSD</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//写入SD卡功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//SD卡实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        String msg = <span class="hljs-string">&quot;sd card read a msg :hello word SD&quot;</span>;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;sd card write msg : &quot;</span> + msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电脑类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Computer</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">(SDCard sdCard)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(sdCard == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException(<span class="hljs-string">&quot;sd card null&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> sdCard.readSD();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//TF卡接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TFCard</span> </span>&#123;<br>    <span class="hljs-comment">//读取TF卡方法</span><br>    <span class="hljs-function">String <span class="hljs-title">readTF</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-comment">//写入TF卡功能</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">writeTF</span><span class="hljs-params">(String msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//TF卡实现类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TFCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TFCard</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readTF</span><span class="hljs-params">()</span> </span>&#123;<br>        String msg =<span class="hljs-string">&quot;tf card read msg : hello word tf card&quot;</span>;<br>        <span class="hljs-keyword">return</span> msg;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeTF</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;tf card write a msg : &quot;</span> + msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//定义适配器类（SD兼容TF）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDAdapterTF</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">TFCardImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter read tf card &quot;</span>);<br>        <span class="hljs-keyword">return</span> readTF();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter write tf card&quot;</span>);<br>        writeTF(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        SDCard sdCard = <span class="hljs-keyword">new</span> SDCardImpl();<br>        System.out.println(computer.readSD(sdCard));<br><br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>        SDAdapterTF adapter = <span class="hljs-keyword">new</span> SDAdapterTF();<br>        System.out.println(computer.readSD(adapter));<br>    &#125;<br>&#125;<br>读取SD卡信息<br>读取SD卡信息<br>------------<br>适配器适配方法readSD。。。<br>读取TF卡信息<br>读取TF卡信息<br></code></pre></td></tr></table></figure>

<p>类适配器模式违背了合成复用原则。类适配器是客户类有一个接口规范的情况下可用，反之不可用。</p>
<h3 id="5-2-4-对象适配器模式"><a href="#5-2-4-对象适配器模式" class="headerlink" title="5.2.4 对象适配器模式"></a>5.2.4 对象适配器模式</h3><p>实现方式：对象适配器模式可釆用将现有组件库中已经实现的组件引入适配器类中，该类同时实现当前系统的业务接口。</p>
<p>【例】读卡器</p>
<p>我们使用对象适配器模式将读卡器的案例进行改写。类图如下：</p>
<img src="/images/设计模式-day03/对象适配器模式.png" style="zoom:80%;">

<p>代码如下：</p>
<p>类适配器模式的代码，我们只需要修改适配器类（SDAdapterTF）和测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//创建适配器对象（SD兼容TF）</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SDAdapterTF</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">SDCard</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> TFCard tfCard;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SDAdapterTF</span><span class="hljs-params">(TFCard tfCard)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tfCard = tfCard;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">readSD</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter read tf card &quot;</span>);<br>        <span class="hljs-keyword">return</span> tfCard.readTF();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">writeSD</span><span class="hljs-params">(String msg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;adapter write tf card&quot;</span>);<br>        tfCard.writeTF(msg);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Computer computer = <span class="hljs-keyword">new</span> Computer();<br>        SDCard sdCard = <span class="hljs-keyword">new</span> SDCardImpl();<br>        System.out.println(computer.readSD(sdCard));<br><br>        System.out.println(<span class="hljs-string">&quot;------------&quot;</span>);<br><br>        TFCard tfCard = <span class="hljs-keyword">new</span> TFCardImpl();<br>        SDAdapterTF adapter = <span class="hljs-keyword">new</span> SDAdapterTF(tfCard);<br>        System.out.println(computer.readSD(adapter));<br>    &#125;<br>&#125;<br>读取SD卡信息<br>读取SD卡信息<br>------------<br>适配器适配方法readSD。。。<br>读取TF卡信息<br>读取TF卡信息<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：当不需要<strong>全部实现</strong>接口提供的方法时，可先设计一个<strong>抽象类</strong>实现接口，并为该接口中每个方法提供一个<strong>默认实现</strong>（空方法），那么该抽象类的子类可<strong>有选择</strong>地覆盖父类的某些方法来实现需求，它适用于<strong>一个接口不想使用其所有的方法</strong>的情况。</p>
</blockquote>
<p>举例：WebMvcConfigurerAdapter和WebMvcConfigurer</p>
<h3 id="5-2-5-应用场景"><a href="#5-2-5-应用场景" class="headerlink" title="5.2.5 应用场景"></a>5.2.5 应用场景</h3><ul>
<li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li>
<li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li>
</ul>
<h3 id="5-2-6-JDK源码解析"><a href="#5-2-6-JDK源码解析" class="headerlink" title="5.2.6 JDK源码解析"></a>5.2.6 JDK源码解析</h3><p>Reader（字符流）、InputStream（字节流）的适配使用的是InputStreamReader。</p>
<p>InputStreamReader继承自java.io包中的Reader，对他中的抽象的未实现的方法给出实现。如：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> sd.read();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">char</span> cbuf[], <span class="hljs-keyword">int</span> offset, <span class="hljs-keyword">int</span> length)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">return</span> sd.read(cbuf, offset, length);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如上代码中的sd（StreamDecoder类对象），在Sun的JDK实现中，实际的方法实现是对sun.nio.cs.StreamDecoder类的同名方法的调用封装。类结构图如下：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-jdk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90.png"></p>
<p>从上图可以看出：</p>
<ul>
<li>InputStreamReader是对同样实现了Reader的StreamDecoder的封装。</li>
<li>StreamDecoder不是Java SE API中的内容，是Sun  JDK给出的自身实现。但我们知道他们对构造方法中的字节流类（InputStream）进行封装，并通过该类进行了字节流和字符流之间的解码转换。</li>
</ul>
<p><font color="red">结论：</font></p>
<p>​    从表层来看，InputStreamReader做了InputStream字节流类到Reader字符流之间的转换。而从如上Sun JDK中的实现类关系结构中可以看出，是StreamDecoder的设计实现在实际上采用了适配器模式。</p>
<h2 id="5-3-装饰者模式"><a href="#5-3-装饰者模式" class="headerlink" title="5.3 装饰者模式"></a>5.3 装饰者模式</h2><h3 id="5-3-1-概述"><a href="#5-3-1-概述" class="headerlink" title="5.3.1 概述"></a>5.3.1 概述</h3><p>我们先来看一个快餐店的例子。</p>
<p>快餐店有炒面、炒饭这些快餐，可以额外附加鸡蛋、火腿、培根这些配菜，当然加配菜需要额外加钱，每个配菜的价钱通常不太一样，那么计算总价就会显得比较麻烦。</p>
<img src="/images/设计模式-day03/装饰者模式-使用前.png" style="zoom:80%;">

<p>使用继承的方式存在的问题：</p>
<ul>
<li><p>扩展性不好</p>
<p>如果要再加一种配料（火腿肠），我们就会发现需要给FriedRice和FriedNoodles分别定义一个子类。如果要新增一个快餐品类（炒河粉）的话，就需要定义更多的子类。</p>
</li>
<li><p>产生过多的子类</p>
</li>
</ul>
<p><strong>定义：</strong></p>
<p>​    指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式。</p>
<h3 id="5-3-2-结构"><a href="#5-3-2-结构" class="headerlink" title="5.3.2 结构"></a>5.3.2 结构</h3><p>装饰（Decorator）模式中的角色：</p>
<ul>
<li>抽象构件（Component）角色 ：定义一个抽象接口以规范准备接收附加责任的对象。</li>
<li>具体构件（Concrete  Component）角色 ：实现抽象构件，通过装饰角色为其添加一些职责。</li>
<li>抽象装饰（Decorator）角色 ： 继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</li>
<li>具体装饰（ConcreteDecorator）角色 ：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</li>
</ul>
<h3 id="5-3-3-案例"><a href="#5-3-3-案例" class="headerlink" title="5.3.3 案例"></a>5.3.3 案例</h3><p>我们使用装饰者模式对快餐店案例进行改进，体会装饰者模式的精髓。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day03//装饰者模式.png" style="zoom:75%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//快餐接口</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FastFood</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">float</span> price;<br>    <span class="hljs-keyword">private</span> String desc;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastFood</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FastFood</span><span class="hljs-params">(<span class="hljs-keyword">float</span> price, String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPrice</span><span class="hljs-params">(<span class="hljs-keyword">float</span> price)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.price = price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">getPrice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> price;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDesc</span><span class="hljs-params">(String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.desc = desc;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span></span>;  <span class="hljs-comment">//获取价格</span><br>&#125;<br><br><span class="hljs-comment">//炒饭</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedRice</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FriedRice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">10</span>, <span class="hljs-string">&quot;炒饭&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//炒面</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FriedNoodles</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FriedNoodles</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(<span class="hljs-number">12</span>, <span class="hljs-string">&quot;炒面&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//配料类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Garnish</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">FastFood</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> FastFood fastFood;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FastFood <span class="hljs-title">getFastFood</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> fastFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFastFood</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.fastFood = fastFood;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Garnish</span><span class="hljs-params">(FastFood fastFood, <span class="hljs-keyword">float</span> price, String desc)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(price,desc);<br>        <span class="hljs-keyword">this</span>.fastFood = fastFood;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//鸡蛋配料</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Egg</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Garnish</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Egg</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(fastFood,<span class="hljs-number">1</span>,<span class="hljs-string">&quot;鸡蛋&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice() + getFastFood().getPrice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc() + getFastFood().getDesc();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//培根配料</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Bacon</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Garnish</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Bacon</span><span class="hljs-params">(FastFood fastFood)</span> </span>&#123;<br><br>        <span class="hljs-keyword">super</span>(fastFood,<span class="hljs-number">2</span>,<span class="hljs-string">&quot;培根&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">float</span> <span class="hljs-title">cost</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPrice() + getFastFood().getPrice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDesc</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getDesc() + getFastFood().getDesc();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//点一份炒饭</span><br>        FastFood food = <span class="hljs-keyword">new</span> FriedRice();<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-comment">//点一份加鸡蛋的炒饭</span><br>        FastFood food1 = <span class="hljs-keyword">new</span> FriedRice();<br><br>        food1 = <span class="hljs-keyword">new</span> Egg(food1);<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food1.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food1.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br><br>        System.out.println(<span class="hljs-string">&quot;========&quot;</span>);<br>        <span class="hljs-comment">//点一份加培根的炒面</span><br>        FastFood food2 = <span class="hljs-keyword">new</span> FriedNoodles();<br>        food2 = <span class="hljs-keyword">new</span> Bacon(food2);<br>        <span class="hljs-comment">//花费的价格</span><br>        System.out.println(food2.getDesc() + <span class="hljs-string">&quot; &quot;</span> + food2.cost() + <span class="hljs-string">&quot;元&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li><p>饰者模式可以带来比继承更加灵活性的扩展功能，使用更加方便，可以通过组合不同的装饰者对象来获取具有不同行为状态的多样化的结果。装饰者模式比继承更具良好的扩展性，完美的遵循开闭原则，继承是静态的附加责任，装饰者则是动态的附加责任。</p>
</li>
<li><p>装饰类和被装饰类可以独立发展，不会相互耦合，装饰模式是继承的一个替代模式，装饰模式可以动态扩展一个实现类的功能。</p>
</li>
</ul>
<h3 id="5-3-4-使用场景"><a href="#5-3-4-使用场景" class="headerlink" title="5.3.4 使用场景"></a>5.3.4 使用场景</h3><ul>
<li><p>当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</p>
<p>不能采用继承的情况主要有两类：</p>
<ul>
<li>第一类是系统中存在大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长；</li>
<li>第二类是因为类定义不能继承（如final类）</li>
</ul>
</li>
<li><p>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</p>
</li>
<li><p>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</p>
</li>
</ul>
<h3 id="5-3-5-JDK源码解析"><a href="#5-3-5-JDK源码解析" class="headerlink" title="5.3.5 JDK源码解析"></a>5.3.5 JDK源码解析</h3><p>IO流中的包装类使用到了装饰者模式。BufferedInputStream，BufferedOutputStream，BufferedReader，BufferedWriter。</p>
<p>我们以BufferedWriter举例来说明，先看看如何使用BufferedWriter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception</span>&#123;<br>        <span class="hljs-comment">//创建BufferedWriter对象</span><br>        <span class="hljs-comment">//创建FileWriter对象</span><br>        FileWriter fw = <span class="hljs-keyword">new</span> FileWriter(<span class="hljs-string">&quot;C:\\Users\\Think\\Desktop\\a.txt&quot;</span>);<br>        BufferedWriter bw = <span class="hljs-keyword">new</span> BufferedWriter(fw);<br><br>        <span class="hljs-comment">//写数据</span><br>        bw.write(<span class="hljs-string">&quot;hello Buffered&quot;</span>);<br><br>        bw.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用起来感觉确实像是装饰者模式，接下来看它们的结构：</p>
<img src="/images/设计模式-day03/装饰者模式-jdk源码.png" style="zoom:80%;">

<blockquote>
<p><font color="red">小结：</font></p>
<p>​    BufferedWriter使用装饰者模式对Writer子实现类进行了增强，添加了缓冲区，提高了写数据的效率。</p>
</blockquote>
<h3 id="5-3-6-代理和装饰者的区别"><a href="#5-3-6-代理和装饰者的区别" class="headerlink" title="5.3.6 代理和装饰者的区别"></a>5.3.6 代理和装饰者的区别</h3><p>静态代理和装饰者模式的区别：</p>
<ul>
<li>相同点：<ul>
<li>都要实现与目标类相同的业务接口</li>
<li>在两个类中都要声明目标对象</li>
<li>都可以在不修改目标类的前提下增强目标方法</li>
</ul>
</li>
<li>不同点：<ul>
<li>目的不同<br>装饰者是为了增强目标对象<br>静态代理是为了保护和隐藏目标对象</li>
<li>获取目标对象构建的地方不同<br>装饰者是由外界传递进来，可以通过构造方法传递<br>静态代理是在代理类内部创建，以此来隐藏目标对象</li>
<li>本质区别：<ul>
<li>1、代理模式是**==控制访问==**</li>
<li>2、装饰者模式是**==动态增强行为==**</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="5-4-桥接模式"><a href="#5-4-桥接模式" class="headerlink" title="5.4 桥接模式"></a>5.4 桥接模式</h2><h3 id="5-4-1-概述"><a href="#5-4-1-概述" class="headerlink" title="5.4.1 概述"></a>5.4.1 概述</h3><p>现在有一个需求，需要创建不同的图形，并且每个图形都有可能会有不同的颜色。我们可以利用继承的方式来设计类的关系：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/image-20200207194617620.png"></p>
<p>我们可以发现有很多的类，假如我们再增加一个形状或再增加一种颜色，就需要创建更多的类。</p>
<p>试想，在一个有多种可能会变化的维度的系统中，用继承方式会造成类爆炸，扩展起来不灵活。每次在一个维度上新增一个具体实现都要增加多个子类。为了更加灵活的设计系统，我们此时可以考虑使用桥接模式。</p>
<p><strong>定义：</strong></p>
<p>​    <strong>将抽象与实现分离，使它们可以独立变化</strong>。**==它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。==**</p>
<h3 id="5-4-2-结构"><a href="#5-4-2-结构" class="headerlink" title="5.4.2 结构"></a>5.4.2 结构</h3><p>桥接（Bridge）模式包含以下主要角色：</p>
<ul>
<li>抽象化（Abstraction）角色 ：定义抽象类，并包含一个对实现化对象的引用。</li>
<li>扩展抽象化（Refined  Abstraction）角色 ：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</li>
<li>实现化（Implementor）角色 ：定义实现化角色的接口，供扩展抽象化角色调用。</li>
<li>具体实现化（Concrete Implementor）角色 ：给出实现化角色接口的具体实现。</li>
</ul>
<h3 id="5-4-3-案例"><a href="#5-4-3-案例" class="headerlink" title="5.4.3 案例"></a>5.4.3 案例</h3><p>【例】视频播放器</p>
<p>需要开发一个跨平台视频播放器，可以在不同操作系统平台（如Windows、Mac、Linux等）上播放多种格式的视频文件，常见的视频格式包括RMVB、AVI、WMV等。该播放器包含了两个维度，适合使用桥接模式。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day03/桥接模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//视频文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">VideoFile</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(String fileName)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//avi文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AVIFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VideoFile</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;avi视频文件：&quot;</span>+ fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//rmvb文件</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">REVBBFile</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">VideoFile</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;rmvb文件：&quot;</span> + fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//操作系统版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> VideoFile videoFile;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OperatingSystemVersion</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.videoFile = videoFile;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//Windows版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Windows</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OperatingSystem</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Windows</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(videoFile);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>        videoFile.decode(fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//mac版本</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mac</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">OperatingSystemVersion</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Mac</span><span class="hljs-params">(VideoFile videoFile)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(videoFile);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">(String fileName)</span> </span>&#123;<br>		videoFile.decode(fileName);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        OperatingSystem os = <span class="hljs-keyword">new</span> Windows(<span class="hljs-keyword">new</span> AVIFile());<br>        os.play(<span class="hljs-string">&quot;战狼3&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li><p>桥接模式提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统。</p>
<p>如：如果现在还有一种视频文件类型wmv，我们只需要再定义一个类实现VideoFile接口即可，其他类不需要发生变化。</p>
</li>
<li><p>实现细节对客户透明</p>
</li>
</ul>
<h3 id="5-4-4-使用场景"><a href="#5-4-4-使用场景" class="headerlink" title="5.4.4 使用场景"></a>5.4.4 使用场景</h3><ul>
<li>当一个类存在两个独立变化的维度，且这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在构件的抽象化角色和具体化角色之间增加更多的灵活性时。避免在两个层次之间建立静态的继承联系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li>
</ul>
<h2 id="5-5-外观模式"><a href="#5-5-外观模式" class="headerlink" title="5.5 外观模式"></a>5.5 外观模式</h2><h3 id="5-5-1-概述"><a href="#5-5-1-概述" class="headerlink" title="5.5.1 概述"></a>5.5.1 概述</h3><p>有些人可能炒过股票，但其实大部分人都不太懂，这种没有足够了解证券知识的情况下做股票是很容易亏钱的，刚开始炒股肯定都会想，如果有个懂行的帮帮手就好，其实基金就是个好帮手，支付宝里就有许多的基金，它将投资者分散的资金集中起来，交由专业的经理人进行管理，投资于股票、债券、外汇等领域，而基金投资的收益归持有者所有，管理机构收取一定比例的托管管理费用。</p>
<p><strong>定义：</strong></p>
<p>​    又名门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>​    <strong>外观（Facade）模式是“迪米特法则”的典型应用</strong></p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day03/%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E5%BC%95%E5%85%A5.jpg"></p>
<h3 id="5-5-2-结构"><a href="#5-5-2-结构" class="headerlink" title="5.5.2 结构"></a>5.5.2 结构</h3><p>外观（Facade）模式包含以下主要角色：</p>
<ul>
<li>外观（Facade）角色：为多个子系统对外提供一个共同的接口。</li>
<li>子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</li>
</ul>
<h3 id="5-5-3-案例"><a href="#5-5-3-案例" class="headerlink" title="5.5.3 案例"></a>5.5.3 案例</h3><p>【例】智能家电控制</p>
<p>小明的爷爷已经60岁了，一个人在家生活：每次都需要打开灯、打开电视、打开空调；睡觉时关闭灯、关闭电视、关闭空调；操作起来都比较麻烦。所以小明给爷爷买了智能音箱，可以通过语音直接控制这些智能家电的开启和关闭。类图如下：</p>
<img src="/images/设计模式-day03/外观模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//灯类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Light</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了灯....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了灯....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//电视类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TV</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了电视....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了电视....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//控制类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AirCondition</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;打开了空调....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;关闭了空调....&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//智能音箱</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SmartAppliancesFacade</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Light light;<br>    <span class="hljs-keyword">private</span> TV tv;<br>    <span class="hljs-keyword">private</span> AirCondition airCondition;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SmartAppliancesFacade</span><span class="hljs-params">()</span> </span>&#123;<br>        light = <span class="hljs-keyword">new</span> Light();<br>        tv = <span class="hljs-keyword">new</span> TV();<br>        airCondition = <span class="hljs-keyword">new</span> AirCondition();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">say</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;打开&quot;</span>)) &#123;<br>            on();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(message.contains(<span class="hljs-string">&quot;关闭&quot;</span>)) &#123;<br>            off();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;我还听不懂你说的！！！&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//起床后一键开电器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">on</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;起床了&quot;</span>);<br>        light.on();<br>        tv.on();<br>        airCondition.on();<br>    &#125;<br><br>    <span class="hljs-comment">//睡觉一键关电器</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">off</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;睡觉了&quot;</span>);<br>        light.off();<br>        tv.off();<br>        airCondition.off();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建外观对象</span><br>        SmartAppliancesFacade facade = <span class="hljs-keyword">new</span> SmartAppliancesFacade();<br>        <span class="hljs-comment">//客户端直接与外观对象进行交互</span><br>        facade.say(<span class="hljs-string">&quot;打开家电&quot;</span>);<br>        facade.say(<span class="hljs-string">&quot;关闭家电&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>好处：</strong></p>
<ul>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不符合开闭原则，修改很麻烦</li>
</ul>
<h3 id="5-5-4-使用场景"><a href="#5-5-4-使用场景" class="headerlink" title="5.5.4 使用场景"></a>5.5.4 使用场景</h3><ul>
<li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li>
<li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li>
<li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li>
</ul>
<h3 id="5-5-5-源码解析"><a href="#5-5-5-源码解析" class="headerlink" title="5.5.5 源码解析"></a>5.5.5 源码解析</h3><p>使用tomcat作为web容器时，接收浏览器发送过来的请求，tomcat会将请求信息封装成ServletRequest对象，如下图①处对象。但是大家想想ServletRequest是一个接口，它还有一个子接口HttpServletRequest，而我们知道该request对象肯定是一个HttpServletRequest对象的子实现类对象，到底是哪个类的对象呢？可以通过输出request对象，我们就会发现是一个名为RequestFacade的类的对象。</p>
<img src="/images/设计模式-day03/image-20200207234545691.png" style="zoom:60%;">

<p>RequestFacade类就使用了外观模式。先看结构图：</p>
<img src="/images/设计模式-day03/外观模式-jdk源码解析.png" style="zoom:70%;">

<p><strong>为什么在此处使用外观模式呢？</strong></p>
<p><a href="https://www.jianshu.com/p/b52db22657f3">https://www.jianshu.com/p/b52db22657f3</a>    </p>
<p>定义 RequestFacade 类，分别实现 ServletRequest ，同时定义私有成员变量 Request ，并且方法的实现调用 Request  的实现。然后，将 RequestFacade上转为 ServletRequest  传给 servlet 的 service 方法，这样即使在 servlet 中被下转为 RequestFacade ，也不能访问私有成员变量对象中的方法。既用了 Request ，又能防止其中方法被不合理的访问。</p>
<blockquote>
<p><code>Request</code>对象中的很多方法都是内部组件之间相互交互时使用的，例如<code>setComet</code>、<code>setRequestedSessionId</code>等方法(这里不一一列举)。这些方法并不对外部公开，但是又必须设置为<code>public</code>因为还需要跟内部组件之间交互使用。最好的解决方法就是通过使用一个<code>Facade</code>类，将与内部组件之间交互使用的方法屏蔽掉，只提供给外部程序感兴趣的方法。</p>
<p>如果不使用<code>Facade</code>类，直接传递的是<code>Request</code>对象与<code>Response</code>对象，那么熟悉容器内部运作的程序员可以分别把<code>ServletRequest</code>和<code>ServletResponse</code>对象向下转换为<code>Request</code>和<code>Response</code>，并调用它们的公共方法，比如拥有<code>Request</code>对象，就可以调用<code>setComet</code>、<code>setRequestedSessionId</code>等方法，这样会危害安全性。</p>
</blockquote>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day06</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day06/</url>
    <content><![CDATA[<h1 id="6-行为型模式"><a href="#6-行为型模式" class="headerlink" title="6 , 行为型模式"></a>6 , 行为型模式</h1><h2 id="6-11-解释器模式"><a href="#6-11-解释器模式" class="headerlink" title="6.11 解释器模式"></a>6.11 解释器模式</h2><h3 id="6-11-1-概述"><a href="#6-11-1-概述" class="headerlink" title="6.11.1 概述"></a>6.11.1 概述</h3><img src="/images/design-model-day06/image-20200215220322641.png" style="zoom:60%;">

<p>如上图，设计一个软件用来进行加减计算。我们第一想法就是使用工具类，提供对应的加法和减法的工具方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//用于两个整数相加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-keyword">int</span> a,<span class="hljs-keyword">int</span> b,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">return</span> a + b + c;<br>&#125;<br><br><span class="hljs-comment">//用于n个整数相加</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">add</span><span class="hljs-params">(Integer ... arr)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (Integer i : arr) &#123;<br>        sum += i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的形式比较单一、有限，如果形式变化非常多，这就不符合要求，因为加法和减法运算，两个运算符与数值可以有无限种组合方式。比如 1+2+3+4+5、1+2+3-4等等。   </p>
<p>显然，现在需要一种翻译识别机器，能够解析由数字以及 + - 符号构成的合法的运算序列。如果把运算符和数字都看作节点的话，能够逐个节点的进行读取解析运算，这就是解释器模式的思维。</p>
<p><strong>定义：</strong></p>
<blockquote>
<p><strong>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</strong></p>
</blockquote>
<p>在解释器模式中，我们需要将待解决的问题，提取出规则，抽象为一种“语言”。比如加减法运算，规则为：由数值和+-符号组成的合法序列，“1+3-2” 就是这种语言的句子。</p>
<p>解释器就是要解析出来语句的含义。但是如何描述规则呢？</p>
<p><strong>文法（语法）规则：</strong></p>
<p>文法是用于描述语言的语法结构的形式规则。</p>
<figure class="highlight mel"><table><tr><td class="code"><pre><code class="hljs mel"><span class="hljs-keyword">expression</span> ::= value | plus | minus<br>plus ::= <span class="hljs-keyword">expression</span> ‘+’ <span class="hljs-keyword">expression</span>   <br>minus ::= <span class="hljs-keyword">expression</span> ‘-’ <span class="hljs-keyword">expression</span>  <br>value ::= integer<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意： 这里的符号“::=”表示“定义为”的意思，竖线 | 表示或，左右的其中一个，引号内为字符本身，引号外为语法。</p>
</blockquote>
<p>上面规则描述为 ：</p>
<p>表达式可以是一个值，也可以是plus或者minus运算，而plus和minus又是由表达式结合运算符构成，值的类型为整型数。</p>
<p><strong>抽象语法树：</strong></p>
<p>在计算机科学中，抽象语法树（AbstractSyntaxTree，AST），或简称语法树（Syntax tree），是源代码语法结构的一种抽象表示。它以树状的形式表现编程语言的语法结构，树上的每个节点都表示源代码中的一种结构。</p>
<p>用树形来表示符合文法规则的句子。</p>
<img src="/images/design-model-day06/image-20200215225227616.png" style="zoom:50%;">

<h3 id="6-11-2-结构"><a href="#6-11-2-结构" class="headerlink" title="6.11.2 结构"></a>6.11.2 结构</h3><p>解释器模式包含以下主要角色。</p>
<ul>
<li><p>抽象表达式（Abstract Expression）角色：定义解释器的接口，约定解释器的解释操作，主要包含解释方法 interpret()。</p>
</li>
<li><p>终结符表达式（Terminal  Expression）角色：是抽象表达式的子类，用来实现文法中与终结符相关的操作，文法中的每一个终结符都有一个具体终结表达式与之相对应。</p>
</li>
<li><p>非终结符表达式（Nonterminal Expression）角色：也是抽象表达式的子类，用来实现文法中与非终结符相关的操作，文法中的每条规则都对应于一个非终结符表达式。</p>
</li>
<li><p>环境（Context）角色：通常包含各个解释器需要的数据或是公共的功能，一般用来传递被所有解释器共享的数据，后面的解释器可以从这里获取这些值。</p>
</li>
<li><p>客户端（Client）：主要任务是将需要分析的句子或表达式转换成使用解释器对象描述的抽象语法树，然后调用解释器的解释方法，当然也可以通过环境角色间接访问解释器的解释方法。</p>
</li>
</ul>
<h3 id="6-11-3-案例实现"><a href="#6-11-3-案例实现" class="headerlink" title="6.11.3 案例实现"></a>6.11.3 案例实现</h3><p>【例】设计实现加减法的软件</p>
<img src="/images/design-model-day06/解释器模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象角色AbstractExpression</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//终结符表达式角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Value</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> value;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Value</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.value = value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(value).toString();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//非终结符表达式角色  加法表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Plus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Plus</span><span class="hljs-params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) + right.interpret(context);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + left.toString() + <span class="hljs-string">&quot; + &quot;</span> + right.toString() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">///非终结符表达式角色 减法表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Minus</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> AbstractExpression left;<br>    <span class="hljs-keyword">private</span> AbstractExpression right;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Minus</span><span class="hljs-params">(AbstractExpression left, AbstractExpression right)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.left = left;<br>        <span class="hljs-keyword">this</span>.right = right;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> left.interpret(context) - right.interpret(context);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;(&quot;</span> + left.toString() + <span class="hljs-string">&quot; - &quot;</span> + right.toString() + <span class="hljs-string">&quot;)&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//终结符表达式角色 变量表达式</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Variable</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractExpression</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Variable</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">interpret</span><span class="hljs-params">(Context ctx)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> ctx.getValue(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//环境类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Map&lt;Variable, Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Variable, Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assign</span><span class="hljs-params">(Variable <span class="hljs-keyword">var</span>, Integer value)</span> </span>&#123;<br>        map.put(<span class="hljs-keyword">var</span>, value);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getValue</span><span class="hljs-params">(Variable <span class="hljs-keyword">var</span>)</span> </span>&#123;<br>        Integer value = map.get(<span class="hljs-keyword">var</span>);<br>        <span class="hljs-keyword">return</span> value;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br><br>        Variable a = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;a&quot;</span>);<br>        Variable b = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;b&quot;</span>);<br>        Variable c = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;c&quot;</span>);<br>        Variable d = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;d&quot;</span>);<br>        Variable e = <span class="hljs-keyword">new</span> Variable(<span class="hljs-string">&quot;e&quot;</span>);<br>        <span class="hljs-comment">//Value v = new Value(1);</span><br><br>        context.assign(a, <span class="hljs-number">1</span>);<br>        context.assign(b, <span class="hljs-number">2</span>);<br>        context.assign(c, <span class="hljs-number">3</span>);<br>        context.assign(d, <span class="hljs-number">4</span>);<br>        context.assign(e, <span class="hljs-number">5</span>);<br><br>        AbstractExpression expression = <span class="hljs-keyword">new</span> Minus(<span class="hljs-keyword">new</span> Plus(<span class="hljs-keyword">new</span> Plus(<span class="hljs-keyword">new</span> Plus(a, b), c), d), e);<br><br>        System.out.println(expression + <span class="hljs-string">&quot;= &quot;</span> + expression.interpret(context));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-11-4-优缺点"><a href="#6-11-4-优缺点" class="headerlink" title="6.11.4 优缺点"></a>6.11.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>易于改变和扩展文法。</p>
<p>由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</p>
</li>
<li><p>实现文法较为容易。</p>
<p>在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂。</p>
</li>
<li><p>增加新的解释表达式较为方便。</p>
<p>如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合 “开闭原则”。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><p>对于复杂文法难以维护。</p>
<p>在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护。</p>
</li>
</ul>
<ul>
<li><p>执行效率较低。</p>
<p>由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</p>
</li>
</ul>
<h3 id="6-11-5-使用场景"><a href="#6-11-5-使用场景" class="headerlink" title="6.11.5 使用场景"></a>6.11.5 使用场景</h3><ul>
<li><p>当语言的文法较为简单，且执行效率不是关键问题时。</p>
</li>
<li><p>当问题重复出现，且可以用一种简单的语言来进行表达时。</p>
</li>
<li><p>当一个语言需要解释执行，并且语言中的句子可以表示为一个抽象语法树的时候。</p>
</li>
</ul>
<h1 id="7，自定义Spring框架"><a href="#7，自定义Spring框架" class="headerlink" title="7，自定义Spring框架"></a>7，自定义Spring框架</h1><h2 id="7-1-spring使用回顾"><a href="#7-1-spring使用回顾" class="headerlink" title="7.1 spring使用回顾"></a>7.1 spring使用回顾</h2><p>自定义spring框架前，先回顾一下spring框架的使用，从而分析spring的核心，并对核心功能进行模拟。</p>
<ul>
<li><p>数据访问层。定义UserDao接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserDao</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userDaoImpl ....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>业务逻辑层。定义UserService接口及其子实现类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> UserDao userDao;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setUserDao</span><span class="hljs-params">(UserDao userDao)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.userDao = userDao;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;userServiceImpl ...&quot;</span>);<br>        userDao.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>定义UserController类，使用main方法模拟controller层</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建spring容器对象</span><br>        ApplicationContext applicationContext = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;applicationContext.xml&quot;</span>);<br>        <span class="hljs-comment">//从IOC容器中获取UserService对象</span><br>        UserService userService = applicationContext.getBean(<span class="hljs-string">&quot;userService&quot;</span>, UserService.class);<br>        <span class="hljs-comment">//调用UserService对象的add方法</span><br>        userService.add();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>编写配置文件。在类路径下编写一个名为ApplicationContext.xml的配置文件</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs java">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;<br>&lt;beans xmlns:xsi=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br>       xmlns=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span><br>       xmlns:context=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span><br>       xsi:schemaLocation=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span><br><span class="hljs-string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span><br><span class="hljs-string">        http://www.springframework.org/schema/context</span><br><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;<br><br>    &lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;<br>        &lt;property name=&quot;userDao&quot; ref=&quot;userDao&quot;&gt;&lt;/property&gt;<br>    &lt;/bean&gt;<br><br>    &lt;bean id=&quot;userDao&quot; class=&quot;com.itheima.dao.impl.UserDaoImpl&quot;&gt;&lt;/bean&gt;<br><br>&lt;/beans&gt;<br></code></pre></td></tr></table></figure>

<p>代码运行结果如下：</p>
<img src="/images/design-model-day06/image-20200429165544151.png" style="zoom:60%;"></li>
</ul>
<p>通过上面代码及结果可以看出：</p>
<ul>
<li>userService对象是从applicationContext容器对象获取到的，也就是userService对象交由spring进行管理。</li>
<li>上面结果可以看到调用了UserDao对象中的add方法，也就是说UserDao子实现类对象也交由spring管理了。</li>
<li>UserService中的userDao变量我们并没有进行赋值，但是可以正常使用，说明spring已经将UserDao对象赋值给了userDao变量。</li>
</ul>
<p>上面三点体现了Spring框架的IOC（Inversion of Control）和DI（Dependency Injection, DI）</p>
<h2 id="7-2-spring核心功能结构"><a href="#7-2-spring核心功能结构" class="headerlink" title="7.2 spring核心功能结构"></a>7.2 spring核心功能结构</h2><p>Spring大约有20个模块，由1300多个不同的文件构成。这些模块可以分为:</p>
<p>核心容器、AOP和设备支持、数据访问与集成、Web组件、通信报文和集成测试等，下面是 Spring 框架的总体架构图：</p>
<img src="/images/design-model-day06/image-20200429111324770.png" style="zoom:40%;">



<p>核心容器由 beans、core、context 和 expression（Spring Expression Language，SpEL）4个模块组成。</p>
<ul>
<li>spring-beans和spring-core模块是Spring框架的核心模块，包含了控制反转（Inversion of Control，IOC）和依赖注入（Dependency Injection，DI）。BeanFactory使用控制反转对应用程序的配置和依赖性规范与实际的应用程序代码进行了分离。BeanFactory属于延时加载，也就是说在实例化容器对象后并不会自动实例化Bean，只有当Bean被使用时，BeanFactory才会对该 Bean 进行实例化与依赖关系的装配。</li>
<li>spring-context模块构架于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。此外，该模块还提供了许多企业级支持，如邮件访问、远程访问、任务调度等，ApplicationContext 是该模块的核心接口，它的超类是 BeanFactory。与BeanFactory不同，ApplicationContext实例化后会自动对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</li>
<li>spring-context-support模块是对Spring IoC容器及IoC子容器的扩展支持。</li>
<li>spring-context-indexer模块是Spring的类管理组件和Classpath扫描组件。</li>
<li>spring-expression 模块是统一表达式语言（EL）的扩展模块，可以查询、管理运行中的对象，同时也可以方便地调用对象方法，以及操作数组、集合等。它的语法类似于传统EL，但提供了额外的功能，最出色的要数函数调用和简单字符串的模板函数。EL的特性是基于Spring产品的需求而设计的，可以非常方便地同Spring IoC进行交互。</li>
</ul>
<h3 id="7-1-1-bean概述"><a href="#7-1-1-bean概述" class="headerlink" title="7.1.1 bean概述"></a>7.1.1 bean概述</h3><p>Spring 就是面向 <code>Bean</code> 的编程（BOP,Bean Oriented Programming），Bean 在 Spring 中处于核心地位。Bean对于Spring的意义就像Object对于OOP的意义一样，Spring中没有Bean也就没有Spring存在的意义。Spring IoC容器通过配置文件或者注解的方式来管理bean对象之间的依赖关系。</p>
<p>spring中bean用于对一个类进行封装。如下面的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>为什么Bean如此重要呢？</p>
<ul>
<li>spring 将bean对象交由一个叫IOC容器进行管理。</li>
<li>bean对象之间的依赖关系在配置文件中体现，并由spring完成。</li>
</ul>
<h2 id="7-3-Spring-IOC相关接口分析"><a href="#7-3-Spring-IOC相关接口分析" class="headerlink" title="7.3 Spring IOC相关接口分析"></a>7.3 Spring IOC相关接口分析</h2><h3 id="7-3-1-BeanFactory解析"><a href="#7-3-1-BeanFactory解析" class="headerlink" title="7.3.1 BeanFactory解析"></a>7.3.1 BeanFactory解析</h3><p>Spring中Bean的创建是典型的工厂模式，这一系列的Bean工厂，即IoC容器，为开发者管理对象之间的依赖关系提供了很多便利和基础服务，在Spring中有许多IoC容器的实现供用户选择，其相互关系如下图所示。</p>
<img src="/images/design-model-day06/image-20200429185050396.png" style="zoom:60%;">

<p>其中，BeanFactory作为最顶层的一个接口，定义了IoC容器的基本功能规范，BeanFactory有三个重要的子接口：ListableBeanFactory、HierarchicalBeanFactory和AutowireCapableBeanFactory。但是从类图中我们可以发现最终的默认实现类是DefaultListableBeanFactory，它实现了所有的接口。</p>
<p>那么为何要定义这么多层次的接口呢？</p>
<p>每个接口都有它的使用场合，主要是为了区分在Spring内部操作过程中对象的传递和转化，对对象的数据访问所做的限制。例如，</p>
<ul>
<li>ListableBeanFactory接口表示这些Bean可列表化。</li>
<li>HierarchicalBeanFactory表示这些Bean 是有继承关系的，也就是每个 Bean 可能有父 Bean</li>
<li>AutowireCapableBeanFactory 接口定义Bean的自动装配规则。</li>
</ul>
<p>这三个接口共同定义了Bean的集合、Bean之间的关系及Bean行为。最基本的IoC容器接口是BeanFactory，来看一下它的源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br><br>	String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br><br>	<span class="hljs-comment">//根据bean的名称获取IOC容器中的的bean对象</span><br>	<span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	<span class="hljs-comment">//根据bean的名称获取IOC容器中的的bean对象，并指定获取到的bean对象的类型，这样我们使用时就不需要进行类型强转了</span><br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	<span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	&lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>	<br>	&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span></span>;<br>	&lt;T&gt; <span class="hljs-function">ObjectProvider&lt;T&gt; <span class="hljs-title">getBeanProvider</span><span class="hljs-params">(ResolvableType requiredType)</span></span>;<br><br>	<span class="hljs-comment">//判断容器中是否包含指定名称的bean对象</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br>	<span class="hljs-comment">//根据bean的名称判断是否是单例</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>	<span class="hljs-meta">@Nullable</span><br>	Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>	String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在BeanFactory里只对IoC容器的基本行为做了定义，根本不关心你的Bean是如何定义及怎样加载的。正如我们只关心能从工厂里得到什么产品，不关心工厂是怎么生产这些产品的。</p>
<p>BeanFactory有一个很重要的子接口，就是ApplicationContext接口，该接口主要来规范容器中的bean对象是非延时加载，即在创建容器对象的时候就对象bean进行初始化，并存储到一个容器中。</p>
<img src="/images/design-model-day06/image-20200430220155371.png" style="zoom:60%;">

<p>要知道工厂是如何产生对象的，我们需要看具体的IoC容器实现，Spring提供了许多IoC容器实现，比如：</p>
<ul>
<li>ClasspathXmlApplicationContext : 根据类路径加载xml配置文件，并创建IOC容器对象。</li>
<li>FileSystemXmlApplicationContext ：根据系统路径加载xml配置文件，并创建IOC容器对象。</li>
<li>AnnotationConfigApplicationContext ：加载注解类配置，并创建IOC容器。</li>
</ul>
<h3 id="7-3-2-BeanDefinition解析"><a href="#7-3-2-BeanDefinition解析" class="headerlink" title="7.3.2 BeanDefinition解析"></a>7.3.2 BeanDefinition解析</h3><p>Spring IoC容器管理我们定义的各种Bean对象及其相互关系，而Bean对象在Spring实现中是以BeanDefinition来描述的，如下面配置文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>bean标签还有很多属性：<br>	scope、init-method、destory-method等。<br></code></pre></td></tr></table></figure>

<p>其继承体系如下图所示。</p>
<img src="/images/design-model-day06/image-20200429204239868.png" style="zoom:60%;">



<h3 id="7-3-3-BeanDefinitionReader解析"><a href="#7-3-3-BeanDefinitionReader解析" class="headerlink" title="7.3.3 BeanDefinitionReader解析"></a>7.3.3 BeanDefinitionReader解析</h3><p>Bean的解析过程非常复杂，功能被分得很细，因为这里需要被扩展的地方很多，必须保证足够的灵活性，以应对可能的变化。Bean的解析主要就是对Spring配置文件的解析。这个解析过程主要通过BeanDefinitionReader来完成，看看Spring中BeanDefinitionReader的类结构图，如下图所示。</p>
<img src="/images/design-model-day06/image-20200429204700956.png" style="zoom:60%;">

<p>看看BeanDefinitionReader接口定义的功能来理解它具体的作用：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;<br><br>	<span class="hljs-comment">//获取BeanDefinitionRegistry注册器对象</span><br>	<span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function">ResourceLoader <span class="hljs-title">getResourceLoader</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-meta">@Nullable</span><br>	<span class="hljs-function">ClassLoader <span class="hljs-title">getBeanClassLoader</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-function">BeanNameGenerator <span class="hljs-title">getBeanNameGenerator</span><span class="hljs-params">()</span></span>;<br><br>	<span class="hljs-comment">/*</span><br><span class="hljs-comment">		下面的loadBeanDefinitions都是加载bean定义，从指定的资源中</span><br><span class="hljs-comment">	*/</span><br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource resource)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(Resource... resources)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String location)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String... locations)</span> <span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-3-4-BeanDefinitionRegistry解析"><a href="#7-3-4-BeanDefinitionRegistry解析" class="headerlink" title="7.3.4 BeanDefinitionRegistry解析"></a>7.3.4 BeanDefinitionRegistry解析</h3><p>BeanDefinitionReader用来解析bean定义，并封装BeanDefinition对象，而我们定义的配置文件中定义了很多bean标签，所以就有一个问题，解析的BeanDefinition对象存储到哪儿？答案就是BeanDefinition的注册中心，而该注册中心顶层接口就是BeanDefinitionRegistry。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AliasRegistry</span> </span>&#123;<br><br>	<span class="hljs-comment">//往注册表中注册bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span><br><span class="hljs-function">			<span class="hljs-keyword">throws</span> BeanDefinitionStoreException</span>;<br><br>	<span class="hljs-comment">//从注册表中删除指定名称的bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br><br>	<span class="hljs-comment">//获取注册表中指定名称的bean</span><br>	<span class="hljs-function">BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <br>	<span class="hljs-comment">//判断注册表中是否已经注册了指定名称的bean</span><br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;<br>    <br>	<span class="hljs-comment">//获取注册表中所有的bean的名称</span><br>	String[] getBeanDefinitionNames();<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isBeanNameInUse</span><span class="hljs-params">(String beanName)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>继承结构图如下：</p>
<img src="/images/design-model-day06/image-20200429211132185.png" style="zoom:60%;">

<p>从上面类图可以看到BeanDefinitionRegistry接口的子实现类主要有以下几个：</p>
<ul>
<li><p>DefaultListableBeanFactory</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">256</span>);<br></code></pre></td></tr></table></figure></li>
<li><p>SimpleBeanDefinitionRegistry</p>
<p>在该类中定义了如下代码，就是用来注册bean</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;(<span class="hljs-number">64</span>);<br></code></pre></td></tr></table></figure></li>
</ul>
<h3 id="7-3-5-创建容器"><a href="#7-3-5-创建容器" class="headerlink" title="7.3.5 创建容器"></a>7.3.5 创建容器</h3><p>ClassPathXmlApplicationContext对Bean配置资源的载入是从refresh（）方法开始的。refresh（）方法是一个模板方法，规定了 IoC 容器的启动流程，有些逻辑要交给其子类实现。它对 Bean 配置资源进行载入，ClassPathXmlApplicationContext通过调用其父类AbstractApplicationContext的refresh（）方法启动整个IoC容器对Bean定义的载入过程。</p>
<h2 id="7-4-自定义SpringIOC"><a href="#7-4-自定义SpringIOC" class="headerlink" title="7.4 自定义SpringIOC"></a>7.4 自定义SpringIOC</h2><p>现要对下面的配置文件进行解析，并自定义Spring框架的IOC对涉及到的对象进行管理。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.service.impl.UserServiceImpl&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;userDao&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userDao&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.itheima.dao.impl.UserDaoImpl&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="7-4-1-定义bean相关的pojo类"><a href="#7-4-1-定义bean相关的pojo类" class="headerlink" title="7.4.1 定义bean相关的pojo类"></a>7.4.1 定义bean相关的pojo类</h3><h4 id="7-4-1-1-PropertyValue类"><a href="#7-4-1-1-PropertyValue类" class="headerlink" title="7.4.1.1 PropertyValue类"></a>7.4.1.1 PropertyValue类</h4><p>用于封装bean的属性，体现到上面的配置文件就是封装bean标签的子标签property标签数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertyValue</span> </span>&#123;<br><br>  <span class="hljs-keyword">private</span> String name;<br>  <span class="hljs-keyword">private</span> String ref;<br>  <span class="hljs-keyword">private</span> String value;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertyValue</span><span class="hljs-params">()</span> </span>&#123;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertyValue</span><span class="hljs-params">(String name, String ref,String value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>    <span class="hljs-keyword">this</span>.ref = ref;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.name = name;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getRef</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> ref;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRef</span><span class="hljs-params">(String ref)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.ref = ref;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getValue</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> value;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setValue</span><span class="hljs-params">(String value)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.value = value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-1-2-MutablePropertyValues类"><a href="#7-4-1-2-MutablePropertyValues类" class="headerlink" title="7.4.1.2 MutablePropertyValues类"></a>7.4.1.2 MutablePropertyValues类</h4><p>一个bean标签可以有多个property子标签，所以再定义一个MutablePropertyValues类，用来存储并管理多个PropertyValue对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MutablePropertyValues</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterable</span>&lt;<span class="hljs-title">PropertyValue</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;PropertyValue&gt; propertyValueList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutablePropertyValues</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.propertyValueList = <span class="hljs-keyword">new</span> ArrayList&lt;PropertyValue&gt;();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MutablePropertyValues</span><span class="hljs-params">(List&lt;PropertyValue&gt; propertyValueList)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.propertyValueList = (propertyValueList != <span class="hljs-keyword">null</span> ? propertyValueList : <span class="hljs-keyword">new</span> ArrayList&lt;PropertyValue&gt;());<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> PropertyValue[] getPropertyValues() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertyValueList.toArray(<span class="hljs-keyword">new</span> PropertyValue[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValue <span class="hljs-title">getPropertyValue</span><span class="hljs-params">(String propertyName)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (PropertyValue pv : <span class="hljs-keyword">this</span>.propertyValueList) &#123;<br>            <span class="hljs-keyword">if</span> (pv.getName().equals(propertyName)) &#123;<br>                <span class="hljs-keyword">return</span> pv;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;PropertyValue&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> propertyValueList.iterator();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isEmpty</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertyValueList.isEmpty();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MutablePropertyValues <span class="hljs-title">addPropertyValue</span><span class="hljs-params">(PropertyValue pv)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.propertyValueList.size(); i++) &#123;<br>            PropertyValue currentPv = <span class="hljs-keyword">this</span>.propertyValueList.get(i);<br>            <span class="hljs-keyword">if</span> (currentPv.getName().equals(pv.getName())) &#123;<br>                <span class="hljs-keyword">this</span>.propertyValueList.set(i, <span class="hljs-keyword">new</span> PropertyValue(pv.getName(),pv.getRef(), pv.getValue()));<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">this</span>.propertyValueList.add(pv);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">contains</span><span class="hljs-params">(String propertyName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> getPropertyValue(propertyName) != <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-1-3-BeanDefinition类"><a href="#7-4-1-3-BeanDefinition类" class="headerlink" title="7.4.1.3 BeanDefinition类"></a>7.4.1.3 BeanDefinition类</h4><p>BeanDefinition类用来封装bean信息的，主要包含id（即bean对象的名称）、class（需要交由spring管理的类的全类名）及子标签property数据。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanDefinition</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String className;<br><br>    <span class="hljs-keyword">private</span> MutablePropertyValues propertyValues;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeanDefinition</span><span class="hljs-params">()</span> </span>&#123;<br>        propertyValues = <span class="hljs-keyword">new</span> MutablePropertyValues();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(String id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getClassName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> className;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setClassName</span><span class="hljs-params">(String className)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.className = className;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setPropertyValues</span><span class="hljs-params">(MutablePropertyValues propertyValues)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.propertyValues = propertyValues;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MutablePropertyValues <span class="hljs-title">getPropertyValues</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> propertyValues;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-2-定义注册表相关类"><a href="#7-4-2-定义注册表相关类" class="headerlink" title="7.4.2 定义注册表相关类"></a>7.4.2 定义注册表相关类</h3><h4 id="7-4-2-1-BeanDefinitionRegistry接口"><a href="#7-4-2-1-BeanDefinitionRegistry接口" class="headerlink" title="7.4.2.1 BeanDefinitionRegistry接口"></a>7.4.2.1 BeanDefinitionRegistry接口</h4><p>BeanDefinitionRegistry接口定义了注册表的相关操作，定义如下功能：</p>
<ul>
<li>注册BeanDefinition对象到注册表中</li>
<li>从注册表中删除指定名称的BeanDefinition对象</li>
<li>根据名称从注册表中获取BeanDefinition对象</li>
<li>判断注册表中是否包含指定名称的BeanDefinition对象</li>
<li>获取注册表中BeanDefinition对象的个数</li>
<li>获取注册表中所有的BeanDefinition的名称</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<br><br>    <span class="hljs-comment">//注册BeanDefinition对象到注册表中</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span></span>;<br><br>    <span class="hljs-comment">//从注册表中删除指定名称的BeanDefinition对象</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-comment">//根据名称从注册表中获取BeanDefinition对象</span><br>    <span class="hljs-function">BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span></span>;<br><br>    String[] getBeanDefinitionNames();<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-2-2-SimpleBeanDefinitionRegistry类"><a href="#7-4-2-2-SimpleBeanDefinitionRegistry类" class="headerlink" title="7.4.2.2 SimpleBeanDefinitionRegistry类"></a>7.4.2.2 SimpleBeanDefinitionRegistry类</h4><p>该类实现了BeanDefinitionRegistry接口，定义了Map集合作为注册表容器。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SimpleBeanDefinitionRegistry</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistry</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> HashMap&lt;String, BeanDefinition&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinition</span><span class="hljs-params">(String beanName, BeanDefinition beanDefinition)</span> </span>&#123;<br>        beanDefinitionMap.put(beanName,beanDefinition);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        beanDefinitionMap.remove(beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinition <span class="hljs-title">getBeanDefinition</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.get(beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBeanDefinition</span><span class="hljs-params">(String beanName)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.containsKey(beanName);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getBeanDefinitionCount</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] getBeanDefinitionNames() &#123;<br>        <span class="hljs-keyword">return</span> beanDefinitionMap.keySet().toArray(<span class="hljs-keyword">new</span> String[<span class="hljs-number">1</span>]);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-3-定义解析器相关类"><a href="#7-4-3-定义解析器相关类" class="headerlink" title="7.4.3 定义解析器相关类"></a>7.4.3 定义解析器相关类</h3><h4 id="7-4-3-1-BeanDefinitionReader接口"><a href="#7-4-3-1-BeanDefinitionReader接口" class="headerlink" title="7.4.3.1 BeanDefinitionReader接口"></a>7.4.3.1 BeanDefinitionReader接口</h4><p>BeanDefinitionReader是用来解析配置文件并在注册表中注册bean的信息。定义了两个规范：</p>
<ul>
<li>获取注册表的功能，让外界可以通过该对象获取注册表对象。</li>
<li>加载配置文件，并注册bean数据。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;<br><br>	<span class="hljs-comment">//获取注册表对象</span><br>    <span class="hljs-function">BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span></span>;<br>	<span class="hljs-comment">//加载配置文件并在注册表中进行注册</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-3-2-XmlBeanDefinitionReader类"><a href="#7-4-3-2-XmlBeanDefinitionReader类" class="headerlink" title="7.4.3.2 XmlBeanDefinitionReader类"></a>7.4.3.2 XmlBeanDefinitionReader类</h4><p>XmlBeanDefinitionReader类是专门用来解析xml配置文件的。该类实现BeanDefinitionReader接口并实现接口中的两个功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">XmlBeanDefinitionReader</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionReader</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> BeanDefinitionRegistry registry;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">XmlBeanDefinitionReader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.registry = <span class="hljs-keyword">new</span> SimpleBeanDefinitionRegistry();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanDefinitionRegistry <span class="hljs-title">getRegistry</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> registry;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">loadBeanDefinitions</span><span class="hljs-params">(String configLocation)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        InputStream is = <span class="hljs-keyword">this</span>.getClass().getClassLoader().getResourceAsStream(configLocation);<br>        SAXReader reader = <span class="hljs-keyword">new</span> SAXReader();<br>        Document document = reader.read(is);<br>        Element rootElement = document.getRootElement();<br>        <span class="hljs-comment">//解析bean标签</span><br>        parseBean(rootElement);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">parseBean</span><span class="hljs-params">(Element rootElement)</span> </span>&#123;<br><br>        List&lt;Element&gt; elements = rootElement.elements();<br>        <span class="hljs-keyword">for</span> (Element element : elements) &#123;<br>            String id = element.attributeValue(<span class="hljs-string">&quot;id&quot;</span>);<br>            String className = element.attributeValue(<span class="hljs-string">&quot;class&quot;</span>);<br>            BeanDefinition beanDefinition = <span class="hljs-keyword">new</span> BeanDefinition();<br>            beanDefinition.setId(id);<br>            beanDefinition.setClassName(className);<br>            List&lt;Element&gt; list = element.elements(<span class="hljs-string">&quot;property&quot;</span>);<br>            MutablePropertyValues mutablePropertyValues = <span class="hljs-keyword">new</span> MutablePropertyValues();<br>            <span class="hljs-keyword">for</span> (Element element1 : list) &#123;<br>                String name = element1.attributeValue(<span class="hljs-string">&quot;name&quot;</span>);<br>                String ref = element1.attributeValue(<span class="hljs-string">&quot;ref&quot;</span>);<br>                String value = element1.attributeValue(<span class="hljs-string">&quot;value&quot;</span>);<br>                PropertyValue propertyValue = <span class="hljs-keyword">new</span> PropertyValue(name,ref,value);<br>                mutablePropertyValues.addPropertyValue(propertyValue);<br>            &#125;<br>            beanDefinition.setPropertyValues(mutablePropertyValues);<br><br>            registry.registerBeanDefinition(id,beanDefinition);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-4-IOC容器相关类"><a href="#7-4-4-IOC容器相关类" class="headerlink" title="7.4.4 IOC容器相关类"></a>7.4.4 IOC容器相关类</h3><h4 id="7-4-4-1-BeanFactory接口"><a href="#7-4-4-1-BeanFactory接口" class="headerlink" title="7.4.4.1 BeanFactory接口"></a>7.4.4.1 BeanFactory接口</h4><p>在该接口中定义IOC容器的统一规范即获取bean对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>	<span class="hljs-comment">//根据bean对象的名称获取bean对象</span><br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>	<span class="hljs-comment">//根据bean对象的名称获取bean对象，并进行类型转换</span><br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-4-2-ApplicationContext接口"><a href="#7-4-4-2-ApplicationContext接口" class="headerlink" title="7.4.4.2 ApplicationContext接口"></a>7.4.4.2 ApplicationContext接口</h4><p>该接口的所以的子实现类对bean对象的创建都是非延时的，所以在该接口中定义 <code>refresh()</code> 方法，该方法主要完成以下两个功能：</p>
<ul>
<li>加载配置文件。</li>
<li>根据注册表中的BeanDefinition对象封装的数据进行bean对象的创建。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>	<span class="hljs-comment">//进行配置文件加载并进行对象创建</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException, Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="7-4-4-3-AbstractApplicationContext类"><a href="#7-4-4-3-AbstractApplicationContext类" class="headerlink" title="7.4.4.3 AbstractApplicationContext类"></a>7.4.4.3 AbstractApplicationContext类</h4><ul>
<li><p>作为ApplicationContext接口的子类，所以该类也是非延时加载，所以需要在该类中定义一个Map集合，作为bean对象存储的容器。</p>
</li>
<li><p>声明BeanDefinitionReader类型的变量，用来进行xml配置文件的解析，符合单一职责原则。</p>
<p>BeanDefinitionReader类型的对象创建交由子类实现，因为只有子类明确到底创建BeanDefinitionReader哪儿个子实现类对象。</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractApplicationContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationContext</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> BeanDefinitionReader beanDefinitionReader;<br>    <span class="hljs-comment">//用来存储bean对象的容器   key存储的是bean的id值，value存储的是bean对象</span><br>    <span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; singletonObjects = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br><br>    <span class="hljs-comment">//存储配置文件的路径</span><br>    <span class="hljs-keyword">protected</span> String configLocation;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException, Exception </span>&#123;<br><br>        <span class="hljs-comment">//加载BeanDefinition</span><br>        beanDefinitionReader.loadBeanDefinitions(configLocation);<br><br>        <span class="hljs-comment">//初始化bean</span><br>        finishBeanInitialization();<br>    &#125;<br><br>    <span class="hljs-comment">//bean的初始化</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">finishBeanInitialization</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();<br>        String[] beanNames = registry.getBeanDefinitionNames();<br><br>        <span class="hljs-keyword">for</span> (String beanName : beanNames) &#123;<br>            BeanDefinition beanDefinition = registry.getBeanDefinition(beanName);<br>            getBean(beanName);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：该类finishBeanInitialization()方法中调用getBean()方法使用到了模板方法模式。</p>
</blockquote>
<h4 id="7-4-4-4-ClassPathXmlApplicationContext类"><a href="#7-4-4-4-ClassPathXmlApplicationContext类" class="headerlink" title="7.4.4.4 ClassPathXmlApplicationContext类"></a>7.4.4.4 ClassPathXmlApplicationContext类</h4><p>该类主要是加载类路径下的配置文件，并进行bean对象的创建，主要完成以下功能：</p>
<ul>
<li>在构造方法中，创建BeanDefinitionReader对象。</li>
<li>在构造方法中，调用refresh()方法，用于进行配置文件加载、创建bean对象并存储到容器中。</li>
<li>重写父接口中的getBean()方法，并实现依赖注入操作。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassPathXmlApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractApplicationContext</span></span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ClassPathXmlApplicationContext</span><span class="hljs-params">(String configLocation)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.configLocation = configLocation;<br>        <span class="hljs-comment">//构建XmlBeanDefinitionReader对象</span><br>        beanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">this</span>.refresh();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//根据bean的id属性值获取bean对象</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">//return singletonObjects.get(name);</span><br>        Object obj = singletonObjects.get(name);<br>        <span class="hljs-keyword">if</span>(obj != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> obj;<br>        &#125;<br><br>        BeanDefinitionRegistry registry = beanDefinitionReader.getRegistry();<br>        BeanDefinition beanDefinition = registry.getBeanDefinition(name);<br>        <span class="hljs-keyword">if</span>(beanDefinition == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>        &#125;<br>        String className = beanDefinition.getClassName();<br>        Class&lt;?&gt; clazz = Class.forName(className);<br>        Object beanObj = clazz.newInstance();<br>        MutablePropertyValues propertyValues = beanDefinition.getPropertyValues();<br>        <span class="hljs-keyword">for</span> (PropertyValue propertyValue : propertyValues) &#123;<br>            String propertyName = propertyValue.getName();<br>            String value = propertyValue.getValue();<br>            String ref = propertyValue.getRef();<br>            <span class="hljs-keyword">if</span>(ref != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(ref)) &#123;<br><br>                Object bean = getBean(ref);<br>                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);<br>                Method[] methods = clazz.getMethods();<br>                <span class="hljs-keyword">for</span> (Method method : methods) &#123;<br>                    <span class="hljs-keyword">if</span>(method.getName().equals(methodName)) &#123;<br>                        method.invoke(beanObj,bean);<br>                    &#125;<br>                &#125;<br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(value != <span class="hljs-keyword">null</span> &amp;&amp; !<span class="hljs-string">&quot;&quot;</span>.equals(value)) &#123;<br>                String methodName = StringUtils.getSetterMethodNameByFieldName(propertyName);<br>                Method method = clazz.getMethod(methodName, String.class);<br>                method.invoke(beanObj,value);<br>            &#125;<br>        &#125;<br>        singletonObjects.put(name,beanObj);<br>        <span class="hljs-keyword">return</span> beanObj;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Class&lt;? extends T&gt; clazz)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        Object bean = getBean(name);<br>        <span class="hljs-keyword">if</span>(bean != <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> clazz.cast(bean);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="7-4-5-自定义Spring-IOC总结"><a href="#7-4-5-自定义Spring-IOC总结" class="headerlink" title="7.4.5 自定义Spring IOC总结"></a>7.4.5 自定义Spring IOC总结</h3><h4 id="7-4-5-1-使用到的设计模式"><a href="#7-4-5-1-使用到的设计模式" class="headerlink" title="7.4.5.1 使用到的设计模式"></a>7.4.5.1 使用到的设计模式</h4><ul>
<li>工厂模式。这个使用工厂模式 + 配置文件的方式。</li>
<li>单例模式。Spring IOC管理的bean对象都是单例的，此处的单例不是通过构造器进行单例的控制的，而是spring框架对每一个bean只创建了一个对象。</li>
<li>模板方法模式。AbstractApplicationContext类中的finishBeanInitialization()方法调用了子类的getBean()方法，因为getBean()的实现和环境息息相关。</li>
<li>迭代器模式。对于MutablePropertyValues类定义使用到了迭代器模式，因为此类存储并管理PropertyValue对象，也属于一个容器，所以给该容器提供一个遍历方式。</li>
</ul>
<p>spring框架其实使用到了很多设计模式，如AOP使用到了代理模式，选择JDK代理或者CGLIB代理使用到了策略模式，还有适配器模式，装饰者模式，观察者模式等。</p>
<h4 id="7-4-5-2-符合大部分设计原则"><a href="#7-4-5-2-符合大部分设计原则" class="headerlink" title="7.4.5.2 符合大部分设计原则"></a>7.4.5.2 符合大部分设计原则</h4><h4 id="7-4-5-3-整个设计和Spring的设计还是有一定的出入"><a href="#7-4-5-3-整个设计和Spring的设计还是有一定的出入" class="headerlink" title="7.4.5.3 整个设计和Spring的设计还是有一定的出入"></a>7.4.5.3 整个设计和Spring的设计还是有一定的出入</h4><p>spring框架底层是很复杂的，进行了很深入的封装，并对外提供了很好的扩展性。而我们自定义SpringIOC有以下几个目的：</p>
<ul>
<li>了解Spring底层对对象的大体管理机制。</li>
<li>了解设计模式在具体的开发中的使用。</li>
<li>以后学习spring源码，通过该案例的实现，可以降低spring学习的入门成本。</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>activiti基础</title>
    <url>/2021/04/17/Activiti%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="Activiti7"><a href="#Activiti7" class="headerlink" title="Activiti7"></a>Activiti7</h1><h1 id="一、工作流介绍"><a href="#一、工作流介绍" class="headerlink" title="一、工作流介绍"></a>一、工作流介绍</h1><h2 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h2><p>工作流(Workflow)，就是通过计算机对业务流程自动化执行管理。它主要解决的是“使在多个参与者之间按照某种预定义的规则自动进行传递文档、信息或任务的过程，从而实现某个预期的业务目标，或者促使此目标的实现”。</p>
<h2 id="1-2-工作流系统"><a href="#1-2-工作流系统" class="headerlink" title="1.2 工作流系统"></a>1.2 工作流系统</h2><p>一个软件系统中具有工作流的功能，我们把它称为工作流系统，一个系统中工作流的功能是什么？就是对系统的业务流程进行自动化管理，所以工作流是建立在业务流程的基础上，所以一个软件的系统核心根本上还是系统的业务流程，工作流只是协助进行业务流程管理。即使没有工作流业务系统也可以开发运行，只不过有了工作流可以更好的管理业务流程，提高系统的可扩展性。</p>
<h2 id="1-3-适用行业"><a href="#1-3-适用行业" class="headerlink" title="1.3 适用行业"></a>1.3 适用行业</h2><p>消费品行业，制造业，电信服务业，银证险等金融服务业，物流服务业，物业服务业，物业管理，大中型进出口贸易公司，政府事业机构，研究院所及教育服务业等，特别是大的跨国企业和集团公司。</p>
<h2 id="1-4-具体应用"><a href="#1-4-具体应用" class="headerlink" title="1.4 具体应用"></a>1.4 具体应用</h2><p>1、关键业务流程：订单、报价处理、合同审核、客户电话处理、供应链管理等</p>
<p>2、行政管理类:出差申请、加班申请、请假申请、用车申请、各种办公用品申请、购买申请、日报周报等凡是原来手工流转处理的行政表单。</p>
<p>3、人事管理类：员工培训安排、绩效考评、职位变动处理、员工档案信息管理等。</p>
<p>4、财务相关类：付款请求、应收款处理、日常报销处理、出差报销、预算和计划申请等。</p>
<p>5、客户服务类：客户信息管理、客户投诉、请求处理、售后服务管理等。</p>
<p>6、特殊服务类：ISO系列对应流程、质量管理对应流程、产品数据信息管理、贸易公司报关处理、物流公司货物跟踪处理等各种通过表单逐步手工流转完成的任务均可应用工作流软件自动规范地实施。</p>
<h2 id="1-5-实现方式"><a href="#1-5-实现方式" class="headerlink" title="1.5 实现方式"></a>1.5 实现方式</h2><p>在没有专门的工作流引擎之前，我们之前为了实现流程控制，通常的做法就是采用状态字段的值来跟踪流程的变化情况。这样不用角色的用户，通过状态字段的取值来决定记录是否显示。</p>
<p> 针对有权限可以查看的记录，当前用户根据自己的角色来决定审批是否合格的操作。如果合格将状态字段设置一个值，来代表合格；当然如果不合格也需要设置一个值来代表不合格的情况。</p>
<p> 这是一种最为原始的方式。通过状态字段虽然做到了流程控制，但是当我们的流程发生变更的时候，这种方式所编写的代码也要进行调整。</p>
<p> 那么有没有专业的方式来实现工作流的管理呢？并且可以做到业务流程变化之后，我们的程序可以不用改变，如果可以实现这样的效果，那么我们的业务系统的适应能力就得到了极大提升。</p>
<h1 id="二、Activiti7概述"><a href="#二、Activiti7概述" class="headerlink" title="二、Activiti7概述"></a>二、Activiti7概述</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>Alfresco软件在2010年5月17日宣布Activiti业务流程管理（BPM）开源项目的正式启动，其首席架构师由业务流程管理BPM的专家 Tom Baeyens担任，Tom Baeyens就是原来jbpm的架构师，而jbpm是一个非常有名的工作流引擎，当然activiti也是一个工作流引擎。</p>
<p>Activiti是一个工作流引擎， activiti可以将业务系统中复杂的业务流程抽取出来，使用专门的建模语言BPMN2.0进行定义，业务流程按照预先定义的流程进行执行，实现了系统的流程由activiti进行管理，减少业务系统由于流程变更进行系统升级改造的工作量，从而提高系统的健壮性，同时也减少了系统开发维护成本。</p>
<p>官方网站：<a href="https://www.activiti.org/">https://www.activiti.org/</a></p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894539698.jpg" alt="img"></p>
<p>经历的版本:</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894569746.jpg" alt="img"></p>
<p>目前最新版本：Activiti7.0.0.Beta</p>
<h3 id="2-1-1-BPM"><a href="#2-1-1-BPM" class="headerlink" title="2.1.1 BPM"></a>2.1.1 BPM</h3><p>BPM（Business Process Management），即业务流程管理，是一种规范化的构造端到端的业务流程，以持续的提高组织业务效率。常见商业管理教育如EMBA、MBA等均将BPM包含在内。</p>
<h3 id="2-1-2-BPM软件"><a href="#2-1-2-BPM软件" class="headerlink" title="2.1.2 BPM软件"></a>2.1.2 BPM软件</h3><p>BPM软件就是根据企业中业务环境的变化，推进人与人之间、人与系统之间以及系统与系统之间的整合及调整的经营方法与解决方案的IT工具。</p>
<p>通过BPM软件对企业内部及外部的业务流程的整个生命周期进行建模、自动化、管理监控和优化，使企业成本降低，利润得以大幅提升。</p>
<p>BPM软件在企业中应用领域广泛，凡是有业务流程的地方都可以BPM软件进行管理，比如企业人事办公管理、采购流程管理、公文审批流程管理、财务管理等。</p>
<h3 id="2-1-3-BPMN"><a href="#2-1-3-BPMN" class="headerlink" title="2.1.3 BPMN"></a>2.1.3 BPMN</h3><p>BPMN（Business Process Model AndNotation）- 业务流程模型和符号 是由BPMI（BusinessProcess Management Initiative）开发的一套标准的业务流程建模符号，使用BPMN提供的符号可以创建业务流程。 </p>
<p>2004年5月发布了BPMN1.0规范.BPMI于2005年9月并入OMG（The Object Management Group对象管理组织)组织。OMG于2011年1月发布BPMN2.0的最终版本。</p>
<p>具体发展历史如下: </p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894913998.jpg" alt="img"></p>
<p>BPMN 是目前被各 BPM 厂商广泛接受的 BPM 标准。Activiti 就是使用 BPMN 2.0 进行流程建模、流程执行管理，它包括很多的建模符号，比如：</p>
<p>Event </p>
<p>用一个圆圈表示，它是流程中运行过程中发生的事情。</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894954565.jpg" alt="img"></p>
<p>活动用圆角矩形表示，一个流程由一个活动或多个活动组成</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1573894978125.jpg" alt="img"></p>
<p>Bpmn图形其实是通过xml表示业务流程，上边的.bpmn文件使用文本编辑器打开：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">definitions</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:xsd</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">xmlns:activiti</span>=<span class="hljs-string">&quot;http://activiti.org/bpmn&quot;</span> <span class="hljs-attr">xmlns:bpmndi</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/BPMN/20100524/DI&quot;</span> <span class="hljs-attr">xmlns:omgdc</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/DD/20100524/DC&quot;</span> <span class="hljs-attr">xmlns:omgdi</span>=<span class="hljs-string">&quot;http://www.omg.org/spec/DD/20100524/DI&quot;</span> <span class="hljs-attr">typeLanguage</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema&quot;</span> <span class="hljs-attr">expressionLanguage</span>=<span class="hljs-string">&quot;http://www.w3.org/1999/XPath&quot;</span> <span class="hljs-attr">targetNamespace</span>=<span class="hljs-string">&quot;http://www.activiti.org/test&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">process</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myProcess&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;My process&quot;</span> <span class="hljs-attr">isExecutable</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">startEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;startevent1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Start&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">startEvent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usertask1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;创建请假单&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow1&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;startevent1&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;usertask1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usertask2&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;部门经理审核&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow2&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;usertask1&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;usertask2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;usertask3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;人事复核&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">userTask</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow3&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;usertask2&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;usertask3&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">endEvent</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;endevent1&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;End&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">endEvent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">sequenceFlow</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;flow4&quot;</span> <span class="hljs-attr">sourceRef</span>=<span class="hljs-string">&quot;usertask3&quot;</span> <span class="hljs-attr">targetRef</span>=<span class="hljs-string">&quot;endevent1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">sequenceFlow</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">process</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNDiagram</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNDiagram_myProcess&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNPlane</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;myProcess&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNPlane_myProcess&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;startevent1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_startevent1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;130.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;160.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;usertask1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_usertask1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;55.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;105.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;210.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;150.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;usertask2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_usertask2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;55.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;105.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;360.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;150.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;usertask3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_usertask3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;55.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;105.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;510.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;150.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNShape</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;endevent1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNShape_endevent1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdc:Bounds</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&quot;35.0&quot;</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;660.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;160.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdc:Bounds</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNShape</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow1&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow1&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;165.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;210.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow2&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow2&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;315.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;360.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow3&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow3&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;465.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;510.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">bpmndi:BPMNEdge</span> <span class="hljs-attr">bpmnElement</span>=<span class="hljs-string">&quot;flow4&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;BPMNEdge_flow4&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;615.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">omgdi:waypoint</span> <span class="hljs-attr">x</span>=<span class="hljs-string">&quot;660.0&quot;</span> <span class="hljs-attr">y</span>=<span class="hljs-string">&quot;177.0&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">omgdi:waypoint</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNEdge</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNPlane</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">bpmndi:BPMNDiagram</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">definitions</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h2 id="2-2-使用步骤"><a href="#2-2-使用步骤" class="headerlink" title="2.2 使用步骤"></a>2.2 使用步骤</h2><h3 id="部署activiti"><a href="#部署activiti" class="headerlink" title="部署activiti"></a>部署activiti</h3><p>Activiti是一个工作流引擎（其实就是一堆jar包API），业务系统访问(操作)activiti的接口，就可以方便的操作流程相关数据，这样就可以把工作流环境与业务系统的环境集成在一起。</p>
<h3 id="流程定义"><a href="#流程定义" class="headerlink" title="流程定义"></a>流程定义</h3><p>使用activiti流程建模工具(activity-designer)定义业务流程(.bpmn文件) 。</p>
<p><strong>.bpmn文件就是业务流程定义文件</strong>，通过xml定义业务流程。</p>
<h3 id="流程定义部署"><a href="#流程定义部署" class="headerlink" title="流程定义部署"></a>流程定义部署</h3><p>activiti部署业务流程定义（.bpmn文件）。</p>
<p>使用activiti提供的api把流程定义内容存储起来，在Activiti执行过程中可以查询定义的内容</p>
<p><strong>Activiti执行把流程定义内容存储在数据库中</strong></p>
<h3 id="启动一个流程实例"><a href="#启动一个流程实例" class="headerlink" title="启动一个流程实例"></a>启动一个流程实例</h3><p>流程实例也叫：ProcessInstance</p>
<p><strong>启动一个流程实例表示开始一次业务流程的运行。</strong></p>
<p>在员工请假流程定义部署完成后，如果张三要请假就可以启动一个流程实例，如果李四要请假也启动一个流程实例，两个流程的执行互相不影响。</p>
<h3 id="用户查询待办任务-Task"><a href="#用户查询待办任务-Task" class="headerlink" title="用户查询待办任务(Task)"></a>用户查询待办任务(Task)</h3><p>因为现在系统的业务流程已经交给activiti管理，通过activiti就可以查询当前流程执行到哪了，当前用户需要办理什么任务了，这些activiti帮我们管理了，而不需要开发人员自己编写在sql语句查询。</p>
<h3 id="用户办理任务"><a href="#用户办理任务" class="headerlink" title="用户办理任务"></a>用户办理任务</h3><p>用户查询待办任务后，就可以办理某个任务，如果这个任务办理完成还需要其它用户办理，比如采购单创建后由部门经理审核，这个过程也是由activiti帮我们完成了。</p>
<h3 id="流程结束"><a href="#流程结束" class="headerlink" title="流程结束"></a>流程结束</h3><p>当任务办理完成没有下一个任务结点了，这个流程实例就完成了。</p>
<h1 id="三、Activiti环境"><a href="#三、Activiti环境" class="headerlink" title="三、Activiti环境"></a>三、Activiti环境</h1><h2 id="3-1-开发环境"><a href="#3-1-开发环境" class="headerlink" title="3.1 开发环境"></a>3.1 开发环境</h2><p>Jdk1.8或以上版本</p>
<p>Mysql 5及以上的版本</p>
<p>Tomcat8.5</p>
<p>IDEA</p>
<p><strong>注意：activiti的流程定义工具插件可以安装在IDEA下，也可以安装在Eclipse工具下</strong></p>
<h2 id="3-2-Activiti环境"><a href="#3-2-Activiti环境" class="headerlink" title="3.2 Activiti环境"></a>3.2 Activiti环境</h2><p>我们使用：Activiti7.0.0.Beta1  默认支持spring5</p>
<h3 id="3-2-1-下载activiti7"><a href="#3-2-1-下载activiti7" class="headerlink" title="3.2.1 下载activiti7"></a>3.2.1 下载activiti7</h3><p>Activiti下载地址：<a href="http://activiti.org/download.html">http://activiti.org/download.html</a> ，Maven的依赖如下：</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>1)</strong>      <strong>Database</strong>：</p>
<p>activiti运行需要有数据库的支持，支持的数据库有：h2, mysql, oracle, postgres, mssql, db2。</p>
<h3 id="3-2-2-流程设计器IDEA下安装"><a href="#3-2-2-流程设计器IDEA下安装" class="headerlink" title="3.2.2 流程设计器IDEA下安装"></a>3.2.2 流程设计器IDEA下安装</h3><p>在IDEA的File菜单中找到子菜单”Settings”,后面我们再选择左侧的“plugins”菜单，如下图所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574856677.png"></p>
<p>此时我们就可以搜索到actiBPM插件，它就是Activiti Designer的IDEA版本，我们点击Install安装。</p>
<p>安装好后，页面如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574856972.png"></p>
<p>提示需要重启idea，点击重启。</p>
<p>重启完成后，再次打开Settings 下的 Plugins（插件列表），点击右侧的Installed（已安装的插件），在列表中看到actiBPM，就说明已经安装成功了，如下图所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574857172.png"></p>
<p>后面的课程里，我们会使用这个流程设计器进行Activiti的流程设计。</p>
<h3 id="3-2-3-Eclipse-activiti-designer插件"><a href="#3-2-3-Eclipse-activiti-designer插件" class="headerlink" title="3.2.3 Eclipse activiti-designer插件"></a>3.2.3 Eclipse activiti-designer插件</h3><h2 id="3-3-Activiti的数据库支持"><a href="#3-3-Activiti的数据库支持" class="headerlink" title="3.3 Activiti的数据库支持"></a>3.3 Activiti的数据库支持</h2><p>Activiti 在运行时需要数据库的支持，使用25张表，把流程定义节点内容读取到数据库表中，以供后续使用。</p>
<h3 id="3-3-1-Activiti-支持的数据库"><a href="#3-3-1-Activiti-支持的数据库" class="headerlink" title="3.3.1 Activiti 支持的数据库"></a>3.3.1 Activiti 支持的数据库</h3><p>activiti  支持的数据库和版本如下：</p>
<table>
<thead>
<tr>
<th>数据库类型</th>
<th>版本</th>
<th>JDBC连接示例</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>h2</td>
<td>1.3.168</td>
<td>jdbc:h2:tcp://localhost/activiti</td>
<td>默认配置的数据库</td>
</tr>
<tr>
<td>mysql</td>
<td>5.1.21</td>
<td>jdbc:mysql://localhost:3306/activiti?autoReconnect=true</td>
<td>使用 mysql-connector-java 驱动测试</td>
</tr>
<tr>
<td>oracle</td>
<td>11.2.0.1.0</td>
<td>jdbc:oracle:thin:@localhost:1521:xe</td>
<td></td>
</tr>
<tr>
<td>postgres</td>
<td>8.1</td>
<td>jdbc:postgresql://localhost:5432/activiti</td>
<td></td>
</tr>
<tr>
<td>db2</td>
<td>DB2 10.1 using db2jcc4</td>
<td>jdbc:db2://localhost:50000/activiti</td>
<td></td>
</tr>
<tr>
<td>mssql</td>
<td>2008 using sqljdbc4</td>
<td>jdbc:sqlserver://localhost:1433/activiti</td>
<td></td>
</tr>
</tbody></table>
<h3 id="3-3-2-在MySQL生成表"><a href="#3-3-2-在MySQL生成表" class="headerlink" title="3.3.2 在MySQL生成表"></a>3.3.2 在MySQL生成表</h3><h4 id="3-3-2-1-创建数据库"><a href="#3-3-2-1-创建数据库" class="headerlink" title="3.3.2.1 创建数据库"></a>3.3.2.1 创建数据库</h4><p>创建  mysql  数据库  activiti （名字任意）：</p>
<p>CREATE DATABASE activiti DEFAULT CHARACTER SET utf8;</p>
<h4 id="3-3-2-2-使用java代码生成表"><a href="#3-3-2-2-使用java代码生成表" class="headerlink" title="3.3.2.2 使用java代码生成表"></a>3.3.2.2 使用java代码生成表</h4><h5 id="1）-创建-java-工程"><a href="#1）-创建-java-工程" class="headerlink" title="1） 创建 java 工程"></a>1） 创建 java 工程</h5><p>使用idea 创建 java 的maven工程，取名：activiti01。</p>
<h5 id="2）-加入-maven-依赖的坐标（jar-包）"><a href="#2）-加入-maven-依赖的坐标（jar-包）" class="headerlink" title="2） 加入 maven 依赖的坐标（jar 包）"></a>2） 加入 maven 依赖的坐标（jar 包）</h5><p>首先需要在 java 工程中加入 ProcessEngine 所需要的 jar 包，包括：</p>
<ol>
<li><p>activiti-engine-7.0.0.beta1.jar</p>
</li>
<li><p>activiti 依赖的 jar 包： mybatis、 alf4j、 log4j 等</p>
</li>
<li><p>activiti 依赖的 spring 包</p>
</li>
<li><p>mysql数据库驱动</p>
</li>
<li><p>第三方数据连接池 dbcp</p>
</li>
<li><p>单元测试 Junit-4.12.jar</p>
</li>
</ol>
<p>我们使用 maven 来实现项目的构建，所以应当导入这些 jar 所对应的坐标到 pom.xml 文件中。</p>
<p>完整的依赖内容如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">slf4j.version</span>&gt;</span>1.6.6<span class="hljs-tag">&lt;/<span class="hljs-name">slf4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">log4j.version</span>&gt;</span>1.2.12<span class="hljs-tag">&lt;/<span class="hljs-name">log4j.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">activiti.version</span>&gt;</span>7.0.0.Beta1<span class="hljs-tag">&lt;/<span class="hljs-name">activiti.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-engine<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn 模型处理 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-model<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn 转换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn json数据转换 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-json-converter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- bpmn 布局 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-bpmn-layout<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- activiti 云支持 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.activiti.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>activiti-cloud-services-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;activiti.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mysql驱动 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.40<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- mybatis --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 链接池 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-dbcp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- log start --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;log4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="3）-添加log4j日志配置"><a href="#3）-添加log4j日志配置" class="headerlink" title="3） 添加log4j日志配置"></a>3） 添加log4j日志配置</h5><p>我们使用log4j日志包，可以对日志进行配置</p>
<p>在resources 下创建log4j.properties</p>
<figure class="highlight properties"><table><tr><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># Set root category priority to INFO and its only appender to CONSOLE.</span><br><span class="hljs-comment">#log4j.rootCategory=INFO, CONSOLE debug info warn error fatal</span><br><span class="hljs-meta">log4j.rootCategory</span>=<span class="hljs-string">debug, CONSOLE, LOGFILE</span><br><span class="hljs-comment"># Set the enterprise logger category to FATAL and its only appender to CONSOLE.</span><br><span class="hljs-meta">log4j.logger.org.apache.axis.enterprise</span>=<span class="hljs-string">FATAL, CONSOLE</span><br><span class="hljs-comment"># CONSOLE is set to be a ConsoleAppender using a PatternLayout.</span><br><span class="hljs-meta">log4j.appender.CONSOLE</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.CONSOLE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.CONSOLE.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m\n</span><br><span class="hljs-comment"># LOGFILE is set to be a File appender using a PatternLayout.</span><br><span class="hljs-meta">log4j.appender.LOGFILE</span>=<span class="hljs-string">org.apache.log4j.FileAppender</span><br><span class="hljs-meta">log4j.appender.LOGFILE.File</span>=<span class="hljs-string">f:\act\activiti.log</span><br><span class="hljs-meta">log4j.appender.LOGFILE.Append</span>=<span class="hljs-string">true</span><br><span class="hljs-meta">log4j.appender.LOGFILE.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.LOGFILE.layout.ConversionPattern</span>=<span class="hljs-string">%d&#123;ISO8601&#125; %-6r[%15.15t] %-5p %30.30c %x - %m\n</span><br></code></pre></td></tr></table></figure>

<h5 id="4）-添加activiti配置文件"><a href="#4）-添加activiti配置文件" class="headerlink" title="4） 添加activiti配置文件"></a>4） 添加activiti配置文件</h5><p>我们使用activiti提供的默认方式来创建mysql的表。</p>
<p>默认方式的要求是在 resources 下创建 activiti.cfg.xml 文件，注意：默认方式目录和文件名不能修改，因为activiti的源码中已经设置，到固定的目录读取固定文件名的文件。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="5）-在-activiti-cfg-xml-中进行配置"><a href="#5）-在-activiti-cfg-xml-中进行配置" class="headerlink" title="5） 在 activiti.cfg.xml 中进行配置"></a>5） 在 activiti.cfg.xml 中进行配置</h5><p>默认方式要在在activiti.cfg.xml中bean的名字叫processEngineConfiguration，名字不可修改</p>
<p>在这里有2中配置方式：一种是单独配置数据源，一种是不单独配置数据源</p>
<h6 id="1、直接配置processEngineConfiguration"><a href="#1、直接配置processEngineConfiguration" class="headerlink" title="1、直接配置processEngineConfiguration"></a>1、直接配置processEngineConfiguration</h6><p>processEngineConfiguration 用来创建 ProcessEngine，在创建 ProcessEngine 时会执行数据库的操作。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 默认id对应的值 为processEngineConfiguration --&gt;</span><br>    <span class="hljs-comment">&lt;!-- processEngine Activiti的流程引擎 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcDriver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUsername&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcPassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!-- activiti数据库表处理策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h6 id="2、配置数据源后，在processEngineConfiguration-引用"><a href="#2、配置数据源后，在processEngineConfiguration-引用" class="headerlink" title="2、配置数据源后，在processEngineConfiguration 引用"></a>2、配置数据源后，在processEngineConfiguration 引用</h6><p>首先配置数据源</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 这里可以使用 链接池 dbcp--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 引用数据源 上面已经设置好了--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>        <span class="hljs-comment">&lt;!-- activiti数据库表处理策略 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h5 id="6）-java类编写程序生成表"><a href="#6）-java类编写程序生成表" class="headerlink" title="6） java类编写程序生成表"></a>6） java类编写程序生成表</h5><p>创建一个测试类，调用activiti的工具类，生成acitivti需要的数据库表。</p>
<p>直接使用activiti提供的工具类ProcessEngines，会默认读取classpath下的activiti.cfg.xml文件，读取其中的数据库配置，创建 ProcessEngine，在创建ProcessEngine 时会自动创建表。 </p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.activiti01.test;<br><br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngine;<br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngineConfiguration;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestDemo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成 activiti的数据库表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateDbTable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//使用classpath下的activiti.cfg.xml中的配置创建processEngine</span><br>		ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>		System.out.println(processEngine);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>说明：<br>1、运行以上程序段即可完成 activiti 表创建，通过改变 activiti.cfg.xml 中databaseSchemaUpdate 参数的值执行不同的数据表处理策略。<br>2 、 上 边 的 方法 getDefaultProcessEngine方法在执行时，从activiti.cfg.xml 中找固定的名称 processEngineConfiguration 。</p>
<p>在测试程序执行过程中，idea的控制台会输出日志，说明程序正在创建数据表，类似如下,注意红线内容：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1572852095.png"></p>
<p>执行完成后我们查看数据库， 创建了 25 张表，结果如下： </p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1572852222.png"></p>
<p>到这，我们就完成activiti运行需要的数据库和表的创建。</p>
<h2 id="3-4-表结构介绍"><a href="#3-4-表结构介绍" class="headerlink" title="3.4 表结构介绍"></a>3.4 表结构介绍</h2><h3 id="3-4-1-表的命名规则和作用"><a href="#3-4-1-表的命名规则和作用" class="headerlink" title="3.4.1 表的命名规则和作用"></a>3.4.1 表的命名规则和作用</h3><p>看到刚才创建的表，我们发现Activiti 的表都以   ACT_   开头。 </p>
<p>第二部分是表示表的用途的两个字母标识。 用途也和服务的 API 对应。<br><strong>ACT_RE</strong> ：’RE’表示 repository。 这个前缀的表包含了流程定义和流程静态资源 （图片，规则，等等）。<br><strong>ACT_RU</strong>：’RU’表示 runtime。 这些运行时的表，包含流程实例，任务，变量，异步任务，等运行中的数据。 Activiti 只在流程实例执行过程中保存这些数据， 在流程结束时就会删除这些记录。 这样运行时表可以一直很小速度很快。<br><strong>ACT_HI</strong>：’HI’表示 history。 这些表包含历史数据，比如历史流程实例， 变量，任务等等。<br> <strong>ACT_GE</strong> ： GE 表示 general。 通用数据， 用于不同场景下 </p>
<h3 id="3-4-2-Activiti数据表介绍"><a href="#3-4-2-Activiti数据表介绍" class="headerlink" title="3.4.2 Activiti数据表介绍"></a>3.4.2 Activiti数据表介绍</h3><table>
<thead>
<tr>
<th><strong>表分类</strong></th>
<th><strong>表名</strong></th>
<th><strong>解释</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一般数据</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_GE_BYTEARRAY]</td>
<td>通用的流程定义和流程资源</td>
</tr>
<tr>
<td></td>
<td>[ACT_GE_PROPERTY]</td>
<td>系统相关属性</td>
</tr>
<tr>
<td>流程历史记录</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_ACTINST]</td>
<td>历史的流程实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_ATTACHMENT]</td>
<td>历史的流程附件</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_COMMENT]</td>
<td>历史的说明性信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_DETAIL]</td>
<td>历史的流程运行中的细节信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_IDENTITYLINK]</td>
<td>历史的流程运行过程中用户关系</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_PROCINST]</td>
<td>历史的流程实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_TASKINST]</td>
<td>历史的任务实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_HI_VARINST]</td>
<td>历史的流程运行中的变量信息</td>
</tr>
<tr>
<td>流程定义表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_DEPLOYMENT]</td>
<td>部署单元信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_MODEL]</td>
<td>模型信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RE_PROCDEF]</td>
<td>已部署的流程定义</td>
</tr>
<tr>
<td>运行实例表</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_EVENT_SUBSCR]</td>
<td>运行时事件</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_EXECUTION]</td>
<td>运行时流程执行实例</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_IDENTITYLINK]</td>
<td>运行时用户关系信息，存储任务节点与参与者的相关信息</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_JOB]</td>
<td>运行时作业</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_TASK]</td>
<td>运行时任务</td>
</tr>
<tr>
<td></td>
<td>[ACT_RU_VARIABLE]</td>
<td>运行时变量表</td>
</tr>
</tbody></table>
<h1 id="四、Activiti类关系图"><a href="#四、Activiti类关系图" class="headerlink" title="四、Activiti类关系图"></a>四、Activiti类关系图</h1><p>上面我们完成了Activiti数据库表的生成，java代码中我们调用Activiti的工具类，下面来了解Activiti的类关系</p>
<h2 id="4-1-类关系图"><a href="#4-1-类关系图" class="headerlink" title="4.1 类关系图"></a>4.1 类关系图</h2><p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002.jpg" alt="img"></p>
<p>在新版本中，我们通过实验可以发现IdentityService，FormService两个Serivce都已经删除了。</p>
<p>所以后面我们对于这两个Service也不讲解了，但老版本中还是有这两个Service，同学们需要了解一下</p>
<h2 id="4-2-activiti-cfg-xml"><a href="#4-2-activiti-cfg-xml" class="headerlink" title="4.2 activiti.cfg.xml"></a>4.2 activiti.cfg.xml</h2><p>activiti的引擎配置文件，包括：ProcessEngineConfiguration的定义、数据源定义、事务管理器等，此文件其实就是一个spring配置文件。</p>
<h2 id="4-3-流程引擎配置类"><a href="#4-3-流程引擎配置类" class="headerlink" title="4.3 流程引擎配置类"></a>4.3 流程引擎配置类</h2><p>流程引擎的配置类（ProcessEngineConfiguration），通过ProcessEngineConfiguration可以创建工作流引擎ProceccEngine，常用的两种方法如下： </p>
<h3 id="4-3-1-StandaloneProcessEngineConfiguration"><a href="#4-3-1-StandaloneProcessEngineConfiguration" class="headerlink" title="4.3.1 StandaloneProcessEngineConfiguration"></a>4.3.1 StandaloneProcessEngineConfiguration</h3><p>使用StandaloneProcessEngineConfigurationActiviti可以单独运行，来创建ProcessEngine，Activiti会自己处理事务。</p>
<p> 配置文件方式：</p>
<p>通常在activiti.cfg.xml配置文件中定义一个id为 processEngineConfiguration 的bean.</p>
<p>方法如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--配置数据库相关的信息--&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库驱动--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcDriver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库链接--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUrl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库用户名--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcUsername&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--数据库密码--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jdbcPassword&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--actviti数据库表在生成时的策略  true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>还可以加入连接池:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans</span></span><br><span class="hljs-tag"><span class="hljs-string">                    http://www.springframework.org/schema/beans/spring-beans.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/contex</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/context/spring-context.xsd</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx</span></span><br><span class="hljs-tag"><span class="hljs-string">http://www.springframework.org/schema/tx/spring-tx.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql:///activiti&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;123456&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--在默认方式下 bean的id  固定为 processEngineConfiguration--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span></span><br><span class="hljs-tag">          <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.engine.impl.cfg.StandaloneProcessEngineConfiguration&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--引入上面配置好的 链接池--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--actviti数据库表在生成时的策略  true - 如果数据库中已经存在相应的表，那么直接使用，如果不存在，那么会创建--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure>



<h3 id="4-3-2-SpringProcessEngineConfiguration"><a href="#4-3-2-SpringProcessEngineConfiguration" class="headerlink" title="4.3.2 SpringProcessEngineConfiguration"></a>4.3.2 SpringProcessEngineConfiguration</h3><p><strong>通过org.activiti.spring.SpringProcessEngineConfiguration 与==Spring整合==。</strong> </p>
<p>创建spring与activiti的整合配置文件：</p>
<p>activity-spring.cfg.xml（名称可修改）</p>
 <figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span> <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:aop</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/aop&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/beans/spring-beans-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/context </span></span><br><span class="hljs-tag"><span class="hljs-string">        http://www.springframework.org/schema/context/spring-context-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/aop/spring-aop-3.1.xsd </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/tx </span></span><br><span class="hljs-tag"><span class="hljs-string">       http://www.springframework.org/schema/tx/spring-tx-3.1.xsd &quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 工作流引擎配置bean --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.SpringProcessEngineConfiguration&quot;</span>&gt;</span><br>       <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- 使用spring事务管理器 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- 数据库策略 --&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;databaseSchemaUpdate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;drop-create&quot;</span> /&gt;</span><br>       <span class="hljs-comment">&lt;!-- activiti的定时任务关闭 --&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;jobExecutorActivate&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程引擎 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.activiti.spring.ProcessEngineFactoryBean&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;processEngineConfiguration&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 资源服务service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;repositoryService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRepositoryService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 流程运行service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;runtimeService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getRuntimeService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 任务管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;taskService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getTaskService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 历史管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;historyService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getHistoryService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 用户管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;identityService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getIdentityService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 引擎管理service --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;managementService&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;processEngine&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;getManagementService&quot;</span> /&gt;</span><br>    <span class="hljs-comment">&lt;!-- 数据源 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.apache.commons.dbcp.BasicDataSource&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/activiti&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxActive&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;3&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxIdle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;1&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 事务管理器 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span></span><br><span class="hljs-tag">     <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 通知 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>           <span class="hljs-comment">&lt;!-- 传播行为 --&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;save*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;insert*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;delete*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;update*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;REQUIRED&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;find*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">propagation</span>=<span class="hljs-string">&quot;SUPPORTS&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 切面，根据具体项目修改切点配置 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span> <span class="hljs-attr">proxy-target-class</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span>  <span class="hljs-attr">pointcut</span>=<span class="hljs-string">&quot;execution(* com.itheima.ihrm.service.impl.*.(..))&quot;</span>* /&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br><br></code></pre></td></tr></table></figure>

<h3 id="创建processEngineConfiguration"><a href="#创建processEngineConfiguration" class="headerlink" title="创建processEngineConfiguration"></a>创建processEngineConfiguration</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="hljs-string">&quot;activiti.cfg.xml&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>​    上边的代码要求activiti.cfg.xml中必须有一个processEngineConfiguration的bean</p>
<p>也可以使用下边的方法，更改bean 的名字：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(String resource, String beanName);<br></code></pre></td></tr></table></figure>

<h2 id="4-4-工作流引擎创建"><a href="#4-4-工作流引擎创建" class="headerlink" title="4.4 工作流引擎创建"></a>4.4 工作流引擎创建</h2><p>工作流引擎（ProcessEngine），相当于一个门面接口，通过ProcessEngineConfiguration创建processEngine，通过ProcessEngine创建各个service接口。</p>
<h3 id="4-4-1-默认创建方式"><a href="#4-4-1-默认创建方式" class="headerlink" title="4.4.1 默认创建方式"></a>4.4.1 默认创建方式</h3><p>将activiti.cfg.xml文件名及路径固定，且activiti.cfg.xml文件中有 processEngineConfiguration的配置， 可以使用如下代码创建processEngine:</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//直接使用工具类 ProcessEngines，使用classpath下的activiti.cfg.xml中的配置创建processEngine</span><br>ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>System.out.println(processEngine);<br></code></pre></td></tr></table></figure>

<h3 id="4-4-2-一般创建方式"><a href="#4-4-2-一般创建方式" class="headerlink" title="4.4.2 一般创建方式"></a>4.4.2 一般创建方式</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//先构建ProcessEngineConfiguration</span><br>ProcessEngineConfiguration configuration = ProcessEngineConfiguration.createProcessEngineConfigurationFromResource(<span class="hljs-string">&quot;activiti.cfg.xml&quot;</span>);<br><span class="hljs-comment">//通过ProcessEngineConfiguration创建ProcessEngine，此时会创建数据库</span><br>ProcessEngine processEngine = configuration.buildProcessEngine();<br></code></pre></td></tr></table></figure>

<h2 id="4-5-Servcie服务接口"><a href="#4-5-Servcie服务接口" class="headerlink" title="4.5 Servcie服务接口"></a>4.5 Servcie服务接口</h2><p>Service是工作流引擎提供用于进行工作流部署、执行、管理的服务接口，我们使用这些接口可以就是操作服务对应的数据表</p>
<h3 id="4-5-1-Service创建方式"><a href="#4-5-1-Service创建方式" class="headerlink" title="4.5.1 Service创建方式"></a>4.5.1 Service创建方式</h3><p>通过ProcessEngine创建Service</p>
<p>方式如下：</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">RuntimeService runtimeService = processEngine.getRuntimeService();<br>RepositoryService repositoryService = processEngine.getRepositoryService();<br>TaskService taskService = processEngine.getTaskService();<br></code></pre></td></tr></table></figure>

<h3 id="4-5-2-Service总览"><a href="#4-5-2-Service总览" class="headerlink" title="4.5.2 Service总览"></a>4.5.2 Service总览</h3><table>
<thead>
<tr>
<th>service名称</th>
<th>service作用</th>
</tr>
</thead>
<tbody><tr>
<td>RepositoryService</td>
<td>activiti的资源管理类</td>
</tr>
<tr>
<td>RuntimeService</td>
<td>activiti的流程运行管理类</td>
</tr>
<tr>
<td>TaskService</td>
<td>activiti的任务管理类</td>
</tr>
<tr>
<td>HistoryService</td>
<td>activiti的历史管理类</td>
</tr>
<tr>
<td>ManagerService</td>
<td>activiti的引擎管理类</td>
</tr>
</tbody></table>
<p> 简单介绍：</p>
<p><strong>RepositoryService</strong></p>
<p>是activiti的资源管理类，提供了管理和控制流程发布包和流程定义的操作。使用工作流建模工具设计的业务流程图需要使用此service将流程定义文件的内容部署到计算机。</p>
<p>除了部署流程定义以外还可以：查询引擎中的发布包和流程定义。</p>
<p>暂停或激活发布包，对应全部和特定流程定义。 暂停意味着它们不能再执行任何操作了，激活是对应的反向操作。获得多种资源，像是包含在发布包里的文件， 或引擎自动生成的流程图。</p>
<p>获得流程定义的pojo版本， 可以用来通过java解析流程，而不必通过xml。</p>
<h4 id="RuntimeService"><a href="#RuntimeService" class="headerlink" title="RuntimeService"></a>RuntimeService</h4><p>Activiti的流程运行管理类。可以从这个服务类中获取很多关于流程执行相关的信息</p>
<h4 id="TaskService"><a href="#TaskService" class="headerlink" title="TaskService"></a>TaskService</h4><p>Activiti的任务管理类。可以从这个类中获取任务的信息。</p>
<h4 id="HistoryService"><a href="#HistoryService" class="headerlink" title="HistoryService"></a>HistoryService</h4><p>Activiti的历史管理类，可以查询历史信息，执行流程时，引擎会保存很多数据（根据配置），比如流程实例启动时间，任务的参与者， 完成任务的时间，每个流程实例的执行路径，等等。 这个服务主要通过查询功能来获得这些数据。</p>
<h4 id="ManagementService"><a href="#ManagementService" class="headerlink" title="ManagementService"></a>ManagementService</h4><p>Activiti的引擎管理类，提供了对 Activiti 流程引擎的管理和维护功能，这些功能不在工作流驱动的应用程序中使用，主要用于 Activiti 系统的日常维护。</p>
<h1 id="五、Activiti入门"><a href="#五、Activiti入门" class="headerlink" title="五、Activiti入门"></a>五、Activiti入门</h1><p>在本章内容中，我们来创建一个Activiti工作流，并启动这个流程。</p>
<p>创建Activiti工作流主要包含以下几步：</p>
<p>1、定义流程，按照BPMN的规范，使用流程定义工具，用<strong>流程符号</strong>把整个流程描述出来</p>
<p>2、部署流程，把画好的流程定义文件，加载到数据库中，生成表的数据</p>
<p>3、启动流程，使用java代码来操作数据库表中的内容</p>
<h2 id="5-1-流程符号"><a href="#5-1-流程符号" class="headerlink" title="5.1 流程符号"></a>5.1 流程符号</h2><p>BPMN 2.0是业务流程建模符号2.0的缩写。</p>
<p>它由Business Process Management Initiative这个非营利协会创建并不断发展。作为一种标识，BPMN 2.0是使用一些<strong>符号</strong>来明确业务流程设计流程图的一整套符号规范，它能增进业务建模时的沟通效率。</p>
<p>目前BPMN2.0是最新的版本，它用于在BPM上下文中进行布局和可视化的沟通。</p>
<p>接下来我们先来了解在流程设计中常见的 符号。</p>
<p>BPMN2.0的<strong>基本符合</strong>主要包含：</p>
<h3 id="事件-Event"><a href="#事件-Event" class="headerlink" title="事件 Event"></a>事件 Event</h3><p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574522151044.png" alt="1574522151044"></p>
<h3 id="活动-Activity"><a href="#活动-Activity" class="headerlink" title="活动 Activity"></a>活动 Activity</h3><p>活动是工作或任务的一个通用术语。一个活动可以是一个任务，还可以是一个当前流程的子处理流程； 其次，你还可以为活动指定不同的类型。常见活动如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574562726375.png" alt="1574562726375"></p>
<h3 id="网关-GateWay"><a href="#网关-GateWay" class="headerlink" title="网关 GateWay"></a>网关 GateWay</h3><p>网关用来处理决策，有几种常用网关需要了解：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574563600305.png" alt="1574563600305"></p>
<h4 id="排他网关-x"><a href="#排他网关-x" class="headerlink" title="排他网关 (x)"></a>排他网关 (x)</h4><p>——只有一条路径会被选择。流程执行到该网关时，按照输出流的顺序逐个计算，当条件的计算结果为true时，继续执行当前网关的输出流；</p>
<p>​    如果多条线路计算结果都是 true，则会执行第一个值为 true 的线路。如果所有网关计算结果没有true，则引擎会抛出异常。</p>
<p>​    排他网关需要和条件顺序流结合使用，default 属性指定默认顺序流，当所有的条件不满足时会执行默认顺序流。</p>
<h4 id="并行网关"><a href="#并行网关" class="headerlink" title="并行网关 (+)"></a>并行网关 (+)</h4><p>——所有路径会被同时选择</p>
<p>​    拆分 —— 并行执行所有输出顺序流，为每一条顺序流创建一个并行执行线路。</p>
<p>​    合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。</p>
<h4 id="包容网关"><a href="#包容网关" class="headerlink" title="包容网关 (+)"></a>包容网关 (+)</h4><p>—— 可以同时执行多条线路，也可以在网关上设置条件</p>
<p>​    拆分 —— 计算每条线路上的表达式，当表达式计算结果为true时，创建一个并行线路并继续执行</p>
<p>​    合并 —— 所有从并行网关拆分并执行完成的线路均在此等候，直到所有的线路都执行完成才继续向下执行。</p>
<h4 id="事件网关"><a href="#事件网关" class="headerlink" title="事件网关 (+)"></a>事件网关 (+)</h4><p>—— 专门为中间捕获事件设置的，允许设置多个输出流指向多个不同的中间捕获事件。当流程执行到事件网关后，流程处于等待状态，需要等待抛出事件才能将等待状态转换为活动状态。</p>
<h3 id="流向-Flow"><a href="#流向-Flow" class="headerlink" title="流向 Flow"></a>流向 Flow</h3><p>流是连接两个流程节点的连线。常见的流向包含以下几种：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1574563937457.png" alt="1574563937457"></p>
<h2 id="5-2-流程设计器使用"><a href="#5-2-流程设计器使用" class="headerlink" title="5.2 流程设计器使用"></a>5.2 流程设计器使用</h2><h3 id="Activiti-Designer使用"><a href="#Activiti-Designer使用" class="headerlink" title="Activiti-Designer使用"></a>Activiti-Designer使用</h3><h4 id="Palette（画板）"><a href="#Palette（画板）" class="headerlink" title="Palette（画板）"></a>Palette（画板）</h4><p>在idea中安装插件即可使用，画板中包括以下结点：</p>
<p>Connection—连接</p>
<p>Event—事件</p>
<p>Task—任务</p>
<p>Gateway—网关</p>
<p>Container—容器</p>
<p>Boundary event—边界事件</p>
<p>Intermediate event- -中间事件</p>
<p>流程图设计完毕保存生成.bpmn文件</p>
<h4 id="新建流程-IDEA工具"><a href="#新建流程-IDEA工具" class="headerlink" title="新建流程(IDEA工具)"></a>新建流程(IDEA工具)</h4><p>首先选中存放图形的目录(选择resources下的bpmn目录)，点击菜单：New  -&gt; BpmnFile，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575106985823.png" alt="1575106985823"></p>
<p>弹出如下图所示框，输入evection 表示 出差审批流程：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107231004.png" alt="1575107231004"></p>
<p>起完名字evection后（默认扩展名为bpmn），就可以看到流程设计页面，如图所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107336431.png" alt="1575107336431"></p>
<p>左侧区域是绘图区，右侧区域是palette画板区域</p>
<p>鼠标先点击画板的元素即可在左侧绘图</p>
<h3 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h3><p>使用滑板来绘制流程，通过从右侧把图标拖拽到左侧的画板，最终效果如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107648105.png" alt="1575107648105"></p>
<h3 id="指定流程定义Key"><a href="#指定流程定义Key" class="headerlink" title="指定流程定义Key"></a>指定流程定义Key</h3><p>流程定义key即流程定义的标识，通过properties视图查看流程的key</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575115474865.png" alt="1575115474865"></p>
<h3 id="指定任务负责人"><a href="#指定任务负责人" class="headerlink" title="指定任务负责人"></a>指定任务负责人</h3><p>在properties视图指定每个任务结点的负责人，如：填写出差申请的负责人为 zhangsan</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575121491752.png" alt="1575121491752"></p>
<p>经理审批负责人为 jerry</p>
<p>总经理审批负责人为 jack</p>
<p>财务审批负责人为 rose</p>
<h1 id="六、流程操作"><a href="#六、流程操作" class="headerlink" title="六、流程操作"></a>六、流程操作</h1><h2 id="6-1-流程定义"><a href="#6-1-流程定义" class="headerlink" title="6.1 流程定义"></a>6.1 流程定义</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>流程定义是线下按照bpmn2.0标准去描述 业务流程，通常使用idea中的插件对业务流程进行建模。</p>
<p>使用idea下的designer设计器绘制流程，并会生成两个文件：.bpmn和.png</p>
<h3 id="bpmn文件"><a href="#bpmn文件" class="headerlink" title=".bpmn文件"></a>.bpmn文件</h3><p>使用activiti-desinger设计业务流程，会生成.bpmn文件，上面我们已经创建好了bpmn文件</p>
<p>BPMN 2.0根节点是definitions节点。 这个元素中，可以定义多个流程定义（不过我们建议每个文件只包含一个流程定义， 可以简化开发过程中的维护难度）。 注意，definitions元素 最少也要包含xmlns 和 targetNamespace的声明。 targetNamespace可以是任意值，它用来对流程实例进行分类。</p>
<p>流程定义部分：定义了流程每个结点的描述及结点之间的流程流转。</p>
<p>流程布局定义：定义流程每个结点在流程图上的位置坐标等信息。</p>
<h3 id="生成-png图片文件"><a href="#生成-png图片文件" class="headerlink" title="生成.png图片文件"></a>生成.png图片文件</h3><p>IDEA工具中的操作方式</p>
<h4 id="1、修改文件后缀为xml"><a href="#1、修改文件后缀为xml" class="headerlink" title="1、修改文件后缀为xml"></a>1、修改文件后缀为xml</h4><p>首先将evection.bpmn文件改名为evection.xml，如下图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575108966935.png" alt="1575108966935"></p>
<p>evection.xml修改前的bpmn文件，效果如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575107648105-1618661266829.png" alt="1575107648105"></p>
<h4 id="2、使用designer设计器打开-xml文件"><a href="#2、使用designer设计器打开-xml文件" class="headerlink" title="2、使用designer设计器打开.xml文件"></a>2、使用designer设计器打开.xml文件</h4><p>在evection.xml文件上面，点右键并选择Diagrams菜单，再选择Show BPMN2.0 Designer…</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575109268443.png" alt="1575109268443"></p>
<h4 id="3、查看打开的文件"><a href="#3、查看打开的文件" class="headerlink" title="3、查看打开的文件"></a>3、查看打开的文件</h4><p>打开后，却出现乱码，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575109366989.png" alt="1575109366989"></p>
<h4 id="4、解决中文乱码"><a href="#4、解决中文乱码" class="headerlink" title="4、解决中文乱码"></a>4、解决中文乱码</h4><p>1、打开Settings，找到File Encodings，把encoding的选项都选择UTF-8</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575112075626.png" alt="1575112075626"></p>
<p>2、打开IDEA安装路径，找到如下的安装目录</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575109627745.png" alt="1575109627745"></p>
<p>根据自己所安装的版本来决定，我使用的是64位的idea，所以在idea64.exe.vmoptions文件的最后一行追加一条命令： -Dfile.encoding=UTF-8 </p>
<p>如下所示：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/clip_image002-1618663095939.png" alt="https://images2017.cnblogs.com/blog/963440/201712/963440-20171221132445475-1259807908.png"></p>
<p>一定注意，不要有空格，否则重启IDEA时会打不开，然后 重启IDEA。</p>
<p>如果以上方法已经做完，还出现乱码，就再修改一个文件，并在文件的末尾添加： -Dfile.encoding=UTF-8，然后重启idea，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575113551947.png" alt="1575113551947"></p>
<p>最后重新在evection.xml文件上面，点右键并选择Diagrams菜单，再选择Show BPMN2.0 Designer…，看到生成图片，如图：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575113951966.png" alt="1575113951966"></p>
<p>到此，解决乱码问题</p>
<h4 id="5、导出为图片文件"><a href="#5、导出为图片文件" class="headerlink" title="5、导出为图片文件"></a>5、导出为图片文件</h4><p>点击Export To File的小图标，打开如下窗口，注意填写文件名及扩展名，选择好保存图片的位置：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575114245068.png" alt="1575114245068"></p>
<p>然后，我们把png文件拷贝到resources下的bpmn目录，并且把evection.xml改名为evection.bpmn。</p>
<h2 id="6-2-流程定义部署"><a href="#6-2-流程定义部署" class="headerlink" title="6.2 流程定义部署"></a>6.2 流程定义部署</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>将上面在设计器中定义的流程部署到activiti数据库中，就是流程定义部署。</p>
<p>通过调用activiti的api将流程定义的bpmn和png两个文件一个一个添加部署到activiti中，也可以将两个文件打成zip包进行部署。</p>
<h3 id="单个文件部署方式"><a href="#单个文件部署方式" class="headerlink" title="单个文件部署方式"></a>单个文件部署方式</h3><p>分别将bpmn文件和png图片文件部署。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.test;<br><br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngine;<br><span class="hljs-keyword">import</span> org.activiti.engine.ProcessEngines;<br><span class="hljs-keyword">import</span> org.activiti.engine.RepositoryService;<br><span class="hljs-keyword">import</span> org.activiti.engine.repository.Deployment;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ActivitiDemo</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 部署流程定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDeployment</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、创建ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、得到RepositoryService实例</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        3、使用RepositoryService进行部署</span><br>        Deployment deployment = repositoryService.createDeployment()<br>                .addClasspathResource(<span class="hljs-string">&quot;bpmn/evection.bpmn&quot;</span>) <span class="hljs-comment">// 添加bpmn资源</span><br>                .addClasspathResource(<span class="hljs-string">&quot;bpmn/evection.png&quot;</span>)  <span class="hljs-comment">// 添加png资源</span><br>                .name(<span class="hljs-string">&quot;出差申请流程&quot;</span>)<br>                .deploy();<br><span class="hljs-comment">//        4、输出部署信息</span><br>        System.out.println(<span class="hljs-string">&quot;流程部署id：&quot;</span> + deployment.getId());<br>        System.out.println(<span class="hljs-string">&quot;流程部署名称：&quot;</span> + deployment.getName());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。</p>
<h3 id="压缩包部署方式"><a href="#压缩包部署方式" class="headerlink" title="压缩包部署方式"></a>压缩包部署方式</h3><p>将evection.bpmn和evection.png压缩成zip包。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deployProcessByZip</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 定义zip输入流</span><br>		InputStream inputStream = <span class="hljs-keyword">this</span><br>				.getClass()<br>				.getClassLoader()<br>				.getResourceAsStream(<br>						<span class="hljs-string">&quot;bpmn/evection.zip&quot;</span>);<br>		ZipInputStream zipInputStream = <span class="hljs-keyword">new</span> ZipInputStream(inputStream);<br>		<span class="hljs-comment">// 获取repositoryService</span><br>		RepositoryService repositoryService = processEngine<br>				.getRepositoryService();<br>		<span class="hljs-comment">// 流程部署</span><br>		Deployment deployment = repositoryService.createDeployment()<br>				.addZipInputStream(zipInputStream)<br>				.deploy();<br>		System.out.println(<span class="hljs-string">&quot;流程部署id：&quot;</span> + deployment.getId());<br>		System.out.println(<span class="hljs-string">&quot;流程部署名称：&quot;</span> + deployment.getName());<br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>执行此操作后activiti会将上边代码中指定的bpm文件和图片文件保存在activiti数据库。</p>
<h3 id="操作数据表"><a href="#操作数据表" class="headerlink" title="操作数据表"></a>操作数据表</h3><p>流程定义部署后操作activiti的3张表如下：</p>
<p>act_re_deployment     流程定义部署表，每部署一次增加一条记录</p>
<p>act_re_procdef            流程定义表，部署每个新的流程定义都会在这张表中增加一条记录</p>
<p>act_ge_bytearray        流程资源表 </p>
<p>接下来我们来看看，写入了什么数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_re_deployment #流程定义部署表，记录流程部署信息<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575116732147.png" alt="1575116732147"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_re_procdef #流程定义表，记录流程定义信息<br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p>注意，KEY 这个字段是用来唯一识别不同流程的关键字</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575116797665.png" alt="1575116797665"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ge_bytearray #资源表 <br></code></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575116832196.png" alt="1575116832196"></p>
<p> 注意：</p>
<p>act_re_deployment和act_re_procdef一对多关系，一次部署在流程部署表生成一条记录，但一次部署可以部署多个流程定义，每个流程定义在流程定义表生成一条记录。每一个流程定义在act_ge_bytearray会存在两个资源记录，bpmn和png。</p>
<p>建议：一次部署一个流程，这样部署表和流程定义表是一对一有关系，方便读取流程部署及流程定义信息。</p>
<h2 id="6-3-启动流程实例"><a href="#6-3-启动流程实例" class="headerlink" title="6.3 启动流程实例"></a>6.3 启动流程实例</h2><p>流程定义部署在activiti后就可以通过工作流管理业务流程了，也就是说上边部署的出差申请流程可以使用了。</p>
<p>针对该流程，启动一个流程表示发起一个新的出差申请单，这就相当于java类与java对象的关系，类定义好后需要new创建一个对象使用，当然可以new多个对象。对于请出差申请流程，张三发起一个出差申请单需要启动一个流程实例，出差申请单发起一个出差单也需要启动一个流程实例。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testStartProcess</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、创建ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、获取RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        3、根据流程定义Id启动流程</span><br>        ProcessInstance processInstance = runtimeService<br>                .startProcessInstanceByKey(<span class="hljs-string">&quot;myEvection&quot;</span>);<br><span class="hljs-comment">//        输出内容</span><br>        System.out.println(<span class="hljs-string">&quot;流程定义id：&quot;</span> + processInstance.getProcessDefinitionId());<br>        System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + processInstance.getId());<br>        System.out.println(<span class="hljs-string">&quot;当前活动Id：&quot;</span> + processInstance.getActivityId());<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>输出内容如下：</p>
<p><img src="/images/Activiti%E5%9F%BA%E7%A1%80/1575117588624.png" alt="1575117588624"></p>
<p><strong>操作数据表</strong></p>
<p>act_hi_actinst     流程实例执行历史</p>
<p>act_hi_identitylink  流程的参与用户历史信息</p>
<p>act_hi_procinst      流程实例历史信息</p>
<p>act_hi_taskinst       流程任务历史信息</p>
<p>act_ru_execution   流程执行信息</p>
<p>act_ru_identitylink  流程的参与用户信息</p>
<p>act_ru_task              任务信息</p>
<h2 id="6-4-任务查询"><a href="#6-4-任务查询" class="headerlink" title="6.4 任务查询"></a>6.4 任务查询</h2><p>流程启动后，任务的负责人就可以查询自己当前需要处理的任务，查询出来的任务都是该用户的待办任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询当前个人待执行的任务</span><br><span class="hljs-comment">      */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testFindPersonalTaskList</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">//        任务负责人</span><br>        String assignee = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        根据流程key 和 任务负责人 查询任务</span><br>        List&lt;Task&gt; list = taskService.createTaskQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>) <span class="hljs-comment">//流程Key</span><br>                .taskAssignee(assignee)<span class="hljs-comment">//只查询该任务负责人的任务</span><br>                .list();<br><br>        <span class="hljs-keyword">for</span> (Task task : list) &#123;<br><br>            System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + task.getProcessInstanceId());<br>            System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + task.getId());<br>            System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>            System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript">流程实例<span class="hljs-built_in">id</span>：<span class="hljs-number">2501</span><br>任务<span class="hljs-built_in">id</span>：<span class="hljs-number">2505</span><br>任务负责人：zhangsan<br>任务名称：创建出差申请<br></code></pre></td></tr></table></figure>

<h2 id="6-5-流程任务处理"><a href="#6-5-流程任务处理" class="headerlink" title="6.5 流程任务处理"></a>6.5 流程任务处理</h2><p>任务负责人查询待办任务，选择任务进行处理，完成任务。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 完成任务</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取taskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><br><span class="hljs-comment">//        根据流程key 和 任务的负责人 查询任务</span><br><span class="hljs-comment">//        返回一个任务对象</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>) <span class="hljs-comment">//流程Key</span><br>                .taskAssignee(<span class="hljs-string">&quot;zhangsan&quot;</span>)  <span class="hljs-comment">//要查询的负责人</span><br>                .singleResult();<br><br><span class="hljs-comment">//        完成任务,参数：任务id</span><br>        taskService.complete(task.getId());<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<h2 id="6-6-流程定义信息查询"><a href="#6-6-流程定义信息查询" class="headerlink" title="6.6 流程定义信息查询"></a>6.6 流程定义信息查询</h2><p>查询流程相关信息，包含流程定义，流程部署，流程定义版本</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查询流程定义</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProcessDefinition</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        得到ProcessDefinitionQuery 对象</span><br>        ProcessDefinitionQuery processDefinitionQuery = repositoryService.createProcessDefinitionQuery();<br><span class="hljs-comment">//          查询出当前所有的流程定义</span><br><span class="hljs-comment">//          条件：processDefinitionKey =evection</span><br><span class="hljs-comment">//          orderByProcessDefinitionVersion 按照版本排序</span><br><span class="hljs-comment">//        desc倒叙</span><br><span class="hljs-comment">//        list 返回集合</span><br>        List&lt;ProcessDefinition&gt; definitionList = processDefinitionQuery.processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>)<br>                .orderByProcessDefinitionVersion()<br>                .desc()<br>                .list();<br><span class="hljs-comment">//      输出流程定义信息</span><br>        <span class="hljs-keyword">for</span> (ProcessDefinition processDefinition : definitionList) &#123;<br>            System.out.println(<span class="hljs-string">&quot;流程定义 id=&quot;</span>+processDefinition.getId());<br>            System.out.println(<span class="hljs-string">&quot;流程定义 name=&quot;</span>+processDefinition.getName());<br>            System.out.println(<span class="hljs-string">&quot;流程定义 key=&quot;</span>+processDefinition.getKey());<br>            System.out.println(<span class="hljs-string">&quot;流程定义 Version=&quot;</span>+processDefinition.getVersion());<br>            System.out.println(<span class="hljs-string">&quot;流程部署ID =&quot;</span>+processDefinition.getDeploymentId());<br>        &#125;<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery">流程定<span class="hljs-built_in">义id</span>：myEvection:<span class="hljs-number">1</span>:<span class="hljs-number">4</span><br>流程定义名称：出差申请单<br>流程定<span class="hljs-built_in">义key</span>：myEvection<br>流程定义版本：<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>



<h2 id="6-7-流程删除"><a href="#6-7-流程删除" class="headerlink" title="6.7 流程删除"></a>6.7 流程删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDeployment</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 流程部署id</span><br>		String deploymentId = <span class="hljs-string">&quot;1&quot;</span>;<br>		<br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 通过流程引擎获取repositoryService</span><br>		RepositoryService repositoryService = processEngine<br>				.getRepositoryService();<br>		<span class="hljs-comment">//删除流程定义，如果该流程定义已有流程实例启动则删除时出错</span><br>		repositoryService.deleteDeployment(deploymentId);<br>		<span class="hljs-comment">//设置true 级联删除流程定义，即使该流程有流程实例启动也可以删除，设置为false非级别删除方式，如果流程</span><br>		<span class="hljs-comment">//repositoryService.deleteDeployment(deploymentId, true);</span><br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><pre><code>  使用repositoryService删除流程定义，历史表信息不会被删除
</code></pre>
</li>
<li><pre><code>  如果该流程定义下没有正在运行的流程，则可以用普通删除。
</code></pre>
</li>
</ol>
<p>如果该流程定义下存在已经运行的流程，使用普通删除报错，可用级联删除方法将流程及相关记录全部删除。</p>
<p>先删除没有完成流程节点，最后就可以完全删除流程定义信息</p>
<p>项目开发中级联删除操作一般只开放给超级管理员使用.</p>
<h2 id="6-8-流程资源下载"><a href="#6-8-流程资源下载" class="headerlink" title="6.8 流程资源下载"></a>6.8 流程资源下载</h2><p>现在我们的流程资源文件已经上传到数据库了，如果其他用户想要查看这些资源文件，可以从数据库中把资源文件下载到本地。</p>
<p>解决方案有：</p>
<p>1、jdbc对blob类型，clob类型数据读取出来，保存到文件目录</p>
<p>2、使用activiti的api来实现</p>
<p>使用commons-io.jar 解决IO的操作</p>
<p>引入commons-io依赖包</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-io<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure>



<p>通过流程定义对象获取流程定义资源，获取bpmn和png</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.io.IOUtils;<br><br><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteDeployment</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        根据部署id 删除部署信息,如果想要级联删除，可以添加第二个参数，true</span><br>        repositoryService.deleteDeployment(<span class="hljs-string">&quot;1&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title">queryBpmnFile</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br><span class="hljs-comment">//        1、得到引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        3、得到查询器：ProcessDefinitionQuery，设置查询条件,得到想要的流程定义</span><br>        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>)<br>                .singleResult();<br><span class="hljs-comment">//        4、通过流程定义信息，得到部署ID</span><br>        String deploymentId = processDefinition.getDeploymentId();<br><span class="hljs-comment">//        5、通过repositoryService的方法，实现读取图片信息和bpmn信息</span><br><span class="hljs-comment">//        png图片的流</span><br>        InputStream pngInput = repositoryService.getResourceAsStream(deploymentId, processDefinition.getDiagramResourceName());<br><span class="hljs-comment">//        bpmn文件的流</span><br>        InputStream bpmnInput = repositoryService.getResourceAsStream(deploymentId, processDefinition.getResourceName());<br><span class="hljs-comment">//        6、构造OutputStream流</span><br>        File file_png = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/evectionflow01.png&quot;</span>);<br>        File file_bpmn = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;d:/evectionflow01.bpmn&quot;</span>);<br>        FileOutputStream bpmnOut = <span class="hljs-keyword">new</span> FileOutputStream(file_bpmn);<br>        FileOutputStream pngOut = <span class="hljs-keyword">new</span> FileOutputStream(file_png);<br><span class="hljs-comment">//        7、输入流，输出流的转换</span><br>        IOUtils.copy(pngInput,pngOut);<br>        IOUtils.copy(bpmnInput,bpmnOut);<br><span class="hljs-comment">//        8、关闭流</span><br>        pngOut.close();<br>        bpmnOut.close();<br>        pngInput.close();<br>        bpmnInput.close();<br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>说明：</p>
<ol>
<li><pre><code>  deploymentId为流程部署ID
</code></pre>
</li>
<li><pre><code>  resource_name为act_ge_bytearray表中NAME_列的值
</code></pre>
</li>
<li><pre><code>  使用repositoryService的getDeploymentResourceNames方法可以获取指定部署下得所有文件的名称
</code></pre>
</li>
<li><pre><code>  使用repositoryService的getResourceAsStream方法传入部署ID和资源图片名称可以获取部署下指定名称文件的输入流
</code></pre>
</li>
</ol>
<p>最后的将输入流中的图片资源进行输出。</p>
<h2 id="6-9-流程历史信息的查看"><a href="#6-9-流程历史信息的查看" class="headerlink" title="6.9 流程历史信息的查看"></a>6.9 流程历史信息的查看</h2><p>即使流程定义已经删除了，流程执行的历史信息通过前面的分析，依然保存在activiti的act_hi_*相关的表中。所以我们还是可以查询流程执行的历史信息，可以通过HistoryService来查看相关的历史记录。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 查看历史信息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findHistoryInfo</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//      获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取HistoryService</span><br>        HistoryService historyService = processEngine.getHistoryService();<br><span class="hljs-comment">//        获取 actinst表的查询对象</span><br>        HistoricActivityInstanceQuery instanceQuery = historyService.createHistoricActivityInstanceQuery();<br><span class="hljs-comment">//        查询 actinst表，条件：根据 InstanceId 查询</span><br><span class="hljs-comment">//        instanceQuery.processInstanceId(&quot;2501&quot;);</span><br><span class="hljs-comment">//        查询 actinst表，条件：根据 DefinitionId 查询</span><br>        instanceQuery.processDefinitionId(<span class="hljs-string">&quot;myEvection:1:4&quot;</span>);<br><span class="hljs-comment">//        增加排序操作,orderByHistoricActivityInstanceStartTime 根据开始时间排序 asc 升序</span><br>        instanceQuery.orderByHistoricActivityInstanceStartTime().asc();<br><span class="hljs-comment">//        查询所有内容</span><br>        List&lt;HistoricActivityInstance&gt; activityInstanceList = instanceQuery.list();<br><span class="hljs-comment">//        输出</span><br>        <span class="hljs-keyword">for</span> (HistoricActivityInstance hi : activityInstanceList) &#123;<br>            System.out.println(hi.getActivityId());<br>            System.out.println(hi.getActivityName());<br>            System.out.println(hi.getProcessDefinitionId());<br>            System.out.println(hi.getProcessInstanceId());<br>            System.out.println(<span class="hljs-string">&quot;&lt;==========================&gt;&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>activiti基础</tag>
      </tags>
  </entry>
  <entry>
    <title>activiti进阶</title>
    <url>/2021/04/17/Activiti%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h1 id="Activiti进阶"><a href="#Activiti进阶" class="headerlink" title="Activiti进阶"></a>Activiti进阶</h1><h2 id="一、流程实例"><a href="#一、流程实例" class="headerlink" title="一、流程实例"></a>一、流程实例</h2><h3 id="什么是流程实例"><a href="#什么是流程实例" class="headerlink" title="什么是流程实例"></a>什么是流程实例</h3><p><strong>流程实例</strong>（ProcessInstance）代表流程定义的执行实例。</p>
<p>一个流程实例包括了所有的运行节点。我们可以利用这个对象来了解当前流程实例的进度等信息。</p>
<p>例如：用户或程序按照流程定义内容发起一个流程，这就是一个流程实例。</p>
<p>流程定义和流程实例的图解：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577498489089.png" alt="1577498489089"></p>
<h3 id="启动流程实例-并添加Businesskey（业务标识）"><a href="#启动流程实例-并添加Businesskey（业务标识）" class="headerlink" title="启动流程实例 并添加Businesskey（业务标识）"></a>启动流程实例 并添加Businesskey（业务标识）</h3><p>流程定义部署在activiti后，就可以在系统中通过activiti去管理该流程的执行，执行流程表示流程的一次执行。</p>
<p>比如部署系统出差流程后，如果某用户要申请出差这时就需要执行这个流程，如果另外一个用户也要申请出差则也需要执行该流程，每个执行互不影响，每个执行是单独的流程实例。</p>
<p>启动流程实例时，指定的businesskey，就会在act_ru_execution #流程实例的执行表中存储businesskey。</p>
<p>Businesskey：业务标识，通常为业务表的主键，业务标识和流程实例一一对应。业务标识来源于业务系统。存储业务标识就是根据业务标识来关联查询业务系统的数据。</p>
<p>比如：出差流程启动一个流程实例，就可以将出差单的id作为业务标识存储到activiti中，将来查询activiti的流程实例信息就可以获取出差单的id从而关联查询业务系统数据库得到出差单信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例，添加businessKey</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addBusinessKey</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        1、得到ProcessEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        2、得到RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        3、启动流程实例，同时还要指定业务标识businessKey，也就是出差申请单id，这里是1001</span><br>        ProcessInstance processInstance = runtimeService.<br>                startProcessInstanceByKey(<span class="hljs-string">&quot;myEvection&quot;</span>,<span class="hljs-string">&quot;1001&quot;</span>);<br><span class="hljs-comment">//        4、输出processInstance相关属性</span><br>        System.out.println(<span class="hljs-string">&quot;业务id==&quot;</span>+processInstance.getBusinessKey());<br><br>    &#125;<br></code></pre></td></tr></table></figure>

<p>Activiti的act_ru_execution中存储业务标识：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577261568103.png" alt="1577261568103"></p>
<h3 id="操作数据库表"><a href="#操作数据库表" class="headerlink" title="操作数据库表"></a>操作数据库表</h3><p>启动流程实例，操作如下数据库表：</p>
<p>SELECT * FROM act_ru_execution #流程实例执行表，记录当前流程实例的执行情况</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499812252.png" alt="1577499812252"></p>
<p>说明：</p>
<p>流程实例执行，如果当前只有一个分支时，一个流程实例只有一条记录且执行表的主键id和流程实例id相同，如果当前有多个分支正在运行则该执行表中有多条记录，存在执行表的主键和流程实例id不相同的记录。<strong>不论当前有几个分支总会有一条记录的执行表的主键和流程实例</strong>id<strong>相同</strong> </p>
<p>一个流程实例运行完成，此表中与流程实例相关的记录删除。</p>
<p>SELECT * FROM act_ru_task #任务执行表，记录当前执行的任务</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499771599.png" alt="1577499771599"></p>
<p>说明：启动流程实例，流程当前执行到第一个任务结点，此表会插入一条记录表示当前任务的执行情况，如果任务完成则记录删除。</p>
<p>SELECT * FROM act_ru_identitylink #任务参与者，记录当前参与任务的用户或组</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499842115.png" alt="1577499842115"></p>
<p>SELECT * FROM act_hi_procinst #流程实例历史表</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499914186.png" alt="1577499914186"></p>
<p>流程实例启动，会在此表插入一条记录，流程实例运行完成记录也不会删除。</p>
<p> SELECT * FROM act_hi_taskinst  #任务历史表，记录所有任务</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577499985580.png" alt="1577499985580"></p>
<p>开始一个任务，不仅在act_ru_task表插入记录，也会在历史任务表插入一条记录，任务历史表的主键就是任务id，任务完成此表记录不删除。</p>
<p> SELECT * FROM act_hi_actinst  #活动历史表，记录所有活动</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577500036347.png" alt="1577500036347"></p>
<p>活动包括任务，所以此表中不仅记录了任务，还记录了流程执行过程的其它活动，比如开始事件、结束事件。</p>
<h3 id="查询流程实例"><a href="#查询流程实例" class="headerlink" title="查询流程实例"></a>查询流程实例</h3><p>流程在运行过程中可以查询流程实例的状态，当前运行结点等信息。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">queryProcessInstance</span><span class="hljs-params">()</span> </span>&#123;<br>		<span class="hljs-comment">// 流程定义key</span><br>		String processDefinitionKey = <span class="hljs-string">&quot;evection&quot;</span>;<br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>		<span class="hljs-comment">// 获取RunTimeService</span><br>		RuntimeService runtimeService = processEngine.getRuntimeService();<br>		List&lt;ProcessInstance&gt; list = runtimeService<br>				.createProcessInstanceQuery()<br>				.processDefinitionKey(processDefinitionKey)<span class="hljs-comment">//</span><br>				.list();<br><br>		<span class="hljs-keyword">for</span> (ProcessInstance processInstance : list) &#123;<br>			System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>			System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span><br>					+ processInstance.getProcessInstanceId());<br>			System.out.println(<span class="hljs-string">&quot;所属流程定义id：&quot;</span><br>					+ processInstance.getProcessDefinitionId());<br>			System.out.println(<span class="hljs-string">&quot;是否执行完成：&quot;</span> + processInstance.isEnded());<br>			System.out.println(<span class="hljs-string">&quot;是否暂停：&quot;</span> + processInstance.isSuspended());<br>			System.out.println(<span class="hljs-string">&quot;当前活动标识：&quot;</span> + processInstance.getActivityId());<br>		&#125;<br>	&#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="关联BusinessKey"><a href="#关联BusinessKey" class="headerlink" title="关联BusinessKey"></a>关联BusinessKey</h4><p>需求：</p>
<p>在activiti实际应用时，查询流程实例列表时可能要显示出业务系统的一些相关信息，比如：查询当前运行的出差流程列表需要将出差单名称、出差天数等信息显示出来，出差天数等信息在业务系统中存在，而并没有在activiti数据库中存在，所以是无法通过activiti的api查询到出差天数等信息。</p>
<p>实现：</p>
<p>在查询流程实例时，通过businessKey（业务标识 ）关联查询业务系统的出差单表，查询出出差天数等信息。</p>
<p>通过下面的代码就可以获取activiti中所对应实例保存的业务Key。而这个业务Key一般都会保存相关联的业务操作表的主键，再通过主键ID去查询业务信息，比如通过出差单的ID，去查询更多的请假信息（出差人，出差时间，出差天数，出差目的地等）</p>
<p>String businessKey = processInstance.getBusinessKey();</p>
<p>在activiti的act_ru_execution表，字段BUSINESS_KEY就是存放业务KEY的。</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1574136375409.png" alt="1574136375409"></p>
<h3 id="挂起、激活流程实例"><a href="#挂起、激活流程实例" class="headerlink" title="挂起、激活流程实例"></a>挂起、激活流程实例</h3><p>某些情况可能由于流程变更需要将当前运行的流程暂停而不是直接删除，流程暂停后将不会继续执行。</p>
<h4 id="全部流程实例挂起"><a href="#全部流程实例挂起" class="headerlink" title="全部流程实例挂起"></a>全部流程实例挂起</h4><p>操作流程定义为挂起状态，该流程定义下边所有的流程实例全部暂停：</p>
<p>流程定义为挂起状态该流程定义将不允许启动新的流程实例，同时该流程定义下所有的流程实例将全部挂起暂停执行。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 全部流程实例挂起与激活</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SuspendAllProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取repositoryService</span><br>        RepositoryService repositoryService = processEngine.getRepositoryService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery().<br>                processDefinitionKey(<span class="hljs-string">&quot;myEvection&quot;</span>).<br>                singleResult();<br><span class="hljs-comment">//        得到当前流程定义的实例是否都为暂停状态</span><br>        <span class="hljs-keyword">boolean</span> suspended = processDefinition.isSuspended();<br><span class="hljs-comment">//        流程定义id</span><br>        String processDefinitionId = processDefinition.getId();<br><span class="hljs-comment">//        判断是否为暂停</span><br>        <span class="hljs-keyword">if</span>(suspended)&#123;<br><span class="hljs-comment">//         如果是暂停，可以执行激活操作 ,参数1 ：流程定义id ，参数2：是否激活，参数3：激活时间</span><br>            repositoryService.activateProcessDefinitionById(processDefinitionId,<br>                    <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-keyword">null</span><br>            );<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已激活&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//          如果是激活状态，可以暂停，参数1 ：流程定义id ，参数2：是否暂停，参数3：暂停时间</span><br>            repositoryService.suspendProcessDefinitionById(processDefinitionId,<br>                    <span class="hljs-keyword">true</span>,<br>                    <span class="hljs-keyword">null</span>);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已挂起&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br></code></pre></td></tr></table></figure>



<h4 id="单个流程实例挂起"><a href="#单个流程实例挂起" class="headerlink" title="单个流程实例挂起"></a>单个流程实例挂起</h4><p><strong>操作流程实例对象，针对单个流程执行挂起操作，某个流程实例挂起则此流程不再继续执行，完成该流程实例的当前任务将报异常。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单个流程实例挂起与激活</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">SuspendSingleProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        ProcessInstance processInstance = runtimeService.<br>                createProcessInstanceQuery().<br>                processInstanceId(<span class="hljs-string">&quot;15001&quot;</span>).<br>                singleResult();<br><span class="hljs-comment">//        得到当前流程定义的实例是否都为暂停状态</span><br>        <span class="hljs-keyword">boolean</span> suspended = processInstance.isSuspended();<br><span class="hljs-comment">//        流程定义id</span><br>        String processDefinitionId = processInstance.getId();<br><span class="hljs-comment">//        判断是否为暂停</span><br>        <span class="hljs-keyword">if</span>(suspended)&#123;<br><span class="hljs-comment">//         如果是暂停，可以执行激活操作 ,参数：流程定义id</span><br>            runtimeService.activateProcessInstanceById(processDefinitionId);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已激活&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br><span class="hljs-comment">//          如果是激活状态，可以暂停，参数：流程定义id</span><br>            runtimeService.suspendProcessInstanceById( processDefinitionId);<br>            System.out.println(<span class="hljs-string">&quot;流程定义：&quot;</span>+processDefinitionId+<span class="hljs-string">&quot;,已挂起&quot;</span>);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 测试完成个人任务</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取操作任务的服务 TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        完成任务,参数：流程实例id,完成zhangsan的任务</span><br>        Task task = taskService.createTaskQuery()<br>                .processInstanceId(<span class="hljs-string">&quot;15001&quot;</span>)<br>                .taskAssignee(<span class="hljs-string">&quot;rose&quot;</span>)<br>                .singleResult();<br><br><br>        System.out.println(<span class="hljs-string">&quot;流程实例id=&quot;</span>+task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务Id=&quot;</span>+task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人=&quot;</span>+task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称=&quot;</span>+task.getName());<br>        taskService.complete(task.getId());<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="二、个人任务"><a href="#二、个人任务" class="headerlink" title="二、个人任务"></a>二、个人任务</h2><h3 id="2-1、分配任务负责人"><a href="#2-1、分配任务负责人" class="headerlink" title="2.1、分配任务负责人"></a>2.1、分配任务负责人</h3><h4 id="2-1-1、固定分配"><a href="#2-1-1、固定分配" class="headerlink" title="2.1.1、固定分配"></a>2.1.1、固定分配</h4><p>在进行业务流程建模时指定固定的任务负责人， 如图：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1575121491752.png" alt="1575121491752"></p>
<p>并在 properties 视图中，填写 Assignee 项为任务负责人。 </p>
<h4 id="2-1-2、表达式分配"><a href="#2-1-2、表达式分配" class="headerlink" title="2.1.2、表达式分配"></a>2.1.2、表达式分配</h4><p>由于固定分配方式，任务只管一步一步执行任务，执行到每一个任务将按照 bpmn 的配置去分配任<br>务负责人。 </p>
<h5 id="2-1-2-1、UEL-表达式"><a href="#2-1-2-1、UEL-表达式" class="headerlink" title="2.1.2.1、UEL 表达式"></a>2.1.2.1、UEL 表达式</h5><p>Activiti 使用 UEL 表达式， UEL 是 java EE6 规范的一部分， UEL（Unified Expression Language）即 统一表达式语言， activiti 支持两个 UEL 表达式： UEL-value 和 UEL-method。 </p>
<h6 id="1）UEL-value-定义"><a href="#1）UEL-value-定义" class="headerlink" title="1）UEL-value 定义"></a>1）UEL-value 定义</h6><p>如图： </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577503716131.png" alt="1577503716131"></p>
<p>assignee 这个变量是 activiti 的一个流程变量，</p>
<p>或者使用这种方式定义：</p>
<p>如图：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577503804336.png" alt="1577503804336"></p>
<p> user 也是 activiti 的一个流程变量， user.assignee 表示通过调用 user 的 getter 方法获取值。 </p>
<h6 id="2）UEL-method-方式"><a href="#2）UEL-method-方式" class="headerlink" title="2）UEL-method 方式"></a>2）UEL-method 方式</h6><p>如图： </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1585972081.png"></p>
<p>userBean 是 spring 容器中的一个 bean，表示调用该 bean 的 getUserId()方法。 </p>
<h6 id="3）UEL-method-与-UEL-value-结合"><a href="#3）UEL-method-与-UEL-value-结合" class="headerlink" title="3）UEL-method 与 UEL-value 结合"></a>3）UEL-method 与 UEL-value 结合</h6><p>再比如：<br>${ldapService.findManagerForEmployee(emp)}<br>ldapService 是 spring 容器的一个 bean，findManagerForEmployee 是该 bean 的一个方法，emp 是 activiti<br>流程变量， emp 作为参数传到 ldapService.findManagerForEmployee 方法中。 </p>
<h6 id="4）其它"><a href="#4）其它" class="headerlink" title="4）其它"></a>4）其它</h6><p>表达式支持解析基础类型、 bean、 list、 array 和 map，也可作为条件判断。<br>如下：<br>${order.price &gt; 100 &amp;&amp; order.price &lt; 250} </p>
<h5 id="2-1-2-2、编写代码配置负责人"><a href="#2-1-2-2、编写代码配置负责人" class="headerlink" title="2.1.2.2、编写代码配置负责人"></a>2.1.2.2、编写代码配置负责人</h5><h6 id="1-定义任务分配流程变量"><a href="#1-定义任务分配流程变量" class="headerlink" title="1)定义任务分配流程变量"></a>1)定义任务分配流程变量</h6><p>如图：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577503716131-1618662529258.png" alt="1577503716131"></p>
<h6 id="2-设置流程变量"><a href="#2-设置流程变量" class="headerlink" title="2)设置流程变量"></a>2)设置流程变量</h6><p>在启动流程实例时设置流程变量，如下： </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 设置流程负责人</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">assigneeUEL</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//      获取流程引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取 RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        设置assignee的取值，用户可以在界面上设置流程的执行</span><br>        Map&lt;String,Object&gt; assigneeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee0&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee1&quot;</span>,<span class="hljs-string">&quot;李经理&quot;</span>);<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee2&quot;</span>,<span class="hljs-string">&quot;王总经理&quot;</span>);<br>        assigneeMap.put(<span class="hljs-string">&quot;assignee3&quot;</span>,<span class="hljs-string">&quot;赵财务&quot;</span>);<br><span class="hljs-comment">//        启动流程实例，同时还要设置流程定义的assignee的值</span><br>        runtimeService.startProcessInstanceByKey(<span class="hljs-string">&quot;myEvection1&quot;</span>,assigneeMap);<br><span class="hljs-comment">//       输出</span><br>        System.out.println(processEngine.getName());<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>执行成功后，可以在act_ru_variable表中看到刚才map中的数据</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1585562066-1585562152652.png"></p>
<h5 id="2-1-2-3、注意事项"><a href="#2-1-2-3、注意事项" class="headerlink" title="2.1.2.3、注意事项"></a>2.1.2.3、注意事项</h5><p>由于使用了表达式分配，必须保证在任务执行过程表达式执行成功，比如：<br>某个任务使用了表达式${order.price &gt; 100 &amp;&amp; order.price &lt; 250}，当执行该任务时必须保证 order 在<br>流程变量中存在，否则 activiti 异常。 </p>
<h4 id="2-1-3、监听器分配"><a href="#2-1-3、监听器分配" class="headerlink" title="2.1.3、监听器分配"></a>2.1.3、监听器分配</h4><p>可以使用监听器来完成很多Activiti流程的业务。</p>
<p>在本章我们使用监听器的方式来指定负责人，那么在流程设计时就不需要指定assignee。</p>
<p>任务监听器是发生对应的任务相关事件时执行自定义 java 逻辑 或表达式。<br>任务相当事件包括：  </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577506842889.png" alt="1577506842889"></p>
<p><strong>Event的选项包含</strong>：</p>
<figure class="highlight n1ql"><table><tr><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">Create</span>：任务创建后触发<br>Assignment：任务分配后触发<br><span class="hljs-keyword">Delete</span>：任务完成后触发<br><span class="hljs-keyword">All</span>：所有事件发生都触发<br></code></pre></td></tr></table></figure>

<p>定义任务监听类，且类必须实现 org.activiti.engine.delegate.TaskListener 接口 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyTaskListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">TaskListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(DelegateTask delegateTask)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(delegateTask.getName().equals(<span class="hljs-string">&quot;创建出差申请&quot;</span>)&amp;&amp;<br>                delegateTask.getEventName().equals(<span class="hljs-string">&quot;create&quot;</span>))&#123;<br>            <span class="hljs-comment">//这里指定任务负责人</span><br>            delegateTask.setAssignee(<span class="hljs-string">&quot;张三&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure>

<p>DelegateTask对象的内容如下：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1585561653.png"></p>
<h5 id="2-1-3-1、注意事项"><a href="#2-1-3-1、注意事项" class="headerlink" title="2.1.3.1、注意事项"></a>2.1.3.1、注意事项</h5><p>使用监听器分配方式，按照监听事件去执行监听类的 notify 方法，方法如果不能正常执行也会影响<br>任务的执行。 </p>
<h3 id="2-2、查询任务"><a href="#2-2、查询任务" class="headerlink" title="2.2、查询任务"></a>2.2、查询任务</h3><h4 id="查询任务负责人的待办任务"><a href="#查询任务负责人的待办任务" class="headerlink" title="查询任务负责人的待办任务"></a>查询任务负责人的待办任务</h4><p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 查询当前个人待执行的任务</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPersonalTaskList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 流程定义key</span><br>    String processDefinitionKey = <span class="hljs-string">&quot;myEvection1&quot;</span>;<br>    <span class="hljs-comment">// 任务负责人</span><br>    String assignee = <span class="hljs-string">&quot;张三&quot;</span>;<br>    <span class="hljs-comment">// 获取TaskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    List&lt;Task&gt; taskList = taskService.createTaskQuery()<br>    	.processDefinitionKey(processDefinitionKey)<br>    	.includeProcessVariables()<br>        .taskAssignee(assignee)<br>        .list();<br>    <span class="hljs-keyword">for</span> (Task task : taskList) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;流程实例id： &quot;</span> + task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务id： &quot;</span> + task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人： &quot;</span> + task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称： &quot;</span> + task.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="关联-businessKey"><a href="#关联-businessKey" class="headerlink" title="关联 businessKey"></a>关联 businessKey</h4><p>需求：<br>在 activiti 实际应用时，查询待办任务可能要显示出业务系统的一些相关信息。</p>
<p>比如：查询待审批出差任务列表需要将出差单的日期、 出差天数等信息显示出来。</p>
<p>出差天数等信息在业务系统中存在，而并没有在 activiti 数据库中存在，所以是无法通过 activiti 的 api 查询到出差天数等信息。<br>实现：<br>在查询待办任务时，通过 businessKey（业务标识 ）关联查询业务系统的出差单表，查询出出差天数等信息。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findProcessInstance</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        获取RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        查询流程定义的对象</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(<span class="hljs-string">&quot;myEvection1&quot;</span>)<br>                .taskAssignee(<span class="hljs-string">&quot;张三&quot;</span>)<br>                .singleResult();<br><span class="hljs-comment">//        使用task对象获取实例id</span><br>        String processInstanceId = task.getProcessInstanceId();<br><span class="hljs-comment">//          使用实例id，获取流程实例对象</span><br>        ProcessInstance processInstance = runtimeService.createProcessInstanceQuery()<br>                .processInstanceId(processInstanceId)<br>                .singleResult();<br><span class="hljs-comment">//        使用processInstance，得到 businessKey</span><br>        String businessKey = processInstance.getBusinessKey();<br><br>        System.out.println(<span class="hljs-string">&quot;businessKey==&quot;</span>+businessKey);<br><br>    &#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-3、办理任务"><a href="#2-3、办理任务" class="headerlink" title="2.3、办理任务"></a>2.3、办理任务</h3><p>注意：在实际应用中，完成任务前需要校验任务的负责人是否具有该任务的办理权限 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成任务，判断当前用户是否有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//任务id</span><br>        String taskId = <span class="hljs-string">&quot;15005&quot;</span>;<br><span class="hljs-comment">//        任务负责人</span><br>        String assingee = <span class="hljs-string">&quot;张三&quot;</span>;<br>        <span class="hljs-comment">//获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>        <span class="hljs-comment">// 创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        完成任务前，需要校验该负责人可以完成当前任务</span><br><span class="hljs-comment">//        校验方法：</span><br><span class="hljs-comment">//        根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成</span><br>        Task task = taskService.createTaskQuery()<br>                .taskId(taskId)<br>                .taskAssignee(assingee)<br>                .singleResult();<br>        <span class="hljs-keyword">if</span>(task != <span class="hljs-keyword">null</span>)&#123;<br>            taskService.complete(taskId);<br>            System.out.println(<span class="hljs-string">&quot;完成任务&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h2 id="三、流程变量"><a href="#三、流程变量" class="headerlink" title="三、流程变量"></a>三、流程变量</h2><h3 id="3-1、什么是流程变量"><a href="#3-1、什么是流程变量" class="headerlink" title="3.1、什么是流程变量"></a>3.1、什么是流程变量</h3><p>流程变量在 activiti 中是一个非常重要的角色，流程运转有时需要靠流程变量，业务系统和 activiti<br>结合时少不了流程变量，流程变量就是 activiti 在管理工作流时根据管理需要而设置的变量。<br>比如：在出差申请流程流转时如果出差天数大于 3 天则由总经理审核，否则由人事直接审核， 出差天<br>数就可以设置为流程变量，在流程流转时使用。 </p>
<p><strong>注意：虽然流程变量中可以存储业务数据可以通过activiti的api查询流程变量从而实现 查询业务数据，但是不建议这样使用，因为业务数据查询由业务系统负责，activiti设置流程变量是为了流程执行需要而创建。</strong></p>
<h3 id="3-2、流程变量类型"><a href="#3-2、流程变量类型" class="headerlink" title="3.2、流程变量类型"></a>3.2、流程变量类型</h3><p>如果将 pojo 存储到流程变量中，必须实现序列化接口 serializable，为了防止由于新增字段无<br>法反序列化，需要生成 serialVersionUID。 </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/20190731150933695.png"></p>
<h3 id="3-3、流程变量作用域"><a href="#3-3、流程变量作用域" class="headerlink" title="3.3、流程变量作用域"></a>3.3、流程变量作用域</h3><p>流程变量的作用域可以是一个流程实例(processInstance)，或一个任务(task)，或一个执行实例<br>(execution)</p>
<h4 id="3-3-1、globa变量"><a href="#3-3-1、globa变量" class="headerlink" title="3.3.1、globa变量"></a>3.3.1、globa变量</h4><p>流程变量的默认作用域是流程实例。当一个流程变量的作用域为流程实例时，可以称为 global 变量</p>
<p>注意：</p>
<p>如：    Global变量：userId（变量名）、zhangsan（变量值）</p>
<p>global 变量中变量名不允许重复，设置相同名称的变量，后设置的值会覆盖前设置的变量值。</p>
<h4 id="3-3-2、local变量"><a href="#3-3-2、local变量" class="headerlink" title="3.3.2、local变量"></a>3.3.2、local变量</h4><p>任务和执行实例仅仅是针对一个任务和一个执行实例范围，范围没有流程实例大， 称为 local 变量。</p>
<p>Local 变量由于在不同的任务或不同的执行实例中，作用域互不影响，变量名可以相同没有影响。Local 变量名也可以和 global 变量名相同，没有影响。 </p>
<h3 id="3-4、流程变量的使用方法"><a href="#3-4、流程变量的使用方法" class="headerlink" title="3.4、流程变量的使用方法"></a>3.4、流程变量的使用方法</h3><h4 id="3-4-1、在属性上使用UEL表达式"><a href="#3-4-1、在属性上使用UEL表达式" class="headerlink" title="3.4.1、在属性上使用UEL表达式"></a>3.4.1、在属性上使用UEL表达式</h4><p>可以在 assignee 处设置 UEL 表达式，表达式的值为任务的负责人，比如： ${assignee}， assignee 就是一个流程变量名称。</p>
<p>Activiti获取UEL表达式的值，即流程变量assignee的值 ，将assignee的值作为任务的负责人进行任务分配</p>
<h4 id="3-4-2、在连线上使用UEL表达式"><a href="#3-4-2、在连线上使用UEL表达式" class="headerlink" title="3.4.2、在连线上使用UEL表达式"></a>3.4.2、在连线上使用UEL表达式</h4><p>可以在连线上设置UEL表达式，决定流程走向。</p>
<p>比如：${price&lt;10000} 。price就是一个流程变量名称，uel表达式结果类型为布尔类型。</p>
<p>如果UEL表达式是true，要决定 流程执行走向。</p>
<h3 id="3-5、使用Global变量控制流程"><a href="#3-5、使用Global变量控制流程" class="headerlink" title="3.5、使用Global变量控制流程"></a>3.5、使用Global变量控制流程</h3><h4 id="3-5-1、需求"><a href="#3-5-1、需求" class="headerlink" title="3.5.1、需求"></a>3.5.1、需求</h4><p>员工创建出差申请单，由部门经理审核，部门经理审核通过后出差3天及以下由人财务直接审批，3天以上先由总经理审核，总经理审核通过再由财务审批。</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847570736.png" alt="1577847570736"></p>
<h4 id="3-5-2、流程定义"><a href="#3-5-2、流程定义" class="headerlink" title="3.5.2、流程定义"></a>3.5.2、流程定义</h4><p>1）、出差天数大于等于3连线条件</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847654279.png" alt="1577847654279"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847695723.png" alt="1577847695723"></p>
<p>也可以使用对象参数命名，如evection.num：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870487533.png" alt="1577870487533"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870510159.png" alt="1577870510159"></p>
<p>2）、出差天数小于3连线条件</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847740055.png" alt="1577847740055"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577847766231.png" alt="1577847766231"></p>
<p>也可以使用对象参数命名，如：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870638264.png" alt="1577870638264"><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577870654033.png" alt="1577870654033"></p>
<h4 id="3-5-3、设置global流程变量"><a href="#3-5-3、设置global流程变量" class="headerlink" title="3.5.3、设置global流程变量"></a>3.5.3、设置global流程变量</h4><p>在部门经理审核前设置流程变量，变量值为出差单信息（包括出差天数），部门经理审核后可以根据流程变量的值决定流程走向。</p>
<p>在设置流程变量时，可以在启动流程时设置，也可以在任务办理时设置</p>
<h5 id="3-5-3-1、创建POJO对象"><a href="#3-5-3-1、创建POJO对象" class="headerlink" title="3.5.3.1、创建POJO对象"></a>3.5.3.1、创建POJO对象</h5><p>创建出差申请pojo对象</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.demo.pojo;<br><br><span class="hljs-keyword">import</span> java.io.Serializable;<br><span class="hljs-keyword">import</span> java.util.Date;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 出差申请 pojo</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Evection</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 主键id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出差申请单名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String evectionName;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出差天数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Double num;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 预计开始时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date beginDate;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 预计结束时间</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> Date endDate;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 目的地</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String destination;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 出差事由</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> String reson;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">getId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setId</span><span class="hljs-params">(Long id)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.id = id;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getEvectionName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> evectionName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEvectionName</span><span class="hljs-params">(String evectionName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.evectionName = evectionName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getBeginDate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> beginDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeginDate</span><span class="hljs-params">(Date beginDate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.beginDate = beginDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Date <span class="hljs-title">getEndDate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> endDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setEndDate</span><span class="hljs-params">(Date endDate)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.endDate = endDate;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getDestination</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> destination;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDestination</span><span class="hljs-params">(String destination)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.destination = destination;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getReson</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> reson;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setReson</span><span class="hljs-params">(String reson)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.reson = reson;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNum</span><span class="hljs-params">(Double num)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.num = num;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<h5 id="3-5-3-2、启动流程时设置变量"><a href="#3-5-3-2、启动流程时设置变量" class="headerlink" title="3.5.3.2、启动流程时设置变量"></a>3.5.3.2、启动流程时设置变量</h5><p>在启动流程时设置流程变量，变量的作用域是整个流程实例。</p>
<p>通过Map&lt;key,value&gt;设置流程变量，map中可以设置多个变量，这个key就是流程变量的名字。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 启动流程实例,设置流程变量的值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">startProcess</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//        获取流程引擎</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取RunTimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        流程定义key</span><br>        String key = <span class="hljs-string">&quot;myEvection2&quot;</span>;<br><span class="hljs-comment">//       创建变量集合</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">//        创建出差pojo对象</span><br>        Evection evection = <span class="hljs-keyword">new</span> Evection();<br><span class="hljs-comment">//        设置出差天数</span><br>        evection.setNum(<span class="hljs-number">2d</span>);<br><span class="hljs-comment">//      定义流程变量，把出差pojo对象放入map</span><br>        map.put(<span class="hljs-string">&quot;evection&quot;</span>,evection);<br><span class="hljs-comment">//      设置assignee的取值，用户可以在界面上设置流程的执行</span><br>        map.put(<span class="hljs-string">&quot;assignee0&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;assignee1&quot;</span>,<span class="hljs-string">&quot;李经理&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;assignee2&quot;</span>,<span class="hljs-string">&quot;王总经理&quot;</span>);<br>        map.put(<span class="hljs-string">&quot;assignee3&quot;</span>,<span class="hljs-string">&quot;赵财务&quot;</span>);<br><span class="hljs-comment">//        启动流程实例，并设置流程变量的值（把map传入）</span><br>        ProcessInstance processInstance = runtimeService<br>                .startProcessInstanceByKey(key, map);<br><span class="hljs-comment">//      输出</span><br>        System.out.println(<span class="hljs-string">&quot;流程实例名称=&quot;</span>+processInstance.getName());<br>        System.out.println(<span class="hljs-string">&quot;流程定义id==&quot;</span>+processInstance.getProcessDefinitionId());<br><br>    &#125;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成任务，判断当前用户是否有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//任务id</span><br>        String key = <span class="hljs-string">&quot;myEvection2&quot;</span>;<br><span class="hljs-comment">//        任务负责人</span><br>        String assingee = <span class="hljs-string">&quot;张三&quot;</span>;<br>        <span class="hljs-comment">//获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>        <span class="hljs-comment">// 创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//        完成任务前，需要校验该负责人可以完成当前任务</span><br><span class="hljs-comment">//        校验方法：</span><br><span class="hljs-comment">//        根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(key)<br>                .taskAssignee(assingee)<br>                .singleResult();<br>        <span class="hljs-keyword">if</span>(task != <span class="hljs-keyword">null</span>)&#123;<br>            taskService.complete(task.getId());<br>            System.out.println(<span class="hljs-string">&quot;任务执行完成&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>startProcessInstanceByKey(processDefinitionKey, variables)</p>
<p>流程变量作用域是一个流程实例，流程变量使用Map存储，同一个流程实例设置变量map中key相同，后者覆盖前者。</p>
<h5 id="3-5-3-2、任务办理时设置变量"><a href="#3-5-3-2、任务办理时设置变量" class="headerlink" title="3.5.3.2、任务办理时设置变量"></a>3.5.3.2、任务办理时设置变量</h5><p>在完成任务时设置流程变量，该流程变量只有在该任务完成后其它结点才可使用该变量，它的作用域是整个流程实例，如果设置的流程变量的key在流程实例中已存在相同的名字则后设置的变量替换前边设置的变量。</p>
<p>这里需要在创建出差单任务完成时设置流程变量</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 完成任务，判断当前用户是否有权限</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//任务id</span><br>        String key = <span class="hljs-string">&quot;myEvection2&quot;</span>;<br><span class="hljs-comment">//        任务负责人</span><br>        String assingee = <span class="hljs-string">&quot;张三&quot;</span>;<br><span class="hljs-comment">//       获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//       创建TaskService</span><br>        TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//       创建变量集合</span><br>        Map&lt;String, Object&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-comment">//        创建出差pojo对象</span><br>        Evection evection = <span class="hljs-keyword">new</span> Evection();<br><span class="hljs-comment">//        设置出差天数</span><br>        evection.setNum(<span class="hljs-number">2d</span>);<br><span class="hljs-comment">//      定义流程变量</span><br>        map.put(<span class="hljs-string">&quot;evection&quot;</span>,evection);<br><span class="hljs-comment">//        完成任务前，需要校验该负责人可以完成当前任务</span><br><span class="hljs-comment">//        校验方法：</span><br><span class="hljs-comment">//        根据任务id和任务负责人查询当前任务，如果查到该用户有权限，就完成</span><br>        Task task = taskService.createTaskQuery()<br>                .processDefinitionKey(key)<br>                .taskAssignee(assingee)<br>                .singleResult();<br>        <span class="hljs-keyword">if</span>(task != <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//完成任务是，设置流程变量的值</span><br>            taskService.complete(task.getId(),map);<br>            System.out.println(<span class="hljs-string">&quot;任务执行完成&quot;</span>);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>说明：</p>
<p>通过当前任务设置流程变量，需要指定当前任务id，如果当前执行的任务id不存在则抛出异常。</p>
<p>任务办理时也是通过map&lt;key,value&gt;设置流程变量，一次可以设置多个变量。</p>
<h5 id="3-5-3-3、通过当前流程实例设置"><a href="#3-5-3-3、通过当前流程实例设置" class="headerlink" title="3.5.3.3、通过当前流程实例设置"></a>3.5.3.3、通过当前流程实例设置</h5><p>通过流程实例id设置全局变量，该流程实例必须未执行完成。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGlobalVariableByExecutionId</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//    当前流程实例执行 id，通常设置为当前执行的流程实例</span><br>        String executionId=<span class="hljs-string">&quot;2601&quot;</span>;<br><span class="hljs-comment">//     获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br><span class="hljs-comment">//        获取RuntimeService</span><br>        RuntimeService runtimeService = processEngine.getRuntimeService();<br><span class="hljs-comment">//        创建出差pojo对象</span><br>        Evection evection = <span class="hljs-keyword">new</span> Evection();<br><span class="hljs-comment">//        设置天数</span><br>        evection.setNum(<span class="hljs-number">3d</span>);<br><span class="hljs-comment">//      通过流程实例 id设置流程变量</span><br>        runtimeService.setVariable(executionId, <span class="hljs-string">&quot;evection&quot;</span>, evection);<br><span class="hljs-comment">//      一次设置多个值</span><br><span class="hljs-comment">//      runtimeService.setVariables(executionId, variables)</span><br>    &#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>executionId必须当前未结束 流程实例的执行id，通常此id设置流程实例 的id。也可以通runtimeService.getVariable()获取流程变量。</p>
<h5 id="3-5-3-4、通过当前任务设置"><a href="#3-5-3-4、通过当前任务设置" class="headerlink" title="3.5.3.4、通过当前任务设置"></a>3.5.3.4、通过当前任务设置</h5><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setGlobalVariableByTaskId</span><span class="hljs-params">()</span></span>&#123;<br>		<br>		<span class="hljs-comment">//当前待办任务id</span><br>		String taskId=<span class="hljs-string">&quot;1404&quot;</span>;<br><span class="hljs-comment">//     获取processEngine</span><br>        ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>		TaskService taskService = processEngine.getTaskService();<br>		Evection evection = <span class="hljs-keyword">new</span> Evection();<br>		evection.setNum(<span class="hljs-number">3</span>);<br>		<span class="hljs-comment">//通过任务设置流程变量</span><br>		taskService.setVariable(taskId, <span class="hljs-string">&quot;evection&quot;</span>, evection);<br>		<span class="hljs-comment">//一次设置多个值 </span><br>		<span class="hljs-comment">//taskService.setVariables(taskId, variables)</span><br>	&#125;<br><br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>任务id必须是当前待办任务id，act_ru_task中存在。如果该任务已结束，会报错</p>
<p>也可以通过taskService.getVariable()获取流程变量。</p>
<h4 id="3-5-4、测试"><a href="#3-5-4、测试" class="headerlink" title="3.5.4、测试"></a>3.5.4、测试</h4><p>正常测试：</p>
<p>​       设置流程变量的值大于等于3天</p>
<p>​       设计流程变量的值小于3天</p>
<p>异常测试：</p>
<p>​       流程变量不存在</p>
<p>​       流程变量的值为空NULL，price属性为空</p>
<p>​       UEL表达式都不符合条件  </p>
<p>​      不设置连线的条件</p>
<h4 id="3-5-5、注意事项"><a href="#3-5-5、注意事项" class="headerlink" title="3.5.5、注意事项"></a>3.5.5、注意事项</h4><p>1、  如果UEL表达式中流程变量名不存在则报错。</p>
<p>2、  如果UEL表达式中流程变量值为空NULL，流程不按UEL表达式去执行，而流程结束 。</p>
<p>3、  如果UEL表达式都不符合条件，流程结束 </p>
<p>4、  <strong>==如果连线不设置条件，会走flow序号小的那条线==</strong></p>
<h4 id="3-5-6、操作数据库表"><a href="#3-5-6、操作数据库表" class="headerlink" title="3.5.6、操作数据库表"></a>3.5.6、操作数据库表</h4><p>设置流程变量会在当前执行流程变量表插入记录，同时也会在历史流程变量表也插入记录。</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-operator">/</span><span class="hljs-operator">/</span>当前流程变量表<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ru_variable <br></code></pre></td></tr></table></figure>

<p>记录当前运行流程实例可使用的流程变量，包括 global和local变量</p>
<p>Id_：主键</p>
<p>Type_：变量类型</p>
<p>Name_：变量名称 </p>
<p>Execution_id_：所属流程实例执行id，global和local变量都存储</p>
<p>Proc_inst_id_：所属流程实例id，global和local变量都存储 </p>
<p>Task_id_：所属任务id，local变量存储</p>
<p>Bytearray_：serializable类型变量存储对应act_ge_bytearray表的id</p>
<p>Double_：double类型变量值</p>
<p>Long_：long类型变量值</p>
<p>Text_：text类型变量值 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"> #历史流程变量表<br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_hi_varinst <br></code></pre></td></tr></table></figure>

<p>记录所有已创建的流程变量，包括 global和local变量</p>
<p>字段意义参考当前流程变量表。</p>
<h3 id="3-6、设置local流程变量"><a href="#3-6、设置local流程变量" class="headerlink" title="3.6、设置local流程变量"></a>3.6、设置local流程变量</h3><h4 id="3-6-1、任务办理时设置"><a href="#3-6-1、任务办理时设置" class="headerlink" title="3.6.1、任务办理时设置"></a>3.6.1、任务办理时设置</h4><p> 任务办理时设置local流程变量，当前运行的流程实例只能在该任务结束前使用，任务结束该变量无法在当前流程实例使用，可以通过查询历史任务查询。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*处理任务时设置local流程变量</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completTask</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">//任务id</span><br>   String taskId = <span class="hljs-string">&quot;1404&quot;</span>;<br><span class="hljs-comment">//  获取processEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    TaskService taskService = processEngine.getTaskService();<br><span class="hljs-comment">//  定义流程变量</span><br>   Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br>   Evection evection = <span class="hljs-keyword">new</span> Evection ();<br>   evection.setNum(<span class="hljs-number">3d</span>);<br><span class="hljs-comment">// 定义流程变量</span><br>   Map&lt;String, Object&gt; variables = <span class="hljs-keyword">new</span> HashMap&lt;String, Object&gt;();<br><span class="hljs-comment">//  变量名是holiday，变量值是holiday对象</span><br>    variables.put(<span class="hljs-string">&quot;evection&quot;</span>, evection);<br><span class="hljs-comment">//  设置local变量，作用域为该任务</span><br>    taskService.setVariablesLocal(taskId, variables);<br><span class="hljs-comment">//  完成任务</span><br>   taskService.complete(taskId);<br>&#125;<br></code></pre></td></tr></table></figure>


<p>​       说明：</p>
<p>设置作用域为任务的local变量，每个任务可以设置同名的变量，互不影响。</p>
<h4 id="3-6-2、通过当前任务设置"><a href="#3-6-2、通过当前任务设置" class="headerlink" title="3.6.2、通过当前任务设置"></a>3.6.2、通过当前任务设置</h4><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalVariableByTaskId</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//   当前待办任务id</span><br>    String taskId=<span class="hljs-string">&quot;1404&quot;</span>;<br><span class="hljs-comment">//  获取processEngine</span><br>    ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    TaskService taskService = processEngine.getTaskService();<br>    Evection evection = <span class="hljs-keyword">new</span> Evection ();<br>    evection.setNum(<span class="hljs-number">3d</span>);<br><span class="hljs-comment">//  通过任务设置流程变量</span><br>    taskService.setVariableLocal(taskId, <span class="hljs-string">&quot;evection&quot;</span>, evection);<br><span class="hljs-comment">//  一次设置多个值 </span><br>    <span class="hljs-comment">//taskService.setVariablesLocal(taskId, variables)</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：</p>
<p>任务id必须是当前待办任务id，act_ru_task中存在。</p>
<h4 id="3-6-3、-Local变量测试1"><a href="#3-6-3、-Local变量测试1" class="headerlink" title="3.6.3、  Local变量测试1"></a>3.6.3、  Local变量测试1</h4><p>如果上边例子中设置global变量改为设置local变量是否可行？为什么？</p>
<p> Local变量在任务结束后无法在当前流程实例执行中使用，如果后续的流程执行需要用到此变量则会报错。</p>
<h4 id="3-6-4、-Local变量测试2"><a href="#3-6-4、-Local变量测试2" class="headerlink" title="3.6.4、  Local变量测试2"></a>3.6.4、  Local变量测试2</h4><p>在部门经理审核、总经理审核、财务审核时设置local变量，可通过historyService查询每个历史任务时将流程变量的值也查询出来。</p>
<p> 代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 创建历史任务查询对象</span><br>      HistoricTaskInstanceQuery historicTaskInstanceQuery = historyService.createHistoricTaskInstanceQuery();<br>      <span class="hljs-comment">// 查询结果包括 local变量</span><br>      historicTaskInstanceQuery.includeTaskLocalVariables();<br><span class="hljs-keyword">for</span> (HistoricTaskInstance historicTaskInstance : list) &#123;<br>         System.out.println(<span class="hljs-string">&quot;==============================&quot;</span>);<br>         System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + historicTaskInstance.getId());<br>         System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + historicTaskInstance.getName());<br>         System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + historicTaskInstance.getAssignee());<br>     System.out.println(<span class="hljs-string">&quot;任务local变量：&quot;</span>+ historicTaskInstance.getTaskLocalVariables());<br><br>&#125;<br></code></pre></td></tr></table></figure>

<p>注意：查询历史流程变量，特别是查询pojo变量需要经过反序列化，不推荐使用。</p>
<h2 id="四、组任务"><a href="#四、组任务" class="headerlink" title="四、组任务"></a>四、组任务</h2><h3 id="4-1、需求"><a href="#4-1、需求" class="headerlink" title="4.1、需求"></a>4.1、需求</h3><p>在流程定义中在任务结点的 assignee 固定设置任务负责人，在流程定义时将参与者固定设置在.bpmn 文件中，如果临时任务负责人变更则需要修改流程定义，系统可扩展性差。</p>
<p>针对这种情况可以给任务设置多个候选人，可以从候选人中选择参与者来完成任务。 </p>
<h3 id="4-2、设置任务候选人"><a href="#4-2、设置任务候选人" class="headerlink" title="4.2、设置任务候选人"></a>4.2、设置任务候选人</h3><p>在流程图中任务节点的配置中设置 candidate-users(候选人)，多个候选人之间用逗号分开。 </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577878753288.png" alt="1577878753288"></p>
<p>查看bpmn文件</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">userTask</span> <span class="hljs-attr">activiti:candidateUsers</span>=<span class="hljs-string">&quot;lisi,wangwu&quot;</span> <span class="hljs-attr">activiti:exclusive</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;_3&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;经理审批&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>

<p>我们可以看到部门经理的审核人已经设置为 lisi,wangwu 这样的一组候选人，可以使用</p>
<p>activiti:candiateUsers=”用户 1,用户 2,用户 3”的这种方式来实现设置一组候选人 </p>
<h3 id="4-3、组任务"><a href="#4-3、组任务" class="headerlink" title="4.3、组任务"></a>4.3、组任务</h3><h4 id="4-3-1、组任务办理流程"><a href="#4-3-1、组任务办理流程" class="headerlink" title="4.3.1、组任务办理流程"></a>4.3.1、组任务办理流程</h4><h5 id="a、查询组任务"><a href="#a、查询组任务" class="headerlink" title="a、查询组任务"></a>a、查询组任务</h5><p>指定候选人，查询该候选人当前的待办任务。</p>
<p>候选人不能立即办理任务。</p>
<h5 id="b、拾取-claim-任务"><a href="#b、拾取-claim-任务" class="headerlink" title="b、拾取(claim)任务"></a>b、拾取(claim)任务</h5><p>该组任务的所有候选人都能拾取。</p>
<p>将候选人的组任务，变成个人任务。原来候选人就变成了该任务的负责人。</p>
<p>如果拾取后不想办理该任务？</p>
<p>   需要将已经拾取的个人任务归还到组里边，将个人任务变成了组任务。</p>
<h5 id="c、查询个人任务"><a href="#c、查询个人任务" class="headerlink" title="c、查询个人任务"></a>c、查询个人任务</h5><p>查询方式同个人任务部分，根据assignee查询用户负责的个人任务。</p>
<h5 id="d、办理个人任务"><a href="#d、办理个人任务" class="headerlink" title="d、办理个人任务"></a>d、办理个人任务</h5><h4 id="4-3-2、-查询组任务"><a href="#4-3-2、-查询组任务" class="headerlink" title="4.3.2、  查询组任务"></a>4.3.2、  查询组任务</h4><p> 根据候选人查询组任务</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findGroupTaskList</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-comment">// 流程定义key</span><br>       String processDefinitionKey = <span class="hljs-string">&quot;evection3&quot;</span>;<br>       <span class="hljs-comment">// 任务候选人</span><br>       String candidateUser = <span class="hljs-string">&quot;lisi&quot;</span>;<br>        <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       <span class="hljs-comment">// 创建TaskService</span><br>       TaskService taskService = processEngine.getTaskService();<br>       <span class="hljs-comment">//查询组任务</span><br>       List&lt;Task&gt; list = taskService.createTaskQuery()<br>              .processDefinitionKey(processDefinitionKey)<br>              .taskCandidateUser(candidateUser)<span class="hljs-comment">//根据候选人查询</span><br>              .list();<br>       <span class="hljs-keyword">for</span> (Task task : list) &#123;<br>           System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>           System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + task.getProcessInstanceId());<br>           System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + task.getId());<br>           System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>           System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-3-3-、-拾取组任务"><a href="#4-3-3-、-拾取组任务" class="headerlink" title="4.3.3 、 拾取组任务"></a>4.3.3 、 拾取组任务</h4><p> 候选人员拾取组任务后该任务变为自己的个人任务。</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">claimTask</span><span class="hljs-params">()</span></span>&#123;<br>         <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       TaskService taskService = processEngine.getTaskService();<br>       <span class="hljs-comment">//要拾取的任务id</span><br>       String taskId = <span class="hljs-string">&quot;6302&quot;</span>;<br>       <span class="hljs-comment">//任务候选人id</span><br>       String userId = <span class="hljs-string">&quot;lisi&quot;</span>;<br>       <span class="hljs-comment">//拾取任务</span><br>       <span class="hljs-comment">//即使该用户不是候选人也能拾取(建议拾取时校验是否有资格)    </span><br>       <span class="hljs-comment">//校验该用户有没有拾取任务的资格</span><br>       Task task = taskService.createTaskQuery()<br>              .taskId(taskId)<br>              .taskCandidateUser(userId)<span class="hljs-comment">//根据候选人查询</span><br>              .singleResult();<br>       <span class="hljs-keyword">if</span>(task!=<span class="hljs-keyword">null</span>)&#123;<br>         <span class="hljs-comment">//拾取任务</span><br>           taskService.claim(taskId, userId);<br>           System.out.println(<span class="hljs-string">&quot;任务拾取成功&quot;</span>);<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>

<p>说明：即使该用户不是候选人也能拾取，建议拾取时校验是否有资格</p>
<p>组任务拾取后，该任务已有负责人，通过候选人将查询不到该任务</p>
<h4 id="4-3-4、-查询个人待办任务"><a href="#4-3-4、-查询个人待办任务" class="headerlink" title="4.3.4、  查询个人待办任务"></a>4.3.4、  查询个人待办任务</h4><p> 查询方式同个人任务查询</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">findPersonalTaskList</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 流程定义key</span><br>    String processDefinitionKey = <span class="hljs-string">&quot;evection1&quot;</span>;<br>    <span class="hljs-comment">// 任务负责人</span><br>    String assignee = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>     <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>    <span class="hljs-comment">// 创建TaskService</span><br>    TaskService taskService = processEngine.getTaskService();<br>    List&lt;Task&gt; list = taskService.createTaskQuery()<br>        .processDefinitionKey(processDefinitionKey)<br>        .taskAssignee(assignee)<br>        .list();<br>    <span class="hljs-keyword">for</span> (Task task : list) &#123;<br>        System.out.println(<span class="hljs-string">&quot;----------------------------&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;流程实例id：&quot;</span> + task.getProcessInstanceId());<br>        System.out.println(<span class="hljs-string">&quot;任务id：&quot;</span> + task.getId());<br>        System.out.println(<span class="hljs-string">&quot;任务负责人：&quot;</span> + task.getAssignee());<br>        System.out.println(<span class="hljs-string">&quot;任务名称：&quot;</span> + task.getName());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="4-3-5、-办理个人任务"><a href="#4-3-5、-办理个人任务" class="headerlink" title="4.3.5、  办理个人任务"></a>4.3.5、  办理个人任务</h4><p>同个人任务办理</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"> <span class="hljs-comment">/*完成任务*/</span><br>   <span class="hljs-meta">@Test</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">completeTask</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-comment">//     任务ID</span><br>      String taskId = <span class="hljs-string">&quot;12304&quot;</span>;<br><span class="hljs-comment">//     获取processEngine</span><br>      ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>      processEngine.getTaskService()<br>                   .complete(taskId);<br>      System.out.println(<span class="hljs-string">&quot;完成任务：&quot;</span>+taskId);<br>   &#125;<br></code></pre></td></tr></table></figure>

<p>说明：建议完成任务前校验该用户是否是该任务的负责人。</p>
<h4 id="4-3-6、-归还组任务"><a href="#4-3-6、-归还组任务" class="headerlink" title="4.3.6、  归还组任务"></a>4.3.6、  归还组任务</h4><p> 如果个人不想办理该组任务，可以归还组任务，归还后该用户不再是该任务的负责人</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">*归还组任务，由个人任务变为组任务，还可以进行任务交接</span><br><span class="hljs-comment">*/</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAssigneeToGroupTask</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>   <span class="hljs-comment">// 查询任务使用TaskService</span><br>   TaskService taskService = processEngine.getTaskService();<br>   <span class="hljs-comment">// 当前待办任务</span><br>   String taskId = <span class="hljs-string">&quot;6004&quot;</span>;<br>   <span class="hljs-comment">// 任务负责人</span><br>   String userId = <span class="hljs-string">&quot;zhangsan2&quot;</span>;<br>    <span class="hljs-comment">// 校验userId是否是taskId的负责人，如果是负责人才可以归还组任务</span><br>   Task task = taskService<br>       .createTaskQuery()<br>       .taskId(taskId)<br>       .taskAssignee(userId)<br>       .singleResult();<br>    <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>       <span class="hljs-comment">// 如果设置为null，归还组任务,该 任务没有负责人</span><br>       taskService.setAssignee(taskId, <span class="hljs-keyword">null</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p> 说明：建议归还任务前校验该用户是否是该任务的负责人</p>
<p>也可以通过setAssignee方法将任务委托给其它用户负责，注意被委托的用户可以不是候选人（建议不要这样使用）</p>
<h4 id="4-3-7、-任务交接"><a href="#4-3-7、-任务交接" class="headerlink" title="4.3.7、  任务交接"></a>4.3.7、  任务交接</h4><p>任务交接,任务负责人将任务交给其它候选人办理该任务</p>
 <figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAssigneeToCandidateUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//  获取processEngine</span><br>       ProcessEngine processEngine = ProcessEngines.getDefaultProcessEngine();<br>       <span class="hljs-comment">// 查询任务使用TaskService</span><br>       TaskService taskService = processEngine.getTaskService();<br>       <span class="hljs-comment">// 当前待办任务</span><br>       String taskId = <span class="hljs-string">&quot;6004&quot;</span>;<br>       <span class="hljs-comment">// 任务负责人</span><br>       String userId = <span class="hljs-string">&quot;zhangsan2&quot;</span>;<br><span class="hljs-comment">// 将此任务交给其它候选人办理该 任务</span><br>           String candidateuser = <span class="hljs-string">&quot;zhangsan&quot;</span>;<br>       <span class="hljs-comment">// 校验userId是否是taskId的负责人，如果是负责人才可以归还组任务</span><br>       Task task = taskService<br>           .createTaskQuery()<br>           .taskId(taskId)<br>           .taskAssignee(userId)<br>           .singleResult();<br>       <span class="hljs-keyword">if</span> (task != <span class="hljs-keyword">null</span>) &#123;<br>           taskService.setAssignee(taskId, candidateuser);<br>       &#125;<br>    &#125;<br></code></pre></td></tr></table></figure>



<h4 id="4-3-8、-数据库表操作"><a href="#4-3-8、-数据库表操作" class="headerlink" title="4.3.8、  数据库表操作"></a>4.3.8、  数据库表操作</h4><p>查询当前任务执行表</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ru_task <br></code></pre></td></tr></table></figure>

<p>任务执行表，记录当前执行的任务，由于该任务当前是组任务，所有assignee为空，当拾取任务后该字段就是拾取用户的id</p>
<p>查询任务参与者</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> act_ru_identitylink<br></code></pre></td></tr></table></figure>

<p> 任务参与者，记录当前参考任务用户或组，当前任务如果设置了候选人，会向该表插入候选人记录，有几个候选就插入几个</p>
<p>与act_ru_identitylink对应的还有一张历史表act_hi_identitylink，向act_ru_identitylink插入记录的同时也会向历史表插入记录。任务完成</p>
<h2 id="五、网关"><a href="#五、网关" class="headerlink" title="五、网关"></a>五、网关</h2><p>网关用来控制流程的流向</p>
<h3 id="5-1-排他网关ExclusiveGateway"><a href="#5-1-排他网关ExclusiveGateway" class="headerlink" title="5.1 排他网关ExclusiveGateway"></a>5.1 排他网关ExclusiveGateway</h3><h4 id="5-1-1-什么是排他网关："><a href="#5-1-1-什么是排他网关：" class="headerlink" title="5.1.1  什么是排他网关："></a>5.1.1  什么是排他网关：</h4><p>排他网关，用来在流程中实现决策。 当流程执行到这个网关，所有分支都会判断条件是否为true，如果为true则执行该分支，</p>
<p><strong>注意</strong>：**==排他网关只会选择一个为true的分支执行。如果有两个分支条件都为true，排他网关会选择id值较小的一条分支去执行，如果条件都为false，则抛出异常==**。</p>
<p>为什么要用排他网关？</p>
<p>不用排他网关也可以实现分支，如：在连线的condition条件上设置分支条件。</p>
<p><strong>在连线设置condition条件的缺点：如果条件都不满足，流程就结束了(是异常结束)。</strong></p>
<p>如果 使用排他网关决定分支的走向，如下：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577879740282.png" alt="1577879740282"></p>
<p>如果从网关出去的线所有条件都不满足则系统抛出异常。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.activiti.engine.ActivitiException: No outgoing sequence flow of the exclusive gateway <span class="hljs-string">&#x27;exclusivegateway1&#x27;</span> could be selected <span class="hljs-keyword">for</span> continuing the process<br>   at org.activiti.engine.impl.bpmn.behavior.ExclusiveGatewayActivityBehavior.leave(ExclusiveGatewayActivityBehavior.java:<span class="hljs-number">85</span>)<br><br></code></pre></td></tr></table></figure>



<h4 id="5-1-2-流程定义"><a href="#5-1-2-流程定义" class="headerlink" title="5.1.2  流程定义"></a>5.1.2  流程定义</h4><p> 排他网关图标，红框内：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577879961637.png" alt="1577879961637"></p>
<h4 id="5-1-3-测试"><a href="#5-1-3-测试" class="headerlink" title="5.1.3  测试"></a>5.1.3  测试</h4><p>在部门经理审核后，走排他网关，从排他网关出来的分支有两条，一条是判断出差天数是否大于3天，另一条是判断出差天数是否小于等于3天。</p>
<p>设置分支条件时，如果所有分支条件都不是true，报错：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.activiti.engine.ActivitiException: No outgoing sequence flow of the exclusive gateway <span class="hljs-string">&#x27;exclusivegateway1&#x27;</span> could be selected <span class="hljs-keyword">for</span> continuing the process<br><br>       at org.activiti.engine.impl.bpmn.behavior.ExclusiveGatewayActivityBehavior.leave(ExclusiveGatewayActivityBehavior.java:<span class="hljs-number">85</span>)<br><br></code></pre></td></tr></table></figure>

<h3 id="5-2-并行网关ParallelGateway"><a href="#5-2-并行网关ParallelGateway" class="headerlink" title="5.2 并行网关ParallelGateway"></a>5.2 并行网关ParallelGateway</h3><h4 id="5-2-1-什么是并行网关"><a href="#5-2-1-什么是并行网关" class="headerlink" title="5.2.1  什么是并行网关"></a>5.2.1  什么是并行网关</h4><p>并行网关允许将流程分成多条分支，也可以把多条分支汇聚到一起，并行网关的功能是基于进入和外出顺序流的：</p>
<p>l  fork分支：</p>
<p> 并行后的所有外出顺序流，为每个顺序流都创建一个并发分支。</p>
<p>l  join汇聚： </p>
<p>所有到达并行网关，在此等待的进入分支， 直到所有进入顺序流的分支都到达以后， 流程就会通过汇聚网关。</p>
<p>注意，如果同一个并行网关有多个进入和多个外出顺序流， 它就同时具有分支和汇聚功能。 这时，网关会先汇聚所有进入的顺序流，然后再切分成多个并行分支。</p>
<p><strong>与其他网关的主要区别是，并行网关不会解析条件。</strong> <strong>即使顺序流中定义了条件，也会被忽略。</strong></p>
<p>例子：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586679201.png"></p>
<p>说明：</p>
<p>技术经理和项目经理是两个execution分支，在act_ru_execution表有两条记录分别是技术经理和项目经理，act_ru_execution还有一条记录表示该流程实例。</p>
<p>待技术经理和项目经理任务全部完成，在汇聚点汇聚，通过parallelGateway并行网关。</p>
<p>并行网关在业务应用中常用于会签任务，会签任务即多个参与者共同办理的任务。</p>
<h4 id="5-2-2-流程定义"><a href="#5-2-2-流程定义" class="headerlink" title="5.2.2  流程定义"></a>5.2.2  流程定义</h4><p>并行网关图标，红框内：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577880020127.png" alt="1577880020127"></p>
<h4 id="5-2-3-测试"><a href="#5-2-3-测试" class="headerlink" title="5.2.3  测试"></a>5.2.3  测试</h4><p>当执行到并行网关数据库跟踪如下：</p>
<p>当前任务表：SELECT * FROM act_ru_task   </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680533.png"></p>
<p>上图中：有两个任务当前执行。</p>
<p>查询流程实例执行表：SELECT * FROM act_ru_execution </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680570.png"></p>
<p>上图中，说明当前流程实例有多个分支(两个)在运行。</p>
<p>对并行任务的执行：</p>
<p>并行任务执行不分前后，由任务的负责人去执行即可。</p>
<p>执行技术经理任务后，查询当前任务表 SELECT * FROM act_ru_task   </p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680672.png"></p>
<p>已完成的技术经理任务在当前任务表act_ru_task_已被删除。</p>
<p>在流程实例执行表：SELECT * FROM act_ru_execution有中多个分支存在且有并行网关的汇聚结点。</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680728.png"></p>
<p>有并行网关的汇聚结点：说明有一个分支已经到汇聚，等待其它的分支到达。</p>
<p>当所有分支任务都完成，都到达汇聚结点后：</p>
<p>流程实例执行表：SELECT * FROM act_ru_execution，执行流程实例已经变为总经理审批，说明流程执行已经通过并行网关</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586680801.png"></p>
<p>总结：所有分支到达汇聚结点，并行网关执行完成。         </p>
<h3 id="5-3-包含网关InclusiveGateway"><a href="#5-3-包含网关InclusiveGateway" class="headerlink" title="5.3    包含网关InclusiveGateway"></a>5.3    包含网关InclusiveGateway</h3><h4 id="5-3-1-什么是包含网关"><a href="#5-3-1-什么是包含网关" class="headerlink" title="5.3.1  什么是包含网关"></a>5.3.1  什么是包含网关</h4><p>包含网关可以看做是排他网关和并行网关的结合体。 </p>
<p>和排他网关一样，你可以在外出顺序流上定义条件，包含网关会解析它们。 <strong>但是主要的区别是包含网关可以选择多于一条顺序流，这和并行网关一样。</strong></p>
<p>包含网关的功能是基于进入和外出顺序流的：</p>
<p>l  分支： </p>
<p>所有外出顺序流的条件都会被解析，结果为true的顺序流会以并行方式继续执行， 会为每个顺序流创建一个分支。</p>
<p>l  汇聚：</p>
<p> 所有并行分支到达包含网关，会进入等待状态， 直到每个包含流程token的进入顺序流的分支都到达。 这是与并行网关的最大不同。换句话说，<strong>包含网关只会等待被选中执行了的进入顺序流。 在汇聚之后，流程会穿过包含网关继续执行。</strong></p>
<h4 id="5-3-2-流程定义："><a href="#5-3-2-流程定义：" class="headerlink" title="5.3.2  流程定义："></a>5.3.2  流程定义：</h4><p>出差申请大于等于3天需要由项目经理审批，小于3天由技术经理审批，出差申请必须经过人事经理审批。</p>
<p> 包含网关图标，红框内：</p>
<p> <img src="/images/Activiti%E8%BF%9B%E9%98%B6/1577880080004.png" alt="1577880080004"></p>
<p>定义流程：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586689674.png"></p>
<p>注意：通过包含网关的每个分支的连线上设置condition条件。</p>
<h4 id="5-3-3-测试"><a href="#5-3-3-测试" class="headerlink" title="5.3.3  测试"></a>5.3.3  测试</h4><p>如果包含网关设置的条件中，流程变量不存在，报错;</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">org.activiti.engine.ActivitiException: Unknown property used in expression: $&#123;evection.num&gt;=<span class="hljs-number">3</span>&#125;<br></code></pre></td></tr></table></figure>

<p>需要在流程启动时设置流程变量evection.num。</p>
<p>1）、当流程执行到第一个包含网关后，会根据条件判断，当前要走哪几个分支：</p>
<p>流程实例执行表：SELECT * FROM act_ru_execution</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586676678.png"></p>
<p>第一条记录：包含网关分支。</p>
<p>后两条记录代表两个要执行的分支：</p>
<p>ACT_ID = “_13” 代表 项目经理神品</p>
<p>ACT_ID = “_5” 代表 人事经理审批</p>
<p>当前任务表：ACT_RU_TASK</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586676828.png"></p>
<p>上图中，项目经理审批、人事经理审批 都是当前的任务，在并行执行。</p>
<p>如果有一个分支执行先走到汇聚结点的分支，要等待其它执行分支走到汇聚。</p>
<p>2）、先执行项目经理审批，然后查询当前任务表：ACT_RU_TASK</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677325.png"></p>
<p>当前任务还有人事经理审批需要处理。</p>
<p>流程实例执行表：SELECT * FROM act_ru_execution</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677432.png"></p>
<p>发现人事经理的分支还存在，而项目经理分支已经走到ACT_ID = _18的节点。而ACT_ID=__18就是第二个包含网关</p>
<p>这时，因为有2个分支要执行，包含网关会等所有分支走到汇聚才能执行完成。</p>
<p>3）、执行人事经理审批</p>
<p>然后查询当前任务表：ACT_RU_TASK</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677665.png"></p>
<p>当前任务表已经不是人事经理审批了，说明人事经理审批已经完成。 </p>
<p>流程实例执行表：SELECT * FROM act_ru_execution</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586677735.png"></p>
<p>包含网关执行完成，分支和汇聚就从act_ru_execution删除。</p>
<p>小结：在分支时，需要判断条件，<strong>符合条件的分支，将会执行</strong>，符合条件的分支最终才进行汇聚。</p>
<h3 id="5-4-事件网关EventGateway"><a href="#5-4-事件网关EventGateway" class="headerlink" title="5.4 事件网关EventGateway"></a>5.4 事件网关EventGateway</h3><p>事件网关允许根据事件判断流向。网关的每个外出顺序流都要连接到一个中间捕获事件。 当流程到达一个基于事件网关，网关会进入等待状态：会暂停执行。与此同时，会为每个外出顺序流创建相对的事件订阅。</p>
<p>事件网关的外出顺序流和普通顺序流不同，这些顺序流不会真的”执行”， 相反它们让流程引擎去决定执行到事件网关的流程需要订阅哪些事件。 要考虑以下条件：</p>
<ol>
<li>事件网关必须有两条或以上外出顺序流；</li>
<li>事件网关后，只能使用intermediateCatchEvent类型（activiti不支持基于事件网关后连接ReceiveTask）</li>
<li>连接到事件网关的中间捕获事件必须只有一个入口顺序流。 </li>
</ol>
<h4 id="5-4-1流程定义"><a href="#5-4-1流程定义" class="headerlink" title="5.4.1流程定义"></a>5.4.1流程定义</h4><p>事件网关图标，红框内</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586666799.png" alt="1586666799"></p>
<p>intermediateCatchEvent：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586667342.png"></p>
<p>intermediateCatchEvent支持的事件类型：</p>
<p>Message Event: 消息事件</p>
<p>Singal Event：  信号事件</p>
<p>Timer Event：  定时事件</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586667220.png"></p>
<p>使用事件网关定义流程：</p>
<p><img src="/images/Activiti%E8%BF%9B%E9%98%B6/1586694673.png"></p>
<h3 id="5-5-排他、并行、包含网关的区别"><a href="#5-5-排他、并行、包含网关的区别" class="headerlink" title="5.5 排他、并行、包含网关的区别"></a>5.5 排他、并行、包含网关的区别</h3><h4 id="5-5-1-排他网关："><a href="#5-5-1-排他网关：" class="headerlink" title="5.5.1 排他网关："></a>5.5.1 排他网关：</h4><p>​    只有一个分支为true能执行，如果都为true，则执行flowid娇小的那个分支，如果都为false，则报错异常结束</p>
<h4 id="5-5-2-并行网关"><a href="#5-5-2-并行网关" class="headerlink" title="5.5.2 并行网关:"></a>5.5.2 并行网关:</h4><p>​    允许有多个fork分支进入（此时在连线上无论true，flase都会执行，即连线判断无效），等待所有分支join汇聚后才尽心下一步操作。</p>
<h4 id="5-5-3-包含网关"><a href="#5-5-3-包含网关" class="headerlink" title="5.5.3  包含网关:"></a>5.5.3  包含网关:</h4><p>​    允许有多个fork分支进入（此时在连线上判断条件是true或者无设置条件的都会执行），等待所有分支join汇聚后才尽心下一步操作。</p>
]]></content>
      <categories>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>activiti进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode100-1</title>
    <url>/2023/10/07/leetcode100-1/</url>
    <content><![CDATA[<h1 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h1><p>​    <strong>利用哈希集合或者哈希表来解题</strong></p>
<h2 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/">1. 两数之和</a></h2><p><img src="/images/leetcode100-1/image-20231007220032150.png" alt="image-20231007220032150"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A1_1</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] twoSum(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>        <span class="hljs-keyword">int</span> length = nums.length;<br>        <span class="hljs-comment">//暴力解法</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">int</span> before = nums[i];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; length; j++) &#123;<br>                <span class="hljs-keyword">int</span> after = nums[j];<br>                <span class="hljs-keyword">if</span>((before + after) == target)&#123;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;;<br>                &#125;<br><br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//进阶解法，借用hash表</span><br><span class="hljs-comment">//        Map&lt;Integer,Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="hljs-comment">//        for (int i = 0; i &lt; length; i++) &#123;</span><br><span class="hljs-comment">//            if(map.containsKey(target - nums[i]))&#123;</span><br><span class="hljs-comment">//                return new int[]&#123;map.get(target - nums[i]),i&#125;;</span><br><span class="hljs-comment">//            &#125;</span><br><span class="hljs-comment">//            map.put(nums[i],i);</span><br><span class="hljs-comment">//        &#125;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/">49. 字母异位词分组</a></h2><p><img src="/images/leetcode100-1/image-20231007220852918.png" alt="image-20231007220852918"></p>
<p>题意：把是字母异味词的字符放到一个集合里，输出所有集合</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A_49</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;<br>        Map&lt;String,List&lt;String&gt;&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (String str : strs) &#123;<br>            <span class="hljs-keyword">char</span>[] chars = str.toCharArray();<br>            Arrays.sort(chars);<br>            String sortStr = Arrays.toString(chars);<br>            <span class="hljs-keyword">if</span>(map.containsKey(sortStr))&#123;<br>                map.get(sortStr).add(str);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>                list.add(str);<br>                map.put(sortStr,list);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(map.values());<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        A_49 ins = <span class="hljs-keyword">new</span> A_49();<br>        System.out.println(ins.groupAnagrams(<span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;eat&quot;</span>, <span class="hljs-string">&quot;tea&quot;</span>, <span class="hljs-string">&quot;tan&quot;</span>, <span class="hljs-string">&quot;ate&quot;</span>, <span class="hljs-string">&quot;nat&quot;</span>, <span class="hljs-string">&quot;bat&quot;</span>&#125;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p><img src="/images/leetcode100-1/image-20231007223852167.png" alt="image-20231007223852167"></p>
<p>结题思路：</p>
<p>1、利用set存储所有元素，O(1)时间内判断是否拥有某个元素</p>
<p>2、外层遍历nums，只穷举set没有num-1的数，这样只需要递归往num+1的方向查找，整体来说外层一次for循环遍历了n次，内层while总共加起来=n次，总共2n次，所以时间复杂度是O(N)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A_128</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestConsecutive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        Set&lt;Integer&gt; set = <span class="hljs-keyword">new</span> HashSet&lt;Integer&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            set.add(nums[i]);<br>        &#125;<br>        <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(set.contains(nums[i]-<span class="hljs-number">1</span>))&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">int</span> cur = nums[i];<br>                <span class="hljs-keyword">int</span> continueLength = <span class="hljs-number">1</span>;<br>                <span class="hljs-keyword">while</span>(set.contains(cur+<span class="hljs-number">1</span>))&#123;<br>                    cur++;<br>                    continueLength++;<br>                &#125;<br>                max = Math.max(max,continueLength);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> max;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>        A_128 instance = <span class="hljs-keyword">new</span> A_128();<br>        System.out.println(instance.longestConsecutive(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">100</span>,<span class="hljs-number">4</span>,<span class="hljs-number">200</span>,<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;));<br>        System.out.println(instance.longestConsecutive(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h1><h2 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h2><p><img src="/images/leetcode100-1/image-20231014221129644.png" alt="image-20231014221129644"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">moveZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>      <span class="hljs-comment">//left:待处理0的下标，right:待处理的非0下标</span><br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> len = nums.length;<br>    <span class="hljs-keyword">while</span> (right &lt; len)&#123;<br>        <span class="hljs-keyword">if</span>(nums[right] != <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">if</span>(nums[left] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//left=0时才交换，不然没有意义，自己和自己交换</span><br><br>            &#125;<br>            left++;<br>        &#125;<br>        right++;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[left];<br>    nums[left] = nums[right];<br>    nums[right] = temp;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    A1_283 instance = <span class="hljs-keyword">new</span> A1_283();<br>    <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>&#125;;<br>    instance.moveZeroes(nums);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        System.out.print(num+ <span class="hljs-string">&quot; &quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h2><p>结题思路：左右指针分别位于2端，假设 leftValue &lt; rightValue，则向右移动leftIndex（因为即便向左移动了右端，左值与右值的较小数也不会大于左值，但2端的宽度变小，面积必然小于移动前，因此向左移动右端只会越来越小，<strong>这个左指针对应的数不会作为容器的边界了，一开始在左端，因此只能向右移动</strong>）</p>
<p><img src="/images/leetcode100-1/image-20231015211602500.png" alt="image-20231015211602500"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> beforeMax = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = height.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>        <span class="hljs-keyword">int</span> left = height[l];<br>        <span class="hljs-keyword">int</span> right = height[r];<br>        beforeMax = (r - l) * Math.min(left,right);<br>        area = Math.max(beforeMax,area);<br>        <span class="hljs-keyword">if</span>(left &lt; right)&#123;<br>            l++;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            r--;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    A2_11 ins = <span class="hljs-keyword">new</span> A2_11();<br>    <span class="hljs-keyword">int</span>[] nums = &#123;<span class="hljs-number">1</span>,<span class="hljs-number">8</span>,<span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">5</span>,<span class="hljs-number">4</span>,<span class="hljs-number">8</span>,<span class="hljs-number">3</span>,<span class="hljs-number">7</span>&#125;;<br>    System.out.println(ins.maxArea1(nums));<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/">15. 三数之和</a></h2><p>​    <strong>解题思路</strong>：从暴力解法出发，思考如何降低复杂度。排序后，固定第一个数，问题转化成第二个数+第三个数之和=某个固定数，利用双指针指向第2、3个数。</p>
<p><img src="/images/leetcode100-1/image-20231015230133039.png" alt="image-20231015230133039"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(nums == <span class="hljs-keyword">null</span> || nums.length &lt;<span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    Arrays.sort(nums);<br>    <span class="hljs-comment">//排序后，固定第一位,后两位用双指针，类似与2数之和=0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> first = nums[i];<br>        <span class="hljs-comment">//第一个数大于0，提前结束</span><br>        <span class="hljs-keyword">if</span>(first &gt; <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-comment">//前一个数和当前数相等，跳过当前数</span><br>        <span class="hljs-keyword">if</span>(i &gt; <span class="hljs-number">0</span> &amp;&amp; nums[i] == nums[i-<span class="hljs-number">1</span>] ) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-comment">//采用双指针</span><br>        <span class="hljs-keyword">int</span> l = i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> r = nums.length - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span>(l &lt; r)&#123;<br>            <span class="hljs-keyword">int</span> second = nums[l];<br>            <span class="hljs-keyword">int</span> third = nums[r];<br>            <span class="hljs-keyword">int</span> sum = first + second + third;<br>            <span class="hljs-keyword">if</span>(sum == <span class="hljs-number">0</span>)&#123;<br>                result.add(Arrays.asList(first,second,third));<br>                <span class="hljs-comment">//左移和后移动左边界和右边界重复的情况</span><br>                <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[l] == nums[l+<span class="hljs-number">1</span>])&#123;<br>                    l++;<br>                &#125;<br>                <span class="hljs-keyword">while</span>(l &lt; r &amp;&amp; nums[r] == nums[r-<span class="hljs-number">1</span>])&#123;<br>                    r--;<br>                &#125;<br>                l++;<br>                r--;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(sum &gt; <span class="hljs-number">0</span>)&#123;<br>                r--;<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                l++;<br>            &#125;<br>        &#125;<br><br><br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 双指针 + map(结合两数字之和的解法)</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum2(<span class="hljs-keyword">int</span>[] nums) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == nums || nums.length &lt; <span class="hljs-number">3</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>        Arrays.sort(nums);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-comment">//重复则存取大的下标</span><br>            map.put(nums[i],i);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            <span class="hljs-keyword">if</span>(i&gt;<span class="hljs-number">0</span> &amp;&amp; nums[i]== nums[i-<span class="hljs-number">1</span>])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>                <span class="hljs-keyword">if</span>(j != i+<span class="hljs-number">1</span> &amp;&amp; nums[j]== nums[j-<span class="hljs-number">1</span>])&#123;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                <span class="hljs-keyword">int</span> pre = -(nums[i] + nums[j]);<br>                <span class="hljs-keyword">if</span>(map.containsKey(pre) &amp;&amp; map.get(pre) &gt; j)&#123;<br>                    result.add(Arrays.asList(nums[i],nums[j],pre));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h2><p>​    结题思路：对于每个格子来说，当前格子能接到的雨水取决于左右2边是否都大于当前高度，且当前格子的水量=min（左边最高高度，右边最高高度）- 当前高度，先通过遍历维护每个格子的左、右最高高度，减少时间复杂度</p>
<p>​    想通过</p>
<p><img src="/images/leetcode100-1/image-20231017212406342.png" alt="image-20231017212406342"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//简化左右边最高列的算法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">trap1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] height)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(height.length &lt; <span class="hljs-number">3</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span>[] leftHeight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[height.length];<br>    <span class="hljs-keyword">int</span>[] rightHeight = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[height.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; height.length; i++) &#123;<br>        leftHeight[i] = Math.max(height[i-<span class="hljs-number">1</span>],leftHeight[i-<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = height.length-<span class="hljs-number">2</span>; i &gt;=<span class="hljs-number">0</span>; i--) &#123;<br>        rightHeight[i] = Math.max(height[i+<span class="hljs-number">1</span>],rightHeight[i+<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; height.length; i++) &#123;<br><br>        <span class="hljs-keyword">int</span> cur = height[i];<br>        <span class="hljs-keyword">int</span> relativeMin = Math.min(leftHeight[i],rightHeight[i]);<br>        <span class="hljs-keyword">if</span>(relativeMin &lt;= cur)&#123;<br>            sum += <span class="hljs-number">0</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            sum += (relativeMin - cur);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><h2 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h2><p>​    解题思路：滑动窗口，顾名思义，可以通过问题映射控制窗口的2边，先滑动右边，达到特殊条件时，缩小左边，直至右边划到终点。该题就是通过map来判断是否应该继续右边滑动，</p>
<p><img src="/images/leetcode100-1/image-20231018222540259.png" alt="image-20231018222540259"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">lengthOfLongestSubstring</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><br>    Map&lt;Character,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">while</span> (right &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> c = s.charAt(right);<br><br>        <span class="hljs-keyword">if</span>(map.containsKey(c) &amp;&amp; map.get(c) &gt;= left)&#123;<br>            <span class="hljs-comment">//更新重复字符的下标</span><br>            count = Math.max(count,right - left);<br>            left = map.get(c) + <span class="hljs-number">1</span>;<br>            map.put(c,right);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            map.put(c,right);<br>            count = Math.max(count,right - left + <span class="hljs-number">1</span>);<br>        &#125;<br><br>        right++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h2><p><img src="/images/leetcode100-1/image-20231025230113450.png" alt="image-20231025230113450"></p>
<p>结题思路：窗口的滑动条件比第一题复杂：初始化p的字符数组然后维护数组每个元素不小于0。 开始向右滑动窗口，减去并相应字符，如果频率小于0就收缩左侧边界直到频率不再小于0。窗口长度与p长度一致时达成条件</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pLength = p.length();<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-comment">//pCount维护还需要的下标数量</span><br>    <span class="hljs-keyword">int</span>[] pCount= <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pLength; i++) &#123;<br>        ++pCount[p.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>    &#125;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(r &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> rChar = s.charAt(r);<br>        --pCount[rChar - <span class="hljs-string">&#x27;a&#x27;</span>];<br>        <span class="hljs-comment">//右边走过头了，左移直到pCount[rChar - &#x27;a&#x27;] = 0:效果等同于l跳到窗口内左边第一个rChar的下一个位置</span><br>        <span class="hljs-keyword">while</span>(pCount[rChar - <span class="hljs-string">&#x27;a&#x27;</span>] &lt; <span class="hljs-number">0</span> &amp;&amp; l &lt;= r)&#123;<br>            ++pCount[s.charAt(l) - <span class="hljs-string">&#x27;a&#x27;</span>];<br>            l++;<br>        &#125;<br>        <span class="hljs-comment">//pCount的字母数量保证起大于等于0,此时数量一致代表满足条件</span><br>        <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span> == pLength)&#123;<br>            result.add(l);<br>        &#125;<br>        r++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 滑动窗口+map：维护需要p字符的数量</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> p</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">findAnagrams1</span><span class="hljs-params">(String s, String p)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pLength = p.length();<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Map&lt;Character,Integer&gt; needCount = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; pLength; i++) &#123;<br>        <span class="hljs-keyword">char</span> c = p.charAt(i);<br>        needCount.put(c,needCount.getOrDefault(c,<span class="hljs-number">0</span>)+<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(r &lt; s.length())&#123;<br>        <span class="hljs-keyword">char</span> rchar = s.charAt(r);<br>        <span class="hljs-comment">//需要数量-1</span><br>        needCount.put(rchar,needCount.getOrDefault(rchar,<span class="hljs-number">0</span>)-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">while</span>(needCount.get(rchar) &lt; <span class="hljs-number">0</span> &amp;&amp; l &lt;= r)&#123;<br>            <span class="hljs-keyword">char</span> lchar = s.charAt(l);<br>            needCount.put(lchar,needCount.get(lchar)+<span class="hljs-number">1</span>);<br>            l++;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(r - l + <span class="hljs-number">1</span> == pLength)&#123;<br>            result.add(l);<br>        &#125;<br>        r++;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="子串"><a href="#子串" class="headerlink" title="子串"></a>子串</h1><h2 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h2><p><img src="/images/leetcode100-1/image-20231029151439776.png" alt="image-20231029151439776"></p>
<p>​    解题思路：pre[i] = [0..i]的所有数的和，则pre[i] = pre[i-1] + nums[i] ,那么sum[j..i] = k则表示为</p>
<p>pre[i] - pre[j-1] = k ==&gt; pre[j-1] = pre[i] - k，如果pre[j-1]存在，则结果集加一</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 前缀和+hash法</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">subarraySum2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>   <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//前缀和</span><br>   <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>   <span class="hljs-comment">//key：pre=前缀和，value=出现的次数</span><br>   Map&lt;Integer,Integer&gt; dataMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>   <span class="hljs-comment">//初始化空集的场景</span><br>   dataMap.put(<span class="hljs-number">0</span>,<span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> num = nums[i];<br>        pre += num;<br>        <span class="hljs-keyword">if</span>(dataMap.containsKey(pre-k))&#123;<br>            count += dataMap.get(pre-k);<br>        &#125;<br>        dataMap.put(pre,dataMap.getOrDefault(pre,<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/">239. 滑动窗口最大值</a></h2><p><img src="/images/leetcode100-1/image-20231029222648169.png" alt="image-20231029222648169"></p>
<p>​    解题思路：基础解法是滑动窗口，窗口内的维护逻辑利用大顶堆，值大的在堆顶，每次取出堆顶时，判断堆顶元素的下标是不是超过左边界，因此堆的存储内容是int[],第一个元素存储值，第二个元素存储下标</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用大顶堆</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow2(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">int</span>[] ras = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length-k+<span class="hljs-number">1</span>];<br>    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt;((e1,e2) -&gt; &#123;<br>        <span class="hljs-keyword">if</span>(e2[<span class="hljs-number">0</span>] != e1[<span class="hljs-number">0</span>])&#123;<br>            <span class="hljs-keyword">return</span> e2[<span class="hljs-number">0</span>] - e1[<span class="hljs-number">0</span>];<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> e2[<span class="hljs-number">1</span>] - e1[<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">int</span> num = nums[i];<br>        queue.offer(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;num,i&#125;);<br>        <span class="hljs-keyword">while</span>(queue.peek()[<span class="hljs-number">1</span>] &lt;= i - k)&#123;<br>            queue.poll();<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &gt;= k-<span class="hljs-number">1</span>)&#123;<br>            ras[i-k+<span class="hljs-number">1</span>] = queue.peek()[<span class="hljs-number">0</span>];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> ras;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用单调递减队列（双端队列）,存储下标值</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] maxSlidingWindow(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    <span class="hljs-comment">//单调递减队列，存储的是nums的下标值</span><br>    LinkedList&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> LinkedList();<br>    <span class="hljs-comment">// 窗口个数</span><br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length - k + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> right = <span class="hljs-number">0</span>; right &lt; nums.length; right++) &#123;<br>        <span class="hljs-comment">// 如果队列不为空且当前考察元素大于等于队尾元素，则将队尾元素移除。</span><br>        <span class="hljs-comment">// 直到，队列为空或当前考察元素小于新的队尾元素</span><br>        <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; nums[right] &gt; nums[queue.getLast()])&#123;<br>            queue.removeLast();<br>        &#125;<br>        queue.addLast(right);<br>        <span class="hljs-keyword">int</span> left = right - k + <span class="hljs-number">1</span>;<br>        <span class="hljs-comment">//判断左窗口是否已超过队首下标</span><br>        <span class="hljs-keyword">if</span>(queue.peekFirst() &lt; left)&#123;<br>            queue.removeFirst();<br>        &#125;<br>        <span class="hljs-comment">//窗口是否已形成</span><br>        <span class="hljs-keyword">if</span>(right + <span class="hljs-number">1</span> &gt;= k )&#123;<br>            result[left] = nums[queue.peekFirst()];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="76-最小覆盖子串"><a href="#76-最小覆盖子串" class="headerlink" title="76. 最小覆盖子串"></a><a href="https://leetcode.cn/problems/minimum-window-substring/">76. 最小覆盖子串</a></h2><p><img src="/images/leetcode100-1/image-20231105162709432.png" alt="image-20231105162709432"></p>
<p><strong>解题思路：</strong>该题的突破点还是在滑动窗口内，使用合适的数据结构配合，来确认窗口内是否满足覆盖t的所有字符，而且t中字符存在重复的场景；</p>
<p>1、适用int[] tFreq来表示t中需要出现字符的次数</p>
<p>2、使用needCount表示窗口内还缺少的t中字符的个数，用该变量来判断是否满足串口覆盖t</p>
<p>3、其中tFreq的某个字符频次&lt;0时，比如=-1，其实是非t中字符出现了，原本是0，r右移多出了一个无关字符-1，l右移时，对应加上1即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">minWindow</span><span class="hljs-params">(String s, String t)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(s.length() &lt; t.length())&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>        <span class="hljs-comment">//tFreq=窗口各字符还缺少的个数</span><br>        <span class="hljs-keyword">int</span>[] tFreq = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">128</span>];<br>        <span class="hljs-comment">//needCount=滑动窗口中缺少的t中字符的个数</span><br>        <span class="hljs-keyword">int</span> needCount = t.length();<br>        <span class="hljs-keyword">int</span> minLength = Integer.MAX_VALUE;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; t.length(); i++) &#123;<br>            tFreq[t.charAt(i)]++;<br>        &#125;<br>        <span class="hljs-keyword">int</span> l,r;<br>        l = r = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (r &lt; s.length())&#123;<br>            <span class="hljs-keyword">char</span> rChar = s.charAt(r);<br>            <span class="hljs-keyword">if</span> (tFreq[rChar] &gt; <span class="hljs-number">0</span>)&#123;<br>                needCount--;<br>            &#125;<br>            tFreq[rChar]--;<br>            <span class="hljs-comment">//右边界右移</span><br>            r++;<br>            <span class="hljs-keyword">while</span> (needCount == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">char</span> lChar = s.charAt(l);<br>                <span class="hljs-comment">//表示一旦左边界向右移动，会导致 tFreq缺少的字符数增加，即不满足滑动窗口包含t的所有字符</span><br>                <span class="hljs-keyword">if</span> (tFreq[lChar] == <span class="hljs-number">0</span>)&#123;<br>                    <span class="hljs-comment">//记录左右边界和最小长度</span><br>                    <span class="hljs-keyword">if</span>(minLength &gt; (r - l + <span class="hljs-number">1</span>))&#123;<br>                        minLength = r - l + <span class="hljs-number">1</span>;<br>                        result = s.substring(l,r);<br>                    &#125;<br>                    needCount++;<br>                &#125;<br>                tFreq[lChar]++;<br>                <span class="hljs-comment">//左边界右移</span><br>                l++;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h1 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a>普通数组</h1><h2 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h2><p><img src="/images/leetcode100-1/image-20231105233802451.png" alt="image-20231105233802451"></p>
<p><strong>解题思路：</strong>f(x) = Math.max(nums[x],nums[x]+f(x-1)),f(x):以x结尾的连续子数组的最大和</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态规划</span><br><span class="hljs-comment"> * f(x) = Math.max(nums[x],nums[x]+f(x-1)),f(x):以x结尾的连续子数组的最大和</span><br><span class="hljs-comment"> * &#123;-2,1,-3,4,-1,2,1,-5,4&#125;</span><br><span class="hljs-comment"> * &#123;-2,-1,-3,4,3,5,6,1,5&#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxSubArray1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//pre代表f(x-1)</span><br>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> maxAns = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x : nums) &#123;<br>        pre = Math.max(pre + x, x);<br>        maxAns = Math.max(maxAns, pre);<br>    &#125;<br>    <span class="hljs-keyword">return</span> maxAns;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h2><p><img src="/images/leetcode100-1/image-20231106214146161.png" alt="image-20231106214146161"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[][] merge(<span class="hljs-keyword">int</span>[][] intervals) &#123;<br>    Arrays.sort(intervals,(e1,e2) -&gt; e1[<span class="hljs-number">0</span>] - e2[<span class="hljs-number">0</span>]);<br>    List&lt;<span class="hljs-keyword">int</span>[]&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; intervals.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>            result.add(intervals[<span class="hljs-number">0</span>]);<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">int</span>[] pre = result.get(result.size()-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">int</span>[] cur = intervals[i];<br>        <span class="hljs-keyword">if</span>(pre[<span class="hljs-number">1</span>] &lt; cur[<span class="hljs-number">0</span>])&#123;<br>            result.add(cur);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//合并到上一个区间</span><br>            pre[<span class="hljs-number">1</span>] = Math.max(pre[<span class="hljs-number">1</span>],cur[<span class="hljs-number">1</span>]);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result.toArray(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[result.size()][]);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h2><p><img src="/images/leetcode100-1/image-20231106220614583.png" alt="image-20231106220614583"></p>
<p>解题思路：这里采用额外空间结题</p>
<p>1、利用额外数组存储计算后的值</p>
<p>2、利用翻转算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">int</span> addK = k % length;<br>    <span class="hljs-keyword">if</span>(addK == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>            <span class="hljs-keyword">int</span> nextIndex = (i + addK) % length;<br>            result[nextIndex] = nums[i];<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; result.length; i++) &#123;<br>            nums[i] = result[i];<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h2><p><img src="/images/leetcode100-1/image-20231113223910330.png" alt="image-20231113223910330"></p>
<p>题解：f(i)=beforeMulti(i) * afterMulti(i):i之前数组的乘积 + i之后元素素组的乘积</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * beforeMulti[i]:i之前数组的乘积</span><br><span class="hljs-comment"> * afterMulti[i]:i之后元素素组的乘积</span><br><span class="hljs-comment"> * f(i)=beforeMulti(i) * afterMulti(i):i之前数组的乘积 + i之后元素素组的乘积</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] productExceptSelf2(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">int</span>[] beforeMulti = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">int</span>[] afterMulti = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">int</span> multi = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)&#123;<br>            beforeMulti[i] = multi;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            beforeMulti[i] = beforeMulti[i-<span class="hljs-number">1</span>] * nums[i-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    multi = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = nums.length-<span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span>(i == nums.length-<span class="hljs-number">1</span>)&#123;<br>            afterMulti[i] = multi;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            afterMulti[i] = afterMulti[i+<span class="hljs-number">1</span>] * nums[i+<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        result[i] = beforeMulti[i] * afterMulti[i];<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="41-缺失的第一个正数"><a href="#41-缺失的第一个正数" class="headerlink" title="41. 缺失的第一个正数"></a><a href="https://leetcode.cn/problems/first-missing-positive/">41. 缺失的第一个正数</a></h2><p><img src="/images/leetcode100-1/image-20231113224125375.png" alt="image-20231113224125375"></p>
<p>​    <strong>题解：</strong>如果利用map，可以遍历一次后维护所有key，遍历x属于1到N+1,判断key如果不存在x，则答案=x</p>
<p>1、但是map的空间复杂度=O(N)，map可以在O(1)时间内判断x是否出现过</p>
<p>2、我们要找的数就在 [1, N + 1] 里，最后 N + 1 这个元素我们不用找。因为在前面的 N 个元素都找不到的情况下，我们才返回 N + 1；那么，我们可以采取这样的思路：就把 1 这个数放到下标为 0 的位置， 2 这个数放到下标为 1 的位置，按照这种思路整理一遍数组。然后我们再遍历一次数组，第 1 个遇到的它的值不等于下标的那个数，就是我们要找的缺失的第一个正数。这个思想就相当于我们自己编写哈希函数，这个哈希函数的规则特别简单，那就是数值为 i 的数映射到下标为 i - 1 的位置。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 把数组当成hash</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">firstMissingPositive</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-number">0</span> &lt; nums[i] &amp;&amp; nums[i] &lt;= length &amp;&amp; nums[nums[i]-<span class="hljs-number">1</span>] != nums[i])&#123;<br>            swap(nums,i,nums[i]-<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(nums[i] != i+<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> length + <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] arr,<span class="hljs-keyword">int</span> left,<span class="hljs-keyword">int</span> right)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = arr[left];<br>    arr[left] = arr[right];<br>    arr[right] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a>矩阵</h1><h2 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/">73. 矩阵置零</a></h2><p><img src="/images/leetcode100-1/image-20231115223632490.png" alt="image-20231115223632490"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setZeroes</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> xLength = matrix.length;<br>    <span class="hljs-keyword">int</span> yLength = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-comment">//利用2个一维数组表示，x和y轴上是否出现过0</span><br>    <span class="hljs-keyword">boolean</span>[] x = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[xLength];<br>    <span class="hljs-keyword">boolean</span>[] y = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[yLength];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; xLength; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; yLength; j++) &#123;<br>            <span class="hljs-keyword">if</span> (matrix[i][j] == <span class="hljs-number">0</span>) &#123;<br>                x[i] = y[j] = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; xLength; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; yLength; j++) &#123;<br>            <span class="hljs-keyword">if</span> (x[i] || y[j]) &#123;<br>                matrix[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/">54. 螺旋矩阵</a></h2><p><img src="/images/leetcode100-1/image-20231115224204769.png" alt="image-20231115224204769"></p>
<p>**解题思路:**从左到右，上到下，右到左，下到上轮流遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> List&lt;Integer&gt; <span class="hljs-title">spiralOrder1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">if</span>(Objects.isNull(matrix) || matrix.length == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>   <span class="hljs-keyword">int</span> left = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> right = matrix[<span class="hljs-number">0</span>].length - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">int</span> top = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> bottom = matrix.length - <span class="hljs-number">1</span>;<br>   <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>,y = <span class="hljs-number">0</span>;<br>   <span class="hljs-keyword">int</span> resultCount = (right+<span class="hljs-number">1</span>) * (bottom+<span class="hljs-number">1</span>);<br>   <span class="hljs-keyword">while</span>(resultCount != result.size())&#123;<br>       <span class="hljs-comment">//从左到右</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = left; i &lt;= right &amp;&amp; resultCount != result.size(); i++) &#123;<br>           result.add(matrix[top][i]);<br>       &#125;<br>       top++;<br>       <span class="hljs-comment">//从上到下</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = top; i &lt;= bottom &amp;&amp; resultCount != result.size(); i++) &#123;<br>           result.add(matrix[i][right]);<br>       &#125;<br>       right--;<br>       <span class="hljs-comment">//从右到左</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = right; i &gt;= left &amp;&amp; resultCount != result.size(); i--) &#123;<br>           result.add(matrix[bottom][i]);<br>       &#125;<br>       bottom--;<br>       <span class="hljs-comment">//从下到上</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = bottom; i &gt;= top &amp;&amp; resultCount != result.size(); i--) &#123;<br>           result.add(matrix[i][left]);<br>       &#125;<br>       left++;<br>   &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h2><p><img src="/images/leetcode100-1/image-20231127224008845.png" alt="image-20231127224008845"></p>
<p><img src="/images/leetcode100-1/image-20231127230051512.png" alt="image-20231127230051512"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">	 * 原地旋转</span><br><span class="hljs-comment">  * 1、找规律，旋转90度后</span><br><span class="hljs-comment">  * [i,j] =&gt; [j,n-1-i]</span><br><span class="hljs-comment">  * [j,n-1-i] =&gt; [n-1-i,n-1-j]</span><br><span class="hljs-comment">  * [n-1-i,n-1-j] =&gt; [n-1-j,i]</span><br><span class="hljs-comment">  * [n-1-j,i] =&gt; [i,j]</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 调整顺序得</span><br><span class="hljs-comment">  * [n-1-j,i] =&gt; [i,j]</span><br><span class="hljs-comment">  * [n-1-i,n-1-j] =&gt; [n-1-j,i]</span><br><span class="hljs-comment">  * [j,n-1-i] =&gt; [n-1-i,n-1-j]</span><br><span class="hljs-comment">  * [i,j] =&gt; [j,n-1-i]</span><br><span class="hljs-comment">  *</span><br><span class="hljs-comment">  * 2、利用一个临时变量存储[i,j]</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> matrix</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = matrix.length;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n / <span class="hljs-number">2</span>; i++) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n / <span class="hljs-number">2</span>; j++) &#123;<br>             <span class="hljs-keyword">int</span> temp = matrix[i][j];<br>             matrix[i][j] = matrix[n-<span class="hljs-number">1</span>-j][i];<br>             matrix[n-<span class="hljs-number">1</span>-j][i] = matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j];<br>             matrix[n-<span class="hljs-number">1</span>-i][n-<span class="hljs-number">1</span>-j] = matrix[j][n-<span class="hljs-number">1</span>-i];<br>             matrix[j][n-<span class="hljs-number">1</span>-i] = temp;<br>         &#125;<br>     &#125;<br> &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 新增一个辅助数组</span><br><span class="hljs-comment">  * [i,j] =&gt; [j,n-1-i] ==&gt; matrix_new[j,n-1-i] = 则matrix[i,j]</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> matrix</span><br><span class="hljs-comment">  */</span><br> <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">rotate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix)</span> </span>&#123;<br>     <span class="hljs-keyword">int</span> n = matrix.length;<br>     <span class="hljs-keyword">int</span>[][] matrix_new = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n][n];<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>             matrix_new[j][n-i-<span class="hljs-number">1</span>] = matrix[i][j];<br>         &#125;<br>     &#125;<br>     <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>         <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>             matrix[i][j] = matrix_new[i][j];<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure>

<h2 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h2><p><img src="/images/leetcode100-1/image-20231129221758677.png" alt="image-20231129221758677"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从左下角开始查找，</span><br><span class="hljs-comment"> * 当前位置 = target，true，</span><br><span class="hljs-comment"> * 当前位置 &gt; target，向上找、</span><br><span class="hljs-comment"> * 当前位置 &lt; target，向右找、</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> matrix</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> row = matrix.length;<br>    <span class="hljs-keyword">int</span> col = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> i = row-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; j &lt;= col-<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(matrix[i][j] == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[i][j] &gt; target)&#123;<br>            i--;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            j++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><h2 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/">160. 相交链表</a></h2><p><img src="/images/leetcode100-1/image-20231129223125159.png" alt="image-20231129223125159"></p>
<p>解题思路：</p>
<p>1、利用List存储某一个链表，让后遍历第二个链表</p>
<p>2、利用a + b + c = b + c  +a的原理，两边同时遍历，遍历到尾后从另一个链表头从新开始，如果有交点，则会在交点相遇；</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用a + b + c = b + c  +a的原理，两边同时遍历，遍历到尾后从另一个链表头从新开始，</span><br><span class="hljs-comment"> * 如果有交点，则会在交点相遇；</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> headA </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> headB</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">getIntersectionNode3</span><span class="hljs-params">(ListNode headA, ListNode headB)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (headA == <span class="hljs-keyword">null</span> || headB == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ListNode pA = headA, pB = headB;<br>    <span class="hljs-keyword">while</span> (pA != pB) &#123;<br>        pA = pA == <span class="hljs-keyword">null</span> ? headB : pA.next;<br>        pB = pB == <span class="hljs-keyword">null</span> ? headA : pB.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pA;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h2><p><img src="/images/leetcode100-1/image-20231129225943600.png" alt="image-20231129225943600"></p>
<p>解题思路：</p>
<p>1、迭代处理</p>
<p>2、递归算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">	<span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 递归算法</span><br><span class="hljs-comment">    *</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList1</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>       ListNode listNode = head;<br>       <span class="hljs-keyword">if</span> (head != <span class="hljs-keyword">null</span> &amp;&amp; head.next != <span class="hljs-keyword">null</span>) &#123;<br>           listNode = reverseList1(head.next);<br>           head.next.next = head;<br>           head.next = <span class="hljs-keyword">null</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> listNode;<br>   &#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">    * 迭代</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">    * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">    */</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>       ListNode prev = <span class="hljs-keyword">null</span>;<br>       ListNode curr = head;<br>       <span class="hljs-keyword">while</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>           ListNode temp = curr.next;<br>           curr.next = prev;<br>           prev = curr;<br>           curr = temp;<br><br>       &#125;<br>       <span class="hljs-keyword">return</span> prev;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h2><p><img src="/images/leetcode100-1/image-20231130221652789.png" alt="image-20231130221652789"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 先转化成数组</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome2</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    List&lt;ListNode&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != cur)&#123;<br>        list.add(cur);<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">int</span> beginIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> lastIndex = list.size()-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(beginIndex &lt; lastIndex)&#123;<br>        <span class="hljs-keyword">if</span>(list.get(beginIndex).val != list.get(lastIndex).val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        beginIndex++;<br>        lastIndex--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseList</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode prev = <span class="hljs-keyword">null</span>;<br>    ListNode curr = head;<br>    <span class="hljs-keyword">while</span>(curr != <span class="hljs-keyword">null</span>)&#123;<br>        ListNode temp = curr.next;<br>        curr.next = prev;<br>        prev = curr;<br>        curr = temp;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> prev;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反转链表-整个流程可以分为以下五个步骤：</span><br><span class="hljs-comment">     * 1、找到前半部分链表的尾节点。</span><br><span class="hljs-comment">     * 2、反转后半部分链表。</span><br><span class="hljs-comment">     * 3、判断是否回文。</span><br><span class="hljs-comment">     * 4、恢复链表。</span><br><span class="hljs-comment">     * 5、返回结果。</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome1</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    ListNode left = head;<br>    ListNode rigth = head;<br>    <span class="hljs-keyword">while</span> (rigth.next != <span class="hljs-keyword">null</span> &amp;&amp; rigth.next.next!=<span class="hljs-keyword">null</span>)&#123;<br>        rigth = rigth.next.next;<br>        left = left.next;<br>    &#125;<br>    ListNode reverseHead = reverseList(left.next);<br>    ListNode leftNodeHead = head;<br>    ListNode rightNodeHead = reverseHead;<br>    <span class="hljs-keyword">while</span>(rightNodeHead != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(leftNodeHead.val != rightNodeHead.val)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        rightNodeHead = rightNodeHead.next;<br>        leftNodeHead = leftNodeHead.next;<br>    &#125;<br>    reverseHead = reverseList(reverseHead);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/">141. 环形链表</a></h2><p><img src="/images/leetcode100-1/image-20231130225040632.png" alt="image-20231130225040632"></p>
<p>解题思路：</p>
<p>1、利用list，一边遍历一边判断是否包含</p>
<p>2、快慢指针</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    List&lt;ListNode&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(nodes.contains(head))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        nodes.add(head);<br>        head = head.next;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快慢指针</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasCycle1</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode slow = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);<br>    ListNode fast = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);;<br>    <span class="hljs-keyword">while</span>((slow != <span class="hljs-keyword">null</span> &amp;&amp; fast != <span class="hljs-keyword">null</span>))&#123;<br>        slow = slow.next;<br>        fast = fast.next == <span class="hljs-keyword">null</span>?<span class="hljs-keyword">null</span>:fast.next.next;<br>        <span class="hljs-keyword">if</span>(fast != <span class="hljs-keyword">null</span> &amp;&amp; slow == fast)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h2><p><img src="/images/leetcode100-1/image-20231203213712186.png" alt="image-20231203213712186"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    List&lt;ListNode&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">while</span>(head != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">if</span>(nodes.contains(head))&#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        nodes.add(head);<br>        head = head.next;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 快慢指针法</span><br><span class="hljs-comment"> * 1、假设存在环，a:head到入环点,b:入环点到快慢指针的相交点,c:相交点到入环点的距离</span><br><span class="hljs-comment"> * 则根据快慢指针有：a+b+n(b+c) = a+b =&gt; a = (n-1)(b+c)+c</span><br><span class="hljs-comment"> * 即：从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</span><br><span class="hljs-comment"> * 即一个从相遇点出发，一个从开头出发，会在入环点相交</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">detectCycle</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode slow = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);<br>    ListNode fast = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);<br>    <span class="hljs-keyword">while</span>((slow != <span class="hljs-keyword">null</span> &amp;&amp; fast != <span class="hljs-keyword">null</span>))&#123;<br>        slow = slow.next;<br>        fast = fast.next == <span class="hljs-keyword">null</span>?<span class="hljs-keyword">null</span>:fast.next.next;<br>        <span class="hljs-keyword">if</span>(slow != <span class="hljs-keyword">null</span> &amp;&amp; slow == fast)&#123;<br>            ListNode preHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);<br>            <span class="hljs-keyword">while</span>(preHead != slow)&#123;<br>                preHead = preHead.next;<br>                slow = slow.next;<br>            &#125;<br>            <span class="hljs-keyword">return</span> slow;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h2><p><img src="/images/leetcode100-1/image-20231205211557220.png" alt="image-20231205211557220"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;<br>       ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>       ListNode cur = pre;<br>       <span class="hljs-keyword">while</span>(list1 != <span class="hljs-keyword">null</span> &amp;&amp; list2 != <span class="hljs-keyword">null</span>)&#123;<br>           <span class="hljs-keyword">if</span>(list1.val &lt;= list2.val)&#123;<br>               cur.next = list1;<br>               list1 = list1.next;<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               cur.next = list2;<br>               list2 = list2.next;<br>           &#125;<br>           cur = cur.next;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(list1 != <span class="hljs-keyword">null</span>)&#123;<br>           cur.next = list1;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(list2 != <span class="hljs-keyword">null</span>)&#123;<br>           cur.next = list2;<br>       &#125;<br>       <span class="hljs-keyword">return</span> pre.next;<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h2><p><img src="/images/leetcode100-1/image-20231205211748244.png" alt="image-20231205211748244"></p>
<p>解题思路：关键点——标志位int add = 0表示是否进一位</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ListNode <span class="hljs-title">addTwoNumbers</span><span class="hljs-params">(ListNode l1, ListNode l2)</span> </span>&#123;<br>    ListNode list1 = l1;<br>    ListNode list2 = l2;<br>    ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    ListNode cur = pre;<br>    <span class="hljs-keyword">int</span> add = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(list1 !=<span class="hljs-keyword">null</span> || list2 !=<span class="hljs-keyword">null</span> || add == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">int</span> val1 = list1 != <span class="hljs-keyword">null</span>?list1.val:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> val2 = list2 != <span class="hljs-keyword">null</span>?list2.val:<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> value = (val1 + val2 + add) % <span class="hljs-number">10</span>;<br>        add = (val1 + val2 + add) &gt;= <span class="hljs-number">10</span> ? <span class="hljs-number">1</span>:<span class="hljs-number">0</span>;<br>        cur.next = <span class="hljs-keyword">new</span> ListNode(value);<br>        cur = cur.next;<br>        list1 = list1!=<span class="hljs-keyword">null</span>?list1.next:<span class="hljs-keyword">null</span>;<br>        list2 = list2!=<span class="hljs-keyword">null</span>?list2.next:<span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/">19. 删除链表的倒数第 N 个结点</a></h2><p><img src="/images/leetcode100-1/image-20231205224045839.png" alt="image-20231205224045839"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 双指针：</span><br><span class="hljs-comment"> * 1：2个指针先间隔n的距离</span><br><span class="hljs-comment"> * 2:2个指针同步向后移动，直至后一个指针移动到尾部</span><br><span class="hljs-comment"> * 3:做删除操作</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    ListNode pre = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    pre.next = head;<br>    ListNode first = pre;<br>    ListNode second = pre;<br>    <span class="hljs-keyword">while</span>(n-- &gt; <span class="hljs-number">0</span>)&#123;<br>        first = first.next;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(first !=<span class="hljs-keyword">null</span> &amp;&amp; first.next != <span class="hljs-keyword">null</span>)&#123;<br>        first = first.next;<br>        second = second.next;<br>    &#125;<br>    second.next = second.next.next;<br>    <span class="hljs-keyword">return</span> pre.next;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用list</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">removeNthFromEnd2</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    List&lt;ListNode&gt; nodes = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    ListNode pre = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    nodes.add(pre);<br>    pre.next = head;<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;<br>        nodes.add(cur);<br>        cur = cur.next;<br>    &#125;<br>    nodes.get(nodes.size() - n - <span class="hljs-number">1</span>).next = nodes.get(nodes.size() - n).next;<br>    <span class="hljs-keyword">return</span> nodes.get(<span class="hljs-number">0</span>).next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h2><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 借助双指针first、second</span><br><span class="hljs-comment"> * 双指针的前置指针 pre</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode(-<span class="hljs-number">1</span>);<br>    <span class="hljs-comment">//pre 表示first和second中first的前一个节点</span><br>    dummyHead.next = head;<br>    ListNode pre = dummyHead;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode first = dummyHead;<br>    ListNode second = dummyHead;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != first.next &amp;&amp; <span class="hljs-keyword">null</span> != first.next.next)&#123;<br>        first = first.next;<br>        second = first.next;<br>        <span class="hljs-comment">//新链的前置节点.next = second</span><br>        pre.next = second;<br>        first.next = second.next;<br>        second.next = first;<br>        pre = first;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归</span><br><span class="hljs-comment"> * 双指针的前置指针 pre</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">swapPairs1</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode newHead = head.next;<br>    head.next = swapPairs1(newHead.next);<br>    newHead.next = head;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h2><p>解题思路：解法与2个一组翻转链表基本一致，区别在于维护步长n，尝试找n个一组，才翻转，并且维护翻转前后的pre和next</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归算法</span><br><span class="hljs-comment"> * 1、找出反转前的原head(反转后的尾结点),反转前的尾结点newHead(反转之后的头结点)</span><br><span class="hljs-comment"> * 2、temp = newHead.next,临时存储待反转的后续节点,newHead.next = null，以便反转</span><br><span class="hljs-comment"> * 3、反转head-&gt;newHead这个链表</span><br><span class="hljs-comment"> * 4、head.next = 递归(newHead.next)1-4点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span> || head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode newHead = head;<br>    <span class="hljs-keyword">int</span> n = k;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-number">1</span> &amp;&amp; newHead.next != <span class="hljs-keyword">null</span>)&#123;<br>        newHead = newHead.next;<br>        n--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(n != <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        ListNode temp = newHead.next;<br>        newHead.next = <span class="hljs-keyword">null</span>;<br>        reverse(head);<br>        head.next = reverseKGroup(temp,k);<br>    &#125;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> ListNode <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    ListNode newHead = <span class="hljs-keyword">null</span>;<br>    ListNode curr = head;<br>    <span class="hljs-keyword">while</span> (curr != <span class="hljs-keyword">null</span>) &#123;<br>        ListNode next = curr.next;<br>        curr.next = newHead;<br>        newHead = curr;<br>        curr = next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 迭代法</span><br><span class="hljs-comment"> * 1、尝试遍历k个节点</span><br><span class="hljs-comment"> * 2、遍历k个，则借助begin，end 翻转之后</span><br><span class="hljs-comment"> * 3、没有遍历完成，则保持原样</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">reverseKGroup1</span><span class="hljs-params">(ListNode head, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span> || head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode dump = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>);<br>    dump.next = head;<br>    ListNode pre = dump;<br>    ListNode begin = dump;<br>    ListNode end = dump;<br>    <span class="hljs-keyword">while</span>(end.next != <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">int</span> n = k;<br>        begin = pre.next;<br>        <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span> &amp;&amp; end.next != <span class="hljs-keyword">null</span>)&#123;<br>            n--;<br>            end = end.next;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>)&#123;<br>            ListNode temp = end.next;<br>            end.next = <span class="hljs-keyword">null</span>;<br>            pre.next = reverse(begin);<br>            pre = begin;<br>            end = pre;<br>            end.next = temp;<br><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> dump.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="138-随机链表的复制"><a href="#138-随机链表的复制" class="headerlink" title="138. 随机链表的复制"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></h2><p><img src="/images/leetcode100-1/image-20240123224059146.png" alt="image-20240123224059146"></p>
<h3 id="解法一：遍历2次"><a href="#解法一：遍历2次" class="headerlink" title="解法一：遍历2次"></a>解法一：遍历2次</h3><p>第一次：根据next组装next链，且维护新旧节点的map，第二次根据map组装random链</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 遍历2次 + hasmap</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList1</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    Node oriDummyHead = <span class="hljs-keyword">new</span> Node(-<span class="hljs-number">1</span>);<br>    Node dummyHead = <span class="hljs-keyword">new</span> Node(-<span class="hljs-number">1</span>);<br>    oriDummyHead.next = head;<br>    dummyHead.next = <span class="hljs-keyword">new</span> Node(head.val);<br>    Node newCur = dummyHead;<br>    Node cur = oriDummyHead.next;<br>    Map&lt;Node,Node&gt; nodeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        newCur.next = <span class="hljs-keyword">new</span> Node(cur.val);<br>        newCur = newCur.next;<br>        nodeMap.put(cur,newCur);<br><br>        cur = cur.next;<br>    &#125;<br>    cur = oriDummyHead.next;<br>    newCur = dummyHead.next;<br>    <span class="hljs-keyword">while</span>(newCur != <span class="hljs-keyword">null</span>)&#123;<br>        newCur.random = nodeMap.get(cur.random);<br>        cur = cur.next;<br>        newCur = newCur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：递归-维护新旧节点关系map"><a href="#解法二：递归-维护新旧节点关系map" class="headerlink" title="解法二：递归+维护新旧节点关系map"></a>解法二：递归+维护新旧节点关系map</h3><p>递归时，组装next、random链表时从map中取，没则新建维护进map</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Node,Node&gt; nodeMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList2</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(nodeMap.containsKey(head))&#123;<br>        <span class="hljs-keyword">return</span> nodeMap.get(head);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        Node newNode = <span class="hljs-keyword">new</span> Node(head.val);<br>        nodeMap.put(head,newNode);<br>        newNode.next = copyRandomList2(head.next);<br>        newNode.random = copyRandomList2(head.random);<br>        <span class="hljs-keyword">return</span> newNode;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：A-gt-B-gt-C-gt-A-gt-A’-gt-B-gt-B’-gt-C-gt-C’"><a href="#解法三：A-gt-B-gt-C-gt-A-gt-A’-gt-B-gt-B’-gt-C-gt-C’" class="headerlink" title="解法三：A-&gt;B-&gt;C  ==&gt; A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’"></a>解法三：A-&gt;B-&gt;C  ==&gt; A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’</h3><p>1、复制copy节点， A-&gt;A’-&gt;B-&gt;B’-&gt;C-&gt;C’<br>2、维护random节点，A’的random节点=A的random节点的next<br>3、利用next属性断开新链表得到A’-&gt;B’-&gt;C’</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 影子复制法</span><br><span class="hljs-comment"> * 1、利用next遍历一次，复制节点位于源节点的下一个节点</span><br><span class="hljs-comment"> * 2、再利用next遍历一次，copy.random = cur.random == null?null:cur.random.next;</span><br><span class="hljs-comment"> * 3、再利用next遍历一次，分开复制节点和源节点，返回复制链表节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Node <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    Node cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;<br>        Node node = <span class="hljs-keyword">new</span> Node(cur.val);<br>        node.next = cur.next;<br>        cur.next = node;<br>        cur = node.next;<br>    &#125;<br>    cur = head;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;<br>        Node copyNode = cur.next;<br>        Node random = cur.random;<br>        <span class="hljs-keyword">if</span>(random != <span class="hljs-keyword">null</span>)&#123;<br>            copyNode.random = random.next;<br>        &#125;<br>        cur = cur.next.next;<br>    &#125;<br>    cur = head;<br>    Node newHead = head.next;<br>    <span class="hljs-keyword">while</span> (cur != <span class="hljs-keyword">null</span>)&#123;<br>        Node copyNode = cur.next;<br>        cur.next = copyNode.next;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != cur.next)&#123;<br>            copyNode.next = cur.next.next;<br>        &#125;<br>        cur = cur.next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> newHead;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/">148. 排序链表</a></h2><p><img src="/images/leetcode100-1/image-20240123231924214.png" alt="image-20240123231924214"></p>
<h3 id="解法一-推荐-：自顶向下归并排序"><a href="#解法一-推荐-：自顶向下归并排序" class="headerlink" title="解法一(推荐)：自顶向下归并排序"></a>解法一(推荐)：自顶向下归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用归并排序，自上而下</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList1</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    ListNode slow = head;<br>    ListNode fast = head;<br>    <span class="hljs-keyword">while</span>(fast.next != <span class="hljs-keyword">null</span> &amp;&amp; fast.next.next != <span class="hljs-keyword">null</span>)&#123;<br>        slow = slow.next;<br>        fast = fast.next.next;<br>    &#125;<br><br>    ListNode newHead = slow.next;<br>    slow.next = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">return</span> mergeTwoLists(sortList1(head),sortList1(newHead));<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(list1 == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list2 == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(list1.val &lt;= list2.val)&#123;<br>        list1.next = mergeTwoLists(list1.next,list2);<br>        <span class="hljs-keyword">return</span> list1;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        list2.next = mergeTwoLists(list1,list2.next);<br>        <span class="hljs-keyword">return</span> list2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：自底向上归并排序"><a href="#解法二：自底向上归并排序" class="headerlink" title="解法二：自底向上归并排序"></a>解法二：自底向上归并排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 自底向上</span><br><span class="hljs-comment"> * 归并思路</span><br><span class="hljs-comment"> * 先假设步长=1，然后步长=2,4,8</span><br><span class="hljs-comment"> * 每个步长都循环执行找到头结点1,2。合并1,2。知道最后一个节点</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> head</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">sortList2</span><span class="hljs-params">(ListNode head)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(head == <span class="hljs-keyword">null</span> || head.next == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> head;<br>    &#125;<br>    <span class="hljs-keyword">int</span> length = <span class="hljs-number">0</span>;<br>    ListNode cur = head;<br>    <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>        length++;<br>        cur = cur.next;<br>    &#125;<br>    ListNode dummyHead = <span class="hljs-keyword">new</span> ListNode(<span class="hljs-number">0</span>,head);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i = (i &lt;&lt; <span class="hljs-number">1</span>)) &#123;<br><br><br>        ListNode pre = dummyHead;<br>        cur = pre.next;<br><br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>            ListNode head1 = cur;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i &amp;&amp; cur.next != <span class="hljs-keyword">null</span>; j++) &#123;<br>                cur = cur.next;<br>            &#125;<br>            ListNode head2 = cur.next;<br>            cur.next = <span class="hljs-keyword">null</span>;<br>            cur = head2;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt; i &amp;&amp; cur!= <span class="hljs-keyword">null</span> &amp;&amp; cur.next != <span class="hljs-keyword">null</span>; j++) &#123;<br>                cur = cur.next;<br>            &#125;<br>            ListNode next = <span class="hljs-keyword">null</span>;<br>            <span class="hljs-keyword">if</span>(cur != <span class="hljs-keyword">null</span>)&#123;<br>                next = cur.next;<br>                cur.next = <span class="hljs-keyword">null</span>;<br><br>            &#125;<br>            pre.next = mergeTwoLists(head1,head2);<br><br>            <span class="hljs-keyword">while</span>(pre.next != <span class="hljs-keyword">null</span>)&#123;<br>                pre = pre.next;<br>            &#125;<br>            cur = next;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> dummyHead.next;<br>    <br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">23. 合并 K 个升序链表</a></h2><p><img src="/images/leetcode100-1/image-20240128112031607.png" alt="image-20240128112031607"></p>
<p>解法解析：类似合并2个有序队列，区别在于方法入参变成ListNode[] lists</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归算法= fx(lists)</span><br><span class="hljs-comment"> * 1、每次找出lists数组中最小的节点list</span><br><span class="hljs-comment"> * 2、lists[list的下标] = list.next</span><br><span class="hljs-comment"> * 3、list.next = f(lists)</span><br><span class="hljs-comment"> * 4、return list;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> lists</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ListNode <span class="hljs-title">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == lists)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    ListNode lessNode = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">int</span> index = -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; lists.length; i++) &#123;<br>        ListNode list = lists[i];<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == lessNode || (<span class="hljs-keyword">null</span> != list &amp;&amp; list.val &lt; lessNode.val))&#123;<br>            lessNode = list;<br>            index = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(lessNode == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br>    lists[index] = lists[index].next;<br>    lessNode.next = mergeKLists(lists);<br>    <span class="hljs-keyword">return</span> lessNode;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="146-LRU-缓存"><a href="#146-LRU-缓存" class="headerlink" title="146. LRU 缓存"></a><a href="https://leetcode.cn/problems/lru-cache/">146. LRU 缓存</a></h2><p><img src="/images/leetcode100-1/image-20240128125456771.png" alt="image-20240128125456771"></p>
<h3 id="解法一：Queue-Map"><a href="#解法一：Queue-Map" class="headerlink" title="解法一：Queue+Map"></a>解法一：Queue+Map</h3><p>比较慢：queue ArrayBlockingQueue对删除操作较慢</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache2</span></span>&#123;<br>    Queue&lt;Integer&gt; queue;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">private</span> Integer capacity;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache2</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        queue = <span class="hljs-keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(capacity);<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;<br>            queue.remove(key);<br>            queue.add(key);<br>            <span class="hljs-keyword">return</span> map.get(key);<br>        &#125;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(map.containsKey(key))&#123;<br>           queue.remove(key);<br>           queue.add(key);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(map.size() == capacity)&#123;<br>                Integer poll = queue.poll();<br>                map.remove(poll);<br>            &#125;<br>            queue.add(key);<br><br>        &#125;<br>        map.put(key,value);<br>    &#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：自定义双向链表-Map"><a href="#解法二：自定义双向链表-Map" class="headerlink" title="解法二：自定义双向链表+Map"></a>解法二：自定义双向链表+Map</h3><p>封装方法doAddToHead、doRemoveNode</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache3</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ListNode</span></span>&#123;<br>        ListNode next;<br>        ListNode pre;<br>        <span class="hljs-keyword">int</span> key;<br>        <span class="hljs-keyword">int</span> val;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> val)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.key = key;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ListNode</span><span class="hljs-params">()</span></span>&#123;<br>        &#125;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ListNode&#123;&quot;</span>+ <span class="hljs-string">&quot;, key=&quot;</span> + key + <span class="hljs-string">&quot;, val=&quot;</span> + val + <span class="hljs-string">&quot;next=&quot;</span> + next +<span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> capacity;<br>    <span class="hljs-keyword">private</span> ListNode head,tail;<br>    <span class="hljs-keyword">private</span> Map&lt;Integer,ListNode&gt; dataMap;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache3</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>        head = <span class="hljs-keyword">new</span> ListNode();<br>        tail = <span class="hljs-keyword">new</span> ListNode();<br>        head.next = tail;<br>        tail.pre = head;<br>        dataMap  = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key,<span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        ListNode node = <span class="hljs-keyword">new</span> ListNode(key,value);<br>        <span class="hljs-keyword">if</span>(dataMap.containsKey(key))&#123;<br>            ListNode oldNode = dataMap.get(key);<br>            <span class="hljs-comment">//移除节点</span><br>            doRemoveNode(oldNode);<br>            <span class="hljs-comment">//加入头结点</span><br>            doAddToHead(node);<br>            dataMap.put(key,node);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            dataMap.put(key,node);<br>            doAddToHead(node);<br>            <span class="hljs-keyword">if</span>(dataMap.size() &gt; capacity)&#123;<br>                <span class="hljs-comment">//移除尾节点</span><br>                ListNode lastNode = tail.pre;<br>                dataMap.remove(lastNode.key);<br>                doRemoveNode(lastNode);<br>            &#125;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(dataMap.containsKey(key))&#123;<br>            <span class="hljs-comment">//移除节点</span><br>            ListNode node = dataMap.get(key);<br>            doRemoveNode(node);<br>            <span class="hljs-comment">//加入头结点</span><br>            doAddToHead(node);<br>            <span class="hljs-keyword">return</span> node.val;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doAddToHead</span><span class="hljs-params">(ListNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node.next = head.next;<br>        head.next.pre = node;<br>        node.pre = head;<br>        head.next = node;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doRemoveNode</span><span class="hljs-params">(ListNode node)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(node == <span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        node.pre.next = node.next;<br>        node.next.pre = node.pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法三：Java自带实现"><a href="#解法三：Java自带实现" class="headerlink" title="解法三：Java自带实现"></a>解法三：Java自带实现</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LRUCache1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LinkedHashMap</span>&lt;<span class="hljs-title">Integer</span>,<span class="hljs-title">Integer</span>&gt;</span>&#123;<br><span class="hljs-comment">//    方法一：利用java自带的实现</span><br><br>    <span class="hljs-keyword">private</span> Integer capacity;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LRUCache1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> capacity)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(capacity,<span class="hljs-number">0.75F</span>,<span class="hljs-keyword">true</span>);<br>        <span class="hljs-keyword">this</span>.capacity = capacity;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.getOrDefault(key,-<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">put</span><span class="hljs-params">(<span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> value)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.put(key,value);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">removeEldestEntry</span><span class="hljs-params">(Map.Entry&lt;Integer, Integer&gt; eldest)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">super</span>.size() &gt; capacity;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h1 id="二分查找1"><a href="#二分查找1" class="headerlink" title="二分查找1"></a>二分查找1</h1><h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1>]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>leetcode100-2</title>
    <url>/2024/02/02/leetcode100-2/</url>
    <content><![CDATA[<h1 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h1><h2 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></h2><p><img src="/images/leetcode100-2/image-20240202092200947.png" alt="image-20240202092200947"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numIslands1</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = grid.length;<br>    <span class="hljs-keyword">int</span> c = grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>                ++ result;<br>                dfs(grid,i,j);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] grid,<span class="hljs-keyword">int</span> r,<span class="hljs-keyword">int</span> c)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(r &gt;= grid.length || c &gt;= grid[<span class="hljs-number">0</span>].length || r &lt; <span class="hljs-number">0</span> || c &lt; <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(grid[r][c] != <span class="hljs-string">&#x27;1&#x27;</span>)&#123;<br>        <span class="hljs-comment">//海洋或者已标记</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">//标记已访问</span><br>    grid[r][c] = <span class="hljs-string">&#x27;2&#x27;</span>;<br>    dfs(grid,r+<span class="hljs-number">1</span>,c);<br>    dfs(grid,r-<span class="hljs-number">1</span>,c);<br>    dfs(grid,r,c+<span class="hljs-number">1</span>);<br>    dfs(grid,r,c-<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h2><p><img src="/images/leetcode100-2/image-20240202093311492.png" alt="image-20240202093311492"></p>
<p>利用队列+宽度遍历</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">orangesRotting</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> r = grid.length;<br>    <span class="hljs-keyword">int</span> c = grid[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>; <span class="hljs-comment">// count 表示新鲜橘子的数量</span><br>    <span class="hljs-keyword">int</span> round = <span class="hljs-number">0</span>; <span class="hljs-comment">// round 表示腐烂的轮数，或者分钟数</span><br>    Queue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; r; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; c; j++) &#123;<br>            <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">2</span>)&#123;<br>                queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;i,j&#125;);<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(grid[i][j] == <span class="hljs-number">1</span>)&#123;<br>                count++;<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!queue.isEmpty() &amp;&amp; count &gt; <span class="hljs-number">0</span>)&#123;<br>        round++;<br>        <span class="hljs-keyword">int</span> n = queue.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            <span class="hljs-keyword">int</span>[] orange = queue.poll();<br>            <span class="hljs-keyword">int</span> row = orange[<span class="hljs-number">0</span>];<br>            <span class="hljs-keyword">int</span> col = orange[<span class="hljs-number">1</span>];<br><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">4</span>; k++) &#123;<br>                <span class="hljs-keyword">int</span> x = row + dx[k];<br>                <span class="hljs-keyword">int</span> y = col + dy[k];<br>                <span class="hljs-keyword">if</span>(x &gt;= <span class="hljs-number">0</span> &amp;&amp; x &lt; r &amp;&amp; y &gt;= <span class="hljs-number">0</span> &amp;&amp; y &lt; c &amp;&amp; grid[x][y] == <span class="hljs-number">1</span>)&#123;<br>                    grid[x][y] = <span class="hljs-number">2</span>;<br>                    count--;<br>                    queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;x,y&#125;);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (count &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> round;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/">207. 课程表</a></h2><p><img src="/images/leetcode100-2/image-20240203133932264.png" alt="image-20240203133932264"></p>
<p><img src="/images/leetcode100-2/image-20240203133917768.png" alt="image-20240203133917768"></p>
<h3 id="解法：有向图-入度-队列-宽度优先遍历"><a href="#解法：有向图-入度-队列-宽度优先遍历" class="headerlink" title="解法：有向图 +入度+队列+ 宽度优先遍历"></a>解法：有向图 +入度+队列+ 宽度优先遍历</h3><p>思路：先学没有前置课程的课程，维护所有课程的入度（前置课程数），学完对应课程C1后，维护其他以C1为前置课程的课程的入度-1，利用队列存储入度为0的课程，循环迭代，直到队列为空。如果课程学习完毕，则完成，否则说明存在有向环，存在死循环</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canFinish</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numCourses, <span class="hljs-keyword">int</span>[][] prerequisites)</span> </span>&#123;<br>    <span class="hljs-comment">//维护每个节点的入度，下标表示第index课程</span><br>    <span class="hljs-keyword">int</span>[] indegrees = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[numCourses];<br>    <span class="hljs-comment">//维护每个课程的后置课程</span><br>    List&lt;List&lt;Integer&gt;&gt; outSides = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Queue&lt;Integer&gt; queue = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">int</span> visitCount = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numCourses; i++) &#123;<br>        outSides.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span>[] prerequisite : prerequisites) &#123;<br>        indegrees[prerequisite[<span class="hljs-number">0</span>]]++;<br>        outSides.get(prerequisite[<span class="hljs-number">1</span>]).add(prerequisite[<span class="hljs-number">0</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; indegrees.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(indegrees[i] == <span class="hljs-number">0</span>)&#123;<br>            queue.offer(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (!queue.isEmpty())&#123;<br>        Integer pre = queue.poll();<br>        visitCount ++;<br>        <span class="hljs-keyword">for</span> (Integer node : outSides.get(pre)) &#123;<br>            indegrees[node]--;<br>            <span class="hljs-keyword">if</span>(indegrees[node] == <span class="hljs-number">0</span>)&#123;<br>                queue.offer(node);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> visitCount == numCourses;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="208-实现-Trie-前缀树"><a href="#208-实现-Trie-前缀树" class="headerlink" title="208. 实现 Trie (前缀树)"></a><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/">208. 实现 Trie (前缀树)</a></h2><p><img src="/images/leetcode100-2/image-20240203163828876.png" alt="image-20240203163828876"></p>
<p>解题思路：实现一种数据结构，能够像树形结构那样层层向下检索字符串的每个字符，且字符都是小写，告诉了我们下一个字母只有26种可能，且需要支持search功能，说明得直到是否包含某个字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Trie</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Trie[] children;<br>    <span class="hljs-comment">//当前单词是否为某个字符串的结束符</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isEnd;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Trie</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.isEnd = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-comment">//实际不存储char，Trie的下标来标识</span><br>        children = <span class="hljs-keyword">new</span> Trie[<span class="hljs-number">26</span>];<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; word.length(); i++) &#123;<br>            <span class="hljs-keyword">char</span> c = word.charAt(i);<br>            <span class="hljs-keyword">int</span> index = c - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(Objects.isNull(node.children[index]))&#123;<br>                node.children[index] = <span class="hljs-keyword">new</span> Trie();<br>            &#125;<br>            node = node.children[index];<br>        &#125;<br>        node.isEnd = <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">search</span><span class="hljs-params">(String word)</span> </span>&#123;<br>        Trie trie = prefixWith(word);<br>        <span class="hljs-keyword">if</span>(trie != <span class="hljs-keyword">null</span> &amp;&amp; trie.isEnd)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">startsWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> prefixWith(prefix) != <span class="hljs-keyword">null</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Trie <span class="hljs-title">prefixWith</span><span class="hljs-params">(String prefix)</span> </span>&#123;<br>        Trie node = <span class="hljs-keyword">this</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prefix.length(); i++) &#123;<br>            <span class="hljs-keyword">int</span> index = prefix.charAt(i) - <span class="hljs-string">&#x27;a&#x27;</span>;<br>            <span class="hljs-keyword">if</span>(node.children[index]!=<span class="hljs-keyword">null</span>)&#123;<br>                node = node.children[index];<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> node;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h1><h2 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/">46. 全排列</a></h2><p><img src="/images/leetcode100-2/image-20240204212627612.png" alt="image-20240204212627612"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; permute1(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">boolean</span>[] visited = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[nums.length];<br>    dfs2(nums, path, visited);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, Deque&lt;Integer&gt; path, <span class="hljs-keyword">boolean</span>[] visited)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (nums.length == path.size()) &#123;<br>        result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(!visited[i])&#123;<br>            Integer num = nums[i];<br>            visited[i] = <span class="hljs-keyword">true</span>;<br>            path.push(num);<br>            dfs2(nums,path,visited);<br>            visited[i] = <span class="hljs-keyword">false</span>;<br>            path.pop();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h2><p><img src="/images/leetcode100-2/image-20240204224047558.png" alt="image-20240204224047558"></p>
<h3 id="解法一：迭代-遍历前一个结果集"><a href="#解法一：迭代-遍历前一个结果集" class="headerlink" title="解法一：迭代+遍历前一个结果集"></a>解法一：迭代+遍历前一个结果集</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; before = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    result.add(before);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        <span class="hljs-keyword">int</span> size = result.size();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; size; i++) &#123;<br>            List&lt;Integer&gt; copy = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(result.get(i));<br>            copy.add(num);<br>            result.add(copy);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="解法二：回溯-满二叉树"><a href="#解法二：回溯-满二叉树" class="headerlink" title="解法二：回溯+满二叉树"></a>解法二：回溯+满二叉树</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; subsets2(<span class="hljs-keyword">int</span>[] nums) &#123;<br>    Deque&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;(nums.length);<br>    dfs2(nums,<span class="hljs-number">0</span>,path);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> i, Deque&lt;Integer&gt; path)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i &gt;= nums.length)&#123;<br>        result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> num = nums[i];<br>    <span class="hljs-comment">//不选num</span><br>    dfs2(nums,i+<span class="hljs-number">1</span>,path);<br>    path.push(num);<br>    <span class="hljs-comment">//选num</span><br>    dfs2(nums,i+<span class="hljs-number">1</span>,path);<br>    path.pop();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h2><p><img src="/images/leetcode100-2/image-20240205215928856.png" alt="image-20240205215928856"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">Map&lt;Character,String&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归+回溯+深度优先</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> digits</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">letterCombinations1</span><span class="hljs-params">(String digits)</span> </span>&#123;<br>    map.put(<span class="hljs-string">&#x27;2&#x27;</span>,<span class="hljs-string">&quot;abc&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;3&#x27;</span>, <span class="hljs-string">&quot;def&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;4&#x27;</span>, <span class="hljs-string">&quot;ghi&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;5&#x27;</span>, <span class="hljs-string">&quot;jkl&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;6&#x27;</span>, <span class="hljs-string">&quot;mno&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;7&#x27;</span>, <span class="hljs-string">&quot;pqrs&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;8&#x27;</span>, <span class="hljs-string">&quot;tuv&quot;</span>);<br>    map.put(<span class="hljs-string">&#x27;9&#x27;</span>, <span class="hljs-string">&quot;wxyz&quot;</span>);<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">char</span>[] chars = digits.toCharArray();<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == digits || digits.length() == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>    dfs(chars,<span class="hljs-number">0</span>,result,path);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[] chars, <span class="hljs-keyword">int</span> i, List&lt;String&gt; result, Deque&lt;String&gt; path)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i == chars.length)&#123;<br>        result.add(String.join(<span class="hljs-string">&quot;&quot;</span>, path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">char</span> aChar = chars[i];<br>    String mapStr = map.get(aChar);<br>    <span class="hljs-keyword">for</span> (Character s : mapStr.toCharArray()) &#123;<br>        path.addLast(s+<span class="hljs-string">&quot;&quot;</span>);<br>        dfs(chars,i+<span class="hljs-number">1</span>,result,path);<br>        path.removeLast();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="39-组合总和"><a href="#39-组合总和" class="headerlink" title="39. 组合总和"></a><a href="https://leetcode.cn/problems/combination-sum/">39. 组合总和</a></h2><p><img src="/images/leetcode100-2/image-20240205224606093.png" alt="image-20240205224606093"></p>
<p><img src="/images/leetcode100-2/image-20240205224644462.png" alt="image-20240205224644462"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 回溯算法 + 剪枝</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> candidates</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> target) &#123;<br>    Arrays.sort(candidates);<br>    List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Integer&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    dfs(candidates,<span class="hljs-number">0</span>,path,result,target);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] candidates, <span class="hljs-keyword">int</span> i, List&lt;Integer&gt; path, List&lt;List&lt;Integer&gt;&gt; result,<span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(target &lt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">if</span>(target == <span class="hljs-number">0</span>)&#123;<br>            result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-comment">//j = i去除重复组合</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; candidates.length; j++) &#123;<br>        <span class="hljs-keyword">int</span> num = candidates[j];<br>        path.add(num);<br>        <span class="hljs-keyword">boolean</span> breakFlag = dfs(candidates, j, path, result, target - num);<br>        path.remove(path.size()-<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span>(breakFlag)&#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="22-括号生成"><a href="#22-括号生成" class="headerlink" title="22. 括号生成"></a><a href="https://leetcode.cn/problems/generate-parentheses/">22. 括号生成</a></h2><p><img src="/images/leetcode100-2/image-20240207105648586.png" alt="image-20240207105648586"></p>
<p>简单递归|回溯</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    dfs2(<span class="hljs-string">&quot;&quot;</span>,n,n);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs2</span><span class="hljs-params">(String s, <span class="hljs-keyword">int</span> leftN, <span class="hljs-keyword">int</span> rightN)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(leftN == <span class="hljs-number">0</span> &amp;&amp; rightN == <span class="hljs-number">0</span>)&#123;<br>        result.add(s);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(leftN &gt; <span class="hljs-number">0</span>)&#123;<br>        dfs2(s+<span class="hljs-string">&quot;(&quot;</span>,leftN-<span class="hljs-number">1</span>,rightN);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(leftN &lt; rightN)&#123;<br>        dfs2(s+<span class="hljs-string">&quot;)&quot;</span>,leftN,rightN-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;String&gt; <span class="hljs-title">generateParenthesis</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    List&lt;String&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    path.add(<span class="hljs-string">&quot;(&quot;</span>);<br>    dfs(result,path,n-<span class="hljs-number">1</span>,n);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;String&gt; result,List&lt;String&gt; path,<span class="hljs-keyword">int</span> leftN,<span class="hljs-keyword">int</span> rightN)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(leftN == <span class="hljs-number">0</span> &amp;&amp; rightN == <span class="hljs-number">0</span>)&#123;<br>        result.add(String.join(<span class="hljs-string">&quot;&quot;</span>,path));<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span>(leftN &gt; <span class="hljs-number">0</span>)&#123;<br>        path.add(<span class="hljs-string">&quot;(&quot;</span>);<br>        dfs(result,path,leftN-<span class="hljs-number">1</span>,rightN);<br>        path.remove(path.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(rightN &gt; <span class="hljs-number">0</span> &amp;&amp; leftN &lt; rightN)&#123;<br>        path.add(<span class="hljs-string">&quot;)&quot;</span>);;<br>        dfs(result,path,leftN,rightN-<span class="hljs-number">1</span>);<br>        path.remove(path.size()-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="79-单词搜索"><a href="#79-单词搜索" class="headerlink" title="79. 单词搜索"></a><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></h2><p><img src="/images/leetcode100-2/image-20240207145336206.png" alt="image-20240207145336206"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">exist</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, String word)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[][] used = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[board.length][board[<span class="hljs-number">0</span>].length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; board.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; board[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(dfs(board,i,j,word,<span class="hljs-number">0</span>,used))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-keyword">char</span>[][] board, <span class="hljs-keyword">int</span> row, <span class="hljs-keyword">int</span> col, String word, <span class="hljs-keyword">int</span> i,<span class="hljs-keyword">boolean</span>[][] used)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(i == word.length())&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">char</span> c = word.charAt(i);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> &lt;= row &amp;&amp; row &lt; board.length &amp;&amp; <span class="hljs-number">0</span> &lt;= col &amp;&amp; col &lt; board[<span class="hljs-number">0</span>].length<br>            &amp;&amp; c == board[row][col] &amp;&amp; !used[row][col] )&#123;<br>        used[row][col] = <span class="hljs-keyword">true</span>;<br>        System.out.println(row + <span class="hljs-string">&quot;,&quot;</span> + col + <span class="hljs-string">&quot;:&quot;</span> +board[row][col]);<br>        <span class="hljs-keyword">boolean</span> dfs1 = dfs(board, row + <span class="hljs-number">1</span>, col, word, i + <span class="hljs-number">1</span>, used);<br>        <span class="hljs-keyword">boolean</span> dfs2 = dfs(board, row - <span class="hljs-number">1</span>, col, word, i + <span class="hljs-number">1</span>, used);<br>        <span class="hljs-keyword">boolean</span> dfs3 = dfs(board, row, col + <span class="hljs-number">1</span>, word, i + <span class="hljs-number">1</span>, used);<br>        <span class="hljs-keyword">boolean</span> dfs4 = dfs(board, row, col - <span class="hljs-number">1</span>, word, i + <span class="hljs-number">1</span>, used);<br>        used[row][col] = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">return</span> dfs1 || dfs2 || dfs3 || dfs4;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="131-分割回文串"><a href="#131-分割回文串" class="headerlink" title="131. 分割回文串"></a><a href="https://leetcode.cn/problems/palindrome-partitioning/">131. 分割回文串</a></h2><p><img src="/images/leetcode100-2/image-20240207163710805.png" alt="image-20240207163710805"></p>
<p>解题思路：想象成树形截取，从截取1个字符，到全部截取，递归调用；截取时判断，截取的字符串是否回文，直至所有字符截取完毕，则收集一路上截取的字符串组合，即为某种结果；搜集所有结果</p>
<p><img src="/images/leetcode100-2/image-20240207164144797.png" alt="image-20240207164144797"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A_6_131</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span>[][] flag;<br>    <span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; partition(String s) &#123;<br>        List&lt;List&lt;String&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        Deque&lt;String&gt; path = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>        flag = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()][s.length()];<br>        <span class="hljs-comment">//利用动态规划，回文的规则：左右两边相等 且左右边界各自-1也是回文串时，[j,i]也是回文</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; s.length(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(s.charAt(i) == s.charAt(j) &amp;&amp; (i - j &lt;= <span class="hljs-number">2</span> || flag[j+<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>]))&#123;<br>                    flag[j][i] = <span class="hljs-keyword">true</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>        dfs(result,path,s,<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(List&lt;List&lt;String&gt;&gt; result, Deque&lt;String&gt; path,String s, <span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(i == s.length())&#123;<br>            result.add(<span class="hljs-keyword">new</span> ArrayList&lt;&gt;(path));<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &lt; s.length(); j++) &#123;<br>            String sub = s.substring(i,j+<span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//  if(isPalindrome(sub))&#123;</span><br>            <span class="hljs-keyword">if</span>(flag[i][j])&#123;<br>                path.addLast(sub);<br>                dfs(result,path,s,j+<span class="hljs-number">1</span>);<br>                path.removeLast();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPalindrome</span><span class="hljs-params">(String str)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = str.length()-<span class="hljs-number">1</span>; i &lt;= j; i++,j--) &#123;<br>            <span class="hljs-keyword">if</span>(str.charAt(i) != str.charAt(j))&#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="51-N-皇后"><a href="#51-N-皇后" class="headerlink" title="51. N 皇后"></a><a href="https://leetcode.cn/problems/n-queens/">51. N 皇后</a></h2><p><img src="/images/leetcode100-2/image-20240209151752517.png" alt="image-20240209151752517"></p>
<h3 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h3><p>​    递归回溯思路，假设每次递归处理一行节点，从第一行开始处理到最后一行。递归下钻时，记录已经失效的节点，通过观察col[]记录皇后列，其中斜向下x-y+n固定的数组sub[]，斜向上x+y固定的数组sum[]来标记皇后斜向的情况。</p>
<p><img src="/images/leetcode100-2/image-20240209152330375.png" alt="image-20240209152330375"></p>
<p><img src="/images/leetcode100-2/image-20240209152344361.png" alt="image-20240209152344361"></p>
<h1 id="二叉搜索"><a href="#二叉搜索" class="headerlink" title="二叉搜索"></a>二叉搜索</h1><h2 id="35-搜索插入位置"><a href="#35-搜索插入位置" class="headerlink" title="35. 搜索插入位置"></a><a href="https://leetcode.cn/problems/search-insert-position/">35. 搜索插入位置</a></h2><p><img src="/images/leetcode100-2/image-20240214131356086.png" alt="image-20240214131356086"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">searchInsert</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            r = mid - <span class="hljs-number">1</span>;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> l;<br>    <span class="hljs-comment">//        return binarySearch(nums,target,0,nums.length-1);</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">binarySearch</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> left, <span class="hljs-keyword">int</span> right)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(right &lt; left)&#123;<br>        <span class="hljs-keyword">return</span> left;<br>    &#125;<br>    <span class="hljs-keyword">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>        <span class="hljs-keyword">return</span> mid;<br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(nums[mid] &lt; target)&#123;<br>        <span class="hljs-keyword">return</span> binarySearch(nums,target,mid+<span class="hljs-number">1</span>,right);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> binarySearch(nums,target,left,mid-<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="74-搜索二维矩阵"><a href="#74-搜索二维矩阵" class="headerlink" title="74. 搜索二维矩阵"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix/">74. 搜索二维矩阵</a></h2><p><img src="/images/leetcode100-2/image-20240214214156606.png" alt="image-20240214214156606"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">searchMatrix</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] matrix, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (matrix == <span class="hljs-keyword">null</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> m = matrix.length;<br>    <span class="hljs-keyword">int</span> n = matrix[<span class="hljs-number">0</span>].length;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = m*n-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> x = mid / n;<br>        <span class="hljs-keyword">int</span> y = mid % n;<br>        <span class="hljs-keyword">if</span>(matrix[x][y] == target)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(matrix[x][y] &gt; target)&#123;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p>
<p><img src="/images/leetcode100-2/image-20240214214641674.png" alt="image-20240214214641674"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、找出=target的任意下标</span><br><span class="hljs-comment"> * 2、根据这个下标向左右扩展</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange2(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            l = r = mid;<br>            <span class="hljs-keyword">while</span>(l &gt; <span class="hljs-number">0</span> &amp;&amp; nums[l-<span class="hljs-number">1</span>] == target)&#123;<br>                l--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(r &lt; nums.length-<span class="hljs-number">1</span> &amp;&amp; nums[r+<span class="hljs-number">1</span>] == target)&#123;<br>                r++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l,r&#125;;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            r = mid - <span class="hljs-number">1</span>;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="34-在排序数组中查找元素的第一个和最后一个位置"><a href="#34-在排序数组中查找元素的第一个和最后一个位置" class="headerlink" title="34. 在排序数组中查找元素的第一个和最后一个位置"></a><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></h2><p><img src="/images/leetcode100-2/image-20240217102733977.png" alt="image-20240217102733977"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、找出=target的任意下标</span><br><span class="hljs-comment"> * 2、根据这个下标向左右扩展</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> target</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] searchRange2(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target) &#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            l = r = mid;<br>            <span class="hljs-keyword">while</span>(l &gt; <span class="hljs-number">0</span> &amp;&amp; nums[l-<span class="hljs-number">1</span>] == target)&#123;<br>                l--;<br>            &#125;<br>            <span class="hljs-keyword">while</span>(r &lt; nums.length-<span class="hljs-number">1</span> &amp;&amp; nums[r+<span class="hljs-number">1</span>] == target)&#123;<br>                r++;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;l,r&#125;;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[mid] &gt; target)&#123;<br>            r = mid - <span class="hljs-number">1</span>;<br><br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;-<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>&#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="33-搜索旋转排序数组"><a href="#33-搜索旋转排序数组" class="headerlink" title="33. 搜索旋转排序数组"></a><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></h2><p><img src="/images/leetcode100-2/image-20240217104118616.png" alt="image-20240217104118616"></p>
<h3 id="解题思路："><a href="#解题思路：" class="headerlink" title="解题思路："></a>解题思路：</h3><p>​    中点mid的取值有2种可能，midValue &gt;= lValue，或者mid &lt; lValue，每种场景都存在某种场景：target落在单调递增的那一段，比如图一的 left &lt; target &lt; mid，图二的mid &lt; target &lt; right，这2种场景时，直接取区间内的那一半范围即可，否则取另一半。</p>
<p><img src="/images/leetcode100-2/image-20240217104340009.png" alt="image-20240217104340009"></p>
<p><img src="/images/leetcode100-2/image-20240217104638071.png" alt="image-20240217104638071"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">search</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> target)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> r = nums.length-<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>        <span class="hljs-keyword">if</span>(nums[l] == target)&#123;<br>            <span class="hljs-keyword">return</span> l;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums[r] == target)&#123;<br>            <span class="hljs-keyword">return</span> r;<br>        &#125;<br>        <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums[mid] == target)&#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[l])&#123;<br>            <span class="hljs-keyword">if</span>(nums[l] &lt; target &amp;&amp; target &lt; nums[mid])&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">if</span>(target &gt; nums[mid] &amp;&amp; target &lt; nums[r])&#123;<br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="153-寻找旋转排序数组中的最小值"><a href="#153-寻找旋转排序数组中的最小值" class="headerlink" title="153. 寻找旋转排序数组中的最小值"></a><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/">153. 寻找旋转排序数组中的最小值</a></h2><p><img src="/images/leetcode100-2/image-20240217110923239.png" alt="image-20240217110923239"></p>
<p>解题思路：最小值初始为左右值的较小值，取mid值与左值比较，最小值出现在非递增区间，逐渐缩小范围。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A5_153</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> min = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> l = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> r = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span>(nums.length==<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> min;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];<br>        &#125;<br>        min = Math.min(nums[l],nums[r]);<br>        <span class="hljs-keyword">while</span>(l &lt;= r)&#123;<br>            <span class="hljs-keyword">int</span> mid = (l+r) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span>(nums[mid] &gt;= nums[<span class="hljs-number">0</span>])&#123;<br>                <span class="hljs-comment">//0,mid还是递增的,最小值一定出现在非递增区间，所以只需查找非递增区间</span><br>                l = mid + <span class="hljs-number">1</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                r = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>            min = Math.min(nums[mid],min);<br>        &#125;<br>        <span class="hljs-keyword">return</span> min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4. 寻找两个正序数组的中位数"></a><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/">4. 寻找两个正序数组的中位数</a></h2><p><img src="/images/leetcode100-2/image-20240217114207215.png" alt="image-20240217114207215"></p>
<p>解题思路：转化成查找整个m+n数组中第k个数的问题，分别比较查找数组m、n的第k/2个数，排除k/2个数后重复这个过程</p>
<p><img src="/images/leetcode100-2/image-20240217114850201.png" alt="image-20240217114850201"></p>
<p><img src="/images/leetcode100-2/image-20240217114923550.png" alt="image-20240217114923550"></p>
<p><img src="/images/leetcode100-2/image-20240217114944802.png" alt="image-20240217114944802"></p>
<p><img src="/images/leetcode100-2/image-20240217115018598.png" alt="image-20240217115018598"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用寻找第k小的数原理</span><br><span class="hljs-comment"> * num1,num2分别比较第k/2的数,排除前k/2个数</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedianSortedArrays</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span>[] nums2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = nums1.length;<br>    <span class="hljs-keyword">int</span> n = nums2.length;<br>    <span class="hljs-comment">//将偶数和奇数的情况合并，如果是奇数，会求两次同样的 k</span><br>    <span class="hljs-keyword">int</span> left = (m + n + <span class="hljs-number">1</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> right = (m + n + <span class="hljs-number">2</span>) &gt;&gt; <span class="hljs-number">1</span>;<br>    <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0.5</span> * (getKthMin(nums1,<span class="hljs-number">0</span>,m-<span class="hljs-number">1</span>,nums2,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,left) +  getKthMin(nums1,<span class="hljs-number">0</span>,m-<span class="hljs-number">1</span>,nums2,<span class="hljs-number">0</span>,n-<span class="hljs-number">1</span>,right));<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">double</span> <span class="hljs-title">getKthMin</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums1, <span class="hljs-keyword">int</span> start1, <span class="hljs-keyword">int</span> end1, <span class="hljs-keyword">int</span>[] nums2, <span class="hljs-keyword">int</span> start2, <span class="hljs-keyword">int</span> end2, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> len1 = end1 - start1 + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> len2 = end2 - start2 + <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//让 len1 的长度小于 len2，这样就能保证如果有数组空了，一定是 len1</span><br>    <span class="hljs-keyword">if</span>(len1 &gt; len2)&#123;<br>        <span class="hljs-keyword">return</span> getKthMin(nums2,start2,end2,nums1,start1,end1,k);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(len1 == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> nums2[start2+k-<span class="hljs-number">1</span>];<br>    &#125;<br>    <span class="hljs-keyword">if</span>(k == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> Math.min(nums1[start1],nums2[start2]);<br>    &#125;<br>    <span class="hljs-keyword">int</span> kStep1 = Math.min(len1, k / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> kStep2 = Math.min(len2, k / <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">int</span> i = start1 + kStep1 - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> j = start2 + kStep2 - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(nums1[i] &lt;= nums2[j])&#123;<br>        <span class="hljs-keyword">return</span> getKthMin(nums1,i+<span class="hljs-number">1</span>,end1, nums2,start2,end2,k- kStep1);<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> getKthMin(nums1,start1,end1, nums2,j+<span class="hljs-number">1</span>,end2,k- kStep2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h1><h2 id="20-有效的括号"><a href="#20-有效的括号" class="headerlink" title="20. 有效的括号"></a><a href="https://leetcode.cn/problems/valid-parentheses/">20. 有效的括号</a></h2><p><img src="/images/leetcode100-2/image-20240220185219528.png" alt="image-20240220185219528"></p>
<p>思路：利用map保存对应{}的关系</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isValid</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s == <span class="hljs-keyword">null</span> || s.length() &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>    Map&lt;Character,Character&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    map.put(<span class="hljs-string">&#x27;(&#x27;</span>,<span class="hljs-string">&#x27;)&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;&#123;&#x27;</span>,<span class="hljs-string">&#x27;&#125;&#x27;</span>);<br>    map.put(<span class="hljs-string">&#x27;[&#x27;</span>,<span class="hljs-string">&#x27;]&#x27;</span>);<br>    Deque&lt;Character&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> aChar : chars)&#123;<br>        Character before = stack.peek();<br>        <span class="hljs-keyword">if</span>(map.containsKey(aChar))&#123;<br>            stack.push(aChar);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != map.get(before) &amp;&amp; aChar == map.get(before))&#123;<br>            stack.pop();<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> stack.isEmpty();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="155-最小栈"><a href="#155-最小栈" class="headerlink" title="155. 最小栈"></a><a href="https://leetcode.cn/problems/min-stack/">155. 最小栈</a></h2><p><img src="/images/leetcode100-2/image-20240220192431193.png" alt="image-20240220192431193"></p>
<p>解法一：利用链表+链表元素插入时设置当前链表的最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A2_155</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span></span>&#123;<br>        Integer val;<br>        Integer min;<br>        Node next;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Integer val)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Node</span><span class="hljs-params">(Integer val, Integer min, Node next)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.val = val;<br>            <span class="hljs-keyword">this</span>.min = min;<br>            <span class="hljs-keyword">this</span>.next = next;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">private</span> Node head;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> == head)&#123;<br>            head = <span class="hljs-keyword">new</span> Node(val,val,<span class="hljs-keyword">null</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            head = <span class="hljs-keyword">new</span> Node(val,Math.min(val, head.min), head);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        head = head.next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head.val;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> head.min;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解法二：利用辅助栈，存储最小值</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A2_155_2</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; oriQueue = <span class="hljs-keyword">new</span> ArrayDeque();<br>    <span class="hljs-keyword">private</span> Deque&lt;Integer&gt; minQueue = <span class="hljs-keyword">new</span> ArrayDeque();<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">push</span><span class="hljs-params">(<span class="hljs-keyword">int</span> val)</span> </span>&#123;<br>        oriQueue.push(val);<br>        <span class="hljs-keyword">if</span>(minQueue.isEmpty())&#123;<br>            minQueue.push(val);<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(minQueue.peek() &gt;= val)&#123;<br>            minQueue.push(val);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pop</span><span class="hljs-params">()</span> </span>&#123;<br>        Integer pop = oriQueue.pop();<br>        <span class="hljs-keyword">if</span>(minQueue.peek().equals(pop))&#123;<br>            minQueue.pop();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">top</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> oriQueue.peek();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getMin</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> minQueue.peek();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="394-字符串解码"><a href="#394-字符串解码" class="headerlink" title="394. 字符串解码"></a><a href="https://leetcode.cn/problems/decode-string/">394. 字符串解码</a></h2><p><img src="/images/leetcode100-2/image-20240220194453163.png" alt="image-20240220194453163"></p>
<p>解题1：利用栈 + 解析[、]号</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String result = <span class="hljs-string">&quot;&quot;</span>;<br>    String left = <span class="hljs-string">&quot;[&quot;</span>;<br>    String right = <span class="hljs-string">&quot;]&quot;</span>;<br>    Deque&lt;String&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">char</span> aChar : chars)&#123;<br>        <span class="hljs-keyword">if</span>(!right.equals(aChar+<span class="hljs-string">&quot;&quot;</span>))&#123;<br>            stack.push(aChar+<span class="hljs-string">&quot;&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">//step 1: 取出[] 内的字符串</span><br>            String copy = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">while</span>(!left.equals(stack.peek()))&#123;<br>                copy = stack.pop() + copy;<br>            &#125;<br>            <span class="hljs-comment">//弹出[</span><br>            stack.pop();<br>            <span class="hljs-comment">//step 2: 获取倍数数字</span><br>            String numStr = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-comment">//弹出数字</span><br>            <span class="hljs-keyword">while</span>(<span class="hljs-keyword">null</span> != stack.peek() &amp;&amp; stack.peek().length()==<span class="hljs-number">1</span> &amp;&amp; <span class="hljs-string">&#x27;0&#x27;</span> &lt;= stack.peek().charAt(<span class="hljs-number">0</span>) &amp;&amp; stack.peek().charAt(<span class="hljs-number">0</span>) &lt;=<br>                    <span class="hljs-string">&#x27;9&#x27;</span> )&#123;<br>                numStr = stack.pop() + numStr;<br>            &#125;<br>            <span class="hljs-keyword">int</span> count = Integer.parseInt(numStr);<br>            String resultCopy = <span class="hljs-string">&quot;&quot;</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; count; i++) &#123;<br>                resultCopy += copy;<br>            &#125;<br>            stack.push(resultCopy);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">while</span>(!stack.isEmpty())&#123;<br>        result = stack.pop() + result;<br>    &#125;<br>   <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>解题2：利用递归：解析字符串，先解析数字，遇到[下标begin，使用应用计数法往右找对应的]end，递归解析原字符串的subString(begin+1,end)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">decodeString1</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (!str.contains(<span class="hljs-string">&quot;[&quot;</span>)) &#123;<br>        <span class="hljs-keyword">return</span> str;<br>    &#125;<br>    StringBuilder sb = <span class="hljs-keyword">new</span> StringBuilder();<br>    <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (index &lt; str.length()) &#123;<br>        <span class="hljs-keyword">char</span> c = str.charAt(index);<br>        index++;<br>        <span class="hljs-keyword">if</span> (Character.isLetter(c)) &#123;<br>            sb.append(c);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Character.isDigit(c)) &#123;<br>            <span class="hljs-comment">// 提取完整的数字(可能会有多位)</span><br>            <span class="hljs-keyword">int</span> num = c - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            <span class="hljs-keyword">while</span> (Character.isDigit(str.charAt(index))) &#123; <span class="hljs-comment">// 前面已经++过了</span><br>                num = num * <span class="hljs-number">10</span> + str.charAt(index) - <span class="hljs-string">&#x27;0&#x27;</span>;<br>                index++;<br>            &#125;<br>            <span class="hljs-comment">// 数字之后必是左括号</span><br>            <span class="hljs-keyword">int</span> leftNum = <span class="hljs-number">0</span>; <span class="hljs-comment">// 使用引用计数的方式，匹配左右括号，0即表示匹配完毕</span><br>            <span class="hljs-keyword">int</span> startIndex = index; <span class="hljs-comment">// 记录左括号的位置</span><br>            <span class="hljs-keyword">do</span> &#123;<br>                <span class="hljs-keyword">if</span> (str.charAt(index) == <span class="hljs-string">&#x27;[&#x27;</span>) leftNum++;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.charAt(index) == <span class="hljs-string">&#x27;]&#x27;</span>) leftNum--;<br>                index++;<br>            &#125; <span class="hljs-keyword">while</span> (leftNum != <span class="hljs-number">0</span>);<br>            <span class="hljs-comment">// 括号内部的字符串递归调用计算</span><br>            String resStr = decodeString(str.substring(startIndex + <span class="hljs-number">1</span>, index - <span class="hljs-number">1</span>));<br>            <span class="hljs-comment">// 计算结果重复n次</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; num; i++) &#123;<br>                sb.append(resStr);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> sb.toString();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="739-每日温度"><a href="#739-每日温度" class="headerlink" title="739. 每日温度"></a><a href="https://leetcode.cn/problems/daily-temperatures/">739. 每日温度</a></h2><p><img src="/images/leetcode100-2/image-20240221192915747.png" alt="image-20240221192915747"></p>
<p>解题1：单调递减栈</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures2(<span class="hljs-keyword">int</span>[] temperatures) &#123;<br>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[temperatures.length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; temperatures.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> temperature = temperatures[i];<br>        <span class="hljs-keyword">while</span>(!stack.isEmpty() &amp;&amp; temperature &gt; temperatures[stack.peek()])&#123;<br>            result[stack.peek()] = i - stack.pop();<br>        &#125;<br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>题解2：从右往左遍历+ 记忆化搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从右到左</span><br><span class="hljs-comment"> * 暴力破解，时间复杂度O(n*n)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> T</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] dailyTemperatures(<span class="hljs-keyword">int</span>[] T) &#123;<br>    <span class="hljs-keyword">int</span> length = T.length;<br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = length-<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-comment">// j = j + result[j],跳过重复比对</span><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; length; j = j + result[j]) &#123;<br>            <span class="hljs-keyword">if</span>(T[j] &gt; T[i])&#123;<br>                result[i] = j-i;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(result[j] == <span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-comment">//T[j] &lt;= T[i],j后面都没有比i大的数了</span><br>                result[i] = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-comment">//其他场景，继续遍历</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="84-柱状图中最大的矩形"><a href="#84-柱状图中最大的矩形" class="headerlink" title="84. 柱状图中最大的矩形"></a><a href="https://leetcode.cn/problems/largest-rectangle-in-histogram/">84. 柱状图中最大的矩形</a></h2><p><img src="/images/leetcode100-2/image-20240221194745083.png" alt="image-20240221194745083"></p>
<p>题解一：暴力破解</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 暴力破解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> heights</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(heights.length == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> length = heights.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">int</span> height = heights[i];<br>        <span class="hljs-keyword">int</span> width = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">int</span> left = i;<br>        <span class="hljs-keyword">int</span> right = i;<br>        <span class="hljs-keyword">while</span>(left-<span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; heights[left-<span class="hljs-number">1</span>] &gt;= height)&#123;<br>            left--;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(right+<span class="hljs-number">1</span> &lt;length &amp;&amp; heights[right+<span class="hljs-number">1</span>] &gt;= height)&#123;<br>            right++;<br>        &#125;<br>        width = right - left + <span class="hljs-number">1</span>;<br>        area = Math.max(area,width * height);<br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>题解二：单调栈 + 哨兵：从暴力破解中发现规律，需要寻找当前下边往左和往右第一个小于自己的值，单调递增栈能保证栈顶的下一个元素为左边第一个小于自己的元素，</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单调栈 + 哨兵</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> heights</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">largestRectangleArea</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] heights)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> area = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> length = heights.length;<br>    <span class="hljs-keyword">if</span>(length == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> area;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(length == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> heights[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] newHeights = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length + <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        newHeights[i+<span class="hljs-number">1</span>] = heights[i];<br>    &#125;<br>    heights = newHeights;<br>    length = length + <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//单调递增栈</span><br>    Deque&lt;Integer&gt; stack = <span class="hljs-keyword">new</span> ArrayDeque&lt;&gt;();<br>    stack.push(<span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//加入哨兵后，循环无需判空</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">while</span> (heights[i] &lt; heights[stack.peek()])&#123;<br>            Integer currentIndex = stack.pop();<br>            <span class="hljs-comment">//向左过程中也没必要判断是否相等，因为宽= i - index - 1;已经包含该场景</span><br>            <span class="hljs-comment">//                while(heights[currentIndex] == heights[stack.peek()])&#123;</span><br>            <span class="hljs-comment">//                    //向左找，与当前一样大时，也左移，否则必然比当前值小</span><br>            <span class="hljs-comment">//                    stack.pop();</span><br>            <span class="hljs-comment">//                &#125;</span><br>            <span class="hljs-keyword">int</span> currentHeight = heights[currentIndex];<br>            <span class="hljs-keyword">int</span> width = i - stack.peek() - <span class="hljs-number">1</span>;<br>            area = Math.max(area,width * currentHeight);<br>        &#125;<br>        stack.push(i);<br>    &#125;<br>    <span class="hljs-keyword">return</span> area;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h1><h2 id="215-数组中的第K个最大元素"><a href="#215-数组中的第K个最大元素" class="headerlink" title="215. 数组中的第K个最大元素"></a><a href="https://leetcode.cn/problems/kth-largest-element-in-an-array/">215. 数组中的第K个最大元素</a></h2><p><img src="/images/leetcode100-2/image-20240222082944791.png" alt="image-20240222082944791"></p>
<p>题解一：提到了O（n）的时间复杂度，且限制-1w&lt;= nums[i] &lt;= 1w，可以使用桶排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span>[] buckets = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">20001</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>            buckets[nums[i] + <span class="hljs-number">10000</span>]++;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">20000</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>            k = k - buckets[i];<br>            <span class="hljs-keyword">if</span> (k &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> i - <span class="hljs-number">10000</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>题解二：维护大小为K的小顶堆，一旦对容量超过K，移除堆顶元素，最终的堆顶元素即为第K大元素。 </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 利用小顶堆</span><br><span class="hljs-comment"> * 时间复杂度 O(nlogK)</span><br><span class="hljs-comment"> * 空间复杂度:O(k)</span><br><span class="hljs-comment"> * 调整堆时间复杂度:O(logK)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k)</span> </span>&#123;<br>    Queue&lt;Integer&gt; heap = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums) &#123;<br>        heap.add(num);<br>        <span class="hljs-keyword">if</span>(heap.size() &gt; k)&#123;<br>            heap.poll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> heap.peek();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="347-前-K-个高频元素"><a href="#347-前-K-个高频元素" class="headerlink" title="347. 前 K 个高频元素"></a><a href="https://leetcode.cn/problems/top-k-frequent-elements/">347. 前 K 个高频元素</a></h2><p><img src="/images/leetcode100-2/image-20240223081713904.png" alt="image-20240223081713904"></p>
<p>解题一：利用小顶堆，维护大小为k的高频元素堆</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * hash + priorityQueue</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> k</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent1(<span class="hljs-keyword">int</span>[] nums,<span class="hljs-keyword">int</span> k) &#123;<br>    Map&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap&lt;Integer,Integer&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        map.put(nums[i],map.getOrDefault(nums[i],<span class="hljs-number">0</span>) + <span class="hljs-number">1</span>);<br>    &#125;<br>    PriorityQueue&lt;<span class="hljs-keyword">int</span>[]&gt; queue = <span class="hljs-keyword">new</span> PriorityQueue&lt;&gt;((e1,e2) -&gt; e1[<span class="hljs-number">1</span>] - e2[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">for</span>(Map.Entry&lt;Integer,Integer&gt; entry : map.entrySet())&#123;<br>        queue.add(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;entry.getKey(),entry.getValue()&#125;);<br>        <span class="hljs-keyword">if</span>(queue.size() &gt; k)&#123;<br>            queue.poll();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[k];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>       result[i] = queue.poll()[<span class="hljs-number">0</span>];<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>题解二：桶排序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span>[] topKFrequent2(<span class="hljs-keyword">int</span>[] nums, <span class="hljs-keyword">int</span> k) &#123;<br>    List&lt;Integer&gt; res = <span class="hljs-keyword">new</span> ArrayList();<br>    <span class="hljs-comment">// 使用字典，统计每个元素出现的次数，元素为键，元素出现的次数为值</span><br>    HashMap&lt;Integer,Integer&gt; map = <span class="hljs-keyword">new</span> HashMap();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> num : nums)&#123;<br>        <span class="hljs-keyword">if</span> (map.containsKey(num)) &#123;<br>            map.put(num, map.get(num) + <span class="hljs-number">1</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            map.put(num, <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//桶排序</span><br>    <span class="hljs-comment">//将频率作为数组下标，对于出现频率不同的数字集合，存入对应的数组下标</span><br>    List&lt;Integer&gt;[] list = <span class="hljs-keyword">new</span> List[nums.length+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> key : map.keySet())&#123;<br>        <span class="hljs-comment">// 获取出现的次数作为下标</span><br>        <span class="hljs-keyword">int</span> i = map.get(key);<br>        <span class="hljs-keyword">if</span>(list[i] == <span class="hljs-keyword">null</span>)&#123;<br>            list[i] = <span class="hljs-keyword">new</span> ArrayList();<br>        &#125;<br>        list[i].add(key);<br>    &#125;<br><br>    <span class="hljs-comment">// 倒序遍历数组获取出现顺序从大到小的排列</span><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = list.length - <span class="hljs-number">1</span>;i &gt;= <span class="hljs-number">0</span> &amp;&amp; res.size() &lt; k;i--)&#123;<br>        <span class="hljs-keyword">if</span>(list[i] == <span class="hljs-keyword">null</span>) <span class="hljs-keyword">continue</span>;<br>        res.addAll(list[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res.stream().mapToInt(Integer::intValue).toArray();<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="295-数据流的中位数"><a href="#295-数据流的中位数" class="headerlink" title="295. 数据流的中位数"></a><a href="https://leetcode.cn/problems/find-median-from-data-stream/">295. 数据流的中位数</a></h2><p><img src="/images/leetcode100-2/image-20240223091145464.png" alt="image-20240223091145464"></p>
<p>题解：维护大+小顶堆，小顶堆数量 &gt;= 大顶堆，2个堆数量的绝对值 &lt; 1</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">PriorityQueue&lt;Integer&gt; queMin;<br>PriorityQueue&lt;Integer&gt; queMax;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MedianFinder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//大顶堆  小于等于中位数的数</span><br>    queMin = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;((a, b) -&gt; (b - a));<br>    <span class="hljs-comment">//小顶堆  记录大于中位数的数</span><br>    queMax = <span class="hljs-keyword">new</span> PriorityQueue&lt;Integer&gt;((a, b) -&gt; (a - b));<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addNum</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(queMin.isEmpty())&#123;<br>        queMin.add(num);<br><br>    &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(queMin.peek() &lt;= num)&#123;<br>        queMax.add(num);<br>        <span class="hljs-comment">//重平衡</span><br>        <span class="hljs-keyword">if</span>(queMax.size() &gt; queMin.size())&#123;<br>            queMin.add(queMax.poll());<br>        &#125;<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        queMin.add(num);<br>        <span class="hljs-comment">//重平衡</span><br>        <span class="hljs-keyword">if</span>(queMin.size() &gt; queMax.size() + <span class="hljs-number">1</span>)&#123;<br>            queMax.add(queMin.poll());<br>        &#125;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">findMedian</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">//小顶堆数量 &gt; 大顶堆数量：元素个数为奇数，取小顶堆堆顶</span><br>    <span class="hljs-comment">//小顶堆数量 = 大顶堆数量：元素个数为偶数，取大小顶堆堆顶 / 2</span><br>    <span class="hljs-keyword">if</span>(queMin.size() &gt; queMax.size())&#123;<br>        <span class="hljs-keyword">return</span> queMin.peek();<br>    &#125;<span class="hljs-keyword">else</span>&#123;<br>        <span class="hljs-keyword">return</span> (queMin.peek() + queMax.peek()) / <span class="hljs-number">2.0</span>;<br>    &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h1><h2 id="121-买卖股票的最佳时机"><a href="#121-买卖股票的最佳时机" class="headerlink" title="121. 买卖股票的最佳时机"></a><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">121. 买卖股票的最佳时机</a></h2><p><img src="/images/leetcode100-2/image-20240224165649724.png" alt="image-20240224165649724"></p>
<p>题解：在遍历过程中，记录最低的股票买入价格，一遍遍历计算出max（当前价格-当前最底价格）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProfit</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] prices)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> minPrice = Integer.MAX_VALUE;<br>    <span class="hljs-keyword">int</span> profit = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; prices.length; i++) &#123;<br>        <span class="hljs-keyword">int</span> price = prices[i];<br>        minPrice = Math.min(minPrice, price);<br>        profit = Math.max(price-minPrice,profit);<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> profit;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="55-跳跃游戏"><a href="#55-跳跃游戏" class="headerlink" title="55. 跳跃游戏"></a><a href="https://leetcode.cn/problems/jump-game/">55. 跳跃游戏</a></h2><p><img src="/images/leetcode100-2/image-20240224202723250.png" alt="image-20240224202723250"></p>
<p>题解：遍历时，维护一个当前可走至的最远下标，直到latestIndex &gt;= nums.length - 1，表示可达最后一个数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可达最远的地方</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canJump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.length == <span class="hljs-number">0</span> || nums.length == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> reach = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> size = nums.length;<br>    <span class="hljs-comment">//i 达不到 &gt;reache 的位置，,提前结束</span><br>    <span class="hljs-comment">//reach &gt;= size -1 ,提前结束</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= reach &amp;&amp; reach &lt; size -<span class="hljs-number">1</span>; i++) &#123;<br>        reach = Math.max(i + nums[i],reach);<br>    &#125;<br>    <span class="hljs-keyword">return</span> reach &gt;= nums.length -<span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="45-跳跃游戏-II"><a href="#45-跳跃游戏-II" class="headerlink" title="45. 跳跃游戏 II"></a><a href="https://leetcode.cn/problems/jump-game-ii/">45. 跳跃游戏 II</a></h2><p><img src="/images/leetcode100-2/image-20240224205522507.png" alt="image-20240224205522507"></p>
<p>题解：在当前位置i，可走arr[i] = step步，贪心的走[1，step]中第j步可走最远，则i的下一步就是j</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 如果我们「贪心」地进行正向查找，每次找到可到达的最远位置，就可以在线性时间内得到最少的跳跃次数。</span><br><span class="hljs-comment"> * 例如，对于数组 [2,3,1,2,4,2,3]，初始位置是下标 0，从下标 0 出发，最远可到达下标 2。下标 0 可到达的位置中，下标 1 的值是 3，从下标 1 出发可以达到更远的位置，因此第一步到达下标 1。</span><br><span class="hljs-comment"> * 从下标 1 出发，最远可到达下标 4。下标 1 可到达的位置中，下标 4 的值是 4 ，从下标 4 出发可以达到更远的位置，因此第二步到达下标 4</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">jump</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-comment">//目前右边可达最大范围</span><br>    <span class="hljs-keyword">int</span> rightIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> nextIndex = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">int</span> jump= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length - <span class="hljs-number">1</span>;) &#123;<br>        <span class="hljs-comment">//step 本步可以行走的范围</span><br>        <span class="hljs-keyword">int</span> step = nums[i];<br>        <span class="hljs-keyword">if</span>(i + step &gt;= length-<span class="hljs-number">1</span>)&#123;<br>            <span class="hljs-keyword">return</span> jump + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= i + step; j++) &#123;<br>            <span class="hljs-comment">// nextStep 在本步范围内，每一步的下一步步长</span><br>            <span class="hljs-keyword">int</span> nextStep = nums[j];<br>            <span class="hljs-comment">//j + nextStep 用来比较走到从i 走到 j时，j能走到的最远距离</span><br>            <span class="hljs-keyword">if</span>(j + nextStep &gt; rightIndex)&#123;<br>                rightIndex = j + nextStep;<br>                nextIndex = j;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//跳到能够到达最远的下标</span><br>        i = nextIndex;<br>        jump++;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> jump;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="763-划分字母区间"><a href="#763-划分字母区间" class="headerlink" title="763. 划分字母区间"></a><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></h2><p><img src="/images/leetcode100-2/image-20240224211122841.png" alt="image-20240224211122841"></p>
<p>题解：维护一个int[26]，存储每个字母最后出现的次数</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Integer&gt; <span class="hljs-title">partitionLabels</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    List&lt;Integer&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">int</span>[] endData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[<span class="hljs-number">26</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>        <span class="hljs-keyword">char</span> c = chars[i];<br>        endData[c - <span class="hljs-string">&#x27;a&#x27;</span>] = i;<br>    &#125;<br><br>    <span class="hljs-keyword">int</span> begin,end;<br>    begin = end = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>        end = Math.max(end,endData[chars[i] - <span class="hljs-string">&#x27;a&#x27;</span>]);<br>        <span class="hljs-comment">//关键的一步，i走到end时，表示到达某一段的终点</span><br>        <span class="hljs-keyword">if</span>(i == end)&#123;<br>            result.add(end - begin + <span class="hljs-number">1</span>);<br>            begin = end + <span class="hljs-number">1</span>;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><h2 id="70-爬楼梯"><a href="#70-爬楼梯" class="headerlink" title="70. 爬楼梯"></a><a href="https://leetcode.cn/problems/climbing-stairs/">70. 爬楼梯</a></h2><p><img src="/images/leetcode100-2/image-20240413222738977.png" alt="image-20240413222738977"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//迭代法</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> pre = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">int</span> ppre = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">0</span> || n == <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> cur = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        ppre = pre;<br>        pre = cur;<br>        cur = ppre + pre;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cur;<br><br>&#125;<br><br>Map&lt;Integer,Integer&gt; dataMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">climbStairs1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> f(n);<br><br>&#125;<br><span class="hljs-comment">//动态规划+记忆化搜索</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(n == <span class="hljs-number">1</span> || n == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(dataMap.containsKey(n))&#123;<br>        <span class="hljs-keyword">return</span> dataMap.get(n);<br>    &#125;<br>    <span class="hljs-keyword">int</span> result = f(n - <span class="hljs-number">1</span>) + f(n - <span class="hljs-number">2</span>);<br>    dataMap.put(n,result);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="118-杨辉三角"><a href="#118-杨辉三角" class="headerlink" title="118. 杨辉三角"></a><a href="https://leetcode.cn/problems/pascals-triangle/">118. 杨辉三角</a></h2><p><img src="/images/leetcode100-2/image-20240413223600193.png" alt="image-20240413223600193"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 递归公式 result[i][j] = result[i-1][j-1] + result[i-1][j]</span><br><span class="hljs-comment">     * 边界：i==0时，输出[1],j==0或者j==i时,值=1</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> numRows</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> List&lt;List&lt;Integer&gt;&gt; generate(<span class="hljs-keyword">int</span> numRows) &#123;<br>        List&lt;List&lt;Integer&gt;&gt; result = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-keyword">if</span>(numRows &lt;= <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; numRows; i++) &#123;<br>            List&lt;Integer&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(i+<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt;= i; j++) &#123;<br>                <span class="hljs-keyword">if</span>(j==<span class="hljs-number">0</span> || j==i)&#123;<br>                    data.add(<span class="hljs-number">1</span>);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                List&lt;Integer&gt; preRowData = result.get(i-<span class="hljs-number">1</span>);<br>                data.add(preRowData.get(j-<span class="hljs-number">1</span>) + preRowData.get(j));<br>            &#125;<br>            result.add(data);<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br></code></pre></td></tr></table></figure>

<h2 id="279-完全平方数"><a href="#279-完全平方数" class="headerlink" title="279. 完全平方数"></a><a href="https://leetcode.cn/problems/perfect-squares/">279. 完全平方数</a></h2><p><img src="/images/leetcode100-2/image-20240418195305821.png" alt="image-20240418195305821"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 递归转化公式:f[i] = min(f[i-j*j] + 1)</span><br><span class="hljs-comment"> * 边界条件：f[0] = 0,当 j = 根号i;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">numSquares</span><span class="hljs-params">(<span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[n+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">int</span> min = Integer.MAX_VALUE;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j*j &lt;= i; j++) &#123;<br>            min = Math.min(min,result[i-j*j]);<br>        &#125;<br>        result[i] = min + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result[n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="322-零钱兑换"><a href="#322-零钱兑换" class="headerlink" title="322. 零钱兑换"></a><a href="https://leetcode.cn/problems/coin-change/">322. 零钱兑换</a></h2><p><img src="/images/leetcode100-2/image-20240423195720003.png" alt="image-20240423195720003"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 转化方程：dp[i] = dp[i-coins[j]] + 1, 0 &lt;= j &lt;= coins.length</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> coins </span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> amount</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">coinChange</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] coins, <span class="hljs-keyword">int</span> amount)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(amount == <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span>[] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[amount+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>        data[i] = Integer.MAX_VALUE;;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= amount; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; coins.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(coins[j] &lt;= i &amp;&amp; data[i-coins[j]] != Integer.MAX_VALUE)&#123;<br>                data[i] = Math.min(data[i],data[i-coins[j]]+<span class="hljs-number">1</span>);<br>            &#125;<br><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> data[amount] == Integer.MAX_VALUE?-<span class="hljs-number">1</span>:data[amount];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="139-单词拆分"><a href="#139-单词拆分" class="headerlink" title="139. 单词拆分"></a><a href="https://leetcode.cn/problems/word-break/">139. 单词拆分</a></h2><p><img src="/images/leetcode100-2/image-20240804224541360.png" alt="image-20240804224541360"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态规划 + 记忆化搜索：内循环取决于i的长度</span><br><span class="hljs-comment"> * 转移方程:dp[i] = dp[j] &amp;&amp; wordDict.contains(s.subString(j,i))</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> wordDict</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">wordBreak</span><span class="hljs-params">(String s, List&lt;String&gt; wordDict)</span> </span>&#123;<br>    HashSet&lt;String&gt; wordDictSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;(wordDict);<br>    <span class="hljs-keyword">boolean</span>[] result = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[s.length()+<span class="hljs-number">1</span>];<br>    result[<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= s.length(); i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; i; j++) &#123;<br>            <span class="hljs-keyword">if</span> (result[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;<br>                result[i] = <span class="hljs-keyword">true</span>;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result[s.length()];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="152-乘积最大子数组"><a href="#152-乘积最大子数组" class="headerlink" title="152. 乘积最大子数组"></a><a href="https://leetcode.cn/problems/maximum-product-subarray/">152. 乘积最大子数组</a></h2><p><img src="/images/leetcode100-2/image-20240423210509222.png" alt="image-20240423210509222"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 整理区分正数负数</span><br><span class="hljs-comment"> * dpMax[i],dpMin[i]分别表示以第i位为结尾的连续子序列的最大和最小乘机</span><br><span class="hljs-comment"> * nums[i]是正数时，我们期望前积最大，是负数时，我们期望前积最小，负负得正</span><br><span class="hljs-comment"> * dpMax[i] = Math.max(nums[i],dpMax[i-1]*nums[i],dpMin[i-1]*nums[i])</span><br><span class="hljs-comment"> * dpMin[i] = Math.max(nums[i],dpMax[i-1]*nums[i],dpMin[i-1]*nums[i])</span><br><span class="hljs-comment"> * result = max dpMax[i];</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">maxProduct</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span>[] maxData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    <span class="hljs-keyword">int</span>[] minData = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[nums.length];<br>    maxData[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    minData[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">int</span> max = nums[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; nums.length; i++) &#123;<br>        maxData[i] = Math.max(nums[i],Math.max(nums[i] * maxData[i-<span class="hljs-number">1</span>],nums[i] * minData[i-<span class="hljs-number">1</span>]));<br>        minData[i] = Math.min(nums[i],Math.min(nums[i] * maxData[i-<span class="hljs-number">1</span>],nums[i] * minData[i-<span class="hljs-number">1</span>]));<br>        max = Math.max(maxData[i],max);<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="416-分割等和子集"><a href="#416-分割等和子集" class="headerlink" title="416. 分割等和子集"></a><a href="https://leetcode.cn/problems/partition-equal-subset-sum/">416. 分割等和子集</a></h2><p><img src="/images/leetcode100-2/image-20240424205325881.png" alt="image-20240424205325881"></p>
<figure class="highlight txt"><table><tr><td class="code"><pre><code class="hljs txt">背包问题：转化问题为：给定一个只包含正整数的非空数组 nums，判断是否可以从数组中选出一些数字，<br>使得这些数字的和等于整个数组的元素和的一半<br>boolean [][]的dp[i][j] 表示在nums数组0-i的范围内，能否选出和为j的数字集合<br>则dp[i][j] = dp[i-1][j] 或者 dp[i-1][j-nums[i]]，即对于当前数字nums[i]选或者不选的结果，其中dp[i][0]=初始化为0<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">canPartition1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>       <span class="hljs-keyword">int</span> len = nums.length;<br>       <span class="hljs-keyword">int</span> sum = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>           sum+=nums[i];<br>       &#125;<br>       <span class="hljs-keyword">if</span>((sum &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">1</span> )&#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>       &#125;<br>       <span class="hljs-keyword">int</span> target = sum / <span class="hljs-number">2</span>;<br>       <span class="hljs-keyword">boolean</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[len][target+<span class="hljs-number">1</span>];<br>       <span class="hljs-comment">//初始化第一行，第一列</span><br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; len; i++) &#123;<br>           dp[i][<span class="hljs-number">0</span>] = <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">if</span>(nums[<span class="hljs-number">0</span>] &lt;= target)&#123;<br>           dp[<span class="hljs-number">0</span>][nums[<span class="hljs-number">0</span>]] = <span class="hljs-keyword">true</span>;<br>       &#125;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; len; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= target; j++) &#123;<br>               dp[i][j] = dp[i-<span class="hljs-number">1</span>][j];<br>               <span class="hljs-keyword">if</span>(nums[i] &lt;= j)&#123;<br>                   dp[i][j] = dp[i][j] || dp[i-<span class="hljs-number">1</span>][j-nums[i]];<br>               &#125;<br>           &#125;<br>           <span class="hljs-keyword">if</span>(dp[i][target])&#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[len-<span class="hljs-number">1</span>][target];<br>   &#125;<br></code></pre></td></tr></table></figure>

<h2 id="32-最长有效括号"><a href="#32-最长有效括号" class="headerlink" title="32. 最长有效括号"></a><a href="https://leetcode.cn/problems/longest-valid-parentheses/">32. 最长有效括号</a></h2><p><img src="/images/leetcode100-2/image-20240425202747943.png" alt="image-20240425202747943"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * int[i] 表示以第i为为结尾的最长有效括号的长度</span><br><span class="hljs-comment"> * 只有当s.charAt(i)==&#x27;)&#x27;时,字符才有效，此时</span><br><span class="hljs-comment"> * 1、s.charAt(i-1)==&#x27;(&#x27;,[i-1,i]凑成一对，dp[i] = dp[i-2] + 2</span><br><span class="hljs-comment"> * 2、s.charAt(i-1)==&#x27;)&#x27;,如果s.charAt(i-1-dp[i-1])==&#x27;(&#x27;,则[i-1-dp[i-1],i]有效，dp[i] = dp[i-1] + 2 + dp[i-2-dp[i-1]]</span><br><span class="hljs-comment"> * 3、其他场景，默认dp[i] = 0;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestValidParentheses</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(s.length() &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> length = s.length();<br>    <span class="hljs-keyword">int</span>[] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length];<br>    <span class="hljs-keyword">int</span> max = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(s.charAt(i) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>            <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                dp[i] = <span class="hljs-number">2</span> + (i&gt;=<span class="hljs-number">2</span>?dp[i-<span class="hljs-number">2</span>]:<span class="hljs-number">0</span>);<br>            &#125;<br>            <span class="hljs-keyword">if</span>(s.charAt(i-<span class="hljs-number">1</span>) == <span class="hljs-string">&#x27;)&#x27;</span>)&#123;<br>                <span class="hljs-keyword">if</span>(i-<span class="hljs-number">1</span>-dp[i-<span class="hljs-number">1</span>] &gt;= <span class="hljs-number">0</span> &amp;&amp; s.charAt(i-<span class="hljs-number">1</span>-dp[i-<span class="hljs-number">1</span>]) == <span class="hljs-string">&#x27;(&#x27;</span>)&#123;<br>                    dp[i] = <span class="hljs-number">2</span> + dp[i-<span class="hljs-number">1</span>] + ((i-<span class="hljs-number">2</span>-dp[i-<span class="hljs-number">1</span>]&gt;=<span class="hljs-number">0</span>)?dp[i-<span class="hljs-number">2</span>-dp[i-<span class="hljs-number">1</span>]]:<span class="hljs-number">0</span>);<br>                &#125;<br>            &#125;<br>            max = Math.max(max,dp[i]);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> max;<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="多维动态规划"><a href="#多维动态规划" class="headerlink" title="多维动态规划"></a>多维动态规划</h1><h2 id="62-不同路径"><a href="#62-不同路径" class="headerlink" title="62. 不同路径"></a><a href="https://leetcode.cn/problems/unique-paths/">62. 不同路径</a></h2><p><img src="/images/leetcode100-2/image-20240425205817866.png" alt="image-20240425205817866"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths1</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m,<span class="hljs-keyword">int</span> n)</span></span>&#123;<br>    <span class="hljs-keyword">int</span>[][] data = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m][n];<br>    data[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; m;i++)&#123;<br>        data[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>;i &lt; n;i++)&#123;<br>        data[<span class="hljs-number">0</span>][i] = <span class="hljs-number">1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;i &lt; m;i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>;j &lt; n;j++)&#123;<br>            data[i][j] = data[i][j - <span class="hljs-number">1</span>] + data[i - <span class="hljs-number">1</span>][j];<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span>  data[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * M * N 从[0，0]到 [m-1,n-1]需要走m-1+n-1=m+n-2步，在其中选n-1向右走，转化为排列组合C(m+n-2,n-1)</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> m</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> n</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">uniquePaths</span><span class="hljs-params">(<span class="hljs-keyword">int</span> m, <span class="hljs-keyword">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">long</span> ans = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> x = n, y = <span class="hljs-number">1</span>; y &lt; m; ++x, ++y) &#123;<br>        ans = ans * x / y;<br>    &#125;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-keyword">int</span>) ans;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="64-最小路径和"><a href="#64-最小路径和" class="headerlink" title="64. 最小路径和"></a><a href="https://leetcode.cn/problems/minimum-path-sum/">64. 最小路径和</a></h2><p><img src="/images/leetcode100-2/image-20240428000233033.png" alt="image-20240428000233033"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-number">5.</span> 最长回文子串<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minPathSum</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[][] grid)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; grid.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; grid[<span class="hljs-number">0</span>].length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span> &amp;&amp; j == <span class="hljs-number">0</span>) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(i == <span class="hljs-number">0</span>)  grid[i][j] = grid[i][j - <span class="hljs-number">1</span>] + grid[i][j];<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(j == <span class="hljs-number">0</span>)  grid[i][j] = grid[i - <span class="hljs-number">1</span>][j] + grid[i][j];<br>            <span class="hljs-keyword">else</span> grid[i][j] = Math.min(grid[i - <span class="hljs-number">1</span>][j], grid[i][j - <span class="hljs-number">1</span>]) + grid[i][j];<br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> grid[grid.length-<span class="hljs-number">1</span>][grid[<span class="hljs-number">0</span>].length-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="5-最长回文子串"><a href="#5-最长回文子串" class="headerlink" title="5. 最长回文子串"></a><a href="https://leetcode.cn/problems/longest-palindromic-substring/">5. 最长回文子串</a></h2><p><img src="/images/leetcode100-2/image-20240428000348203.png" alt="image-20240428000348203"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 暴力破解</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String cut = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">char</span>[] chars = s.toCharArray();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; chars.length; i++) &#123;<br>        String temp = s.substring(i,i+<span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = chars.length; j &gt;= i ; j--) &#123;<br>            String substring = s.substring(i, j);<br>            <span class="hljs-keyword">if</span>(isLongestPalindrome(substring))&#123;<br>                temp = substring;<br>                <span class="hljs-keyword">if</span>(temp.length() &gt; cut.length())&#123;<br>                    cut = temp;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cut;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isLongestPalindrome</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>,j = str.length()-<span class="hljs-number">1</span>; i &lt;= j; i++,j--) &#123;<br>        <span class="hljs-keyword">if</span>(str.charAt(i) != str.charAt(j))&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="动态规划解法："><a href="#动态规划解法：" class="headerlink" title="动态规划解法："></a>动态规划解法：</h3><figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 动态规划</span><br><span class="hljs-comment"> * boolean[][]dp,dp[j][i]表示字符s中，下标j到i的子串是否是回文字符串</span><br><span class="hljs-comment"> * dp[j][i] == &#123;</span><br><span class="hljs-comment"> *     if j == i,true</span><br><span class="hljs-comment"> *     if Sj == Si,&#123;</span><br><span class="hljs-comment"> *         if(i-j==1)&#123;</span><br><span class="hljs-comment"> *             true,相邻</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *         if(dp[j+1][i-1])&#123;</span><br><span class="hljs-comment"> *             true;</span><br><span class="hljs-comment"> *         &#125;</span><br><span class="hljs-comment"> *     &#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> s</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">longestPalindrome1</span><span class="hljs-params">(String s)</span> </span>&#123;<br>    String result = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">int</span> length = s.length();<br>    <span class="hljs-keyword">boolean</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[length][length];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">char</span> charI = s.charAt(i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i; j &gt;= <span class="hljs-number">0</span> ; j--) &#123;<br>            <span class="hljs-keyword">if</span>(i-j == <span class="hljs-number">0</span>)&#123;<br>                dp[j][i] = <span class="hljs-keyword">true</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">if</span>(charI == s.charAt(j))&#123;<br>                    <span class="hljs-keyword">if</span>(i-j==<span class="hljs-number">1</span>)&#123;<br>                        <span class="hljs-comment">//j,i相邻</span><br>                        dp[j][i] = <span class="hljs-keyword">true</span>;<br><br>                    &#125;<span class="hljs-keyword">else</span>&#123;<br>                        <span class="hljs-comment">//状态转移</span><br>                        dp[j][i] = dp[j+<span class="hljs-number">1</span>][i-<span class="hljs-number">1</span>];<br>                    &#125;<br><br>                &#125;<br><br>            &#125;<br><br>            <span class="hljs-keyword">if</span>(dp[j][i])&#123;<br>                result = i-j+<span class="hljs-number">1</span> &gt; result.length()?s.substring(j,i+<span class="hljs-number">1</span>):result;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="1143-最长公共子序列"><a href="#1143-最长公共子序列" class="headerlink" title="1143. 最长公共子序列"></a><a href="https://leetcode.cn/problems/longest-common-subsequence/">1143. 最长公共子序列</a></h2><p><img src="/images/leetcode100-2/image-20240428001134941.png" alt="image-20240428001134941"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">longestCommonSubsequence</span><span class="hljs-params">(String text1, String text2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> m = text1.length(), n = text2.length();<br>    <span class="hljs-comment">//dp[i][j] 表示text1[0,i],text2[0,j]范围内的最长公共子序列长度</span><br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[m + <span class="hljs-number">1</span>][n + <span class="hljs-number">1</span>];<br>    <span class="hljs-comment">//从1开始，默认dp[0][j],dp[i][0]=0</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; i++) &#123;<br>        <span class="hljs-keyword">char</span> c1 = text1.charAt(i - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>            <span class="hljs-keyword">char</span> c2 = text2.charAt(j - <span class="hljs-number">1</span>);<br>            <span class="hljs-comment">//转化方程</span><br>            <span class="hljs-keyword">if</span> (c1 == c2) &#123;<br>                dp[i][j] = dp[i - <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.max(dp[i - <span class="hljs-number">1</span>][j], dp[i][j - <span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m][n];<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="72-编辑距离"><a href="#72-编辑距离" class="headerlink" title="72. 编辑距离"></a><a href="https://leetcode.cn/problems/edit-distance/">72. 编辑距离</a></h2><p><img src="/images/leetcode100-2/image-20240430091704621.png" alt="image-20240430091704621"></p>
<p>编辑距离算法被数据科学家广泛应用，是用作机器翻译和语音识别评价标准的基本算法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dp[i][j]表示word1[0,i],word2[0,j]的转化最少操作数</span><br><span class="hljs-comment"> * 1、word1.charAt(i) == word2.charAt[j]时,无需交换dp[i][j] = dp[i-1][j-1]</span><br><span class="hljs-comment"> * 2、否则,以word1[i]为基准，新增、删除、替换操作后得到word2[j],dp[i][j] = min(dp[i-1][j] 或 dp[i][j-1] 或 dp[i-1][j-1]) + 1</span><br><span class="hljs-comment">  * <span class="hljs-doctag">@param</span> word1</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> word2</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">minDistance1</span><span class="hljs-params">(String word1, String word2)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> length1 = word1.length();<br>    <span class="hljs-keyword">int</span> length2 = word2.length();<br>    <span class="hljs-keyword">int</span>[][] dp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[length1+<span class="hljs-number">1</span>][length2+<span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= length1; i++) &#123;<br>        dp[i][<span class="hljs-number">0</span>] = i;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= length2; j++) &#123;<br>        dp[<span class="hljs-number">0</span>][j] = j;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt;= length1; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">1</span>; j &lt;= length2; j++) &#123;<br>            <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                dp[i][j] = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>            &#125;<span class="hljs-keyword">else</span> &#123;<br>                dp[i][j] = Math.min(dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>],Math.min(dp[i][j-<span class="hljs-number">1</span>],dp[i-<span class="hljs-number">1</span>][j])) + <span class="hljs-number">1</span>;<br>            &#125;<br><br>        &#125;<br><br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[length1][length2];<br>&#125;<br></code></pre></td></tr></table></figure>

<h1 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h1><h2 id="136-只出现一次的数字"><a href="#136-只出现一次的数字" class="headerlink" title="136. 只出现一次的数字"></a><a href="https://leetcode.cn/problems/single-number/">136. 只出现一次的数字</a></h2><p><img src="/images/leetcode100-2/image-20240430220847183.png" alt="image-20240430220847183"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">boolean</span>[] dataArr = <span class="hljs-keyword">new</span> <span class="hljs-keyword">boolean</span>[<span class="hljs-number">60000</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        dataArr[<span class="hljs-number">30000</span>+nums[i]] = !dataArr[<span class="hljs-number">30000</span>+nums[i]];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; dataArr.length; i++) &#123;<br>        <span class="hljs-keyword">if</span>(dataArr[i])&#123;<br>            <span class="hljs-keyword">return</span> i - <span class="hljs-number">30000</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 方法二</span><br><span class="hljs-comment"> * a ^ a = 0,a ^ 0 = a =&gt; a^b^b^c^c = a ^ 0 ^0 = a</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">singleNumber</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        result ^= nums[i];<br>    &#125;<br><br><br><br>    <span class="hljs-keyword">return</span> result;<br><br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="169-多数元素"><a href="#169-多数元素" class="headerlink" title="169. 多数元素"></a><a href="https://leetcode.cn/problems/majority-element/">169. 多数元素</a></h2><p><img src="/images/leetcode100-2/image-20240430221013146.png" alt="image-20240430221013146"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    Map&lt;Integer,Integer&gt; data = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) &#123;<br>        <span class="hljs-keyword">int</span> times = data.getOrDefault(nums[i], <span class="hljs-number">0</span>) + <span class="hljs-number">1</span>;<br>        data.put(nums[i], times);<br>        <span class="hljs-keyword">if</span>(times &gt; length / <span class="hljs-number">2</span>)&#123;<br>            <span class="hljs-keyword">return</span> nums[i];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>摩尔投票法：</strong> 核心理念为<strong>票数正负抵消</strong> 。此方法时间和空间复杂度分别为 O(N) 和 O(1)，为本题的最佳解法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 1、遍历数组时，假设vote=0时，认为下一个读到的数X是众数，如果接下来遍历时遇到=x的，则投票加一，否则减1</span><br><span class="hljs-comment"> * 2、当vote重新等于0时，重复第一步，前面的结果打平，不影响后面的投票。就能及时修正x值，全部遍历完后，x=值肯定是真正的众数。</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">majorityElement1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> x = <span class="hljs-number">0</span>, votes = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> num : nums)&#123;<br>            <span class="hljs-keyword">if</span> (votes == <span class="hljs-number">0</span>) x = num;<br>            votes += num == x ? <span class="hljs-number">1</span> : -<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> x;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="75-颜色分类"><a href="#75-颜色分类" class="headerlink" title="75. 颜色分类"></a><a href="https://leetcode.cn/problems/sort-colors/">75. 颜色分类</a></h2><p><img src="/images/leetcode100-2/image-20240522192824037.png" alt="image-20240522192824037"></p>
<p>经典的荷兰国旗问题</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-comment">//小于target的最右下标</span><br>    <span class="hljs-keyword">int</span> less = -<span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//大于target的最左下标</span><br>    <span class="hljs-keyword">int</span> length = nums.length;<br>    <span class="hljs-keyword">int</span> large = length;<br>    <span class="hljs-keyword">int</span> target = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; large; ) &#123;<br>        <span class="hljs-keyword">int</span> num = nums[i];<br>        <span class="hljs-keyword">if</span>(num &lt; target)&#123;<br>            ++less;<br>            swap(nums,less,i);<br>            i++;<br>        &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(num &gt; target)&#123;<br>            --large;<br>            swap(nums,i,large);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            i++;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[]nums,<span class="hljs-keyword">int</span> i,<span class="hljs-keyword">int</span> j)</span></span>&#123;<br>    <span class="hljs-keyword">int</span> temp = nums[i];<br>    nums[i] = nums[j];<br>    nums[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="31-下一个排列"><a href="#31-下一个排列" class="headerlink" title="31. 下一个排列"></a><a href="https://leetcode.cn/problems/next-permutation/">31. 下一个排列</a></h2><p><img src="/images/leetcode100-2/image-20240522193454237.png" alt="image-20240522193454237"></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 首先从后向前查找第一个顺序对 (i,i+1)，满足 a[i]&lt;a[i+1]。这样「较小数」即为 a[i]。此时 [i+1,n) 必然是下降序列。</span><br><span class="hljs-comment"> * 如果找到了顺序对，那么在区间 [i+1,n) 中从后向前查找第一个元素 j 满足 a[i]&lt;a[j]。这样「较大数」即为 a[j]。</span><br><span class="hljs-comment"> * 交换 a[i] 与 a[j]，此时可以证明区间 [i+1,n) 必为降序。我们可以直接使用双指针反转区间 [i+1,n) 使其变为升序，而无需对该区间进行排序。</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注意</span><br><span class="hljs-comment"> * 如果在步骤 1 找不到顺序对，说明当前序列已经是一个降序序列，即最大的序列，</span><br><span class="hljs-comment"> * 我们直接跳过步骤 2 执行步骤 3，即可得到最小的升序序列</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@param</span> nums</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nextPermutation</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span>(nums.length &lt; <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">int</span> i = nums.length - <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//找到不符合单调递减的起点，待交换的左数</span><br>    <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; nums[i] &gt;= nums[i+<span class="hljs-number">1</span>])&#123;<br>        i--;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(i &gt;= <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">//从右往左找，找到第一个比左数大的右数</span><br>        <span class="hljs-keyword">int</span> j = nums.length-<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (j &gt; i &amp;&amp; nums[j] &lt;= nums[i])&#123;<br>            j--;<br>        &#125;<br>        <span class="hljs-comment">//交换左右数</span><br>        swap(nums,i,j);<br>    &#125;<br>    reverse(nums,i+<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="287-寻找重复数"><a href="#287-寻找重复数" class="headerlink" title="287. 寻找重复数"></a><a href="https://leetcode.cn/problems/find-the-duplicate-number/">287. 寻找重复数</a></h2><p><img src="/images/leetcode100-2/image-20240522202613342.png" alt="image-20240522202613342"></p>
<p>转化为有换问题-&gt;快慢指针-&gt;找入环口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate1</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = i+<span class="hljs-number">1</span>; j &lt; nums.length; j++) &#123;<br>            <span class="hljs-keyword">if</span>(nums[i] == nums[j])&#123;<br>                <span class="hljs-keyword">return</span> nums[i];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>   <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 我们对 nums数组建图，每个位置 i 连一条 i→nums[i]的边。由于存在的重复的数字 target，</span><br><span class="hljs-comment">     * 因此 target 这个位置一定有起码两条指向它的边，因此整张图一定存在环，且我们要找到的 target 就是这个环的入口</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> nums </span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">findDuplicate</span><span class="hljs-params">(<span class="hljs-keyword">int</span>[] nums)</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> fast = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">int</span> slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">do</span> &#123;<br>            slow = nums[slow];<br>            fast = nums[nums[fast]];<br>        &#125;<span class="hljs-keyword">while</span> (fast != slow);<br>        slow = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span> (fast != slow)&#123;<br>            slow = nums[slow];<br>            fast = nums[fast];<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br><br></code></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>leetcode</category>
      </categories>
      <tags>
        <tag>leetcode</tag>
        <tag>热题100</tag>
      </tags>
  </entry>
  <entry>
    <title>分布式-分布式事务基础</title>
    <url>/2023/03/30/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/</url>
    <content><![CDATA[<h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><h3 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务"></a>什么是事务</h3><p>​    什么是事务？举个生活中的例子：你去小卖铺买东西，“一手交钱，一手交货”就是一个事务的例子，交钱和交货必须全部成功，事务才算成功，任一个活动失败，事务将撤销所有已成功的活动。<br>​    简而言之，事务可以看做是一次大的活动，它由不同的小活动组成，这些活动<strong>要么全部成功，要么全部失败</strong>。</p>
<h3 id="数据库本地事务"><a href="#数据库本地事务" class="headerlink" title="数据库本地事务"></a>数据库本地事务</h3><p>​    在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务.</p>
<p><strong>回顾一下数据库事务的四大特性 ACID：</strong></p>
<blockquote>
<p>A（Atomic）：原子性，构成事务的所有操作，要么都执行完成，要么全部不执行，不可能出现部分成功部分失败的情况。</p>
<p>C（Consistency）：一致性，在事务执行前后，数据库的一致性约束没有被破坏。比如：张三向李四转100元，转账前和转账后的数据是正确状态这叫一致性，如果出现张三转出100元，李四账户没有增加100元这就出现了数据错误，就没有达到一致性。</p>
<p>I（Isolation）：隔离性，数据库中的事务一般都是并发的，隔离性是指并发的两个事务的执行互不干扰，一个事务不能看到其他事务运行过程的中间状态。通过配置事务隔离级别可以避脏读、重复读等问题。</p>
<p>D（Durability）：持久性，事务完成之后，该事务对数据的更改会被持久化到数据库，且不会被回滚。</p>
</blockquote>
<p>​    我们的本地事务由资源管理器进行管理，事务的ACID是通过<strong>InnoDB日志和锁</strong>来保证，简单来说</p>
<p>Mysql Innodb引擎ACID实现原理简述：</p>
<p><strong>1、持久性通过redo log（重做日志）来实现</strong></p>
<p><strong>2、原子性和一致性通过undo log（回滚日志）来实现</strong></p>
<p><strong>3、隔离性由MVCC机制和锁来实现</strong></p>
<p>​    UndoLog的原理很简单，为了满足事务的原子性，在操作任何数据之前，首先将数据备份到一个地方（这个存储数据备份的地方称为UndoLog），<strong>是旧数据进行备份</strong>。然后进行数据的修改。如果出现了错误或者用户执行了ROLLBACK语句，系统可以利用Undo Log中的备份将数据恢复到事务开始之前的状态。</p>
<p>​    <strong>RedoLog记录的是新数据的备份</strong>。在事务提交前，只要将RedoLog持久化即可，不需要将数据持久化。当系统崩溃时，虽然数据没有持久化，但是RedoLog已经持久化。系统可以根据RedoLog的内容，将所有数据恢复到最新的状态。</p>
<h3 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h3><p>​    分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，这种<strong>分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务</strong>，例如用户注册送积分事务、创建订单减库存事务，银行转账事务等都是分布式事务。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230315222605196.png" alt="image-20230315222605196"></p>
<p>单一架构下的事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">begin transaction；<br>&#x2F;&#x2F;1.本地数据库操作：张三减少金额<br>&#x2F;&#x2F;2.本地数据库操作：李四增加金额<br>commit transation;<br></code></pre></td></tr></table></figure>

<p>分布式架构下的事务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><code class="hljs mysql">begin transaction；<br>&#x2F;&#x2F;1.本地数据库操作：张三减少金额<br>&#x2F;&#x2F;2.远程调用：让李四增加金额<br>commit transation;<br></code></pre></td></tr></table></figure>

<p>可以设想，李四金额增加了，但是由于网络问题超时响应等原因导致本地事务回滚，就会造成事务不一致。</p>
<h3 id="分布式事物的地产生场景"><a href="#分布式事物的地产生场景" class="headerlink" title="分布式事物的地产生场景"></a>分布式事物的地产生场景</h3><p><strong>1、跨服务远程调用，即跨jvm进程</strong></p>
<img src="/images/分布式-分布式事务01/164d6783a9e3f959_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt="img" style="zoom: 67%;">

<p><strong>2、跨数据库实例产生分布式事务</strong></p>
<img src="/images/分布式-分布式事务01/164d67e0c6026ac4_tplv-t2oaga2asx-zoom-in-crop-mark_3024_0_0_0.awebp" alt="img" style="zoom: 80%;">

<h2 id="分布式事务的基础"><a href="#分布式事务的基础" class="headerlink" title="分布式事务的基础"></a>分布式事务的基础</h2><p>​    分布式系统之所以叫分布式，是因 为提供服务的各个节点分布在不同机器上，相互之间通过网络交互。不能因为有一点网络问题就导致整个系统无法 提供服务，网络因素成为了分布式事务的考量标准之一。因此，分布式事务需要更进一步的理论支持。</p>
<h3 id="CAP"><a href="#CAP" class="headerlink" title="CAP"></a>CAP</h3><p>CAP(定理，又被叫作布鲁尔定理。对于设计分布式系统来说(不仅仅是分布式事务)的架构师来说，CAP就是入门理论。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230317090206074.png" alt="image-20230317090206074"></p>
<h4 id="C-Consistency-一致性"><a href="#C-Consistency-一致性" class="headerlink" title="C - Consistency-一致性"></a>C - Consistency-一致性</h4><p>​    一致性是指写操作后的读操作可以读取到最新的数据状态，当数据分布在多个节点上，从任意结点读取到的数据都是最新的状态。对于数据分布在不同节点上的数据上来说，如果在某个节点更新了数据，那么在其他节点如果都能读取到这个最新的数据，那么就称为强一致，如果有某个节点没有读取到，那就是分布式不一致。</p>
<h4 id="A-Availability-可用性"><a href="#A-Availability-可用性" class="headerlink" title="A - Availability-可用性"></a>A - Availability-可用性</h4><p>​    可用性是指任何事务操作都可以得到响应结果，且不会出现响应超时或响应错误。可用性的两个关键一个是合理的时间，一个是合理的响应。合理的时间指的是请求不能无限被阻塞，应该在合理的时间给出返回。合理的响应指的是系统应该明确返回结果并且结果是正确的，这里的正确指的是比如应该返回50，而不是返回40。</p>
<h4 id="P-Partition-tolerance-分区容错性"><a href="#P-Partition-tolerance-分区容错性" class="headerlink" title="P - Partition tolerance-分区容错性"></a>P - Partition tolerance-分区容错性</h4><p>​    通常分布式系统的各各结点部署在不同的子网，这就是网络分区，不可避免的会出现由于网络问题而导致结点之间通信失败，此时仍可对外提供服务。</p>
<p>​    <strong>分区容错性是分布式系统具备的基本能力</strong></p>
<h4 id="CAP三者不可兼得"><a href="#CAP三者不可兼得" class="headerlink" title="CAP三者不可兼得"></a>CAP三者不可兼得</h4><p>​    在分布式系统中，网络无法100%可靠，分区其实是一个必然现象，如果我们选择了CA而放弃了P，那么当发生分区现象时，为了保证一致性，这个时候必须拒绝请求，但是A又不允许，所以分布式系统理论上不可能选择CA架构，只能选择CP或者AP架构。</p>
<p>​    对于CP来说，放弃可用性，追求一致性和分区容错性，我们的zookeeper其实就是追求的强一致。<br>​    对于AP来说，放弃一致性(这里说的一致性是强一致性)，追求分区容错性和可用性，这是很多分布式系统设计时的选择，后面的BASE也是根据AP来扩展。<br>​    顺便一提，CAP理论中是忽略网络延迟，也就是当事务提交时，从节点A复制到节点B，但是在现实中这个是明显不可能的，所以总会有一定的时间是不一致。同时CAP中选择两个，比如你选择了CP，并不是叫你放弃A。因为P出现的概率实在是太小了，大部分的时间你仍然需要保证CA。就算分区出现了你也要为后来的A做准备，比如通过一些日志的手段，是其他机器回复至可用。</p>
<h3 id="BASE"><a href="#BASE" class="headerlink" title="BASE"></a>BASE</h3><h4 id="强一致性与最终一致性"><a href="#强一致性与最终一致性" class="headerlink" title="强一致性与最终一致性"></a>强一致性与最终一致性</h4><p>​    CAP理论告诉我们一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容忍性（Partition tolerance）这三项中的两项，其中AP在实际应用中较多，AP即舍弃一致性，保证可用性和分区容忍性，但是在实际生产中很多场景都要实现一致性，比如前边我们举的例子主数据库向从数据库同步数据，即使不要一致性，但是最终也要将数据同步成功来保证数据一致，这种一致性和CAP中的一致性不同，CAP中的一致性要求在任何时间查询每个结点数据都必须一致，它强调的是<strong>强一致性</strong>，但是最终一致性是允许可以在一段时间内每个结点的数据不一致，但是经过一段时间每个结点的数据必须一致，它强调的是<strong>最终数据的一致性</strong>。</p>
<h4 id="Base理论"><a href="#Base理论" class="headerlink" title="Base理论"></a>Base理论</h4><p>​    BASE 是 **Basically Available(基本可用)<strong>、</strong>Soft state(软状态)**和 <strong>Eventually consistent (最终一致性)<strong>三个短语的缩写。BASE理论是对CAP中AP的一个扩展，通过牺牲强一致性来获得可用性，当出现故障允许部分不可用但要保证核心功能可用，允许数据在一段时间内是不一致的，但最终达到一致状态。满足BASE理论的事务，我们称之为“</strong>柔性事务</strong>”</p>
<p><strong>基本可用</strong>:</p>
<p>​    分布式系统在出现故障时，允许损失部分可用功能，保证核心功能可用。如，电商网站交易付款出现问题了，商品依然可以正常浏览。</p>
<p><strong>软状态</strong>:</p>
<p>​    由于不要求强一致性，所以BASE允许系统中存在中间状态（也叫软状态），这个状态不影响系统可用性，如订单的”支付中”、“数据同步中”等状态，待数据最终一致后状态改为“成功”状态。</p>
<p><strong>最终一致</strong>:</p>
<p>​    最终一致是指经过一段时间后，所有节点数据都将会达到一致。如订单的”支付中”状态，最终会变为“支付成功”或者”支付失败”，使订单状态与实际交易结果达成一致，但需要一定时间的延迟、等待。</p>
<h2 id="2PC协议及其解决方案"><a href="#2PC协议及其解决方案" class="headerlink" title="2PC协议及其解决方案"></a>2PC协议及其解决方案</h2><h3 id="什么是2PC"><a href="#什么是2PC" class="headerlink" title="什么是2PC"></a>什么是2PC</h3><p>​    2PC即两阶段提交协议，是将整个事务流程分为两个阶段，<strong>准备阶段</strong>（Prepare phase）、<strong>提交阶段</strong>（commitphase），2是指两个阶段，P是指准备阶段，C是指提交阶段。</p>
<p><strong>1. 准备阶段（Prepare phase）：</strong>事务管理器给每个参与者发送Prepare消息，每个数据库参与者在本地执行事务，并写本地的Undo/Redo日志，此时事务没有提交。（Undo日志是记录修改前的数据，用于数据库回滚，Redo日志是记录修改后的数据，用于提交事务后写入数据文件）</p>
<p><strong>2. 提交阶段（commit phase）：</strong>如果事务管理器收到了参与者的执行失败或者超时消息时，直接给每个参与者发送回滚(Rollback)消息；否则，发送提交(Commit)消息；参与者根据事务管理器的指令执行提交或者回滚操作，并释放事务处理过程中使用的锁资源。注意:必须在最后阶段释放锁资源。</p>
<h3 id="XA方案"><a href="#XA方案" class="headerlink" title="XA方案"></a>XA方案</h3><p><strong>DTP</strong>：国际开放标准组织Open Group定义了分布式事务处理模型DTP（Distributed Transaction Processing Reference Model），这模型规范了分布式事务的模型设计。</p>
<p><strong>DTP模型定义如下角色：</strong></p>
<ul>
<li>**AP(**Application Program)：即应用程序，可以理解为使用DTP分布式事务的程序。</li>
<li><strong>RM</strong>(Resource Manager)：即资源管理器，可以理解为事务的参与者，一般情况下是指一个数据库实例，通过资源管理器对该数据库进行控制，资源管理器控制着分支事务。</li>
<li><strong>TM</strong>(Transaction Manager)：事务管理器，负责协调和管理事务，事务管理器控制着全局事务，管理事务生命周期，并协调各个RM。全局事务是指分布式事务处理环境中，需要操作多个数据库共同完成一个工作，这个工作即是一个全局事务。</li>
</ul>
<p>下面新用户注册送积分为例来说明：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230319165353627.png" alt="image-20230319165353627"></p>
<p><strong>以上三个角色之间的交互方式如下：</strong></p>
<ol>
<li>TM向AP提供应用程序编程接口，AP通过TM提交及回滚事务。</li>
<li>TM交易中间件通过XA接口来通知RM数据库事务的开始、结束以及提交、回滚等。</li>
</ol>
<p><strong>执行流程如下：</strong></p>
<p>1、应用程序（AP）持有用户库和积分库两个数据源。<br>2、应用程序（AP）通过TM通知用户库RM新增用户，同时通知积分库RM为该用户新增积分，RM此时并未提交事<br>务，此时用户和积分资源锁定。<br>3、TM收到执行回复，只要有一方失败则分别向其他RM发起回滚事务，回滚完毕，资源锁释放。<br>4、TM收到执行回复，全部成功，此时向所有RM发起提交事务，提交完毕，资源锁释放</p>
<p><strong>DTP模型定义TM和RM之间通讯的接口规范叫XA，简单理解为数据库提供的2PC接口协议，基于数据库的XA协议来实现2PC又称为XA方案</strong>。</p>
<h3 id="XA方案的问题"><a href="#XA方案的问题" class="headerlink" title="XA方案的问题"></a>XA方案的问题</h3><p><strong>单点问题</strong></p>
<p>​    事务管理器在整个流程中扮演的角色很关键，如果其宕机，比如在第一阶段已经完成，在第二阶段正准备提交的时候事务管理器宕机，资源管理器就会一直阻塞，导致数据库无法使用。</p>
<p><strong>同步阻塞</strong></p>
<p>​    在准备就绪之后，资源管理器中的资源一直处于阻塞，直到提交完成，释放资源。</p>
<p><strong>数据不一致</strong></p>
<p>​    两阶段提交协议虽然为分布式数据强一致性所设计，但仍然存在数据不一致性的可能，比如在第二阶段中，假设协调者发出了事务commit的通知，但是因为网络问题该通知仅被一部分参与者所收到并执行了commit操作，其余的参与者则因为没有收到通知一直处于阻塞状态，这时候就产生了数据的不一致性。</p>
<p>​    总的来说，XA协议比较简单，成本较低，但是其单点问题，以及不能支持高并发(由于同步阻塞)依然是其最大的弱点。</p>
<h3 id="Seata-AT-方案"><a href="#Seata-AT-方案" class="headerlink" title="Seata (AT)方案"></a>Seata (AT)方案</h3><h4 id="是什么"><a href="#是什么" class="headerlink" title="是什么"></a>是什么</h4><p>​    Seata 是一款开源的分布式事务解决方案，致力于提供高性能和简单易用的分布式事务服务。Seata 将为用户提供了 AT（Auto Transaction）、TCC、SAGA 和 XA 事务模式，为用户打造一站式的分布式解决方案。</p>
<p>​    传统2PC的问题在Seata中得到了解决，它通过对本地关系数据库的分支事务的协调来驱动完成全局事务，是<strong>工作在应用层</strong>的中间件。主要优点是性能较好，且不长时间占用连接资源，它以高效并且<strong>对业务0侵入</strong>的方式解决微服务场景下面临的分布式事务问题，它目前主要提供<strong>AT模式</strong>(即2PC)及TCC模式的分布式事务解决方案。</p>
<p>​    Seata把一个分布式事务理解成一个包含了若干分支事务的全局事务。全局事务的职责是协调其下管辖的分支事务达成一致，要么一起成功提交，要么一起失败回滚。此外，通常分支事务本身就是一个关系数据库的本地事务，下图是全局事务与分支事务的关系图：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230319233044827.png" alt="image-20230319233044827"></p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230319233148264.png" alt="image-20230319233148264"></p>
<p>Seata定义了3个组件来协议分布式事务的处理过程：</p>
<p>Transaction Coordinator (<strong>TC</strong>)： 事务协调器，它是独立的中间件，需要独立部署运行，它维护全局事务的运<br>行状态，接收TM指令发起全局事务的提交与回滚，负责与RM通信协调各各分支事务的提交或回滚。</p>
<p>Transaction Manager (<strong>TM</strong>)： 事务管理器，TM需要嵌入应用程序中工作，它负责开启一个全局事务，并最终<br>向TC发起全局提交或全局回滚的指令。</p>
<p>Resource Manager (<strong>RM</strong>)： 控制分支事务，负责分支注册、状态汇报，并接收事务协调器TC的指令，驱动分<br>支（本地）事务的提交和回滚。</p>
<p>拿新用户注册送积分举例Seata的分布式事务过程：</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230319233404655.png" alt="image-20230319233404655"></p>
<p>具体的执行流程如下：</p>
<ol>
<li>用户服务的 TM 向 TC 申请开启一个全局事务，全局事务创建成功并生成一个全局唯一的XID。</li>
<li>用户服务的 RM 向 TC 注册 分支事务，该分支事务在用户服务执行新增用户逻辑，并将其纳入 XID 对应全局<br>事务的管辖。</li>
<li>用户服务执行分支事务，向用户表插入一条记录。</li>
<li>逻辑执行到远程调用积分服务时(XID 在微服务调用链路的上下文中传播)。积分服务的RM 向 TC 注册分支事<br>务，该分支事务执行增加积分的逻辑，并将其纳入 XID 对应全局事务的管辖。</li>
<li>积分服务执行分支事务，向积分记录表插入一条记录，执行完毕后，返回用户服务。</li>
<li>用户服务分支事务执行完毕。</li>
<li>TM 向 TC 发起针对 XID 的全局提交或回滚决议。</li>
<li>TC 调度 XID 下管辖的全部分支事务完成提交或回滚请求。</li>
</ol>
<h4 id="Seata实现2PC（AT模式）与传统2PC（XA模式）的差别"><a href="#Seata实现2PC（AT模式）与传统2PC（XA模式）的差别" class="headerlink" title="Seata实现2PC（AT模式）与传统2PC（XA模式）的差别"></a>Seata实现2PC（AT模式）与传统2PC（XA模式）的差别</h4><table>
<thead>
<tr>
<th></th>
<th>XA</th>
<th>Seata AT</th>
</tr>
</thead>
<tbody><tr>
<td>架构层次</td>
<td>RM是数据库本身</td>
<td>RM是以jar包形式作为中间件部署在应用程序这一侧</td>
</tr>
<tr>
<td>资源锁定</td>
<td>事务性资源锁定到第二阶段完成</td>
<td>第一阶段就提交完成后释放，整体效率较高</td>
</tr>
</tbody></table>
<h2 id="3PC协议"><a href="#3PC协议" class="headerlink" title="3PC协议"></a>3PC协议</h2><h3 id="是什么-1"><a href="#是什么-1" class="headerlink" title="是什么"></a>是什么</h3><p>​    1、在2阶段提交协议的基础上、<br>​    2、三阶段提交协议在协调者和参与者中都引入超时机制，<br>​    3、并且把两阶段提交协议的第一个阶段拆分成了两步：询问，然后再锁资源，最后真正提交</p>
<p>1、can commit<br>    预执行一次、不占用资源<br>2、pre commit<br>    预执行一次，记录undo/redo日志，占用资源<br>3、do commit<br>    事务提交阶段</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/501938d549794ceab7cddeabd04a90af_tplv-k3u1fbpfcp-zoom-in-crop-mark_4536_0_0_0.awebp" alt="img"></p>
<p>​    3PC 多了一个阶段其实就是在执行事务之前来确认参与者是否正常，防止个别参与者不正常的情况下，其他参与者都执行了事务，锁定资源。<br>​    出发点是好的，但是绝大部分情况下肯定是正常的，所以每次都<strong>多了一个交互阶段就很不划算</strong>。<br>​    3PC 在参与者处也引入了超时机制，这样在协调者挂了的情况下，如果已经到了提交阶段了，参与者等半天没收到协调者的情况的话就会自动提交事务。不过万一协调者发的是回滚命令呢？这就数据不一致了。</p>
<h3 id="2PC与3PC"><a href="#2PC与3PC" class="headerlink" title="2PC与3PC"></a>2PC与3PC</h3><p>​    2PC 是一个强一致性的同步阻塞协议，性能已经是比较差的了，</p>
<p>​    3PC 主要是为了解决两阶段提交协议的阻塞问题，从原来的两个阶段扩展为三个阶段，增加了超时机制。但是多了一个阶段就多了一次通讯的开销，而且是绝大部分情况下无用的通讯。</p>
<p>​    2PC 还是 3PC 都是协议，可以认为是一种指导思想，和真正的落地还是有差别的。</p>
<h2 id="TCC事务及其解决方案"><a href="#TCC事务及其解决方案" class="headerlink" title="TCC事务及其解决方案"></a>TCC事务及其解决方案</h2><h3 id="是什么-2"><a href="#是什么-2" class="headerlink" title="是什么"></a>是什么</h3><p>​    <strong>TCC是Try、Confifirm、Cancel三个词语的缩写</strong>，TCC要求每个分支事务实现三个操作：预处理Try、确认Confifirm、撤销Cancel。Try操作做业务检查及资源预留，Confifirm做业务确认操作，Cancel实现一个与Try相反的操作即回滚操作。TM首先发起所有的分支事务的try操作，任何一个分支事务的try操作执行失败，TM将会发起所有分支事务的Cancel操作，若try操作全部成功，TM将会发起所有分支事务的Confifirm操作，其中Confifirm/Cancel操作若执行失败，TM会进行重试。 </p>
<p><strong>TCC分为三个阶段：</strong></p>
<p>1、Try 阶段是做业务检查(一致性)及资源预留(隔离)，此阶段仅是一个初步操作，它和后续的Confifirm 一起才能真正构成一个完整的业务逻辑。</p>
<p>2、Confifirm 阶段是做确认提交，Try阶段所有分支事务执行成功后开始执行 Confifirm。通常情况下，采用TCC则认为 Confifirm阶段是不会出错的。即：只要Try成功，Confifirm一定成功。若Confifirm阶段真的出错了，需引入重试机制或人工处理。</p>
<p>3、Cancel 阶段是在业务执行错误需要回滚的状态下执行分支事务的业务取消，预留资源释放。通常情况下，采用TCC则认为Cancel阶段也是一定成功的。若Cancel阶段真的出错了，需引入重试机制或人工处理。</p>
<p>TM事务管理器，TM事务管理器可以实现为独立的服务，也可以让全局事务发起方充当TM的角色，TM独立出来是为了成为公用组件，是为了考虑系统结构和软件复用。</p>
<p>TM在发起全局事务时生成<strong>全局事务记录</strong>，全局事务ID贯穿整个分布式事务调用链条，用来记录事务上下文，追踪和记录状态，由于Confifirm 和cancel失败需进行重试，因此需要实现为幂等，幂等性是指同一个操作无论请求多少次，其结果都相同。 与之相对的，每个分支注册的事务称为<strong>分支事务记录</strong></p>
<h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><p>TCC事务机制相比于上面介绍的XA，解决了其几个缺点:<br>1.单点问题：由主业务方发起并完成这个业务活动。业务活动管理器也变成多点，引入集群。<br>2.同步阻塞：引入超时，超时后进行补偿，并且不会锁定整个资源，<strong>将资源转换为业务逻辑形式，粒度变小</strong>。<br>3.数据不一致：有了补偿机制之后，由业务活动管理器控制一致性</p>
<p><strong>适用场景</strong>：</p>
<ul>
<li>强隔离性，严格一致性要求的活动业务（能够控制粒度）。</li>
<li>执行时间较短的业务</li>
</ul>
<p>缺点:</p>
<p>​    1、代码入侵业务</p>
<p>​    2、实现较复杂</p>
<h3 id="TCC需要注意三种异常处理"><a href="#TCC需要注意三种异常处理" class="headerlink" title="TCC需要注意三种异常处理"></a>TCC需要注意三种异常处理</h3><p><strong>空回滚：</strong></p>
<p>​    未Try就Cancel，直接返回成功</p>
<p><strong>幂等：</strong></p>
<p>​    Try、Confirm、Cancel需要保证幂等，可重复执行以支持TCC的提交重试机制</p>
<p><strong>悬挂：</strong></p>
<p>​    Cancel后再Try，会造成资源被“占用“，要求二阶段即Cancel执行后，不允许执行一阶段即Try</p>
<p><strong>经典案例</strong>：<strong>A 转账 30 元给 B，A和B账户在不同的服务</strong></p>
<p><strong>方案一</strong>：</p>
<p>账户A:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">try</span>：<br><span class="hljs-attribute">1</span>、检查余额是否够<span class="hljs-number">30</span>元<br><span class="hljs-attribute">2</span>、扣减<span class="hljs-number">30</span>元<br><span class="hljs-attribute">confirm</span>：空<br><span class="hljs-attribute">cancel</span>：增加<span class="hljs-number">30</span>元<br></code></pre></td></tr></table></figure>

<p>账户B:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">try</span>：增加<span class="hljs-number">30</span>元 <br><span class="hljs-attribute">confirm</span>：空 <br><span class="hljs-attribute">cancel</span>：减少<span class="hljs-number">30</span>元 <br></code></pre></td></tr></table></figure>

<p>存在的问题：1、无幂等、空回滚、悬挂校验 2、B在try时新增30可能会被别的线程消费</p>
<p><strong>优化方案</strong>：</p>
<p>账户A:</p>
<figure class="highlight md"><table><tr><td class="code"><pre><code class="hljs md">try：<br>1、try幂等校验<br>2、try悬挂校验<br>3、减少30元<br>confirm：空<br>cancel：<br>1、cancel幂等校验<br>2、cancel空回滚校验<br>3、增加30元<br></code></pre></td></tr></table></figure>

<p>账户B:</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><code class="hljs vim"><span class="hljs-keyword">try</span>： 空<br><span class="hljs-keyword">confirm</span>： <br><span class="hljs-number">1</span>、<span class="hljs-keyword">confirm</span>幂等校验    <br><span class="hljs-number">2</span>、正式增加<span class="hljs-number">30</span>元 <br>cancel：空<br></code></pre></td></tr></table></figure>

<h3 id="TCC-解决方案"><a href="#TCC-解决方案" class="headerlink" title="TCC 解决方案"></a>TCC 解决方案</h3><p><strong>目前市面上的TCC框架众多比如下面这几种：</strong></p>
<table>
<thead>
<tr>
<th>框架名称</th>
<th>Gitbub地址</th>
</tr>
</thead>
<tbody><tr>
<td>tcc-transaction</td>
<td><a href="https://github.com/changmingxie/tcc-transaction">https://github.com/changmingxie/tcc-transaction</a></td>
</tr>
<tr>
<td>Hmily</td>
<td><a href="https://github.com/dromara/hmily">https://github.com/dromara/hmily</a></td>
</tr>
<tr>
<td>ByteTCC</td>
<td><a href="https://github.com/liuyangming/ByteTCC">https://github.com/liuyangming/ByteTCC</a></td>
</tr>
<tr>
<td>EasyTransaction</td>
<td><a href="https://github.com/QNJR-GROUP/EasyTransaction">https://github.com/QNJR-GROUP/EasyTransaction</a></td>
</tr>
<tr>
<td>Seata TCC模式</td>
<td><a href="https://github.com/seata/seata">https://github.com/seata/seata</a></td>
</tr>
</tbody></table>
<h2 id="Saga事务及其解决方案"><a href="#Saga事务及其解决方案" class="headerlink" title="Saga事务及其解决方案"></a>Saga事务及其解决方案</h2><h3 id="是什么-3"><a href="#是什么-3" class="headerlink" title="是什么"></a>是什么</h3><p>​    Saga是30年前一篇数据库伦理提到的一个概念（理论基础：Hector &amp; Kenneth 发表论⽂ Sagas （1987））。其核心思想是将长事务拆分为多个本地短事务，由Saga事务协调器协调，如果正常结束那就正常完成，如果某个步骤失败，则补偿前面已经成功的操作。</p>
<p>​    Saga的组成：每个Saga由一系列sub-transaction Ti 组成 每个Ti 都有对应的补偿动作Ci，补偿动作用于撤销Ti造成的结果,这里的每个T，都是一个本地事务。 可以看到，和TCC相比，Saga没有“预留 try”动作，它的Ti就是直接提交到库。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/TB1Y2kuw7T2gK0jSZFkXXcIQFXa-445-444.png" alt="Saga模式示意图"></p>
<p>Saga的执行顺序有两种：</p>
<p>1、T1, T2, T3, …, Tn</p>
<p>2、T1, T2, …, Tj, Cj,…, C2, C1，其中0 &lt; j &lt; n<br>Saga定义了两种恢复策略：</p>
<p>1、向后恢复：即上面提到的第二种执行顺序，其中j是发生错误的sub-transaction，这种做法的效果是撤销掉之前所有成功的sub-transation，使得整个Saga的执行结果撤销。</p>
<p>2、向前恢复，适用于必须要成功的场景，执行顺序是类似于这样的：T1, T2, …, Tj(失败), Tj(重试),…, Tn，其中j是发生错误的sub-transaction。该情况下不需要Ci</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><ul>
<li>业务流程长、业务流程多</li>
<li>参与者包含其它公司或遗留系统服务，无法提供 TCC 模式要求的三个接口</li>
</ul>
<h3 id="优势"><a href="#优势" class="headerlink" title="优势"></a>优势</h3><ul>
<li>一阶段提交本地事务，无锁，高性能</li>
<li>事件驱动架构，参与者可异步执行，高吞吐</li>
<li>补偿服务易于实现</li>
</ul>
<h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul>
<li>不保证隔离性</li>
</ul>
<p>拿100元买一瓶水的例子来说，这里定义：</p>
<p>​    T1=扣100元 T2=给用户加一瓶水 T3=减库存一瓶水<br>​    C1=加100元 C2=给用户减一瓶水 C3=给库存加一瓶水<br>我们一次进行T1,T2，T3如果发生问题，就执行发生问题的C操作的反向。上面说到的隔离性的问题会出现在，如果执行到T3这个时候需要执行回滚，但是这个用户已经把水喝了(另外一个事务)，回滚的时候就会发现，无法给用户减一瓶水了。这就是事务之间没有隔离性的问题。</p>
<p><strong>三种异常处理</strong></p>
<p><strong>空补偿：</strong>原服务未执行，补偿服务执行了；允许空补偿, 即没有找到要补偿的业务主键时返回补偿成功并将原业务主键记录下来。</p>
<p><strong>悬挂：</strong>补偿服务比原服务先执行；检查当前业务主键是否已经在空补偿记录下来的业务主键中存在，如果存在则要拒绝服务的执行</p>
<p><strong>幂等：</strong>原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新；原服务与补偿服务都需要保证幂等性, 由于网络可能超时, 可以设置重试策略，重试发生时要通过幂等控制避免业务数据重复更新</p>
<p><strong>隔离性问题如何解决</strong></p>
<p>1、参照华为的解决方案(Servicecomb):从业务层面入手加入一 Session 以及锁的机制来保证能够串行化操作资源；</p>
<p>2、在业务层面通过预先冻结资金的方式隔离这部分资源， 最后在业务操作的过程中可以通过及时读取当前状态的方式获取到最新的更新。</p>
<p>3、不回滚，提供“向前”恢复上下文继续执行的能力, 让业务最终执行成功, 达到最终一致性的目的。</p>
<h3 id="Seata-Saga模式"><a href="#Seata-Saga模式" class="headerlink" title="Seata(Saga模式)"></a><a href="https://seata.io/zh-cn/docs/user/saga.html">Seata(Saga模式)</a></h3><h2 id="最终一致性之可靠消息方案"><a href="#最终一致性之可靠消息方案" class="headerlink" title="最终一致性之可靠消息方案"></a>最终一致性之可靠消息方案</h2><h3 id="是什么-4"><a href="#是什么-4" class="headerlink" title="是什么"></a>是什么</h3><p>​    可靠消息最终一致性方案是指当<strong>事务发起方执行完成本地事务后并发出一条消息</strong>，<strong>事务参与方(消息消费者)一定能够接收消息并处理事务成功</strong>，此方案强调的是只要消息发给事务参与方最终事务要达到一致。</p>
<p>​    比如利用消息中间件来完成可靠消息，如下图</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230321224855999.png" alt="image-20230321224855999"></p>
<p>​    事务发起方（消息生产方）将消息发给消息中间件，事务参与方从消息中间件接收消息，事务发起方和消息中间件之间，事务参与方（消息消费方）和消息中间件之间都是通过网络通信，由于网络通信的不确定性会导致分布式事务问题。因此可靠消息最终一致性方案要解决以下几个问题：</p>
<p>1、<strong>本地事务与消息发送的原子性问题</strong></p>
<p>​    事务发起方在本地事务执行成功后消息必须发出去，否则就丢弃消息。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。本地事务与消息发送的原子性问题是实现可靠消息最终一致性方案的<strong>关键问题</strong></p>
<p>先发送消息，再操作数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span> transaction；<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>发送MQ<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>数据库操作<br><span class="hljs-keyword">commit</span> transation;<br>这种情况下无法保证数据库操作与发送消息的一致性，因为可能发送消息成功，数据库操作失败。<br></code></pre></td></tr></table></figure>

<p>先进行数据库操作，再发送消息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">begin</span> transaction；<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">1.</span>数据库操作<br><span class="hljs-operator">/</span><span class="hljs-operator">/</span><span class="hljs-number">2.</span>发送MQ<br><span class="hljs-keyword">commit</span> transation;<br></code></pre></td></tr></table></figure>

<p>​    这种情况下貌似没有问题，如果发送MQ消息失败，就会抛出异常，导致数据库事务回滚。但如果是超时异常，数据库回滚，但MQ其实已经正常发送了，同样会导致不一致。</p>
<p>2、<strong>事务参与方接受消息的可靠性</strong></p>
<p>​    事务参与方必须能够从消息队列接收到消息，如果接收消息失败可以重复接收消息。</p>
<p>3、<strong>消息重复消费的问题</strong></p>
<p>​    由于网络2的存在，若某一个消费节点超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。要解决消息重复消费的问题就要实现事务参与方的方法<strong>幂等</strong>性</p>
<h3 id="本地消息表方案"><a href="#本地消息表方案" class="headerlink" title="本地消息表方案"></a>本地消息表方案</h3><p>​    本地消息表这个方案最初是eBay提出的，此方案的核心是<strong>通过本地事务保证数据业务操作和消息的一致性</strong>，然后通过定时任务将消息发送至消息中间件，待确认消息发送给消费方成功再将消息删除或者修改状态。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230321234442367.png" alt="image-20230321234442367"></p>
<p>1、在同一事务插入消息表使原子性问题得到解决</p>
<p>2、定时任务轮询消息表保证了消息一定能到达事务参与方</p>
<p>3、通过MQ消费的ACK机制确保消费者消费了消息，消费者需要自身实现幂等</p>
<h3 id="RocketMQ事务消息方案"><a href="#RocketMQ事务消息方案" class="headerlink" title="RocketMQ事务消息方案"></a>RocketMQ事务消息方案</h3><p>​    RocketMQ 事务消息设计则主要是为了解决 Producer 端的消息发送与本地事务执行的原子性问题，RocketMQ 的设计中 broker 与 producer 端的<strong>双向通信</strong>能力，使得 broker 天生可以作为一个事务协调者存在；而RocketMQ本身提供的存储机制为事务消息提供了持久化能力；</p>
<p>​    RocketMQ 的高可用机制以及可靠消息设计则为事务消息在系统发生异常时依然能够保证达成事务的最终一致性。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230322222239901.png" alt="image-20230322222239901"></p>
<p>以注册送积分的例子来描述，Producer 即MQ发送方，本例中是用户服务，负责新增用户。MQ订阅方即消息消费方，本例中是积分服务，负责新增积分。执行流程如下：</p>
<p><strong>1、Producer 发送事务消息</strong><br>    Producer （MQ发送方）发送事务消息至MQ Server，MQ Server将消息状态标记为Prepared（预备状态），注<br>意此时这条消息消费者（MQ订阅方）是无法消费到的。本例中，Producer 发送 ”增加积分消息“ 到MQ Server。</p>
<p><strong>2、MQ Server回应消息发送成功</strong></p>
<p>​    MQ Server接收到Producer 发送给的消息则回应发送成功表示MQ已接收到消息</p>
<p><strong>3、Producer 执行本地事务</strong></p>
<p>​    Producer 端执行业务代码逻辑，通过本地数据库事务控制。本例中，Producer 执行添加用户操作</p>
<p><strong>4、消息投递</strong></p>
<p>​    若Producer 本地事务执行成功则自动向MQServer发送commit消息，MQ Server接收到commit消息后将”增加积分消息“ 状态标记为可消费，此时MQ订阅方（积分服务）即正常消费消息；若Producer 本地事务执行失败则自动向MQServer发送rollback消息，MQ Server接收到rollback消息后 将删除”增加积分消息“ 。</p>
<p>​    MQ订阅方（积分服务）消费消息，消费成功则向MQ回应ack，否则将重复接收消息。这里ack默认自动回应，即程序执行正常则自动回应ack。</p>
<p><strong>5、事务回查</strong></p>
<p>​    如果执行Producer端本地事务过程中，执行端挂掉，或者超时，MQ Server将会不停的询问同组的其他 Producer来获取事务执行状态，这个过程叫事务回查。MQ Server会根据事务回查结果来决定是否投递消息。<br>​    以上主干流程已由RocketMQ实现，对用户侧来说，<strong>用户需要分别实现本地事务执行以及本地事务回查方法，因此只需关注本地事务的执行状态即可。</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//1、RoacketMQ提供RocketMQLocalTransactionListener接口：</span><br><span class="hljs-comment">//消息发送成功回调此方法，此方法执行本地事务</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RocketMQLocalTransactionListener</span> </span>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">‐ 发送prepare消息成功此方法被回调，该方法用于执行本地事务</span><br><span class="hljs-comment">‐ <span class="hljs-doctag">@param</span> msg 回传的消息，利用transactionId即可获取到该消息的唯一Id</span><br><span class="hljs-comment">‐ <span class="hljs-doctag">@param</span> arg 调用send方法时传递的参数，当send时候若有额外的参数可以传递到send方法中，这里能获取到</span><br><span class="hljs-comment">‐ <span class="hljs-doctag">@return</span> 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOW：回调</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">RocketMQLocalTransactionState <span class="hljs-title">executeLocalTransaction</span><span class="hljs-params">(Message msg, Object arg)</span></span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment">‐ <span class="hljs-doctag">@param</span> msg 通过获取transactionId来判断这条消息的本地事务执行状态</span><br><span class="hljs-comment">‐ <span class="hljs-doctag">@return</span> 返回事务状态，COMMIT：提交 ROLLBACK：回滚 UNKNOW：回调</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">RocketMQLocalTransactionState <span class="hljs-title">checkLocalTransaction</span><span class="hljs-params">(Message msg)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//2、RocketMQ提供用于发送事务消息的API：</span><br><span class="hljs-comment">//此方法检查事务执行状态</span><br>TransactionMQProducer producer = <span class="hljs-keyword">new</span> TransactionMQProducer(<span class="hljs-string">&quot;ProducerGroup&quot;</span>);<br>producer.setNamesrvAddr(<span class="hljs-string">&quot;127.0.0.1:9876&quot;</span>);<br>producer.start();<br><span class="hljs-comment">//设置TransactionListener实现</span><br>producer.setTransactionListener(transactionListener）；<br><span class="hljs-comment">//发送事务消息</span><br>SendResult sendResult = producer.sendMessageInTransaction(msg, <span class="hljs-keyword">null</span>);<br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>​    可靠消息最终一致性事务适合执行周期长且实时性要求不高的场景。引入消息机制后，同步的事务操作变为基于消息执行的异步操作, 避免了分布式事务中的同步阻塞操作的影响，并实现了两个服务的解耦。</p>
<h2 id="最终一致性之最大努力通知"><a href="#最终一致性之最大努力通知" class="headerlink" title="最终一致性之最大努力通知"></a>最终一致性之最大努力通知</h2><h3 id="是什么-5"><a href="#是什么-5" class="headerlink" title="是什么"></a>是什么</h3><p>目标：<strong>发起通知方通过一定的机制最大努力将业务处理结果通知到接收方</strong>，具体包括：</p>
<p><strong>1、有一定的消息重复通知机制。</strong></p>
<p>​    因为接收通知方可能没有接收到通知，此时要有一定的机制对消息重复通知。</p>
<p><strong>2、消息校对机制。</strong></p>
<p>​    如果尽最大努力也没有通知到接收方，或者接收方消费消息后要再次消费，此时可由接收方主动向通知方查询消息信息来满足需求。</p>
<p><strong>最大努力通知与可靠消息一致性有什么不同</strong></p>
<p><strong>1、解决方案思想不同</strong></p>
<p>​    可靠消息一致性，发起通知方需要保证将消息发出去，并且将消息发到接收通知方，<strong>消息的可靠性关键由发起通知方来保证</strong>。</p>
<p>​    最大努力通知，发起通知方尽最大的努力将业务处理结果通知为接收通知方，但是可能消息接收不到，此时需要接收通知方主动调用发起通知方的接口查询业务处理结果，<strong>通知的可靠性关键在接收通知方</strong>。</p>
<p><strong>2、两者的业务应用场景不同</strong></p>
<p>​    可靠消息一致性关注的是交易过程的事务一致，以异步的方式完成交易。</p>
<p>​    最大努力通知关注的是交易后的<strong>通知事务</strong>，即将交易结果可靠的通知出去。</p>
<p><strong>3、技术解决方向不同</strong></p>
<p>​    可靠消息一致性要解决消息从发出到接收的一致性，即消息发出并且被接收到。</p>
<p>​    最大努力通知无法保证消息从发出到接收的一致性，只提供消息接收的可靠性机制。可靠机制：最大努力的将消息通知给接收方，当消息无法被接收方接收时，由接收方主动查询消息（业务处理结果）。</p>
<h3 id="技术方案"><a href="#技术方案" class="headerlink" title="技术方案"></a>技术方案</h3><h4 id="消息通知方-MQ-ack机制-接受通知方"><a href="#消息通知方-MQ-ack机制-接受通知方" class="headerlink" title="消息通知方 + MQ(ack机制) + 接受通知方"></a>消息通知方 + MQ(ack机制) + 接受通知方</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230325160143614.png" alt="image-20230325160143614"></p>
<p>1、消息通知方发送通知MQ（普通消息）</p>
<p>2、接受通知方监听MQ</p>
<p>3、接收通知方接受消息成功，业务处理完成后回应ack，若无回应，则MQ会重复通知</p>
<p>4、接收通知方可以通过消息校对接口（通知方提供）来校对消息的一致性</p>
<h4 id="消息通知方-MQ-ack机制-通知程序-接受通知方"><a href="#消息通知方-MQ-ack机制-通知程序-接受通知方" class="headerlink" title="消息通知方 + MQ(ack机制) + 通知程序+接受通知方"></a>消息通知方 + MQ(ack机制) + 通知程序+接受通知方</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230325161104590.png" alt="image-20230325161104590"></p>
<p>1、消息通知方发送通知MQ（普通消息）</p>
<p>2、通知程序监听 MQ监听MQ</p>
<p>3、通知程序通过互联网接口协议（如http、webservice）调用接收通知方案接口，完成通知。<br>通知程序调用接收通知方接口成功就表示通知成功，即消费MQ消息成功，MQ将不再向通知程序投递通知消<br>息。</p>
<p>4、接收通知方可以通过消息校对接口（通知方提供）来校对消息的一致性</p>
<h4 id="举例：充值结果通知"><a href="#举例：充值结果通知" class="headerlink" title="举例：充值结果通知"></a>举例：充值结果通知</h4><p>充值系统：通知方</p>
<p>账户系统：被通知方</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230326195650362.png" alt="image-20230326195650362"></p>
<p>交互流程如下：</p>
<p>1、用户请求充值系统进行充值<br>2、充值系统完成充值将充值结果发给MQ<br>3、账户系统监听MQ，接收充值结果通知，如果接收不到消息，MQ会重复发送通知。接收到充值结果通知账户系<br>统增加充值金额<br>4、账户系统也可以主动查询充值系统的充值结果查询接口，增加金额</p>
<h2 id="综合案例分析"><a href="#综合案例分析" class="headerlink" title="综合案例分析"></a>综合案例分析</h2><p>​    结合互联网金融项目中的业务场景，来进行分布式事务解决方案可行性分析</p>
<h3 id="系统介绍"><a href="#系统介绍" class="headerlink" title="系统介绍"></a>系统介绍</h3><h4 id="P2P介绍"><a href="#P2P介绍" class="headerlink" title="P2P介绍"></a>P2P介绍</h4><p>​    P2P金融又叫P2P信贷。其中P2P是 peer-to-peer 或 person-to-person 的简写，意思是：个人对个人。P2P金融指个人与个人间的小额借贷交易，一般需要借助电子商务专业网络平台帮助借贷双方确立借贷关系并完成相关交易手续。借款者可自行发布借款信息，包括金额、利息、还款方式和时间，实现自助式借款;投资者根据借款人发布的信息，自行决定出借金额，实现自助式借贷。<br>​    目前，国家对P2P行业的监控与规范性控制越来越严格，出台了很多政策来对其专项整治。并主张采用“银行存管模式”来规避P2P平台挪用借投人资金的风险，通过银行开发的“银行存管系统”管理投资者的资金，每位P2P平台用户在银行的存管系统内都会有一个独立账号，平台来管理交易，做到资金和交易分开，让P2P平台不能接触到资金，就可以一定程度避免资金被挪用的风险。<br>​    什么是银行存管模式？<br>银行存管模式涉及到2套账户体系，P2P平台和银行各一套账户体系。投资人在P2P平台注册后，会同时跳转到银行再开一个电子账户，2个账户间有一一对应的关系。当投资人投资时，资金进入的是平台在银行为投资人开设的二级账户中，每一笔交易，是由银行在投资人与借款人间的交易划转，P2P平台仅能看到信息的流动。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230410084845209.png" alt="image-20230410084845209"></p>
<h4 id="总体业务流程"><a href="#总体业务流程" class="headerlink" title="总体业务流程"></a>总体业务流程</h4><p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230410085033602.png" alt="image-20230410085033602"></p>
<h4 id="业务术语"><a href="#业务术语" class="headerlink" title="业务术语"></a>业务术语</h4><table>
<thead>
<tr>
<th align="left">术语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">银行的存管模式</td>
<td>此种模式下，涉及到2套账户体系，P2P平台和银行各一套账户体系。投资人在P2P平台注册后，会同时跳转到银行再开一个电子账户，2个账户间有一一对应的关系。当投资人投资时，资金进入的是平台在银行为投资人开设的二级账户中，每一笔交易，是由银行在投资人与借款人间的交易划转，P2P平台仅能看到信息的流动</td>
</tr>
<tr>
<td align="left">标的</td>
<td>P2P业内，习惯把借款人发布的投资项目称为“标的”</td>
</tr>
<tr>
<td align="left">发标</td>
<td>借款人在P2P平台中创建并发布“标的”过程</td>
</tr>
<tr>
<td align="left">投标</td>
<td>投资人在认可相关借款人之后进行的一种借贷行为，对自己中意的借款标的进行投资操作，一个借款标可由单个投资人或多个投资人承接</td>
</tr>
<tr>
<td align="left">满标</td>
<td>单笔借款标筹集齐所有借款资金即为满标，计息时间是以标满当日开始计息，投资人较多的平台多数</td>
</tr>
</tbody></table>
<h4 id="模块说明"><a href="#模块说明" class="headerlink" title="模块说明"></a>模块说明</h4><p><strong>统一账号服务</strong><br>    用户的登录账号、密码、角色、权限、资源等系统级信息的管理，不包含用户业务信息。<br><strong>用户中心</strong><br>    提供用户业务信息的管理，如会员信息、实名认证信息、绑定银行卡信息等，“用户中心”的每个用户与“统一账号服务”中的账号关联<br><strong>交易中心</strong><br>    提供发标、投标等业务<br><strong>还款服务</strong><br>    提供还款计划的生成、执行、记录与归档<br><strong>银行存管系统(模拟)</strong><br>    模拟银行存管系统，进行资金的存管，划转</p>
<h3 id="注册账号"><a href="#注册账号" class="headerlink" title="注册账号"></a>注册账号</h3><h4 id="业务流程"><a href="#业务流程" class="headerlink" title="业务流程"></a>业务流程</h4><p>​    采用用户、账号分离设计(这样设计的好处是，当用户的业务信息发生变化时，不会影响的认证、授权等系统机制)，因此需要保证用户信息与账号信息的一致性。</p>
<p>​    用户向用户中心发起注册请求，用户中心保存用户业务信息，然后通知统一账号服务新建该用户所对应登录账号。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230410093050816.png" alt="image-20230410093050816"></p>
<h4 id="解决方案分析"><a href="#解决方案分析" class="headerlink" title="解决方案分析"></a>解决方案分析</h4><p>针对注册业务，如果用户与账号信息不一致，则会导致严重问题，因此该业务对一致性要求较为严格，即当用户服</p>
<p>务和账号服务任意一方出现问题都需要回滚事务。</p>
<p>根据上述需求进行解决方案分析：</p>
<p>1 、采用可靠消息一致性方案</p>
<p>可靠消息一致性要求只要消息发出，事务参与者接到消息就要将事务执行成功，不存在回滚的要求，所以不适用。</p>
<p>2 、采用最大努力通知方案</p>
<p>最大努力通知表示发起通知方执行完本地事务后将结果通知给事务参与者，即使事务参与者执行业务处理失败发起</p>
<p>通知方也不会回滚事务，所以不适用。</p>
<p>3 、采用Seata实现2PC</p>
<p>在用户中心发起全局事务，统一账户服务为事务参与者，用户中心和统一账户服务只要有一方出现问题则全局事务<br>回滚，符合要求。</p>
<p>实现方法如下：</p>
<p>​    1 、用户中心添加用户信息，开启全局事务</p>
<p>​    2 、统一账号服务添加账号信息，作为事务参与者</p>
<p>​    3 、其中一方执行失败Seata对SQL进行逆操作删除用户信息和账号信息，实现回滚。</p>
<p>4 、采用Hmily实现TCC</p>
<p>TCC也可以实现用户中心和统一账户服务只要有一方出现问题则全局事务回滚，符合要求。</p>
<p>实现方法如下：</p>
<p>1 、用户中心</p>
<p>try：添加用户，状态为不可用</p>
<p>confirm：更新用户状态为可用</p>
<p>cancel：删除用户</p>
<p>2 、统一账号服务</p>
<p>try：添加账号，状态为不可用</p>
<p>confirm：更新账号状态为可用</p>
<p>cancel：删除账号</p>
<h3 id="存管开户"><a href="#存管开户" class="headerlink" title="存管开户"></a>存管开户</h3><h4 id="业务流程-1"><a href="#业务流程-1" class="headerlink" title="业务流程"></a>业务流程</h4><p>​    根据政策要求，P2P业务必须让银行存管资金，用户的资金在银行存管系统的账户中，而不在P2P平台中，因此用户要在银行存管系统开户。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230412083838985.png" alt="image-20230412083838985"></p>
<p>​    用户向用户中心提交开户资料，用户中心生成开户请求号并重定向至银行存管系统开户页面。用户设置存管密码并确认开户后，银行存管立即返回“请求已受理”。在某一时刻，银行存管系统处理完该开户请求后，将调用回调地址通知处理结果，若通知失败，则按一定策略重试通知。同时，银行存管系统应提供开户结果查询的接口，供用户中心校对结果。</p>
<h4 id="解决方案分析-1"><a href="#解决方案分析-1" class="headerlink" title="解决方案分析"></a>解决方案分析</h4><p>​    P2P平台的用户中心与银行存管系统之间属于跨系统交互，银行存管系统属于外部系统，用户中心无法干预银行存管系统，所以用户中心只能在收到银行存管系统的业务处理结果通知后积极处理，开户后的使用情况完全由用户中心来控制。<br>根据上述需求进行解决方案分析：</p>
<p>1 、采用Seata实现2PC</p>
<p>需要侵入银行存管系统的数据库，由于它的外部系统，所以不适用。</p>
<p>2 、采用Hmily实现TCC</p>
<p>TCC侵入性更强，所以不适用。</p>
<p>3 、基于MQ的可靠消息一致性</p>
<p>如果让银行存管系统监听 MQ则不合适 ，因为它的外部系统。如果银行存管系统将消息发给MQ用户中心监听MQ是可以的，但是由于相对银行存管系统来说用户中心属于外部系统，银行存管系统是不会让外部系统直接监听自己的MQ的，基于MQ的通信协议也不方便外部系统间的交互，所以本方案不合适。</p>
<p>4 、最大努力通知方案</p>
<p>银行存管系统内部使用MQ，银行存管系统处理完业务后将处理结果发给MQ，由银行存管的通知程序专门发送通<br>知，并且采用互联网协议通知给第三方系统（用户中心）。</p>
<p><img src="/images/%E5%88%86%E5%B8%83%E5%BC%8F-%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A101/image-20230412084557915.png" alt="image-20230412084557915"></p>
<h3 id="满标审核"><a href="#满标审核" class="headerlink" title="满标审核"></a>满标审核</h3><h4 id="业务流程-2"><a href="#业务流程-2" class="headerlink" title="业务流程"></a>业务流程</h4><p>​    在借款人标的募集够所有的资金后，P2P运营管理员审批该标的，触发放款，并开启还款流程。</p>
<h4 id="解决方案分析-2"><a href="#解决方案分析-2" class="headerlink" title="解决方案分析"></a>解决方案分析</h4><p>根据上述需求进行解决方案分析：</p>
<p>1 、采用Seata实现2PC</p>
<p>Seata在事务执行过程会进行数据库资源锁定，由于事务执行时长较长会将资源锁定较长时间，所以不适用。</p>
<p>2 、采用Hmily实现TCC</p>
<p>本需求对业务一致性要求较低，因为生成还款计划的时长较长，所以不要求交易中心修改标的状态为“还款中”就立<br>即生成还款计划 ，所以本方案不适用。</p>
<p>3 、基于MQ的可靠消息一致性</p>
<p>满标审批通过后由交易中心修改标的状态为“还款中”并且向还款服务发送消息，还款服务接收到消息开始生成还款<br>计划，基本于MQ的可靠消息一致性方案适用此场景 。</p>
<p>4 、最大努力通知方案</p>
<p>满标审批通过后由交易中心向还款服务发送通知要求生成还款计划，还款服务并且对外提供还款计划生成结果校对<br>接口供其它服务查询，最大努力 通知方案也适用本场景 。</p>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><h3 id="能不用分布式事务就不用"><a href="#能不用分布式事务就不用" class="headerlink" title="能不用分布式事务就不用"></a>能不用分布式事务就不用</h3><p>​    能不用分布式事务就不用，如果非得使用的话，结合自己的业务分析，看看自己的业务比较适合哪一种，是在乎强一致，还是最终一致即可。上面对解决方案只是一些简单介绍，如果真正的想要落地，其实每种方案需要思考的地方都非常多，复杂度都比较大，所以最后再次提醒一定要判断好是否使用分布式事务。</p>
<h3 id="没有银弹"><a href="#没有银弹" class="headerlink" title="没有银弹"></a>没有银弹</h3><p>​    无论是数据库层的XA、还是应用层TCC、可靠消息、最大努力通知等方案，都没有完美解决分布式事务问题，它们不过是各自在性能、一致性、可用性等方面做取舍，寻求某些场景偏好下的权衡。</p>
<h3 id="合理的服务拆分"><a href="#合理的服务拆分" class="headerlink" title="合理的服务拆分"></a>合理的服务拆分</h3><p>​    必须使用分布式事务时，若某系统频繁且不合理的使用分布式事务，应首先从整体设计角度观察服务的拆分是否合理，是否高内聚低耦合？是否粒度太小？一个合理的服务划分可以大大减少不必要的分布式事务场景。</p>
<h3 id="各方案特点总结"><a href="#各方案特点总结" class="headerlink" title="各方案特点总结"></a>各方案特点总结</h3><table>
<thead>
<tr>
<th></th>
<th><strong>2PC</strong></th>
<th><strong>TCC</strong></th>
<th>Saga</th>
<th><strong>可靠消息</strong></th>
<th><strong>最大努力通知</strong></th>
</tr>
</thead>
<tbody><tr>
<td>一致性</td>
<td>强一致性</td>
<td>强一致性</td>
<td>强一致性</td>
<td>最终一致</td>
<td>最终一致</td>
</tr>
<tr>
<td>吞吐量</td>
<td>低</td>
<td>中</td>
<td>中</td>
<td>高</td>
<td>高</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>易</td>
<td>难</td>
<td>较难</td>
<td>中</td>
<td>中</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>特性/方案</th>
<th>XA</th>
<th>AT</th>
<th>TCC</th>
<th>SAGA</th>
</tr>
</thead>
<tbody><tr>
<td>一致性</td>
<td>强一致</td>
<td>强一致</td>
<td>强一致</td>
<td>强一致</td>
</tr>
<tr>
<td>代码入侵</td>
<td>无</td>
<td>无</td>
<td>强</td>
<td>较强</td>
</tr>
<tr>
<td>数据库事务</td>
<td>支持XA 事务的数据库</td>
<td>支持本地 ACID 事务的关系型数据库</td>
<td>不依赖</td>
<td>不依赖</td>
</tr>
<tr>
<td>实现复杂度</td>
<td>简单</td>
<td>简单</td>
<td>复杂</td>
<td>较复杂</td>
</tr>
</tbody></table>
<p><strong>强一致性方案</strong></p>
<table>
<thead>
<tr>
<th>分布式事务模式</th>
<th>介绍</th>
<th>技术栈</th>
</tr>
</thead>
<tbody><tr>
<td>XA</td>
<td>分布式强一致性的解决方案，依赖支持XA 事务的数据库，但<strong>性能低</strong>而使用较少。</td>
<td>seata、shardingsphere</td>
</tr>
<tr>
<td>AT</td>
<td>无侵入的分布式事务解决方案，依赖支持本地 ACID 事务的关系型数据库，适用于不希望对业务进行改造的场景，几乎0学习成本（sql都由框架托管统一执行）</td>
<td>seata、shardingsphere</td>
</tr>
<tr>
<td>TCC</td>
<td>高性能分布式事务解决方案，适用于核心系统等对性能有很高要求的场景（不适合长事务和嵌套事务（service a-&gt;service b-&gt;service c）），实现较为灵活，代码入侵大（应用自己定义数据操作的粒度，使得降低锁冲突、提高吞吐量成为可能，对应用的侵入性非常强，业务逻辑的每个分支都需要实现try、confirm、cancel三个操作。此外，其实现难度也比较大）</td>
<td>seata、service-comb</td>
</tr>
<tr>
<td>Saga</td>
<td>长事务解决方案，适用于业务流程长且需要保证事务最终一致性的业务系统（存在隔离性问题），代码存在入侵。</td>
<td>seata、shardingsphere、service-comb</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>分布式事务</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>分布式事务</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day05</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day05/</url>
    <content><![CDATA[<h1 id="6，行为型模式"><a href="#6，行为型模式" class="headerlink" title="6，行为型模式"></a>6，行为型模式</h1><h2 id="6-5-状态模式"><a href="#6-5-状态模式" class="headerlink" title="6.5 状态模式"></a>6.5 状态模式</h2><h3 id="6-5-1-概述"><a href="#6-5-1-概述" class="headerlink" title="6.5.1 概述"></a>6.5.1 概述</h3><p>【例】通过按钮来控制一个电梯的状态，一个电梯有开门状态，关门状态，停止状态，运行状态。每一种状态改变，都有可能要根据其他状态来更新处理。例如，如果电梯门现在处于运行时状态，就不能进行开门操作，而如果电梯门是停止状态，就可以执行开门操作。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day05/状态模式前.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ILift</span> </span>&#123;<br>    <span class="hljs-comment">//电梯的4个状态</span><br>    <span class="hljs-comment">//开门状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> OPENING_STATE = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">//关门状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> CLOSING_STATE = <span class="hljs-number">2</span>;<br>    <span class="hljs-comment">//运行状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> RUNNING_STATE = <span class="hljs-number">3</span>;<br>    <span class="hljs-comment">//停止状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> STOPPING_STATE = <span class="hljs-number">4</span>;<br><br><br>    <span class="hljs-comment">//电梯的动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Lift</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ILift</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> state;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setState</span><span class="hljs-params">(<span class="hljs-keyword">int</span> state)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.state = state;<br>    &#125;<br><br>    <span class="hljs-comment">//执行关门动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE:<br>                System.out.println(<span class="hljs-string">&quot;电梯关门了。。。&quot;</span>);<span class="hljs-comment">//只有开门状态可以关闭电梯门，可以对应电梯状态表来看</span><br>                <span class="hljs-keyword">this</span>.setState(CLOSING_STATE);<span class="hljs-comment">//关门之后电梯就是关闭状态了</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<br>                <span class="hljs-comment">//do nothing //已经是关门状态，不能关门</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<br>                <span class="hljs-comment">//do nothing //运行时电梯门是关着的，不能关门</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                <span class="hljs-comment">//do nothing //停止时电梯也是关着的，不能关门</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行开门动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE:<span class="hljs-comment">//门已经开了，不能再开门了</span><br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<span class="hljs-comment">//关门状态，门打开:</span><br>                System.out.println(<span class="hljs-string">&quot;电梯门打开了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(OPENING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<br>                <span class="hljs-comment">//do nothing 运行时电梯不能开门</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                System.out.println(<span class="hljs-string">&quot;电梯门开了。。。&quot;</span>);<span class="hljs-comment">//电梯停了，可以开门了</span><br>                <span class="hljs-keyword">this</span>.setState(OPENING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行运行动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE:<span class="hljs-comment">//电梯不能开着门就走</span><br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<span class="hljs-comment">//门关了，可以运行了</span><br>                System.out.println(<span class="hljs-string">&quot;电梯开始运行了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(RUNNING_STATE);<span class="hljs-comment">//现在是运行状态</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<br>                <span class="hljs-comment">//do nothing 已经是运行状态了</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                System.out.println(<span class="hljs-string">&quot;电梯开始运行了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(RUNNING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//执行停止动作</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-keyword">this</span>.state) &#123;<br>            <span class="hljs-keyword">case</span> OPENING_STATE: <span class="hljs-comment">//开门的电梯已经是是停止的了(正常情况下)</span><br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> CLOSING_STATE:<span class="hljs-comment">//关门时才可以停止</span><br>                System.out.println(<span class="hljs-string">&quot;电梯停止了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(STOPPING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> RUNNING_STATE:<span class="hljs-comment">//运行时当然可以停止了</span><br>                System.out.println(<span class="hljs-string">&quot;电梯停止了。。。&quot;</span>);<br>                <span class="hljs-keyword">this</span>.setState(STOPPING_STATE);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> STOPPING_STATE:<br>                <span class="hljs-comment">//do nothing</span><br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Lift lift = <span class="hljs-keyword">new</span> Lift();<br>        lift.setState(ILift.STOPPING_STATE);<span class="hljs-comment">//电梯是停止的</span><br>        lift.open();<span class="hljs-comment">//开门</span><br>        lift.close();<span class="hljs-comment">//关门</span><br>        lift.run();<span class="hljs-comment">//运行</span><br>        lift.stop();<span class="hljs-comment">//停止</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>问题分析：</p>
<ul>
<li>使用了大量的switch…case这样的判断（if…else也是一样)，使程序的可阅读性变差。</li>
<li>扩展性很差。如果新加了断电的状态，我们需要修改上面判断逻辑</li>
</ul>
<p><strong>定义：</strong></p>
<p>对有状态的对象，把复杂的“判断逻辑”提取到不同的状态对象中，允许状态对象在其内部状态发生改变时改变其行为。</p>
<h3 id="6-5-2-结构"><a href="#6-5-2-结构" class="headerlink" title="6.5.2 结构"></a>6.5.2 结构</h3><p>状态模式包含以下主要角色。</p>
<ul>
<li>环境（Context）角色：也称为上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象来处理。</li>
<li>抽象状态（State）角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为。</li>
<li>具体状态（Concrete  State）角色：实现抽象状态所对应的行为。</li>
</ul>
<h3 id="6-5-3-案例实现"><a href="#6-5-3-案例实现" class="headerlink" title="6.5.3 案例实现"></a>6.5.3 案例实现</h3><p>对上述电梯的案例使用状态模式进行改进。类图如下：</p>
<img src="/images/设计模式-day05/状态模式.png" style="zoom:70%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象状态类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LiftState</span> </span>&#123;<br>    <span class="hljs-comment">//定义一个环境角色，也就是封装状态的变化引起的功能变化</span><br>    <span class="hljs-keyword">protected</span> Context context;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setContext</span><span class="hljs-params">(Context context)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.context = context;<br>    &#125;<br><br>    <span class="hljs-comment">//电梯开门动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//电梯关门动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//电梯运行动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//电梯停止动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//开启状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OpenningState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-comment">//开启当然可以关闭了，我就想测试一下电梯门开关功能</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯门开启...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.closeingState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().close();<br>    &#125;<br><br>    <span class="hljs-comment">//电梯门不能开着就跑，这里什么也不做</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">//开门状态已经是停止的了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//运行状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RunningState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-comment">//运行的时候开电梯门？你疯了！电梯不会给你开的</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">//电梯门关闭？这是肯定了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//虽然可以关门，但这个动作不归我执行</span><br>        <span class="hljs-comment">//do nothing</span><br>    &#125;<br><br>    <span class="hljs-comment">//这是在运行状态下要实现的方法</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯正在运行...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//这个事绝对是合理的，光运行不停止还有谁敢做这个电梯？！估计只有上帝了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.stoppingState);<br>        <span class="hljs-keyword">super</span>.context.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//停止状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoppingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-comment">//停止状态，开门，那是要的！</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.openningState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().open();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<span class="hljs-comment">//虽然可以关门，但这个动作不归我执行</span><br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.closeingState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().close();<br>    &#125;<br><br>    <span class="hljs-comment">//停止状态再跑起来，正常的很</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//状态修改</span><br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.runningState);<br>        <span class="hljs-comment">//动作委托为CloseState来执行，也就是委托给了ClosingState子类执行这个动作</span><br>        <span class="hljs-keyword">super</span>.context.getLiftState().run();<br>    &#125;<br><br>    <span class="hljs-comment">//停止状态是怎么发生的呢？当然是停止方法执行了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯停止了...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//关闭状态</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClosingState</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">LiftState</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">//电梯门关闭，这是关闭状态要实现的动作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;电梯门关闭...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//电梯门关了再打开，逗你玩呢，那这个允许呀</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.openningState);<br>        <span class="hljs-keyword">super</span>.context.open();<br>    &#125;<br><br><br>    <span class="hljs-comment">//电梯门关了就跑，这是再正常不过了</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.runningState);<br>        <span class="hljs-keyword">super</span>.context.run();<br>    &#125;<br><br>    <span class="hljs-comment">//电梯门关着，我就不按楼层</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.context.setLiftState(Context.stoppingState);<br>        <span class="hljs-keyword">super</span>.context.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//环境角色</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span> </span>&#123;<br>    <span class="hljs-comment">//定义出所有的电梯状态</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> OpenningState openningState = <span class="hljs-keyword">new</span> OpenningState();<span class="hljs-comment">//开门状态，这时候电梯只能关闭</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> ClosingState closeingState = <span class="hljs-keyword">new</span> ClosingState();<span class="hljs-comment">//关闭状态，这时候电梯可以运行、停止和开门</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> RunningState runningState = <span class="hljs-keyword">new</span> RunningState();<span class="hljs-comment">//运行状态，这时候电梯只能停止</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> StoppingState stoppingState = <span class="hljs-keyword">new</span> StoppingState();<span class="hljs-comment">//停止状态，这时候电梯可以开门、运行</span><br><br><br>    <span class="hljs-comment">//定义一个当前电梯状态</span><br>    <span class="hljs-keyword">private</span> LiftState liftState;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LiftState <span class="hljs-title">getLiftState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.liftState;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLiftState</span><span class="hljs-params">(LiftState liftState)</span> </span>&#123;<br>        <span class="hljs-comment">//当前环境改变</span><br>        <span class="hljs-keyword">this</span>.liftState = liftState;<br>        <span class="hljs-comment">//把当前的环境通知到各个实现类中</span><br>        <span class="hljs-keyword">this</span>.liftState.setContext(<span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">open</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.open();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.close();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.run();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.liftState.stop();<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Context context = <span class="hljs-keyword">new</span> Context();<br>        context.setLiftState(<span class="hljs-keyword">new</span> ClosingState());<br><br>        context.open();<br>        context.close();<br>        context.run();<br>        context.stop();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-5-4-优缺点"><a href="#6-5-4-优缺点" class="headerlink" title="6.5.4 优缺点"></a>6.5.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。</li>
<li>允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>状态模式的使用必然会增加系统类和对象的个数。 </li>
<li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。</li>
<li>状态模式对”开闭原则”的支持并不太好。</li>
</ul>
<h3 id="6-5-5-使用场景"><a href="#6-5-5-使用场景" class="headerlink" title="6.5.5 使用场景"></a>6.5.5 使用场景</h3><ul>
<li>当一个对象的行为取决于它的状态，并且它必须在运行时根据状态改变它的行为时，就可以考虑使用状态模式。</li>
<li>一个操作中含有庞大的分支结构，并且这些分支决定于对象的状态时。</li>
</ul>
<h3 id="6-5-6-菜鸟教程：策略模式和状态模式的区别"><a href="#6-5-6-菜鸟教程：策略模式和状态模式的区别" class="headerlink" title="6.5.6 菜鸟教程：策略模式和状态模式的区别"></a>6.5.6 菜鸟教程：策略模式和状态模式的区别</h3><p>​    1、策略模式:更侧重于选中客户端哪种策略,不同策略对应不同操作</p>
<p>​    2、状态模式:侧重于客户端无需知道内部状态，<strong>对象状态可以自行流转</strong>，且不同状态不同操作结果，</p>
<p>​        客户端不需要清楚状态的改变，它只用调用状态的方法就行</p>
<p>​    <a href="https://www.runoob.com/w3cnote/state-vs-strategy.html">https://www.runoob.com/w3cnote/state-vs-strategy.html</a> </p>
<h2 id="6-6-观察者模式"><a href="#6-6-观察者模式" class="headerlink" title="6.6 观察者模式"></a>6.6 观察者模式</h2><h3 id="6-6-1-概述"><a href="#6-6-1-概述" class="headerlink" title="6.6.1 概述"></a>6.6.1 概述</h3><p><strong>定义：</strong></p>
<p>又被称为发布-订阅（Publish/Subscribe）模式，它定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态变化时，会通知所有的观察者对象，使他们能够自动更新自己。</p>
<h3 id="6-6-2-结构"><a href="#6-6-2-结构" class="headerlink" title="6.6.2 结构"></a>6.6.2 结构</h3><p>在观察者模式中有如下角色：</p>
<ul>
<li>Subject：抽象主题（抽象被观察者），抽象主题角色把所有观察者对象保存在一个集合里，每个主题都可以有任意数量的观察者，抽象主题提供一个接口，可以增加和删除观察者对象。</li>
<li>ConcreteSubject：具体主题（具体被观察者），该角色将有关状态存入具体观察者对象，在具体主题的内部状态发生改变时，给所有注册过的观察者发送通知。</li>
<li>Observer：抽象观察者，是观察者的抽象类，它定义了一个更新接口，使得在得到主题更改通知时更新自己。</li>
<li>ConcrereObserver：具体观察者，实现抽象观察者定义的更新接口，以便在得到主题更改通知时更新自身的状态。</li>
</ul>
<h3 id="6-6-3-案例实现"><a href="#6-6-3-案例实现" class="headerlink" title="6.6.3 案例实现"></a>6.6.3 案例实现</h3><p>【例】微信公众号</p>
<p>在使用微信公众号时，大家都会有这样的体验，当你关注的公众号中有新内容更新的话，它就会推送给关注公众号的微信用户端。我们使用观察者模式来模拟这样的场景，微信用户就是观察者，微信公众号是被观察者，有多个的微信用户关注了程序猿这个公众号。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day05/观察者模式.png" style="zoom:80%;">

<p>代码如下：</p>
<p>定义抽象观察者类，里面定义一个更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体观察者类，微信用户是观察者，里面实现了更新的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeixinUser</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-comment">// 微信用户名</span><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeixinUser</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;-&quot;</span> + message);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义抽象主题类，提供了attach、detach、notify三个方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//增加订阅者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer observer)</span></span>;<br><br>    <span class="hljs-comment">//删除订阅者</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer observer)</span></span>;<br>    <br>    <span class="hljs-comment">//通知订阅者更新消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(String message)</span></span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>微信公众号是具体主题（具体被观察者），里面存储了订阅该公众号的微信用户，并实现了抽象主题中的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubscriptionSubject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-comment">//储存订阅公众号的微信用户</span><br>    <span class="hljs-keyword">private</span> List&lt;Observer&gt; weixinUserlist = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">attach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        weixinUserlist.add(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">detach</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        weixinUserlist.remove(observer);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notify</span><span class="hljs-params">(String message)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : weixinUserlist) &#123;<br>            observer.update(message);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端程序</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SubscriptionSubject mSubscriptionSubject=<span class="hljs-keyword">new</span> SubscriptionSubject();<br>        <span class="hljs-comment">//创建微信用户</span><br>        WeixinUser user1=<span class="hljs-keyword">new</span> WeixinUser(<span class="hljs-string">&quot;孙悟空&quot;</span>);<br>        WeixinUser user2=<span class="hljs-keyword">new</span> WeixinUser(<span class="hljs-string">&quot;猪悟能&quot;</span>);<br>        WeixinUser user3=<span class="hljs-keyword">new</span> WeixinUser(<span class="hljs-string">&quot;沙悟净&quot;</span>);<br>        <span class="hljs-comment">//订阅公众号</span><br>        mSubscriptionSubject.attach(user1);<br>        mSubscriptionSubject.attach(user2);<br>        mSubscriptionSubject.attach(user3);<br>        <span class="hljs-comment">//公众号更新发出消息给订阅的微信用户</span><br>        mSubscriptionSubject.notify(<span class="hljs-string">&quot;传智黑马的专栏更新了&quot;</span>);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-6-4-优缺点"><a href="#6-6-4-优缺点" class="headerlink" title="6.6.4 优缺点"></a>6.6.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>降低了目标与观察者之间的耦合关系，两者之间是抽象耦合关系。</li>
<li>被观察者发送通知，所有注册的观察者都会收到信息【可以实现广播机制】</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>如果观察者非常多的话，那么所有的观察者收到被观察者发送的通知会耗时</li>
<li>如果被观察者有循环依赖的话，那么被观察者发送通知会使观察者循环调用，会导致系统崩溃</li>
</ul>
<h3 id="6-6-5-使用场景"><a href="#6-6-5-使用场景" class="headerlink" title="6.6.5 使用场景"></a>6.6.5 使用场景</h3><ul>
<li>对象间存在一对多关系，一个对象的状态发生改变会影响其他对象。</li>
<li>当一个抽象模型有两个方面，其中一个方面依赖于另一方面时。</li>
</ul>
<h3 id="6-6-6-JDK中提供的实现"><a href="#6-6-6-JDK中提供的实现" class="headerlink" title="6.6.6 JDK中提供的实现"></a>6.6.6 JDK中提供的实现</h3><p>在 Java 中，通过 java.util.Observable 类和 java.util.Observer 接口定义了观察者模式，只要实现它们的子类就可以编写观察者模式实例。</p>
<p><strong>1，Observable类</strong></p>
<p>Observable 类是抽象目标类（被观察者），它有一个 Vector 集合成员变量，用于保存所有要通知的观察者对象，下面来介绍它最重要的 3 个方法。</p>
<ul>
<li><p>void addObserver(Observer o) 方法：用于将新的观察者对象添加到集合中。</p>
</li>
<li><p>void notifyObservers(Object arg) 方法：调用集合中的所有观察者对象的 update方法，通知它们数据发生改变。通常越晚加入集合的观察者越先得到通知。</p>
</li>
<li><p>void setChange() 方法：用来设置一个 boolean 类型的内部标志，注明目标对象发生了变化。当它为true时，notifyObservers() 才会通知观察者。</p>
</li>
</ul>
<p><strong>2，Observer 接口</strong></p>
<p>Observer 接口是抽象观察者，它监视目标对象的变化，当目标对象发生变化时，观察者得到通知，并调用 update 方法，进行相应的工作。</p>
<p>【例】警察抓小偷</p>
<p>警察抓小偷也可以使用观察者模式来实现，警察是观察者，小偷是被观察者。代码如下：</p>
<p>小偷是一个被观察者，所以需要继承Observable类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thief</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Observable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Thief</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">steal</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;小偷：我偷东西了，有没有人来抓我！！！&quot;</span>);<br>        <span class="hljs-keyword">super</span>.setChanged(); <span class="hljs-comment">//changed  = true</span><br>        <span class="hljs-keyword">super</span>.notifyObservers();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>警察是一个观察者，所以需要让其实现Observer接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Policemen</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Policemen</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setName</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Observable o, Object arg)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;警察：&quot;</span> + ((Thief) o).getName() + <span class="hljs-string">&quot;，我已经盯你很久了，你可以保持沉默，但你所说的将成为呈堂证供！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建小偷对象</span><br>        Thief t = <span class="hljs-keyword">new</span> Thief(<span class="hljs-string">&quot;隔壁老王&quot;</span>);<br>        <span class="hljs-comment">//创建警察对象</span><br>        Policemen p = <span class="hljs-keyword">new</span> Policemen(<span class="hljs-string">&quot;小李&quot;</span>);<br>        <span class="hljs-comment">//让警察盯着小偷</span><br>        t.addObserver(p);<br>        <span class="hljs-comment">//小偷偷东西</span><br>        t.steal();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-7-中介者模式（https-blog-csdn-net-wwwdc1012-article-details-83389158）"><a href="#6-7-中介者模式（https-blog-csdn-net-wwwdc1012-article-details-83389158）" class="headerlink" title="6.7 中介者模式（https://blog.csdn.net/wwwdc1012/article/details/83389158）"></a>6.7 中介者模式（<a href="https://blog.csdn.net/wwwdc1012/article/details/83389158%EF%BC%89">https://blog.csdn.net/wwwdc1012/article/details/83389158）</a></h2><h3 id="6-7-1-概述"><a href="#6-7-1-概述" class="headerlink" title="6.7.1 概述"></a>6.7.1 概述</h3><p>一般来说，同事类之间的关系是比较复杂的，多个同事类之间互相关联时，他们之间的关系会呈现为复杂的网状结构，这是一种过度耦合的架构，即不利于类的复用，也不稳定。例如在下左图中，有六个同事类对象，假如对象1发生变化，那么将会有4个对象受到影响。如果对象2发生变化，那么将会有5个对象受到影响。也就是说，同事类之间直接关联的设计是不好的。</p>
<p>如果引入中介者模式，那么同事类之间的关系将变为星型结构，从下右图中可以看到，任何一个类的变动，只会影响的类本身，以及中介者，这样就减小了系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。</p>
<img src="/images/设计模式-day05/image-20200214110924010.png" style="zoom:60%;">

<p><strong>定义：</strong></p>
<p>又叫调停模式，定义一个中介角色来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。</p>
<h3 id="6-7-2-结构"><a href="#6-7-2-结构" class="headerlink" title="6.7.2 结构"></a>6.7.2 结构</h3><p>中介者模式包含以下主要角色：</p>
<ul>
<li><p>抽象中介者（Mediator）角色：它是中介者的接口，提供了同事对象注册与转发同事对象信息的抽象方法。</p>
</li>
<li><p>具体中介者（ConcreteMediator）角色：实现中介者接口，定义一个 List 来管理同事对象，协调各个同事角色之间的交互关系，因此它依赖于同事角色。</p>
</li>
<li><p>抽象同事类（Colleague）角色：定义同事类的接口，保存中介者对象，提供同事对象交互的抽象方法，实现所有相互影响的同事类的公共功能。</p>
</li>
<li><p>具体同事类（Concrete Colleague）角色：是抽象同事类的实现者，当需要与其他同事对象交互时，由中介者对象负责后续的交互。</p>
</li>
</ul>
<h3 id="6-7-3-案例实现"><a href="#6-7-3-案例实现" class="headerlink" title="6.7.3 案例实现"></a>6.7.3 案例实现</h3><p>【例】租房</p>
<p>现在租房基本都是通过房屋中介，房主将房屋托管给房屋中介，而租房者从房屋中介获取房屋信息。房屋中介充当租房者与房屋所有者之间的中介者。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day05/中介者模式.png" style="zoom:70%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//抽象中介者</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-comment">//申明一个联络方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message,Person person)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//抽象同事类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> Mediator mediator;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(String name,Mediator mediator)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.mediator = mediator;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体同事类 房屋拥有者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HouseOwner</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">HouseOwner</span><span class="hljs-params">(String name, Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message)</span></span>&#123;<br>        mediator.constact(message, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;房主&quot;</span> + name +<span class="hljs-string">&quot;获取到的信息：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//具体同事类 承租人</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tenant</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tenant</span><span class="hljs-params">(String name, Mediator mediator)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(name, mediator);<br>    &#125;<br><br>    <span class="hljs-comment">//与中介者联系</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message)</span></span>&#123;<br>        mediator.constact(message, <span class="hljs-keyword">this</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//获取信息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getMessage</span><span class="hljs-params">(String message)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;租房者&quot;</span> + name +<span class="hljs-string">&quot;获取到的信息：&quot;</span> + message);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//中介机构</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MediatorStructure</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mediator</span> </span>&#123;<br>    <span class="hljs-comment">//首先中介结构必须知道所有房主和租房者的信息</span><br>    <span class="hljs-keyword">private</span> HouseOwner houseOwner;<br>    <span class="hljs-keyword">private</span> Tenant tenant;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> HouseOwner <span class="hljs-title">getHouseOwner</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> houseOwner;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setHouseOwner</span><span class="hljs-params">(HouseOwner houseOwner)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.houseOwner = houseOwner;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Tenant <span class="hljs-title">getTenant</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> tenant;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTenant</span><span class="hljs-params">(Tenant tenant)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.tenant = tenant;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">constact</span><span class="hljs-params">(String message, Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (person == houseOwner) &#123;          <span class="hljs-comment">//如果是房主，则租房者获得信息</span><br>            tenant.getMessage(message);<br>        &#125; <span class="hljs-keyword">else</span> &#123;       <span class="hljs-comment">//反正则是房主获得信息</span><br>            houseOwner.getMessage(message);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//一个房主、一个租房者、一个中介机构</span><br>        MediatorStructure mediator = <span class="hljs-keyword">new</span> MediatorStructure();<br><br>        <span class="hljs-comment">//房主和租房者只需要知道中介机构即可</span><br>        HouseOwner houseOwner = <span class="hljs-keyword">new</span> HouseOwner(<span class="hljs-string">&quot;张三&quot;</span>, mediator);<br>        Tenant tenant = <span class="hljs-keyword">new</span> Tenant(<span class="hljs-string">&quot;李四&quot;</span>, mediator);<br><br>        <span class="hljs-comment">//中介结构要知道房主和租房者</span><br>        mediator.setHouseOwner(houseOwner);<br>        mediator.setTenant(tenant);<br><br>        tenant.constact(<span class="hljs-string">&quot;需要租三室的房子&quot;</span>);<br>        houseOwner.constact(<span class="hljs-string">&quot;我这有三室的房子，你需要租吗？&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-7-4-优缺点"><a href="#6-7-4-优缺点" class="headerlink" title="6.7.4 优缺点"></a>6.7.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>松散耦合</p>
<p>中介者模式通过把多个同事对象之间的交互封装到中介者对象里面，从而使得同事对象之间松散耦合，基本上可以做到互补依赖。这样一来，同事对象就可以独立地变化和复用，而不再像以前那样“牵一处而动全身”了。</p>
</li>
<li><p>集中控制交互</p>
<p>多个同事对象的交互，被封装在中介者对象里面集中管理，使得这些交互行为发生变化的时候，只需要修改中介者对象就可以了，当然如果是已经做好的系统，那么就扩展中介者对象，而各个同事类不需要做修改。</p>
</li>
<li><p>一对多关联转变为一对一的关联</p>
<p>没有使用中介者模式的时候，同事对象之间的关系通常是一对多的，引入中介者对象以后，中介者对象和同事对象的关系通常变成双向的一对一，这会让对象的关系更容易理解和实现。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>当同事类太多时，中介者的职责将很大，它会变得复杂而庞大，以至于系统难以维护。</p>
<h3 id="6-7-5-使用场景"><a href="#6-7-5-使用场景" class="headerlink" title="6.7.5 使用场景"></a>6.7.5 使用场景</h3><ul>
<li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li>
<li>当想创建一个运行于多个类之间的对象，又不想生成新的子类时。</li>
</ul>
<h2 id="6-8-迭代器模式"><a href="#6-8-迭代器模式" class="headerlink" title="6.8 迭代器模式"></a>6.8 迭代器模式</h2><h3 id="6-8-1-概述"><a href="#6-8-1-概述" class="headerlink" title="6.8.1 概述"></a>6.8.1 概述</h3><p><strong>定义：</strong></p>
<p>提供一个对象来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。 </p>
<h3 id="6-8-2-结构"><a href="#6-8-2-结构" class="headerlink" title="6.8.2 结构"></a>6.8.2 结构</h3><p>迭代器模式主要包含以下角色：</p>
<ul>
<li><p>抽象聚合（Aggregate）角色：定义存储、添加、删除聚合元素以及创建迭代器对象的接口。</p>
</li>
<li><p>具体聚合（ConcreteAggregate）角色：实现抽象聚合类，返回一个具体迭代器的实例。</p>
</li>
<li><p>抽象迭代器（Iterator）角色：定义访问和遍历聚合元素的接口，通常包含 hasNext()、next() 等方法。</p>
</li>
<li><p>具体迭代器（Concretelterator）角色：实现抽象迭代器接口中所定义的方法，完成对聚合对象的遍历，记录遍历的当前位置。</p>
</li>
</ul>
<h3 id="6-8-3-案例实现"><a href="#6-8-3-案例实现" class="headerlink" title="6.8.3 案例实现"></a>6.8.3 案例实现</h3><p>【例】定义一个可以存储学生对象的容器对象，将遍历该容器的功能交由迭代器实现，涉及到的类如下：</p>
<img src="/images/设计模式-day05/迭代器模式.png" style="zoom:90%;">



<p>代码如下：</p>
<p>定义迭代器接口，声明hasNext、next方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentIterator</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Student <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体的迭代器类，重写所有的抽象方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentIteratorImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentIterator</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; list;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> position = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">StudentIteratorImpl</span><span class="hljs-params">(List&lt;Student&gt; list)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list = list;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> position &lt; list.size();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        Student currentStudent = list.get(position);<br>        position ++;<br>        <span class="hljs-keyword">return</span> currentStudent;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义抽象容器类，包含添加元素，删除元素，获取迭代器对象的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">StudentAggregate</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">removeStudent</span><span class="hljs-params">(Student student)</span></span>;<br><br>    <span class="hljs-function">StudentIterator <span class="hljs-title">getStudentIterator</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体的容器类，重写所有的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentAggregateImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">StudentAggregate</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Student&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;Student&gt;();  <span class="hljs-comment">// 学生列表</span><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list.add(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">removeStudent</span><span class="hljs-params">(Student student)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.list.remove(student);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StudentIterator <span class="hljs-title">getStudentIterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StudentIteratorImpl(list);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-8-4-优缺点"><a href="#6-8-4-优缺点" class="headerlink" title="6.8.4 优缺点"></a>6.8.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li>
<li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li>
<li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足 “开闭原则” 的要求。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>增加了类的个数，这在一定程度上增加了系统的复杂性。</p>
<h3 id="6-8-5-使用场景"><a href="#6-8-5-使用场景" class="headerlink" title="6.8.5 使用场景"></a>6.8.5 使用场景</h3><ul>
<li>当需要为聚合对象提供多种遍历方式时。</li>
<li>当需要为遍历不同的聚合结构提供一个统一的接口时。</li>
<li>当访问一个聚合对象的内容而无须暴露其内部细节的表示时。</li>
</ul>
<h3 id="6-8-6-JDK源码解析"><a href="#6-8-6-JDK源码解析" class="headerlink" title="6.8.6 JDK源码解析"></a>6.8.6 JDK源码解析</h3><p>迭代器模式在JAVA的很多集合类中被广泛应用，接下来看看JAVA源码中是如何使用迭代器模式的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">List&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>Iterator&lt;String&gt; iterator = list.iterator(); <span class="hljs-comment">//list.iterator()方法返回的肯定是Iterator接口的子实现类对象</span><br><span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>    System.out.println(iterator.next());<br>&#125;<br></code></pre></td></tr></table></figure>

<p>看完这段代码是不是很熟悉，与我们上面代码基本类似。单列集合都使用到了迭代器，我们以ArrayList举例来说明</p>
<ul>
<li>List：抽象聚合类</li>
<li>ArrayList：具体的聚合类</li>
<li>Iterator：抽象迭代器</li>
<li>list.iterator()：返回的是实现了 <code>Iterator</code> 接口的具体迭代器对象</li>
</ul>
<p>具体的来看看 ArrayList的代码实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArrayList</span>&lt;<span class="hljs-title">E</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractList</span>&lt;<span class="hljs-title">E</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">List</span>&lt;<span class="hljs-title">E</span>&gt;, <span class="hljs-title">RandomAccess</span>, <span class="hljs-title">Cloneable</span>, <span class="hljs-title">java</span>.<span class="hljs-title">io</span>.<span class="hljs-title">Serializable</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Iterator&lt;E&gt; <span class="hljs-title">iterator</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Itr();<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Itr</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>        <span class="hljs-keyword">int</span> cursor;       <span class="hljs-comment">// 下一个要返回元素的索引</span><br>        <span class="hljs-keyword">int</span> lastRet = -<span class="hljs-number">1</span>; <span class="hljs-comment">// 上一个返回元素的索引</span><br>        <span class="hljs-keyword">int</span> expectedModCount = modCount;<br><br>        Itr() &#123;&#125;<br>		<br>        <span class="hljs-comment">//判断是否还有元素</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> cursor != size;<br>        &#125;<br><br>        <span class="hljs-comment">//获取下一个元素</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> E <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>            checkForComodification();<br>            <span class="hljs-keyword">int</span> i = cursor;<br>            <span class="hljs-keyword">if</span> (i &gt;= size)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchElementException();<br>            Object[] elementData = ArrayList.<span class="hljs-keyword">this</span>.elementData;<br>            <span class="hljs-keyword">if</span> (i &gt;= elementData.length)<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ConcurrentModificationException();<br>            cursor = i + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> (E) elementData[lastRet = i];<br>        &#125;<br>        ...<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这部分代码还是比较简单，大致就是在 <code>iterator</code> 方法中返回了一个实例化的 <code>Iterator</code> 对象。Itr是一个内部类，它实现了 <code>Iterator</code> 接口并重写了其中的抽象方法。</p>
<blockquote>
<p>注意： </p>
<p>​    当我们在使用JAVA开发的时候，想使用迭代器模式的话，只要让我们自己定义的容器类实现<code>java.util.Iterable</code>并实现其中的iterator()方法使其返回一个 <code>java.util.Iterator</code> 的实现类就可以了。</p>
</blockquote>
<h2 id="6-9-访问者模式"><a href="#6-9-访问者模式" class="headerlink" title="6.9 访问者模式"></a>6.9 访问者模式</h2><h3 id="6-9-1-概述"><a href="#6-9-1-概述" class="headerlink" title="6.9.1 概述"></a>6.9.1 概述</h3><p><strong>定义：</strong></p>
<p>封装一些作用于某种数据结构中的各元素的操作，它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作。</p>
<h3 id="6-9-2-结构"><a href="#6-9-2-结构" class="headerlink" title="6.9.2 结构"></a>6.9.2 结构</h3><p>访问者模式包含以下主要角色:</p>
<ul>
<li>抽象访问者（Visitor）角色：定义了对每一个元素<code>（Element）</code>访问的行为，它的参数就是可以访问的元素，它的方法个数理论上来讲与元素类个数（Element的实现类个数）是一样的，从这点不难看出，访问者模式要求元素类的个数不能改变。</li>
<li>具体访问者（ConcreteVisitor）角色：给出对每一个元素类访问时所产生的具体行为。</li>
<li>抽象元素（Element）角色：定义了一个接受访问者的方法（<code>accept</code>），其意义是指，每一个元素都要可以被访问者访问。</li>
<li>具体元素（ConcreteElement）角色： 提供接受访问方法的具体实现，而这个具体的实现，通常情况下是使用访问者提供的访问该元素类的方法。</li>
<li>对象结构（Object Structure）角色：定义当中所提到的对象结构，对象结构是一个抽象表述，具体点可以理解为一个具有容器性质或者复合对象特性的类，它会含有一组元素（<code>Element</code>），并且可以迭代这些元素，供访问者访问。</li>
</ul>
<h3 id="6-9-3-案例实现"><a href="#6-9-3-案例实现" class="headerlink" title="6.9.3 案例实现"></a>6.9.3 案例实现</h3><p>【例】给宠物喂食</p>
<p>现在养宠物的人特别多，我们就以这个为例，当然宠物还分为狗，猫等，要给宠物喂食的话，主人可以喂，其他人也可以喂食。</p>
<ul>
<li>访问者角色：给宠物喂食的人</li>
<li>具体访问者角色：主人、其他人</li>
<li>抽象元素角色：动物抽象类</li>
<li>具体元素角色：宠物狗、宠物猫</li>
<li>结构对象角色：主人家</li>
</ul>
<p>类图如下：</p>
<p><img src="/images/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day05/%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F.png"></p>
<p>代码如下：</p>
<p>创建抽象访问者接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Cat cat)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Dog dog)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>创建不同的具体访问者角色（主人和其他人），都需要实现 <code>Person</code>接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Owner</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Cat cat)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食猫&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;主人喂食狗&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Someone</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Person</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Cat cat)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食猫&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">feed</span><span class="hljs-params">(Dog dog)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;其他人喂食狗&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义抽象节点 – 宠物</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Person person)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义实现<code>Animal</code>接口的 具体节点（元素）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        person.feed(<span class="hljs-keyword">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;好好吃，汪汪汪！！！&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Animal</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        person.feed(<span class="hljs-keyword">this</span>);<br>        System.out.println(<span class="hljs-string">&quot;好好吃，喵喵喵！！！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义对象结构，此案例中就是主人的家</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Home</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> List&lt;Animal&gt; nodeList = <span class="hljs-keyword">new</span> ArrayList&lt;Animal&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">action</span><span class="hljs-params">(Person person)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Animal node : nodeList) &#123;<br>            node.accept(person);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//添加操作</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Animal animal)</span> </span>&#123;<br>        nodeList.add(animal);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>

<p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Home home = <span class="hljs-keyword">new</span> Home();<br>        home.add(<span class="hljs-keyword">new</span> Dog());<br>        home.add(<span class="hljs-keyword">new</span> Cat());<br><br>        Owner owner = <span class="hljs-keyword">new</span> Owner();<br>        home.action(owner);<br><br>        Someone someone = <span class="hljs-keyword">new</span> Someone();<br>        home.action(someone);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-9-4-优缺点"><a href="#6-9-4-优缺点" class="headerlink" title="6.9.4 优缺点"></a>6.9.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>扩展性好</p>
<p>在不修改对象结构中的元素的情况下，为对象结构中的元素添加新的功能。</p>
</li>
<li><p>复用性好</p>
<p>通过访问者来定义整个对象结构通用的功能，从而提高复用程度。</p>
</li>
<li><p>分离无关行为</p>
<p>通过访问者来分离无关的行为，把相关的行为封装在一起，构成一个访问者，这样每一个访问者的功能都比较单一。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li><p>对象结构变化很困难</p>
<p>在访问者模式中，每增加一个新的元素类，都要在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”。</p>
</li>
<li><p>违反了依赖倒置原则</p>
<p>访问者模式依赖了具体类，而没有依赖抽象类。</p>
</li>
</ul>
<h3 id="6-9-5-使用场景"><a href="#6-9-5-使用场景" class="headerlink" title="6.9.5  使用场景"></a>6.9.5  使用场景</h3><ul>
<li><p>对象结构相对稳定，但其操作算法经常变化的程序。</p>
</li>
<li><p>对象结构中的对象需要提供多种不同且不相关的操作，而且要避免让这些操作的变化影响对象的结构。</p>
</li>
</ul>
<h3 id="6-9-6-扩展"><a href="#6-9-6-扩展" class="headerlink" title="6.9.6 扩展"></a>6.9.6 扩展</h3><p>访问者模式用到了一种双分派的技术。</p>
<p><strong>1，分派：</strong></p>
<p>变量被声明时的类型叫做变量的静态类型，有些人又把静态类型叫做明显类型；而变量所引用的对象的真实类型又叫做变量的实际类型。比如 <code>Map map = new HashMap()</code> ，map变量的静态类型是 <code>Map</code> ，实际类型是 <code>HashMap</code> 。根据对象的类型而对方法进行的选择，就是分派(Dispatch)，分派(Dispatch)又分为两种，即静态分派和动态分派。</p>
<p><strong>静态分派(Static Dispatch)</strong> 发生在编译时期，分派根据静态类型信息发生。静态分派对于我们来说并不陌生，方法重载就是静态分派。</p>
<p><strong>动态分派(Dynamic Dispatch)</strong> 发生在运行时期，动态分派动态地置换掉某个方法。Java通过方法的重写支持动态分派。</p>
<p><strong>2，动态分派：</strong></p>
<p>通过方法的重写支持动态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>     <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>   	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Dog();<br>        a.execute();<br>        <br>        Animal a1 = <span class="hljs-keyword">new</span> Cat();<br>        a1.execute();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码的结果大家应该直接可以说出来，这不就是多态吗！运行执行的是子类中的方法。</p>
<p>Java编译器在编译时期并不总是知道哪些代码会被执行，因为编译器仅仅知道对象的静态类型，而不知道对象的真实类型；而方法的调用则是根据对象的真实类型，而不是静态类型。</p>
<p><strong>3，静态分派：</strong></p>
<p>通过方法重载支持静态分派。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Execute</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Animal a)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Animal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Dog d)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Cat c)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Animal();<br>        Animal a1 = <span class="hljs-keyword">new</span> Dog();<br>        Animal a2 = <span class="hljs-keyword">new</span> Cat();<br><br>        Execute exe = <span class="hljs-keyword">new</span> Execute();<br>        exe.execute(a);<br>        exe.execute(a1);<br>        exe.execute(a2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行结果：</p>
<img src="/images/设计模式-day05/image-20200214215446638.png" style="zoom:70%;">

<p>这个结果可能出乎一些人的意料了，为什么呢？</p>
<p><strong>==重载方法的分派是根据静态类型进行的，这个分派过程在编译时期就完成了==</strong></p>
<p><strong>4，双分派：</strong></p>
<p>所谓双分派技术就是在选择一个方法的时候，不仅仅要根据消息接收者（receiver）的运行时区别，还要根据参数的运行时区别。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Execute exe)</span> </span>&#123;<br>        exe.execute(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Execute exe)</span> </span>&#123;<br>        exe.execute(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">accept</span><span class="hljs-params">(Execute exe)</span> </span>&#123;<br>        exe.execute(<span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Execute</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Animal a)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;animal&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Dog d)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;dog&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">(Cat c)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;cat&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Animal a = <span class="hljs-keyword">new</span> Animal();<br>        Animal d = <span class="hljs-keyword">new</span> Dog();<br>        Animal c = <span class="hljs-keyword">new</span> Cat();<br><br>        Execute exe = <span class="hljs-keyword">new</span> Execute();<br>        a.accept(exe);<br>        d.accept(exe);<br>        c.accept(exe);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上面代码中，客户端将Execute对象做为参数传递给Animal类型的变量调用的方法，这里完成第一次分派，这里是方法重写，所以是动态分派，也就是执行实际类型中的方法，同时也<code>将自己this作为参数传递进去，这里就完成了第二次分派</code>，这里的Execute类中有多个重载的方法，而传递进行的是this，就是具体的实际类型的对象。</p>
<p>说到这里，我们已经明白双分派是怎么回事了，但是它有什么效果呢？就是可以实现方法的动态绑定，我们可以对上面的程序进行修改。</p>
<p>运行结果如下：</p>
<img src="/images/设计模式-day05/image-20200426233931693.png" style="zoom:67%;">

<p><strong>==双分派实现动态绑定的本质，就是在重载方法委派的前面加上了继承体系中覆盖的环节，由于覆盖是动态的，所以重载就是动态的了。==</strong></p>
<h2 id="6-10-备忘录模式"><a href="#6-10-备忘录模式" class="headerlink" title="6.10 备忘录模式"></a>6.10 备忘录模式</h2><h3 id="6-10-1-概述"><a href="#6-10-1-概述" class="headerlink" title="6.10.1 概述"></a>6.10.1 概述</h3><p>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原，很多软件都提供了撤销（Undo）操作，如 Word、记事本、Photoshop、IDEA等软件在编辑时按 Ctrl+Z 组合键时能撤销当前操作，使文档恢复到之前的状态；还有在 浏览器 中的后退键、数据库事务管理中的回滚操作、玩游戏时的中间结果存档功能、数据库与操作系统的备份操作、棋类游戏中的悔棋功能等都属于这类。</p>
<p><strong>定义：</strong></p>
<p>又叫快照模式，在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便以后当需要时能将该对象恢复到原先保存的状态。</p>
<h3 id="6-10-2-结构"><a href="#6-10-2-结构" class="headerlink" title="6.10.2 结构"></a>6.10.2 结构</h3><p>备忘录模式的主要角色如下：</p>
<ul>
<li>发起人（Originator）角色：记录当前时刻的内部状态信息，提供创建备忘录和恢复备忘录数据的功能，实现其他业务功能，它可以访问备忘录里的所有信息。</li>
<li>备忘录（Memento）角色：负责存储发起人的内部状态，在需要的时候提供这些内部状态给发起人。</li>
<li>管理者（Caretaker）角色：对备忘录进行管理，提供保存与获取备忘录的功能，但其不能对备忘录的内容进行访问与修改。</li>
</ul>
<blockquote>
<p>备忘录有两个等效的接口：</p>
<ul>
<li><strong>窄接口</strong>：管理者(Caretaker)对象（和其他发起人对象之外的任何对象）看到的是备忘录的窄接口(narror Interface)，这个窄接口只允许他把备忘录对象传给其他的对象。</li>
<li><strong>宽接口</strong>：与管理者看到的窄接口相反，发起人对象可以看到一个宽接口(wide Interface)，这个宽接口允许它读取所有的数据，以便根据这些数据恢复这个发起人对象的内部状态。</li>
</ul>
</blockquote>
<h3 id="6-10-3-案例实现"><a href="#6-10-3-案例实现" class="headerlink" title="6.10.3 案例实现"></a>6.10.3 案例实现</h3><p>【例】游戏挑战BOSS</p>
<p>游戏中的某个场景，一游戏角色有生命力、攻击力、防御力等数据，在打Boss前和后一定会不一样的，我们允许玩家如果感觉与Boss决斗的效果不理想可以让游戏恢复到决斗之前的状态。</p>
<p>要实现上述案例，有两种方式：</p>
<ul>
<li>“白箱”备忘录模式</li>
<li>“黑箱”备忘录模式</li>
</ul>
<h4 id="6-10-3-1-“白箱”备忘录模式"><a href="#6-10-3-1-“白箱”备忘录模式" class="headerlink" title="6.10.3.1 “白箱”备忘录模式"></a>6.10.3.1 “白箱”备忘录模式</h4><p>备忘录角色对任何对象都提供一个接口，即宽接口，备忘录角色的内部所存储的状态就对所有对象公开。类图如下：</p>
<img src="/images/设计模式-day05/白箱备忘录模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//游戏角色类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameRole</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit; <span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk; <span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def; <span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title">saveState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RoleStateMemento(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//回复角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverState</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-keyword">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-keyword">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateDisplay</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力：&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力：&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力：&quot;</span> + def);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//游戏状态存储类(备忘录类)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateMemento</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit, <span class="hljs-keyword">int</span> atk, <span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//角色状态管理者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateCaretaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> RoleStateMemento roleStateMemento;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RoleStateMemento <span class="hljs-title">getRoleStateMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> roleStateMemento;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRoleStateMemento</span><span class="hljs-params">(RoleStateMemento roleStateMemento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.roleStateMemento = roleStateMemento;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss前------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        GameRole gameRole = <span class="hljs-keyword">new</span> GameRole();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        RoleStateCaretaker roleStateCaretaker = <span class="hljs-keyword">new</span> RoleStateCaretaker();<br>        roleStateCaretaker.setRoleStateMemento(gameRole.saveState());<br><br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss后------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss时，损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br>        System.out.println(<span class="hljs-string">&quot;------------恢复之前状态------------&quot;</span>);<br>        <span class="hljs-comment">//恢复之前状态</span><br>        gameRole.recoverState(roleStateCaretaker.getRoleStateMemento());<br>        gameRole.stateDisplay();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>分析：白箱备忘录模式是破坏封装性的。但是通过程序员自律，同样可以在一定程度上实现模式的大部分用意。</p>
</blockquote>
<h4 id="6-10-3-2-“黑箱”备忘录模式"><a href="#6-10-3-2-“黑箱”备忘录模式" class="headerlink" title="6.10.3.2 “黑箱”备忘录模式"></a>6.10.3.2 “黑箱”备忘录模式</h4><p>备忘录角色对发起人对象提供一个宽接口，而为其他对象提供一个窄接口。在Java语言中，实现双重接口的办法就是将<strong>备忘录类</strong>设计成<strong>发起人类</strong>的内部成员类。</p>
<p>将 <code>RoleStateMemento</code> 设为 <code>GameRole</code> 的内部类，从而将 <code>RoleStateMemento</code> 对象封装在 <code>GameRole</code> 里面；在外面提供一个标识接口 <code>Memento</code> 给 <code>RoleStateCaretaker</code> 及其他对象使用。这样 <code>GameRole</code> 类看到的是 <code>RoleStateMemento</code> 所有的接口，而<code>RoleStateCaretaker</code>  及其他对象看到的仅仅是标识接口 <code>Memento</code> 所暴露出来的接口，从而维护了封装型。类图如下：</p>
<img src="/images/设计模式-day05/黑箱备忘录模式.png" style="zoom:70%;">

<p>代码如下：</p>
<p>窄接口<code>Memento</code>，这是一个标识接口，因此没有定义出任何的方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Memento</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义发起人类 <code>GameRole</code>，并在内部定义备忘录内部类 <code>RoleStateMemento</code>（该内部类设置为私有的）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java">/游戏角色类<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GameRole</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit; <span class="hljs-comment">//生命力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk; <span class="hljs-comment">//攻击力</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def; <span class="hljs-comment">//防御力</span><br><br>    <span class="hljs-comment">//初始化状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">100</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">100</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//战斗</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fight</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.atk = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">this</span>.def = <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-comment">//保存角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">saveState</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RoleStateMemento(vit, atk, def);<br>    &#125;<br><br>    <span class="hljs-comment">//回复角色状态</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recoverState</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<br>        RoleStateMemento roleStateMemento = (RoleStateMemento) memento;<br>        <span class="hljs-keyword">this</span>.vit = roleStateMemento.getVit();<br>        <span class="hljs-keyword">this</span>.atk = roleStateMemento.getAtk();<br>        <span class="hljs-keyword">this</span>.def = roleStateMemento.getDef();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stateDisplay</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;角色生命力：&quot;</span> + vit);<br>        System.out.println(<span class="hljs-string">&quot;角色攻击力：&quot;</span> + atk);<br>        System.out.println(<span class="hljs-string">&quot;角色防御力：&quot;</span> + def);<br><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.vit = vit;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.atk = atk;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> def;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.def = def;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateMemento</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Memento</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> vit;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> atk;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> def;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RoleStateMemento</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit, <span class="hljs-keyword">int</span> atk, <span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.vit = vit;<br>            <span class="hljs-keyword">this</span>.atk = atk;<br>            <span class="hljs-keyword">this</span>.def = def;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getVit</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> vit;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setVit</span><span class="hljs-params">(<span class="hljs-keyword">int</span> vit)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.vit = vit;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getAtk</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> atk;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAtk</span><span class="hljs-params">(<span class="hljs-keyword">int</span> atk)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.atk = atk;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDef</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">return</span> def;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDef</span><span class="hljs-params">(<span class="hljs-keyword">int</span> def)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.def = def;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>负责人角色类 <code>RoleStateCaretaker</code> 能够得到的备忘录对象是以 <code>Memento</code> 为接口的，由于这个接口仅仅是一个标识接口，因此负责人角色不可能改变这个备忘录对象的内容</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//角色状态管理者类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoleStateCaretaker</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Memento memento;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Memento <span class="hljs-title">getMemento</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> memento;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMemento</span><span class="hljs-params">(Memento memento)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.memento = memento;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>客户端测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss前------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss前</span><br>        GameRole gameRole = <span class="hljs-keyword">new</span> GameRole();<br>        gameRole.initState();<br>        gameRole.stateDisplay();<br><br>        <span class="hljs-comment">//保存进度</span><br>        RoleStateCaretaker roleStateCaretaker = <span class="hljs-keyword">new</span> RoleStateCaretaker();<br>        roleStateCaretaker.setMemento(gameRole.saveState());<br>        <br>        System.out.println(<span class="hljs-string">&quot;------------大战Boss后------------&quot;</span>);<br>        <span class="hljs-comment">//大战Boss时，损耗严重</span><br>        gameRole.fight();<br>        gameRole.stateDisplay();<br>        System.out.println(<span class="hljs-string">&quot;------------恢复之前状态------------&quot;</span>);<br>        <span class="hljs-comment">//恢复之前状态</span><br>        gameRole.recoverState(roleStateCaretaker.getMemento());<br>        gameRole.stateDisplay();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="6-10-4-优缺点"><a href="#6-10-4-优缺点" class="headerlink" title="6.10.4 优缺点"></a>6.10.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>提供了一种可以恢复状态的机制。当用户需要时能够比较方便地将数据恢复到某个历史的状态。</li>
<li>实现了内部状态的封装。除了创建它的发起人之外，其他对象都不能够访问这些状态信息。</li>
<li>简化了发起人类。发起人不需要管理和保存其内部状态的各个备份，所有状态信息都保存在备忘录中，并由管理者进行管理，这符合单一职责原则。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>资源消耗大。如果要保存的内部状态信息过多或者特别频繁，将会占用比较大的内存资源。</li>
</ul>
<h3 id="6-10-5-使用场景"><a href="#6-10-5-使用场景" class="headerlink" title="6.10.5 使用场景"></a>6.10.5 使用场景</h3><ul>
<li><p>需要保存与恢复数据的场景，如玩游戏时的中间结果的存档功能。</p>
</li>
<li><p>需要提供一个可回滚操作的场景，如 Word、记事本、Photoshop，idea等软件在编辑时按 Ctrl+Z 组合键，还有数据库中事务操作。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式-day04</title>
    <url>/2021/02/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-day04/</url>
    <content><![CDATA[<h1 id="5，结构型模式"><a href="#5，结构型模式" class="headerlink" title="5，结构型模式"></a>5，结构型模式</h1><h2 id="5-6-组合模式"><a href="#5-6-组合模式" class="headerlink" title="5.6 组合模式"></a>5.6 组合模式</h2><h3 id="5-6-1-概述"><a href="#5-6-1-概述" class="headerlink" title="5.6.1 概述"></a>5.6.1 概述</h3><img src="/images/设计模式-day04/image-20200208180417291.png" style="zoom:60%;">

<p>​    对于这个图片肯定会非常熟悉，上图我们可以看做是一个文件系统，对于这样的结构我们称之为树形结构。在树形结构中可以通过调用某个方法来遍历整个树，当我们找到某个叶子节点后，就可以对叶子节点进行相关的操作。可以将这颗树理解成一个大的容器，容器里面包含很多的成员对象，这些成员对象即可是容器对象也可以是叶子对象。但是由于容器对象和叶子对象在功能上面的区别，使得我们在使用的过程中必须要区分容器对象和叶子对象，但是这样就会给客户带来不必要的麻烦，作为客户而已，它始终希望能够一致的对待容器对象和叶子对象。</p>
<p><strong>定义：</strong></p>
<p>​    又名部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了对象组的树形结构。</p>
<h3 id="5-6-2-结构"><a href="#5-6-2-结构" class="headerlink" title="5.6.2 结构"></a>5.6.2 结构</h3><p>组合模式主要包含三种角色：</p>
<ul>
<li>抽象根节点（Component）：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性。</li>
<li>树枝节点（Composite）：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成一个树形结构。</li>
<li>叶子节点（Leaf）：叶子节点对象，其下再无分支，是系统层次遍历的最小单位。</li>
</ul>
<h3 id="5-6-3-案例实现"><a href="#5-6-3-案例实现" class="headerlink" title="5.6.3 案例实现"></a>5.6.3 案例实现</h3><p>【例】软件菜单</p>
<p>如下图，我们在访问别的一些管理系统时，经常可以看到类似的菜单。一个菜单可以包含菜单项（菜单项是指不再包含其他内容的菜单条目），也可以包含带有其他菜单项的菜单，因此使用组合模式描述菜单就很恰当，我们的需求是针对一个菜单，打印出其包含的所有菜单以及菜单项的名称。</p>
<img src="/images/设计模式-day04/image-20200208182322313.png" style="zoom:80%;">

<p>要实现该案例，我们先画出类图：</p>
<img src="/images/设计模式-day04/组合模式.png" style="zoom:80%;">

<p><strong>代码实现：</strong></p>
<p>不管是菜单还是菜单项，都应该继承自统一的接口，这里姑且将这个统一的接口称为菜单组件。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//菜单组件  不管是菜单还是菜单项，都应该继承该类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">protected</span> String name;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">int</span> level;<br><br>    <span class="hljs-comment">//添加菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//移除菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//获取指定的子菜单</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br><br>    <span class="hljs-comment">//获取菜单名称</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里的MenuComponent定义为抽象类，因为有一些共有的属性和行为要在该类中实现，Menu和MenuItem类就可以只覆盖自己感兴趣的方法，而不用搭理不需要或者不感兴趣的方法，举例来说，Menu类可以包含子菜单，因此需要覆盖add()、remove()、getChild()方法，但是MenuItem就不应该有这些方法。这里给出的默认实现是抛出异常，你也可以根据自己的需要改写默认实现。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Menu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;MenuComponent&gt; menuComponentList;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Menu</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> level)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.level = level;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        menuComponentList = <span class="hljs-keyword">new</span> ArrayList&lt;MenuComponent&gt;();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;<br>        menuComponentList.add(menuComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(MenuComponent menuComponent)</span> </span>&#123;<br>        menuComponentList.remove(menuComponent);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MenuComponent <span class="hljs-title">getChild</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> menuComponentList.get(i);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; level; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);<br>        &#125;<br>        System.out.println(name);<br>        <span class="hljs-keyword">for</span> (MenuComponent menuComponent : menuComponentList) &#123;<br>            menuComponent.print();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Menu类已经实现了除了getName方法的其他所有方法，因为Menu类具有添加菜单，移除菜单和获取子菜单的功能。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MenuItem</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MenuComponent</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MenuItem</span><span class="hljs-params">(String name,<span class="hljs-keyword">int</span> level)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.level = level;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>; i &lt; level; i++) &#123;<br>            System.out.print(<span class="hljs-string">&quot;--&quot;</span>);<br>        &#125;<br>        System.out.println(name);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>MenuItem是菜单项，不能再有子菜单，所以添加菜单，移除菜单和获取子菜单的功能并不能实现。</p>
<h3 id="5-6-4-组合模式的分类"><a href="#5-6-4-组合模式的分类" class="headerlink" title="5.6.4 组合模式的分类"></a>5.6.4 组合模式的分类</h3><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</p>
<ul>
<li><p>透明组合模式</p>
<p>透明组合模式中，抽象根节点角色中声明了所有用于管理成员对象的方法，比如在示例中 <code>MenuComponent</code> 声明了 <code>add</code>、<code>remove</code> 、<code>getChild</code> 方法，这样做的好处是确保所有的构件类都有相同的接口。透明组合模式也是组合模式的标准形式。</p>
<p>透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的，叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供 add()、remove() 等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）</p>
</li>
<li><p>安全组合模式</p>
<p>在安全组合模式中，在抽象构件角色中没有声明任何用于管理成员对象的方法，而是在树枝节点 <code>Menu</code> 类中声明并实现这些方法。安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p>
<img src="/images/设计模式-day04/组合模式-安全性.png" style="zoom:80%;"></li>
</ul>
<h3 id="5-6-5-优点"><a href="#5-6-5-优点" class="headerlink" title="5.6.5 优点"></a>5.6.5 优点</h3><ul>
<li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li>
<li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li>
<li>在组合模式中增加新的树枝节点和叶子节点都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li>
<li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子节点和树枝节点的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li>
</ul>
<h3 id="5-6-6-使用场景"><a href="#5-6-6-使用场景" class="headerlink" title="5.6.6 使用场景"></a>5.6.6 使用场景</h3><p>组合模式正是应树形结构而生，所以组合模式的使用场景就是出现树形结构的地方。比如：文件目录显示，多级目录呈现等树形结构数据的操作。</p>
<h2 id="5-7-享元模式"><a href="#5-7-享元模式" class="headerlink" title="5.7 享元模式"></a>5.7 享元模式</h2><h3 id="5-7-1-概述"><a href="#5-7-1-概述" class="headerlink" title="5.7.1 概述"></a>5.7.1 概述</h3><p><strong>定义：</strong></p>
<p>​    **==运用共享技术来有效地支持大量细粒度对象的复用==**。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似对象的开销，从而提高系统资源的利用率。</p>
<h3 id="5-7-2-结构"><a href="#5-7-2-结构" class="headerlink" title="5.7.2 结构"></a>5.7.2 结构</h3><p>享元（Flyweight ）模式中存在以下两种状态：</p>
<ol>
<li>内部状态，即不会随着环境的改变而改变的可共享部分。</li>
<li>外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。</li>
</ol>
<p>享元模式的主要有以下角色：</p>
<ul>
<li>抽象享元角色（Flyweight）：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>具体享元（Concrete Flyweight）角色 ：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li>
<li>非享元（Unsharable Flyweight)角色 ：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li>
<li>享元工厂（Flyweight Factory）角色 ：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</li>
</ul>
<h3 id="5-7-3-案例实现"><a href="#5-7-3-案例实现" class="headerlink" title="5.7.3 案例实现"></a>5.7.3 案例实现</h3><p>【例】俄罗斯方块</p>
<p>下面的图片是众所周知的俄罗斯方块中的一个个方块，如果在俄罗斯方块这个游戏中，每个不同的方块都是一个实例对象，这些对象就要占用很多的内存空间，下面利用享元模式进行实现。</p>
<img src="/images/设计模式-day04/俄罗斯方块.jpeg" style="zoom:60%;">



<p><strong>先来看类图：</strong></p>
<img src="/images/设计模式-day04/享元模式.png" style="zoom:80%;">

<p><strong>代码如下：</strong></p>
<p>俄罗斯方块有不同的形状，我们可以对这些形状向上抽取出AbstractBox，用来定义共性的属性和行为。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">display</span><span class="hljs-params">(String color)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;方块形状：&quot;</span> + <span class="hljs-keyword">this</span>.getShape() + <span class="hljs-string">&quot; 颜色：&quot;</span> + color);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>接下来就是定义不同的形状了，IBox类、LBox类、OBox类等。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;L&quot;</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OBox</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractBox</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getShape</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;O&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>提供了一个工厂类（BoxFactory），用来管理享元对象（也就是AbstractBox子类对象），该工厂类对象只需要一个，所以可以使用单例模式。并给工厂类提供一个获取形状的方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BoxFactory</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HashMap&lt;String, AbstractBox&gt; map;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">BoxFactory</span><span class="hljs-params">()</span> </span>&#123;<br>        map = <span class="hljs-keyword">new</span> HashMap&lt;String, AbstractBox&gt;();<br>        AbstractBox iBox = <span class="hljs-keyword">new</span> IBox();<br>        AbstractBox lBox = <span class="hljs-keyword">new</span> LBox();<br>        AbstractBox oBox = <span class="hljs-keyword">new</span> OBox();<br>        map.put(<span class="hljs-string">&quot;I&quot;</span>, iBox);<br>        map.put(<span class="hljs-string">&quot;L&quot;</span>, lBox);<br>        map.put(<span class="hljs-string">&quot;O&quot;</span>, oBox);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BoxFactory <span class="hljs-title">getInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> SingletonHolder.INSTANCE;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SingletonHolder</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> BoxFactory INSTANCE = <span class="hljs-keyword">new</span> BoxFactory();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AbstractBox <span class="hljs-title">getBox</span><span class="hljs-params">(String key)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> map.get(key);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-7-5-优缺点和使用场景"><a href="#5-7-5-优缺点和使用场景" class="headerlink" title="5.7.5 优缺点和使用场景"></a>5.7.5 优缺点和使用场景</h3><p><strong>1，优点</strong></p>
<ul>
<li><strong>极大减少内存中相似或相同对象数量</strong>，节约系统资源，提供系统性能</li>
<li>享元模式中的外部状态相对独立，且不影响内部状态</li>
</ul>
<p><strong>2，缺点：</strong></p>
<p>为了使对象可以共享，需要将享元对象的部分状态外部化，分离内部状态和外部状态，使程序逻辑复杂</p>
<p><strong>3，使用场景：</strong></p>
<ul>
<li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li>
<li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li>
<li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li>
</ul>
<h3 id="5-7-6-JDK源码解析"><a href="#5-7-6-JDK源码解析" class="headerlink" title="5.7.6 JDK源码解析"></a>5.7.6 JDK源码解析</h3><p>Integer类使用了享元模式。我们先看下面的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer i1 = <span class="hljs-number">127</span>;<br>        Integer i2 = <span class="hljs-number">127</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;i1和i2对象是否是同一个对象？&quot;</span> + (i1 == i2));<br><br>        Integer i3 = <span class="hljs-number">128</span>;<br>        Integer i4 = <span class="hljs-number">128</span>;<br><br>        System.out.println(<span class="hljs-string">&quot;i3和i4对象是否是同一个对象？&quot;</span> + (i3 == i4));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>运行上面代码，结果如下：</p>
<img src="/images/设计模式-day04/image-20200208212930857.png" style="zoom:80%;">

<p>为什么第一个输出语句输出的是true，第二个输出语句输出的是false？通过反编译软件进行反编译，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Integer i1 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">127</span>);<br>        Integer i2 Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">127</span>);<br>        System.out.println((String)<span class="hljs-keyword">new</span> StringBuilder().append((String)<span class="hljs-string">&quot;i1\u548ci2\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="hljs-keyword">boolean</span>)(i1 == i2)).toString());<br>        Integer i3 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">128</span>);<br>        Integer i4 = Integer.valueOf((<span class="hljs-keyword">int</span>)<span class="hljs-number">128</span>);<br>        System.out.println((String)<span class="hljs-keyword">new</span> StringBuilder().append((String)<span class="hljs-string">&quot;i3\u548ci4\u5bf9\u8c61\u662f\u5426\u662f\u540c\u4e00\u4e2a\u5bf9\u8c61\uff1f&quot;</span>).append((<span class="hljs-keyword">boolean</span>)(i3 == i4)).toString());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面代码可以看到，直接给Integer类型的变量赋值基本数据类型数据的操作底层使用的是 <code>valueOf()</code> ，所以只需要看该方法即可</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Integer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Number</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparable</span>&lt;<span class="hljs-title">Integer</span>&gt; </span>&#123;<br>    <br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br>    <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                &#125;<br>            &#125;<br>            high = h;<br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>可以看到 <code>Integer</code> 默认先创建并缓存 <code>-128 ~ 127</code> 之间数的 <code>Integer</code> 对象，当调用 <code>valueOf</code> 时如果参数在 <code>-128 ~ 127</code> 之间则计算下标并从缓存中返回，否则创建一个新的 <code>Integer</code> 对象。</p>
<h1 id="6，行为型模式"><a href="#6，行为型模式" class="headerlink" title="6，行为型模式"></a>6，行为型模式</h1><p>行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。</p>
<p>行为型模式分为类行为模式和对象行为模式，前者采用继承机制来在类间分派行为，后者采用组合或聚合在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以对象行为模式比类行为模式具有更大的灵活性。</p>
<p>行为型模式分为：</p>
<ul>
<li>模板方法模式</li>
<li>策略模式</li>
<li>命令模式</li>
<li>职责链模式</li>
<li>状态模式</li>
<li>观察者模式</li>
<li>中介者模式</li>
<li>迭代器模式</li>
<li>访问者模式</li>
<li>备忘录模式</li>
<li>解释器模式</li>
</ul>
<p>以上 11 种行为型模式，除了模板方法模式和解释器模式是类行为型模式，其他的全部属于对象行为型模式。</p>
<h2 id="6-1-模板方法模式"><a href="#6-1-模板方法模式" class="headerlink" title="6.1 模板方法模式"></a>6.1 模板方法模式</h2><h3 id="6-1-1-概述"><a href="#6-1-1-概述" class="headerlink" title="6.1.1 概述"></a>6.1.1 概述</h3><p>在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的关键步骤，而且确定了这些步骤的执行顺序，但某些步骤的具体实现还未知，或者说某些步骤的实现与具体的环境相关。</p>
<p>例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，可以延迟到子类中实现。</p>
<p><strong>定义：</strong></p>
<p>定义一个操作中的算法骨架，而将算法的一些步骤延迟到子类中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。</p>
<h3 id="6-1-2-结构"><a href="#6-1-2-结构" class="headerlink" title="6.1.2 结构"></a>6.1.2 结构</h3><p>模板方法（Template Method）模式包含以下主要角色：</p>
<ul>
<li><p>抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。</p>
<ul>
<li><p>模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。</p>
</li>
<li><p>基本方法：是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：</p>
<ul>
<li><p>抽象方法(Abstract Method) ：一个抽象方法由抽象类声明、由其具体子类实现。</p>
</li>
<li><p>具体方法(Concrete Method) ：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</p>
</li>
<li><p>钩子方法(Hook Method) ：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。</p>
<p>一般钩子方法是用于判断的逻辑方法，这类方法名一般为isXxx，返回值类型为boolean类型。</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的组成步骤。</p>
</li>
</ul>
<h3 id="6-1-3-案例实现"><a href="#6-1-3-案例实现" class="headerlink" title="6.1.3 案例实现"></a>6.1.3 案例实现</h3><p>【例】炒菜</p>
<p>炒菜的步骤是固定的，分为倒油、热油、倒蔬菜、倒调料品、翻炒等步骤。现通过模板方法模式来用代码模拟。类图如下：</p>
<img src="/images/设计模式-day04/模板方法模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cookProcess</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//第一步：倒油</span><br>        <span class="hljs-keyword">this</span>.pourOil();<br>        <span class="hljs-comment">//第二步：热油</span><br>        <span class="hljs-keyword">this</span>.heatOil();<br>        <span class="hljs-comment">//第三步：倒蔬菜</span><br>        <span class="hljs-keyword">this</span>.pourVegetable();<br>        <span class="hljs-comment">//第四步：倒调味料</span><br>        <span class="hljs-keyword">this</span>.pourSauce();<br>        <span class="hljs-comment">//第五步：翻炒</span><br>        <span class="hljs-keyword">this</span>.fry();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourOil</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;倒油&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//第二步：热油是一样的，所以直接实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">heatOil</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;热油&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">//第三步：倒蔬菜是不一样的（一个下包菜，一个是下菜心）</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//第四步：倒调味料是不一样</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span></span>;<br><br><br>    <span class="hljs-comment">//第五步：翻炒是一样的，所以直接实现</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">fry</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;炒啊炒啊炒到熟啊&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass_BaoCai</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的蔬菜是包菜&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的酱料是辣椒&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteClass_CaiXin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourVegetable</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的蔬菜是菜心&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">pourSauce</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;下锅的酱料是蒜蓉&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//炒手撕包菜</span><br>        ConcreteClass_BaoCai baoCai = <span class="hljs-keyword">new</span> ConcreteClass_BaoCai();<br>        baoCai.cookProcess();<br><br>        <span class="hljs-comment">//炒蒜蓉菜心</span><br>        ConcreteClass_CaiXin caiXin = <span class="hljs-keyword">new</span> ConcreteClass_CaiXin();<br>        caiXin.cookProcess();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<blockquote>
<p>注意：为防止恶意操作，一般模板方法都加上 final 关键词。</p>
</blockquote>
<h3 id="6-1-3-优缺点"><a href="#6-1-3-优缺点" class="headerlink" title="6.1.3 优缺点"></a>6.1.3 优缺点</h3><p><strong>优点：</strong></p>
<ul>
<li><p>提高代码复用性</p>
<p>将相同部分的代码放在抽象的父类中，而将不同的代码放入不同的子类中。</p>
</li>
<li><p>实现了反向控制</p>
<p>通过一个父类调用其子类的操作，通过对子类的具体实现扩展不同的行为，实现了反向控制 ，并符合“开闭原则”。</p>
</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。</li>
<li>父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。</li>
</ul>
<h3 id="6-1-4-适用场景"><a href="#6-1-4-适用场景" class="headerlink" title="6.1.4 适用场景"></a>6.1.4 适用场景</h3><ul>
<li>算法的整体步骤很固定，但其中个别部分易变时，这时候可以使用模板方法模式，将容易变的部分抽象出来，供子类实现。</li>
<li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li>
</ul>
<h3 id="6-1-5-JDK源码解析"><a href="#6-1-5-JDK源码解析" class="headerlink" title="6.1.5 JDK源码解析"></a>6.1.5 JDK源码解析</h3><p>InputStream类就使用了模板方法模式。在InputStream类中定义了多个 <code>read()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InputStream</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Closeable</span> </span>&#123;<br>    <span class="hljs-comment">//抽象方法，要求子类必须重写</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[])</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">return</span> read(b, <span class="hljs-number">0</span>, b.length);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">read</span><span class="hljs-params">(<span class="hljs-keyword">byte</span> b[], <span class="hljs-keyword">int</span> off, <span class="hljs-keyword">int</span> len)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (b == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (off &lt; <span class="hljs-number">0</span> || len &lt; <span class="hljs-number">0</span> || len &gt; b.length - off) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IndexOutOfBoundsException();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">int</span> c = read(); <span class="hljs-comment">//调用了无参的read方法，该方法是每次读取一个字节数据</span><br>        <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br>        b[off] = (<span class="hljs-keyword">byte</span>)c;<br><br>        <span class="hljs-keyword">int</span> i = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">for</span> (; i &lt; len ; i++) &#123;<br>                c = read();<br>                <span class="hljs-keyword">if</span> (c == -<span class="hljs-number">1</span>) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                b[off + i] = (<span class="hljs-keyword">byte</span>)c;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException ee) &#123;<br>        &#125;<br>        <span class="hljs-keyword">return</span> i;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>从上面代码可以看到，无参的 <code>read()</code> 方法是抽象方法，要求子类必须实现。而 <code>read(byte b[])</code> 方法调用了 <code>read(byte b[], int off, int len)</code> 方法，所以在此处重点看的方法是带三个参数的方法。 </p>
<p>在该方法中第18行、27行，可以看到调用了无参的抽象的 <code>read()</code> 方法。</p>
<p>总结如下： 在InputStream父类中已经定义好了读取一个字节数组数据的方法是每次读取一个字节，并将其存储到数组的第一个索引位置，读取len个字节数据。具体如何读取一个字节数据呢？由子类实现。</p>
<h2 id="6-2-策略模式"><a href="#6-2-策略模式" class="headerlink" title="6.2 策略模式"></a>6.2 策略模式</h2><h3 id="6-2-1-概述"><a href="#6-2-1-概述" class="headerlink" title="6.2.1 概述"></a>6.2.1 概述</h3><p>先看下面的图片，我们去旅游选择出行模式有很多种，可以骑自行车、可以坐汽车、可以坐火车、可以坐飞机。</p>
<img src="/images/设计模式-day04/image-20200210143039168.png" style="zoom:80%;">

<p>作为一个程序猿，开发需要选择一款开发工具，当然可以进行代码开发的工具有很多，可以选择Idea进行开发，也可以使用eclipse进行开发，也可以使用其他的一些开发工具。</p>
<img src="/images/设计模式-day04/image-20200210144457478.png" style="zoom:70%;">

<p><strong>定义：</strong></p>
<p>​    该模式定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的变化不会影响使用算法的客户。策略模式属于对象行为模式，它通过对算法进行封装，把使用算法的责任和算法的实现分割开来，并委派给不同的对象对这些算法进行管理。</p>
<h3 id="6-2-2-结构"><a href="#6-2-2-结构" class="headerlink" title="6.2.2 结构"></a>6.2.2 结构</h3><p>策略模式的主要角色如下：</p>
<ul>
<li>抽象策略（Strategy）类：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li>
<li>具体策略（Concrete Strategy）类：实现了抽象策略定义的接口，提供具体的算法实现或行为。</li>
<li>环境（Context）类：持有一个策略类的引用，最终给客户端调用。</li>
</ul>
<h3 id="6-2-3-案例实现"><a href="#6-2-3-案例实现" class="headerlink" title="6.2.3 案例实现"></a>6.2.3 案例实现</h3><p>【例】促销活动</p>
<p>一家百货公司在定年度的促销活动。针对不同的节日（春节、中秋节、圣诞节）推出不同的促销活动，由促销员将促销活动展示给客户。类图如下：</p>
<img src="/images/设计模式-day04/策略模式.png" style="zoom:80%;">

<p>代码如下：</p>
<p>定义百货公司所有促销活动的共同接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Strategy</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义具体策略角色（Concrete Strategy）：每个节日具体的促销活动</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//为春节准备的促销活动A</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;买一送一&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//为中秋准备的促销活动B</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;满200元减50元&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//为圣诞准备的促销活动C</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StrategyC</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Strategy</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">show</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;满1000元加一元换购任意200元以下商品&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>定义环境角色（Context）：用于连接上下文，即把促销活动推销给客户，这里可以理解为销售员</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SalesMan</span> </span>&#123;                        <br>    <span class="hljs-comment">//持有抽象策略角色的引用                              </span><br>    <span class="hljs-keyword">private</span> Strategy strategy;                 <br>                                               <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SalesMan</span><span class="hljs-params">(Strategy strategy)</span> </span>&#123;       <br>        <span class="hljs-keyword">this</span>.strategy = strategy;              <br>    &#125;                                          <br>                                               <br>    <span class="hljs-comment">//向客户展示促销活动                                </span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">salesManShow</span><span class="hljs-params">()</span></span>&#123;                <br>        strategy.show();                       <br>    &#125;                                          <br>&#125;                                              <br></code></pre></td></tr></table></figure>



<h3 id="6-2-4-优缺点"><a href="#6-2-4-优缺点" class="headerlink" title="6.2.4 优缺点"></a>6.2.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>策略类之间可以自由切换</p>
<p>由于策略类都实现同一个接口，所以使它们之间可以自由切换。</p>
</li>
<li><p>易于扩展</p>
<p>增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合“开闭原则“</p>
</li>
<li><p>避免使用多重条件选择语句（if else），充分体现面向对象设计思想。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li>
<li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li>
</ul>
<h3 id="6-2-5-使用场景"><a href="#6-2-5-使用场景" class="headerlink" title="6.2.5 使用场景"></a>6.2.5 使用场景</h3><ul>
<li>一个系统需要动态地在几种算法中选择一种时，可将每个算法封装到策略类中。</li>
<li>一个类定义了多种行为，并且这些行为在这个类的操作中以多个条件语句的形式出现，可将每个条件分支移入它们各自的策略类中以代替这些条件语句。</li>
<li>系统中各算法彼此完全独立，且要求对客户隐藏具体算法的实现细节时。</li>
<li>系统要求使用算法的客户不应该知道其操作的数据时，可使用策略模式来隐藏与算法相关的数据结构。</li>
<li>多个类只区别在表现行为不同，可以使用策略模式，在运行时动态选择具体要执行的行为。</li>
</ul>
<h3 id="6-2-6-JDK源码解析"><a href="#6-2-6-JDK源码解析" class="headerlink" title="6.2.6 JDK源码解析"></a>6.2.6 JDK源码解析</h3><p><code>Comparator</code> 中的策略模式。在Arrays类中有一个 <code>sort()</code> 方法，如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Arrays</span></span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-keyword">null</span>) &#123;<br>            sort(a);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (LegacyMergeSort.userRequested)<br>                legacyMergeSort(a, c);<br>            <span class="hljs-keyword">else</span><br>                TimSort.sort(a, <span class="hljs-number">0</span>, a.length, c, <span class="hljs-keyword">null</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Arrays就是一个环境角色类，这个sort方法可以传一个新策略让Arrays根据这个策略来进行排序。就比如下面的测试类。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">demo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        Integer[] data = &#123;<span class="hljs-number">12</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>&#125;;<br>        <span class="hljs-comment">// 实现降序排序</span><br>        Arrays.sort(data, <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> o2 - o1;<br>            &#125;<br>        &#125;);<br>        System.out.println(Arrays.toString(data)); <span class="hljs-comment">//[12, 5, 4, 3, 2, 2, 1]</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这里我们在调用Arrays的sort方法时，第二个参数传递的是Comparator接口的子实现类对象。所以Comparator充当的是抽象策略角色，而具体的子实现类充当的是具体策略角色。环境角色类（Arrays）应该持有抽象策略的引用来调用。那么，Arrays类的sort方法到底有没有使用Comparator子实现类中的 <code>compare()</code> 方法吗？让我们继续查看TimSort类的 <code>sort()</code> 方法，代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimSort</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sort</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi, Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c,</span></span><br><span class="hljs-function"><span class="hljs-params">                         T[] work, <span class="hljs-keyword">int</span> workBase, <span class="hljs-keyword">int</span> workLen)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> c != <span class="hljs-keyword">null</span> &amp;&amp; a != <span class="hljs-keyword">null</span> &amp;&amp; lo &gt;= <span class="hljs-number">0</span> &amp;&amp; lo &lt;= hi &amp;&amp; hi &lt;= a.length;<br><br>        <span class="hljs-keyword">int</span> nRemaining  = hi - lo;<br>        <span class="hljs-keyword">if</span> (nRemaining &lt; <span class="hljs-number">2</span>)<br>            <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// Arrays of size 0 and 1 are always sorted</span><br><br>        <span class="hljs-comment">// If array is small, do a &quot;mini-TimSort&quot; with no merges</span><br>        <span class="hljs-keyword">if</span> (nRemaining &lt; MIN_MERGE) &#123;<br>            <span class="hljs-keyword">int</span> initRunLen = countRunAndMakeAscending(a, lo, hi, c);<br>            binarySort(a, lo, hi, lo + initRunLen, c);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        ...<br>    &#125;   <br>        <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">countRunAndMakeAscending</span><span class="hljs-params">(T[] a, <span class="hljs-keyword">int</span> lo, <span class="hljs-keyword">int</span> hi,Comparator&lt;? <span class="hljs-keyword">super</span> T&gt; c)</span> </span>&#123;<br>        <span class="hljs-keyword">assert</span> lo &lt; hi;<br>        <span class="hljs-keyword">int</span> runHi = lo + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (runHi == hi)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br><br>        <span class="hljs-comment">// Find end of run, and reverse range if descending</span><br>        <span class="hljs-keyword">if</span> (c.compare(a[runHi++], a[lo]) &lt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// Descending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &lt; <span class="hljs-number">0</span>)<br>                runHi++;<br>            reverseRange(a, lo, runHi);<br>        &#125; <span class="hljs-keyword">else</span> &#123;                              <span class="hljs-comment">// Ascending</span><br>            <span class="hljs-keyword">while</span> (runHi &lt; hi &amp;&amp; c.compare(a[runHi], a[runHi - <span class="hljs-number">1</span>]) &gt;= <span class="hljs-number">0</span>)<br>                runHi++;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> runHi - lo;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>上面的代码中最终会跑到 <code>countRunAndMakeAscending()</code> 这个方法中。我们可以看见，只用了compare方法，所以在调用Arrays.sort方法只传具体compare重写方法的类对象就行，这也是Comparator接口中必须要子类实现的一个方法。</p>
<h3 id="6-2-7-策略模式的实战使用"><a href="#6-2-7-策略模式的实战使用" class="headerlink" title="6.2.7 策略模式的实战使用"></a>6.2.7 策略模式的实战使用</h3><p>==<strong><a href="https://blog.csdn.net/m0_37602117/article/details/101756303">https://blog.csdn.net/m0_37602117/article/details/101756303</a></strong>==</p>
<h2 id="6-3-命令模式"><a href="#6-3-命令模式" class="headerlink" title="6.3 命令模式"></a>6.3 命令模式</h2><h3 id="6-3-1-概述"><a href="#6-3-1-概述" class="headerlink" title="6.3.1 概述"></a>6.3.1 概述</h3><p>日常生活中，我们出去吃饭都会遇到下面的场景。</p>
<img src="/images/设计模式-day04/image-20200211130313251.png" style="zoom:60%;">

<p><strong>定义：</strong></p>
<p>将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。这样两者之间通过命令对象进行沟通，这样方便将命令对象进行存储、传递、调用、增加与管理。</p>
<h3 id="6-3-2-结构"><a href="#6-3-2-结构" class="headerlink" title="6.3.2 结构"></a>6.3.2 结构</h3><p>命令模式包含以下主要角色：</p>
<ul>
<li>抽象命令类（Command）角色： 定义命令的接口，声明执行的方法。</li>
<li>具体命令（Concrete  Command）角色：具体的命令，实现命令接口；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。</li>
<li>实现者/接收者（Receiver）角色： 接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。</li>
<li>调用者/请求者（Invoker）角色： 要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。</li>
</ul>
<h3 id="6-3-3-案例实现"><a href="#6-3-3-案例实现" class="headerlink" title="6.3.3 案例实现"></a>6.3.3 案例实现</h3><p>将上面的案例用代码实现，那我们就需要分析命令模式的角色在该案例中由谁来充当。</p>
<p>服务员： 就是调用者角色，由她来发起命令。</p>
<p>资深大厨： 就是接收者角色，真正命令执行的对象。</p>
<p>订单： 命令中包含订单。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day04/命令模式.png" style="zoom:75%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Command</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span></span>;<span class="hljs-comment">//只需要定义一个统一的执行方法</span><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderCommand</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Command</span> </span>&#123;<br><br>    <span class="hljs-comment">//持有接受者对象</span><br>    <span class="hljs-keyword">private</span> SeniorChef receiver;<br>    <span class="hljs-keyword">private</span> Order order;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderCommand</span><span class="hljs-params">(SeniorChef receiver, Order order)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.receiver = receiver;<br>        <span class="hljs-keyword">this</span>.order = order;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span>  </span>&#123;<br>        System.out.println(order.getDiningTable() + <span class="hljs-string">&quot;桌的订单：&quot;</span>);<br>        Set&lt;String&gt; keys = order.getFoodDic().keySet();<br>        <span class="hljs-keyword">for</span> (String key : keys) &#123;<br>            receiver.makeFood(order.getFoodDic().get(key),key);<br>        &#125;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">100</span>);<span class="hljs-comment">//停顿一下 模拟做饭的过程</span><br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br><br><br>        System.out.println(order.getDiningTable() + <span class="hljs-string">&quot;桌的饭弄好了&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Order</span> </span>&#123;<br>    <span class="hljs-comment">// 餐桌号码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> diningTable;<br><br>    <span class="hljs-comment">// 用来存储餐名并记录份数</span><br>    <span class="hljs-keyword">private</span> Map&lt;String, Integer&gt; foodDic = <span class="hljs-keyword">new</span> HashMap&lt;String, Integer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getDiningTable</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> diningTable;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDiningTable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> diningTable)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.diningTable = diningTable;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Integer&gt; <span class="hljs-title">getFoodDic</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> foodDic;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setFoodDic</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> num)</span> </span>&#123;<br>        foodDic.put(name,num);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 资深大厨类 是命令的Receiver</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SeniorChef</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">makeFood</span><span class="hljs-params">(<span class="hljs-keyword">int</span> num,String foodName)</span> </span>&#123;<br>        System.out.println(num + <span class="hljs-string">&quot;份&quot;</span> + foodName);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Waitor</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ArrayList&lt;Command&gt; commands;<span class="hljs-comment">//可以持有很多的命令对象</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Waitor</span><span class="hljs-params">()</span> </span>&#123;<br>        commands = <span class="hljs-keyword">new</span> ArrayList();<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCommand</span><span class="hljs-params">(Command cmd)</span></span>&#123;<br>        commands.add(cmd);<br>    &#125;<br><br>    <span class="hljs-comment">// 发出命令 喊 订单来了，厨师开始执行</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">orderUp</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;美女服务员：叮咚，大厨，新订单来了.......&quot;</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; commands.size(); i++) &#123;<br>            Command cmd = commands.get(i);<br>            <span class="hljs-keyword">if</span> (cmd != <span class="hljs-keyword">null</span>) &#123;<br>                cmd.execute();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//创建2个order</span><br>        Order order1 = <span class="hljs-keyword">new</span> Order();<br>        order1.setDiningTable(<span class="hljs-number">1</span>);<br>        order1.getFoodDic().put(<span class="hljs-string">&quot;西红柿鸡蛋面&quot;</span>,<span class="hljs-number">1</span>);<br>        order1.getFoodDic().put(<span class="hljs-string">&quot;小杯可乐&quot;</span>,<span class="hljs-number">2</span>);<br><br>        Order order2 = <span class="hljs-keyword">new</span> Order();<br>        order2.setDiningTable(<span class="hljs-number">3</span>);<br>        order2.getFoodDic().put(<span class="hljs-string">&quot;尖椒肉丝盖饭&quot;</span>,<span class="hljs-number">1</span>);<br>        order2.getFoodDic().put(<span class="hljs-string">&quot;小杯雪碧&quot;</span>,<span class="hljs-number">1</span>);<br><br>        <span class="hljs-comment">//创建接收者</span><br>        SeniorChef receiver=<span class="hljs-keyword">new</span> SeniorChef();<br>        <span class="hljs-comment">//将订单和接收者封装成命令对象</span><br>        OrderCommand cmd1 = <span class="hljs-keyword">new</span> OrderCommand(receiver, order1);<br>        OrderCommand cmd2 = <span class="hljs-keyword">new</span> OrderCommand(receiver, order2);<br>        <span class="hljs-comment">//创建调用者 waitor</span><br>        Waitor invoker = <span class="hljs-keyword">new</span> Waitor();<br>        invoker.setCommand(cmd1);<br>        invoker.setCommand(cmd2);<br><br>        <span class="hljs-comment">//将订单带到柜台 并向厨师喊 订单来了</span><br>        invoker.orderUp();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-3-4-优缺点"><a href="#6-3-4-优缺点" class="headerlink" title="6.3.4 优缺点"></a>6.3.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li>降低系统的耦合度。命令模式能将调用操作的对象与实现该操作的对象解耦。</li>
<li>增加或删除命令非常方便。采用命令模式增加与删除命令不会影响其他类，它满足“开闭原则”，对扩展比较灵活。</li>
<li>可以实现宏命令。命令模式可以与组合模式结合，将多个命令装配成一个组合命令，即宏命令。</li>
<li>方便实现 Undo 和 Redo 操作。命令模式可以与后面介绍的备忘录模式结合，实现命令的撤销与恢复。</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>使用命令模式可能会导致某些系统有过多的具体命令类。</li>
<li>系统结构更加复杂。</li>
</ul>
<h3 id="6-3-5-使用场景"><a href="#6-3-5-使用场景" class="headerlink" title="6.3.5 使用场景"></a>6.3.5 使用场景</h3><ul>
<li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。</li>
<li>系统需要在不同的时间指定请求、将请求排队和执行请求。</li>
<li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li>
</ul>
<h3 id="6-3-6-JDK源码解析"><a href="#6-3-6-JDK源码解析" class="headerlink" title="6.3.6 JDK源码解析"></a>6.3.6 JDK源码解析</h3><p>Runable是一个典型命令模式，Runnable担当命令的角色，Thread充当的是调用者，start方法就是其执行方法</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//命令接口(抽象命令角色)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-comment">//调用者</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Thread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Runnable target;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (threadStatus != <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalThreadStateException();<br><br>        group.add(<span class="hljs-keyword">this</span>);<br><br>        <span class="hljs-keyword">boolean</span> started = <span class="hljs-keyword">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            start0();<br>            started = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (!started) &#123;<br>                    group.threadStartFailed(<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable ignore) &#123;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">native</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start0</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>会调用一个native方法start0(),调用系统方法，开启一个线程。而接收者是对程序员开放的，可以自己定义接收者。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * jdk Runnable 命令模式</span><br><span class="hljs-comment"> *		TurnOffThread ： 属于具体</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TurnOffThread</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span></span>&#123;<br>     <span class="hljs-keyword">private</span> Receiver receiver;<br>    <br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TurnOffThread</span><span class="hljs-params">(Receiver receiver)</span> </span>&#123;<br>     	<span class="hljs-keyword">this</span>.receiver = receiver;<br>     &#125;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>     	receiver.turnOFF();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 测试类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br>     <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>         Receiver receiver = <span class="hljs-keyword">new</span> Receiver();<br>         TurnOffThread turnOffThread = <span class="hljs-keyword">new</span> TurnOffThread(receiver);<br>         Thread thread = <span class="hljs-keyword">new</span> Thread(turnOffThread);<br>         thread.start();<br>     &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-4-责任链模式"><a href="#6-4-责任链模式" class="headerlink" title="6.4 责任链模式"></a>6.4 责任链模式</h2><h3 id="6-4-1-概述"><a href="#6-4-1-概述" class="headerlink" title="6.4.1 概述"></a>6.4.1 概述</h3><p>在现实生活中，常常会出现这样的事例：一个请求有多个对象可以处理，但每个对象的处理条件或权限不同。例如，公司员工请假，可批假的领导有部门负责人、副总经理、总经理等，但每个领导能批准的天数不同，员工必须根据自己要请假的天数去找不同的领导签名，也就是说员工必须记住每个领导的姓名、电话和地址等信息，这增加了难度。这样的例子还有很多，如找领导出差报销、生活中的“击鼓传花”游戏等。</p>
<p><strong>定义：</strong></p>
<p>又名职责链模式，为了避免请求发送者与多个请求处理者耦合在一起，将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p>
<h3 id="6-4-2-结构"><a href="#6-4-2-结构" class="headerlink" title="6.4.2 结构"></a>6.4.2 结构</h3><p>职责链模式主要包含以下角色:</p>
<ul>
<li>抽象处理者（Handler）角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接。</li>
<li>具体处理者（Concrete Handler）角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者。</li>
<li>客户类（Client）角色：创建处理链，并向链头的具体处理者对象提交请求，它不关心处理细节和请求的传递过程。</li>
</ul>
<h3 id="6-4-3-案例实现"><a href="#6-4-3-案例实现" class="headerlink" title="6.4.3 案例实现"></a>6.4.3 案例实现</h3><p>现需要开发一个请假流程控制系统。请假一天以下的假只需要小组长同意即可；请假1天到3天的假还需要部门经理同意；请求3天到7天还需要总经理同意才行。</p>
<p>类图如下：</p>
<img src="/images/设计模式-day04/责任链模式.png" style="zoom:80%;">

<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//请假条</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeaveRequest</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String name;<span class="hljs-comment">//姓名</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> num;<span class="hljs-comment">//请假天数</span><br>    <span class="hljs-keyword">private</span> String content;<span class="hljs-comment">//请假内容</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LeaveRequest</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> num, String content)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.num = num;<br>        <span class="hljs-keyword">this</span>.content = content;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getNum</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> num;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContent</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> content;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//处理者抽象类</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_ONE = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_THREE = <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> NUM_SEVEN = <span class="hljs-number">7</span>;<br><br>    <span class="hljs-comment">//该领导处理的请假天数区间</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numStart;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> numEnd;<br><br>    <span class="hljs-comment">//领导上面还有领导</span><br>    <span class="hljs-keyword">private</span> Handler nextHandler;<br><br>    <span class="hljs-comment">//设置请假天数范围 上不封顶</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numStart)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.numStart = numStart;<br>    &#125;<br><br>    <span class="hljs-comment">//设置请假天数范围</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> numStart, <span class="hljs-keyword">int</span> numEnd)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.numStart = numStart;<br>        <span class="hljs-keyword">this</span>.numEnd = numEnd;<br>    &#125;<br><br>    <span class="hljs-comment">//设置上级领导</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNextHandler</span><span class="hljs-params">(Handler nextHandler)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.nextHandler = nextHandler;<br>    &#125;<br><br>    <span class="hljs-comment">//提交请假条</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">submit</span><span class="hljs-params">(LeaveRequest leave)</span></span>&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-number">0</span> == <span class="hljs-keyword">this</span>.numStart)&#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-comment">//如果请假天数达到该领导者的处理要求</span><br>        <span class="hljs-keyword">if</span>(leave.getNum() &gt;= <span class="hljs-keyword">this</span>.numStart)&#123;<br>            <span class="hljs-keyword">this</span>.handleLeave(leave);<br><br>            <span class="hljs-comment">//如果还有上级 并且请假天数超过了当前领导的处理范围</span><br>            <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != <span class="hljs-keyword">this</span>.nextHandler &amp;&amp; leave.getNum() &gt; numEnd)&#123;<br>                <span class="hljs-keyword">this</span>.nextHandler.submit(leave);<span class="hljs-comment">//继续提交</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;流程结束&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//各级领导处理请假条方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span></span>;<br>&#125;<br><br><span class="hljs-comment">//小组长</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GroupLeader</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GroupLeader</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//小组长处理1-3天的请假</span><br>        <span class="hljs-keyword">super</span>(Handler.NUM_ONE, Handler.NUM_THREE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span> </span>&#123;<br>        System.out.println(leave.getName() + <span class="hljs-string">&quot;请假&quot;</span> + leave.getNum() + <span class="hljs-string">&quot;天,&quot;</span> + leave.getContent() + <span class="hljs-string">&quot;。&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;小组长审批：同意。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//部门经理</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Manager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Manager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//部门经理处理3-7天的请假</span><br>        <span class="hljs-keyword">super</span>(Handler.NUM_THREE, Handler.NUM_SEVEN);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span> </span>&#123;<br>        System.out.println(leave.getName() + <span class="hljs-string">&quot;请假&quot;</span> + leave.getNum() + <span class="hljs-string">&quot;天,&quot;</span> + leave.getContent() + <span class="hljs-string">&quot;。&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;部门经理审批：同意。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//总经理</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneralManager</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">GeneralManager</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//部门经理处理7天以上的请假</span><br>        <span class="hljs-keyword">super</span>(Handler.NUM_SEVEN);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleLeave</span><span class="hljs-params">(LeaveRequest leave)</span> </span>&#123;<br>        System.out.println(leave.getName() + <span class="hljs-string">&quot;请假&quot;</span> + leave.getNum() + <span class="hljs-string">&quot;天,&quot;</span> + leave.getContent() + <span class="hljs-string">&quot;。&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;总经理审批：同意。&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//测试类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">//请假条来一张</span><br>        LeaveRequest leave = <span class="hljs-keyword">new</span> LeaveRequest(<span class="hljs-string">&quot;小花&quot;</span>,<span class="hljs-number">5</span>,<span class="hljs-string">&quot;身体不适&quot;</span>);<br><br>        <span class="hljs-comment">//各位领导</span><br>        GroupLeader groupLeader = <span class="hljs-keyword">new</span> GroupLeader();<br>        Manager manager = <span class="hljs-keyword">new</span> Manager();<br>        GeneralManager generalManager = <span class="hljs-keyword">new</span> GeneralManager();<br><br>        groupLeader.setNextHandler(manager);<span class="hljs-comment">//小组长的领导是部门经理</span><br>        manager.setNextHandler(generalManager);<span class="hljs-comment">//部门经理的领导是总经理</span><br>        <span class="hljs-comment">//之所以在这里设置上级领导，是因为可以根据实际需求来更改设置，如果实战中上级领导人都是固定的，则可以移到领导实现类中。</span><br><br>        <span class="hljs-comment">//提交申请</span><br>        groupLeader.submit(leave);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="6-4-4-优缺点"><a href="#6-4-4-优缺点" class="headerlink" title="6.4.4 优缺点"></a>6.4.4 优缺点</h3><p><strong>1，优点：</strong></p>
<ul>
<li><p>降低了对象之间的耦合度</p>
<p>该模式降低了请求发送者和接收者的耦合度。</p>
</li>
<li><p>增强了系统的可扩展性</p>
<p>可以根据需要增加新的请求处理类，<strong>满足开闭原则</strong>。</p>
</li>
<li><p>增强了给<strong>对象指派职责的灵活性</strong></p>
<p>当工作流程发生变化，可以动态地改变链内的成员或者修改它们的次序，也可动态地新增或者删除责任。</p>
</li>
<li><p><strong>==责任链简化了对象之间的连接==</strong></p>
<p>一个对象只需保持一个指向其后继者的引用，不需保持其他所有处理者的引用，这避免了使用众多的 if 或者 if···else 语句。</p>
</li>
<li><p>责任分担</p>
<p>每个类只需要处理自己该处理的工作，不能处理的传递给下一个对象完成，明确各类的责任范围，符合类的<strong>单一职责原则</strong>。</p>
</li>
</ul>
<p><strong>2，缺点：</strong></p>
<ul>
<li>不能保证每个请求一定被处理。由于一个请求没有明确的接收者，所以不能保证它一定会被处理，该请求可能一直传到链的末端都得不到处理。</li>
<li>对比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定影响。</li>
<li>职责链建立的合理性要靠客户端来保证，增加了客户端的复杂性，可能会由于职责链的错误设置而导致系统出错，如可能会造成循环调用。</li>
</ul>
<h3 id="6-4-5-源码解析"><a href="#6-4-5-源码解析" class="headerlink" title="6.4.5 源码解析"></a>6.4.5 源码解析</h3><p>在javaWeb应用开发中，FilterChain是职责链（过滤器）模式的典型应用，以下是Filter的模拟实现分析:</p>
<ul>
<li><p>模拟web请求Request以及web响应Response</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Request</span></span>&#123;<br> <br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Response</span></span>&#123;<br> <br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>模拟web过滤器Filter</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Filter</span> </span>&#123;<br>	<span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request req,Response res,FilterChain c)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>模拟实现具体过滤器  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FirstFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器1 前置处理&quot;</span>);<br><br>        <span class="hljs-comment">// 先执行所有request再倒序执行所有response</span><br>        chain.doFilter(request, response);<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器1 后置处理&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SecondFilter</span>  <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request request, Response response, FilterChain chain)</span> </span>&#123;<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器2 前置处理&quot;</span>);<br><br>        <span class="hljs-comment">// 先执行所有request再倒序执行所有response</span><br>        chain.doFilter(request, response);<br><br>        System.out.println(<span class="hljs-string">&quot;过滤器2 后置处理&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>模拟实现过滤器链FilterChain  </p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterChain</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> List&lt;Filter&gt; filters = <span class="hljs-keyword">new</span> ArrayList&lt;Filter&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-comment">// 链式调用</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterChain <span class="hljs-title">addFilter</span><span class="hljs-params">(Filter filter)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.filters.add(filter);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(Request request, Response response)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (index == filters.size()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        Filter filter = filters.get(index);<br>        index++;<br>        filter.doFilter(request, response, <span class="hljs-keyword">this</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li><p>测试类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Request  req = <span class="hljs-keyword">null</span>;<br>        Response res = <span class="hljs-keyword">null</span> ;<br><br>        FilterChain filterChain = <span class="hljs-keyword">new</span> FilterChain();<br>        filterChain.addFilter(<span class="hljs-keyword">new</span> FirstFilter()).addFilter(<span class="hljs-keyword">new</span> SecondFilter());<br>        filterChain.doFilter(req,res);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
</search>
